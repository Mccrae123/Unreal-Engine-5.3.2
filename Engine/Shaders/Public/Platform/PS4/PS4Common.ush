// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PS4Common.usf: #defines for using .hlsl shaders in .pssl (inverted from Sony's header), and a few standard UE defines
=============================================================================*/

#pragma once

// So we can force a recompile...
#define PSSL_VERSION 4.008.061

// make all matrices as row major
#pragma pack_matrix (row_major) 

#pragma warning(disable:5203)
#pragma warning(disable:5206)
#pragma warning(disable:5557) // vector or matrix accessed with dynamic index, user is responsible for ensuring that index is within bounds.

// Used to tell the compiler that two versions are needed for the shader.
#define COMPILE_FOR_NEO _Pragma("MCPP warning UE4SHADERMETADATA_PS4_NEO_PROFILE")

// The compiler can ICE with half's, and the hardware doesn't care (HLSL converts halfs to floats)
// so we just force the issue here.
#define half float
#define half2 float2
#define half3 float3
#define half4 float4

// The compiler ICEs a lot with bools, just make them uints, should work fine
#define bool uint

// HLSL standard for 64bits is uint64_t.
#define uint64_t ulong

// PSSL doesn't support the loop flags and coherency flags we use in HLSL
#define globallycoherent //PSSLC does not support this modifier
#define UAV_LOOP //PSSLC does not support this modifier
#define ALLOW_UAV_CONDITION //PSSLC defaults to allowing UAV conditions. See: https://ps4.scedev.net/forums/thread/73636/
#define FASTOPT
#define LOOP					[loop]
#define UNROLL					[unroll]
#define UNROLL_N(N)				[unroll(N)]
#define INVARIANT				__invariant
#define ENABLE_RE_Z				[RE_Z]
#define EARLYDEPTHSTENCIL		[FORCE_EARLY_DEPTH_STENCIL]
#define REVERSEBITS				ReverseBits

// PS4 HW has both early depth test and RE_Z mode
// On PS4, early depth stencil test also implies early depth write, which is not compatible with pixel shaders that discard or modify output depth
// To handle these cases, RE_Z mode performs depth test once before pixel shader (to handle early rejection) and again after pixel shader along with depth write
#define DEPTHSTENCIL_EARLYTEST_LATEWRITE ENABLE_RE_Z

#define countbits(x) CountSetBits(x)

// handle any with float3, without modifying other platforms
bool any(float2 A)
{
	return any((bool2)A);
}
bool any(float3 A)
{
	return any((bool3)A);
}
bool any(float4 A)
{
	return any((bool4)A);
}

// Sets a variable as being shared among all effects defined  
#define groupshared thread_group_memory
// Set to a vertex shader output variable to note that this data should not be interpolated before going on to fragment shader.  Just as a Semantic is bound to a specific varying parameter this also affect all varying data parameter of a given stream 
#define nointerpolation nointerp
// Turn off perspective-correction during interpolation 
#define noperspective nopersp
// compile as a hardware switch statement  
#define forcecase force_switch
// compile each case as indiviual hardware case subroutines with the switch as a series of subroutines 
#define call call_subs
// Back-Facing primitive indicator  
#define VFACE VERTEXFACE
// 2D Screen pixel location  
#define VPOS SCREENPOS
// Transformed Position 
#define POSITIONNT POSITION_TRANSFORMED
// Vertex Identifier 
#define SV_VertexID S_VERTEX_ID
// Instance Identifier 
#define SV_InstanceID S_INSTANCE_ID
// Sample Index 
#define SV_SampleIndex S_SAMPLE_INDEX
// Primitive Identifier  
#define SV_PrimitiveID S_PRIMITIVE_ID
// Specific Geometry Shader Index passed to the Geometry Shader as input 
#define SV_GSInstanceID S_GSINSTANCE_ID
// Control Point Identifier passed to the hull shader and also to domain shader  
#define SV_OutputControlPointID S_OUTPUT_CONTROL_POINT_ID
// The tessellation amount on for each patch edge available to the hull and domain shader 
#define SV_TessFactor S_EDGE_TESS_FACTOR
// The tesselation amount for a patch surface available to the hull and domain shader 
#define SV_InsideTessFactor S_INSIDE_TESS_FACTOR
// The uv location that the domain shader is to work on 
#define SV_DomainLocation S_DOMAIN_LOCATION
// The per group dimension Global thread Offset 
#define SV_DispatchThreadID S_DISPATCH_THREAD_ID
// The per dimension offset within a dispatch call 
#define SV_GroupID S_GROUP_ID
// Computed flat index of a thread within a group 
#define SV_GroupIndex S_GROUP_INDEX
// Offset of a thread within a group per group dimension 
#define SV_GroupThreadID S_GROUP_THREAD_ID
// If a primitive is front facing 
#define SV_IsFrontFace S_FRONT_FACE
// Output Coverage 
#define SV_Coverage S_COVERAGE
// Clip Distance ( default of 0 ) 
#define SV_ClipDistance S_CLIP_DISTANCE
// Cull Distance ( default of 0 ) 
#define SV_CullDistance S_CULL_DISTANCE
// Clip Distance 0 
#define SV_ClipDistance0 S_CLIP_DISTANCE0
// Cull Distance 0 
#define SV_CullDistance0 S_CULL_DISTANCE0
// Clip Distance 1 
#define SV_ClipDistance1 S_CLIP_DISTANCE1
// Cull Distance 1 
#define SV_CullDistance1 S_CULL_DISTANCE1
// Render Target Array Index 
#define SV_RenderTargetArrayIndex S_RENDER_TARGET_INDEX
// for Render Target Arrays output 
#define SV_Target S_TARGET_OUTPUT
// for Render Target 0 output 
#define SV_Target0 S_TARGET_OUTPUT0
// for Render Target 1 output 
#define SV_Target1 S_TARGET_OUTPUT1
// for Render Target 2 output 
#define SV_Target2 S_TARGET_OUTPUT2
// for Render Target 3 output 
#define SV_Target3 S_TARGET_OUTPUT3
// for Render Target 4 output 
#define SV_Target4 S_TARGET_OUTPUT4
// for Render Target 5 output 
#define SV_Target5 S_TARGET_OUTPUT5
// for Render Target 6 output 
#define SV_Target6 S_TARGET_OUTPUT6
// for Render Target 7 output 
#define SV_Target7 S_TARGET_OUTPUT7
// Viewport Array Index 
#define SV_ViewPortArrayIndex S_VIEWPORT_INDEX
// SV HLSL DX9 backward comparitiblity mapped simply to typical semantics in PSSL 
#define SV_DEPTH S_DEPTH_OUTPUT
// SV HLSL DX9 backward comparitiblity mapped simply to typical semantics in PSSL 
#define SV_POSITION S_POSITION
#define SV_Position S_POSITION
// "patch type of domain shader (tri, quad, isoline)" 
#define domain DOMAIN_PATCH_TYPE
// maximum tessellation factor for a given hull shader 
#define maxtessfactor MAX_TESS_FACTOR
// number of control points that can be produced by one thread of a HULL shader 
#define outputcontrolpoints OUTPUT_CONTROL_POINTS
// output tesselator primitive type 
#define outputtopology OUTPUT_TOPOLOGY_TYPE
// the tessellation type for the HULL Shader 
#define partitioning PARTITIONING_TYPE
// the function name in the hull shader that will be used to produce patch constant data 
#define patchconstantfunc PATCH_CONSTANT_FUNC
// used for geometry shader instancing 
#define instance INSTANCE
// the 3D thread description for a single thread group 
#define numthreads NUM_THREADS
// the count of the elements of each patch 
#define patchsize PATCH_SIZE
// maximum number of vertices produced in a single geometry shader execution 
#define maxvertexcount MAX_VERTEX_COUNT
// returns the location of the first bit set high 
#define firstbithigh FirstSetBit_Hi
// returns the location of the first bit set low 
#define firstbitlow FirstSetBit_Lo
// returns number of render-target samples 
#define renderTargetSampleCount sampleCount
// "returns the sample position (x,y) for sample index x" 
#define renderTargetSamplePosition samplePosition
// Array of 1D Texture Buffers 
#define Texture1DArray Texture1D_Array
// Array of 2D Texture Buffers 
#define Texture2DArray Texture2D_Array
// Array of Cube Map Textures  
#define TextureCubeArray TextureCube_Array
// Multisampled 2D Texture 
#define Texture2DMS MS_Texture2D
// Array of Multisampled 2D Textures  
#define Texture2DMSArray MS_Texture2D_Array
// "Readonly Generic Buffer Type that all other Resource buffers are derived (Byte, Texture*, Regular, RW*)" 
#define Buffer DataBuffer
// "Writeable Generic Buffer Type that all other Resource buffers are derived (Byte, Texture*, Regular, RW*)" 
#define RWBuffer RW_DataBuffer
// Readonly Buffer of raw bytes of data that indexes by Bytes 
#define ByteAddressBuffer ByteBuffer
// Readable and Writeable Buffer of raw bytes of data that indexes by Bytes 
#define RWByteAddressBuffer RW_ByteBuffer
// Readonly Buffer of user defined structures and indexes by structure.  Read Only buffers with fixed/regular structure sizes through out the buffer stream 
#define StructuredBuffer RegularBuffer
// Writeable Regular Buffer 
#define RWStructuredBuffer RW_RegularBuffer
// Readable and Writeable 1D Texture 
#define RWTexture1D RW_Texture1D
// Readable and Writeable 2D Texture  
#define RWTexture2D RW_Texture2D
// Readable and Writeable 3D Texture  
#define RWTexture3D RW_Texture3D
// Readable and Writeable Array of 1D Textures 
#define RWTexture1DArray RW_Texture1D_Array
// Readable and Writeable Array of 2D Textures  
#define RWTexture2DArray RW_Texture2D_Array
// Structured Buffer with special Append Method 
#define AppendStructuredBuffer AppendRegularBuffer
// Structured Buffer with special Consume Method  
#define ConsumeStructuredBuffer ConsumeRegularBuffer
// Fast access buffer for shaders generally for storing constants 
#define cbuffer ConstantBuffer
// Shader buffer for storing constants that allow for better indexed data accesses  
#define tbuffer TextureBuffer
// Performs an Atomic Add 
#define InterlockedAdd AtomicAdd
// Performs an Atomic Min  
#define InterlockedMin AtomicMin
// Performs an Atomic Max 
#define InterlockedMax AtomicMax
// Performs an Atomic Or 
#define InterlockedOr AtomicOr
// Performs an Atomic And 
#define InterlockedAnd AtomicAnd
// Performs an Atomic Xor 
#define InterlockedXor AtomicXor
// Performs an Atomic comparison between the input and value and result  
#define InterlockedCompareStore AtomicCmpStore
// Performs an Atomic comparison of the input to the compare val and exchanges the the result 
#define InterlockedCompareExchange AtomicCmpExchange
// Performs an Atomic exchange 
#define InterlockedExchange AtomicExchange
// Stream of triangles with Append and RestartStrip Methods  
#define TriangleStream TriangleBuffer
// Stream of points with Append and RestartStrip Methods  
#define PointStream PointBuffer
// Stream of lines with Append and RestartStrip Methods  
#define LineStream LineBuffer
// GS Input Prim Type 
#define triangle Triangle
// GS Input Prim Type 
#define point Point
// GS Input Prim Type 
// @NOTE: This #define will throw a compile error
// #define line Line
// Adjacency tri list or tri strip 
#define triangleadj AdjacentTriangle
// Adjacency line list or line strip 
#define lineadj AdjacentLine
// Blocks all threads in a group until all shared group memory accesses have completed 
#define GroupMemoryBarrier ThreadGroupMemoryBarrier
// Blocks all threads in a group until all shared group memory accesses have completed and all threads have reached that point 
#define GroupMemoryBarrierWithGroupSync ThreadGroupMemoryBarrierSync
//  
#define AllMemoryBarrier MemoryBarrier
//  
#define AllMemoryBarrierWithGroupSync MemoryBarrierSync
//  
#define DeviceMemoryBarrier SharedMemoryBarrier
//  
#define DeviceMemoryBarrierWithGroupSync SharedMemoryBarrierSync
// For accessing the individual miplevels of a TextureBuffer Type 
#define mips MipMaps
// Allows for direct increment of the buffer counter 
#define IncrementCounter IncrementCount
// Allows for direct decrement of the buffer counter 
#define DecrementCounter DecrementCount
// "Samples a teuture from level 0, but use a comparison value to reject Samples " 
#define SampleCmpLevelZero SampleCmpLOD0
// Sample from particular mipmap level  
#define SampleLevel SampleLOD
// Samples a texture using a specified gradient influence on the Sample location calculation  
#define SampleGrad SampleGradient
// Returns the computed lod 
#define CalculateLevelOfDetail GetLOD
// "Returns the computed lod, but unclamped" 
#define CalculateLevelOfDetailUnclamped GetLODUnclamped
// Return the position of a specified Sample 
#define GetSamplePosition GetSamplePoint

// Interpolator attributes
#define COMPRESSED_16_FLOAT	compressed_16_float	// Encodes a 32-bit float using a 16-bit float.
#define COMPRESSED_16_UNORM	compressed_16_unorm	// Encodes a 32-bit float in range [0..1] using a 16-bit unsigned int
#define COMPRESSED_16_SNORM	compressed_16_snorm	// Encodes a 32-bit float in range [-1..1] using a 16-bit signed int
#define COMPRESSED_16_UINT	compressed_16_uint	// Clamps a 32-bit unsigned int to fit a 16-bit unsigned int.
#define COMPRESSED_16_INT	compressed_16_int	// Clamps a 32-bit signed int to fit a 16-bit signed int.
#define COMPRESSED_8_UNORM	compressed_8_unorm	// Encodes a 32-bit float in range [0..1] using an 8-bit unsigned int.
#define COMPRESSED_8_SNORM	compressed_8_snorm	// Encodes a 32-bit float in range [-1..1] using an 8-bit signed int.
#define COMPRESSED_8_UINT	compressed_8_uint	// Clamps a 32-bit unsigned int to fit an 8-bit unsigned int.

#define COMPILER_SUPPORTS_EMPTY_STRUCTS	1

#define COMPILER_SUPPORTS_MINMAX3 1

#define COMPILER_SUPPORTS_UNPACKBYTEN 1

// Mirrors GRHISupportsRectTopology = 1.
#define PLATFORM_SUPPORTS_RECT_LIST 1

#define PLATFORM_SUPPORTS_DEVELOPMENT_SHADERS 0 
#define PLATFORM_SUPPORTS_EDITOR_SHADERS 0

sce::Gnm::Sampler GetDefaultBuiltinSampler()
{
	sce::Gnm::Sampler BuiltinSampler;
	BuiltinSampler.init();
	// Default engine is sce::Gnm::kAnisotropyRatio8...
	BuiltinSampler.setAnisotropyRatio(sce::Gnm::kAnisotropyRatio1);
	BuiltinSampler.setBorderColor(sce::Gnm::kBorderColorTransBlack);
	BuiltinSampler.setDepthCompareFunction(sce::Gnm::kDepthCompareNever);
	BuiltinSampler.setForceUnnormalized(false);
	BuiltinSampler.setForceDegamma(false);
	BuiltinSampler.setLodRange(0, 0xfff);
	BuiltinSampler.setMipClampRegionSize(0);
	BuiltinSampler.setZClampRegionSize(0);
	BuiltinSampler.setAnisotropyBias(0);
	BuiltinSampler.setAnisotropyThreshold(0);
	BuiltinSampler.setLodBias(0, 0);
	return BuiltinSampler;
}


// ---------------------------------------------------- Global samplers.

SamplerState GetPS4PointWrappedSampler()
{
	sce::Gnm::Sampler BuiltinSampler = GetDefaultBuiltinSampler();
	BuiltinSampler.setXyFilterMode(sce::Gnm::kFilterModePoint, sce::Gnm::kFilterModePoint);
	BuiltinSampler.setMipFilterMode(sce::Gnm::kMipFilterModePoint);
	BuiltinSampler.setZFilterMode(sce::Gnm::kZFilterModePoint);
	BuiltinSampler.setWrapMode(sce::Gnm::kWrapModeWrap, sce::Gnm::kWrapModeWrap, sce::Gnm::kWrapModeWrap);
	return SamplerState(BuiltinSampler);
}

SamplerState GetPS4PointClampedSampler()
{
	sce::Gnm::Sampler BuiltinSampler = GetDefaultBuiltinSampler();
	BuiltinSampler.setXyFilterMode(sce::Gnm::kFilterModePoint, sce::Gnm::kFilterModePoint);
	BuiltinSampler.setMipFilterMode(sce::Gnm::kMipFilterModePoint);
	BuiltinSampler.setZFilterMode(sce::Gnm::kZFilterModePoint);
	BuiltinSampler.setWrapMode(sce::Gnm::kWrapModeClampLastTexel, sce::Gnm::kWrapModeClampLastTexel, sce::Gnm::kWrapModeClampLastTexel);
	return SamplerState(BuiltinSampler);
}

SamplerState GetPS4BilinearWrappedSampler()
{
	sce::Gnm::Sampler BuiltinSampler = GetDefaultBuiltinSampler();
	BuiltinSampler.setWrapMode(sce::Gnm::kWrapModeWrap, sce::Gnm::kWrapModeWrap, sce::Gnm::kWrapModeWrap);
	BuiltinSampler.setXyFilterMode(sce::Gnm::kFilterModeBilinear, sce::Gnm::kFilterModeBilinear);
	BuiltinSampler.setZFilterMode(sce::Gnm::kZFilterModePoint);
	BuiltinSampler.setMipFilterMode(sce::Gnm::kMipFilterModePoint);
	return SamplerState(BuiltinSampler);
}

SamplerState GetPS4BilinearClampedSampler()
{
	sce::Gnm::Sampler BuiltinSampler = GetDefaultBuiltinSampler();
	BuiltinSampler.setXyFilterMode(sce::Gnm::kFilterModeBilinear, sce::Gnm::kFilterModeBilinear);
	BuiltinSampler.setMipFilterMode(sce::Gnm::kMipFilterModePoint);
	BuiltinSampler.setZFilterMode(sce::Gnm::kZFilterModePoint);
	BuiltinSampler.setWrapMode(sce::Gnm::kWrapModeClampLastTexel, sce::Gnm::kWrapModeClampLastTexel, sce::Gnm::kWrapModeClampLastTexel);
	return SamplerState(BuiltinSampler);
}

SamplerState GetPS4TrilinearWrappedSampler()
{
	sce::Gnm::Sampler BuiltinSampler = GetDefaultBuiltinSampler();
	BuiltinSampler.setXyFilterMode(sce::Gnm::kFilterModeBilinear, sce::Gnm::kFilterModeBilinear);
	BuiltinSampler.setMipFilterMode(sce::Gnm::kMipFilterModeLinear);
	BuiltinSampler.setZFilterMode(sce::Gnm::kZFilterModeLinear);
	BuiltinSampler.setWrapMode(sce::Gnm::kWrapModeWrap, sce::Gnm::kWrapModeWrap, sce::Gnm::kWrapModeWrap);
	return SamplerState(BuiltinSampler);
}

SamplerState GetPS4TrilinearClampedSampler()
{
	sce::Gnm::Sampler BuiltinSampler = GetDefaultBuiltinSampler();
	BuiltinSampler.setXyFilterMode(sce::Gnm::kFilterModeBilinear, sce::Gnm::kFilterModeBilinear);
	BuiltinSampler.setMipFilterMode(sce::Gnm::kMipFilterModeLinear);
	BuiltinSampler.setZFilterMode(sce::Gnm::kZFilterModeLinear);
	BuiltinSampler.setWrapMode(sce::Gnm::kWrapModeClampLastTexel, sce::Gnm::kWrapModeClampLastTexel, sce::Gnm::kWrapModeClampLastTexel);
	return SamplerState(BuiltinSampler);
}

// Implements UE4's Get global sampler.
// Filter={Point,Bilinear,Trilinear}
// WrapMode={Wrapped,Clamped}
#define GetGlobalSampler(Filter,WrapMode) \
	GetPS4##Filter##WrapMode##Sampler()


// ---------------------------------------------------- HLSL standardized SM6 intrisics

#define __PS4_OverloadFunction1Paran(FunctionName,Type) \
	Type##2 FunctionName(Type##2 v) { return Type##2(FunctionName(v.x), FunctionName(v.y)); } \
	Type##3 FunctionName(Type##3 v) { return Type##3(FunctionName(v.xy), FunctionName(v.z)); } \
	Type##4 FunctionName(Type##4 v) { return Type##4(FunctionName(v.xy), FunctionName(v.zw)); }

	
// Allows to shift VGPR value to SGPR.
#define COMPILER_SUPPORTS_TO_SCALAR_MEMORY 1
#if COMPILER_SUPPORTS_TO_SCALAR_MEMORY

// Moves a value (x) from VGPR to SGPR.
float ToScalarMemory(float x)
{
	return ReadFirstLane(x);
}

int ToScalarMemory(int x)
{
	return ReadFirstLane(x);
}

uint ToScalarMemory(uint x)
{
	return ReadFirstLane(x);
}
	
__PS4_OverloadFunction1Paran(ToScalarMemory, float)
__PS4_OverloadFunction1Paran(ToScalarMemory, int)
__PS4_OverloadFunction1Paran(ToScalarMemory, uint)

#endif // COMPILER_SUPPORTS_TO_SCALAR_MEMORY


// Manages the line.
#define COMPILER_SUPPORTS_WAVE_ONCE 1
#if COMPILER_SUPPORTS_WAVE_ONCE

// Returns the number of lane in a wave on the platform.
#define WaveGetLaneCount() uint(64)

// Return the lane's index in the wave in [[0; WaveGetLaneCount()[[
uint WaveGetLaneIndex()
{
	// https://gpuopen.com/amd-gcn-assembly-cross-lane-operations/
	// v_mbcnt_lo_u32_b32  v0, -1, 0
	// v_mbcnt_hi_u32_b32  v0, -1, v0
	return __v_mbcnt_hi_u32_b32(-1, __v_mbcnt_lo_u32_b32(-1, 0));
}

// Return the lane's index in the first active wave in [[0; WaveGetLaneCount()[[
uint WaveGetFirstActiveLaneIndex()
{
	return __s_ff1_i32_b64(__s_read_exec());
}

// Return true for only one lane in the wave.
bool WaveOnce()
{
	return WaveGetLaneIndex() == 0;
}

// Return true for only one active lane in the wave.
bool WaveActiveOnce()
{
	return WaveGetLaneIndex() == WaveGetFirstActiveLaneIndex();
}


#endif // COMPILER_SUPPORTS_WAVE_ONCE


// Allows voting between the lanes of a wave.
#define COMPILER_SUPPORTS_WAVE_VOTE 1
#if COMPILER_SUPPORTS_WAVE_VOTE

bool WaveAnyTrue(bool expr)
{
	return CrossLaneOr(expr);
}

bool WaveAllTrue(bool expr)
{
	return CrossLaneAnd(expr);
}

bool WaveAllEqual(bool expr)
{
	return WaveAnyTrue(expr) == WaveAllTrue(expr);
}

uint64_t WaveBallot(bool expr)
{
	return ballot(expr);
}


#endif // COMPILER_SUPPORTS_WAVE_VOTE


// Min and max all lane.
#define COMPILER_SUPPORTS_WAVE_MINMAX 1
#if COMPILER_SUPPORTS_WAVE_MINMAX

float WaveAllMin(float x)
{
	return CrossLaneMin(x);
}

int WaveAllMin(int x)
{
	return CrossLaneMin(x);
}

uint WaveAllMin(uint x)
{
	return CrossLaneMin(x);
}

__PS4_OverloadFunction1Paran(WaveAllMin, int)
__PS4_OverloadFunction1Paran(WaveAllMin, uint)
__PS4_OverloadFunction1Paran(WaveAllMin, float)


float WaveAllMax(float x)
{
	return CrossLaneMax(x);
}

int WaveAllMax(int x)
{
	return CrossLaneMax(x);
}

uint WaveAllMax(uint x)
{
	return CrossLaneMax(x);
}

__PS4_OverloadFunction1Paran(WaveAllMax, int)
__PS4_OverloadFunction1Paran(WaveAllMax, uint)
__PS4_OverloadFunction1Paran(WaveAllMax, float)

#endif // COMPILER_SUPPORTS_WAVE_MINMAX


#define COMPILER_SUPPORTS_WAVE_BIT_ORAND 1
#if COMPILER_SUPPORTS_WAVE_BIT_ORAND

uint WaveAllBitAnd(uint x)
{
	return CrossLaneAnd(x);
}

__PS4_OverloadFunction1Paran(WaveAllBitAnd, uint)

uint WaveAllBitOr(uint x)
{
	return CrossLaneOr(x);
}

__PS4_OverloadFunction1Paran(WaveAllBitOr, uint)

#endif // COMPILER_SUPPORTS_WAVE_BIT_ORAND


// Wave Query
//#define WaveIsHelperLane() UNSUPPORTED

// Wave Broadcast
#define WaveReadLaneAt(x, laneId) \
	ReadLane(x, laneId)

// Wave Reduction
#define WaveAllSum(x) \
	CrossLaneAdd(x)
#define WaveAllProduct(x) \
	CrossLaneMul(x)
#define WaveAllBitXor(x) \
	CrossLaneXor(x)

// Wave Scan and Prefix
//#define WavePrefixSum() UNSUPPORTED
//#define WavePrefixProduct() UNSUPPORTED

// Global Ordered Append
//#define WaveGetOrderedIndex() UNSUPPORTED
//#define GlobalOrderedCountIncrement() UNSUPPORTED

// Quad-wide Shuffle operations
//#define QuadReadLaneAt() UNSUPPORTED
//#define QuadSwapX() UNSUPPORTED
//#define QuadSwapY() UNSUPPORTED

#define COMPILER_SUPPORTS_WAVE_SWIZZLE_GCN 1
#if COMPILER_SUPPORTS_WAVE_SWIZZLE_GCN

float WaveLaneSwizzleGCN(float x, const uint and_mask, const uint or_mask, const uint xor_mask)
{
	return LaneSwizzle(x, and_mask & 0x1F, or_mask & 0x1F, xor_mask & 0x1F);
}

#endif


#define COMPILER_SUPPORTS_QUAD_PASS 1
#if COMPILER_SUPPORTS_QUAD_PASS

float QuadReadAcrossX(float v)
{
	return QuadSwizzle(v, 1,0,3,2);
}

float QuadReadAcrossY(float v)
{
	return QuadSwizzle(v, 2,3,0,1);
}

uint QuadReadAcrossX(uint v)
{
	return QuadSwizzle(v, 1,0,3,2);
}

uint QuadReadAcrossY(uint v)
{
	return QuadSwizzle(v, 2,3,0,1);
}

#endif

// ---------------------------------------------------- HLSL standardized SM6 intrisics

// SDK 5.0 & 5.5 have a VGPR scheduling issue, waiting for SDK 5.5 patch.
#define WORKARROUND_UE_58394 [isolate]
