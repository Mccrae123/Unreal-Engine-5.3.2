// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PhysicsFieldBuilder.ush
=============================================================================*/

#pragma once

#include "Common.ush"

/* -----------------------------------------------------------------
 * Field System constants and context
 * -----------------------------------------------------------------
 */

Buffer<float> NodesParams;
Buffer<int> NodesOffsets;
Buffer<int> TargetsOffsets;
RWTexture3D<float> FieldClipmap;

int ClipmapResolution;
float ClipmapDistance;
float3 ClipmapCenter;
int ClipmapCount;
int ClipmapExponent;

int ClipmapIndex;
int DatasIndex;
int TargetType;

/* -----------------------------------------------------------------
 * Field System defines
 * -----------------------------------------------------------------
 */

#define MAX_DATAS 64

#define NONE_TYPE 0
#define RESULTS_TYPE 1
#define INTEGER_TYPE 2
#define SCALAR_TYPE 3
#define VECTOR_TYPE 4

#define NONE_TARGET 0
#define DYNAMIC_STATE 1
#define	LINEAR_FORCE 2
#define	EXTERNAL_CLUSTER_STRAIN	3
#define	FIELD_KILL 4
#define	LINEAR_VELOCITY 5
#define	ANGULAR_VELOCITY 6
#define	ANGULAR_TORQUE 7
#define	INTERNAL_CLUSTER_STRAIN 8
#define	DISABLE_THRESHOLD 9
#define	SLEEPING_THRESHOLD 10
#define	POSITION_STATIC 11
#define	POSITION_ANIMATED 12
#define	POSITION_TARGET 13
#define	DYNAMIC_CONSTRAINT 14
#define	COLLISION_GROUP 15
#define	ACTIVATE_DISABLED 16

#define NONE_NODE 0
#define UNIFORM_INTEGER 1
#define RADIAL_MASK_INTEGER 2
#define UNIFORM_SCALAR 3
#define RADIAL_FALLOFF_SCALAR 4
#define PLANE_FALLOFF_SCALAR 5
#define BOX_FALLOFF_SCALAR 6
#define NOISE_SCALAR 7
#define UNIFORM_VECTOR 8
#define RADIAL_VECTOR 9
#define RANDOM_VECTOR 10
#define SUM_SCALAR 11
#define SUM_VECTOR 12
#define CONVERSION_FIELD 13
#define CULLING_FIELD 14

#define SET_ALWAYS 0
#define SET_IFF_NOT_INTERIOR 1
#define SET_IFF_NOT_EXTERIOR 2

#define NONE_FALLOFF 0 
#define FALLOFF_LINEAR 1
#define FALLOFF_INVERSE 2
#define FALLOFF_SQUARED 3
#define FALLOFF_LOGARITHMIC 4

#define MULTIPLY_OP 0
#define DIVIDE_OP 1
#define ADD_OP 2
#define SUBTRACT_OP 3

#define CULLING_INSIDE 0
#define CULLING_OUTSIDE 1

/* -----------------------------------------------------------------
 * Quat utils
 * -----------------------------------------------------------------
 */

float3 FieldRotateVectorByQuat(in float3 Vector, in float4 Quat)
{
	float3 T = 2.0 * cross(Quat.xyz, Vector);
	return Vector + Quat.w * T + cross(Quat.xyz, T);
}

float3 FieldUnRotateVectorByQuat(in float3 Vector, in float4 Quat)
{
	float3 T = 2.0 * cross(Quat.xyz, Vector);
	return Vector - Quat.w * T + cross(Quat.xyz, T);
}

/* -----------------------------------------------------------------
 * Uniform Integer Field
 * -----------------------------------------------------------------
 */

#define UNIFORM_INTEGER_MAGNITUDE 0

void EvaluateUniformInteger(in float3 SamplePosition, in int NodeOffset,
						inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	ContextDatas[LocalIndex++] = NodesParams[NodeOffset + UNIFORM_INTEGER_MAGNITUDE];
}

/* -----------------------------------------------------------------
 * Radial Int Mask Field
 * -----------------------------------------------------------------
 */

#define RADIAL_MASK_INTEGER_RADIUS 0
#define RADIAL_MASK_INTEGER_POSITIONX 1
#define RADIAL_MASK_INTEGER_POSITIONY 2
#define RADIAL_MASK_INTEGER_POSITIONZ 3
#define RADIAL_MASK_INTEGER_INTERIOR_VALUE 4
#define RADIAL_MASK_INTEGER_EXTERIOR_VALUE 5
#define RADIAL_MASK_INTEGER_SET_MASK_CONDITION 6

void EvaluateRadialMaskInteger(in float3 SamplePosition, in int NodeOffset,
					inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const float3 DeltaPosition = float3(NodesParams[NodeOffset + RADIAL_MASK_INTEGER_POSITIONX],
										 NodesParams[NodeOffset + RADIAL_MASK_INTEGER_POSITIONY],
										 NodesParams[NodeOffset + RADIAL_MASK_INTEGER_POSITIONZ]) - SamplePosition;
	const float DistanceSquared = dot(DeltaPosition, DeltaPosition);
	const int DeltaResult = (DistanceSquared < NodesParams[NodeOffset + RADIAL_MASK_INTEGER_RADIUS] *
											 NodesParams[NodeOffset + RADIAL_MASK_INTEGER_RADIUS]) ?
											 NodesParams[NodeOffset + RADIAL_MASK_INTEGER_INTERIOR_VALUE] :
											 NodesParams[NodeOffset + RADIAL_MASK_INTEGER_EXTERIOR_VALUE];
	const int MaskCondition = NodesParams[NodeOffset + RADIAL_MASK_INTEGER_SET_MASK_CONDITION];
	
	ContextDatas[LocalIndex++] = (MaskCondition == SET_ALWAYS) ? DeltaResult :
					 (MaskCondition == SET_IFF_NOT_INTERIOR && DeltaResult != NodesParams[NodeOffset + RADIAL_MASK_INTEGER_INTERIOR_VALUE]) ? DeltaResult :
					 (MaskCondition == SET_IFF_NOT_EXTERIOR && DeltaResult != NodesParams[NodeOffset + RADIAL_MASK_INTEGER_EXTERIOR_VALUE]) ? DeltaResult : 0;
}

/* -----------------------------------------------------------------
 * Uniform Scalar Field
 * -----------------------------------------------------------------
 */

#define UNIFORM_SCALAR_MAGNITUDE 0

void EvaluateUniformScalar(in float3 SamplePosition, in int NodeOffset,
					inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	ContextDatas[LocalIndex++] = NodesParams[NodeOffset + UNIFORM_SCALAR_MAGNITUDE];
}

/* -----------------------------------------------------------------
 * Common Falloff functions
 * -----------------------------------------------------------------
 */

void SetFalloffValue(in int FieldFalloff, in float FieldMagnitude, in float DeltaDistance, out float OutNodeResult)
{
	if (FieldFalloff == NONE_FALLOFF)
	{
		OutNodeResult = FieldMagnitude;
	}
	else if (FieldFalloff == FALLOFF_LINEAR)
	{
		OutNodeResult = FieldMagnitude * DeltaDistance;
	}
	else if (FieldFalloff == FALLOFF_SQUARED)
	{
		OutNodeResult = FieldMagnitude * DeltaDistance * DeltaDistance;
	}
	else if (FieldFalloff == FALLOFF_INVERSE && DeltaDistance > 1e-6)
	{
		OutNodeResult = FieldMagnitude / DeltaDistance;
	}
	else if (FieldFalloff == FALLOFF_LOGARITHMIC)
	{
		OutNodeResult = FieldMagnitude * log(DeltaDistance + 1.0) / log(10.0);
	}
	else
	{
		OutNodeResult = 0.0;
	}
}

/* -----------------------------------------------------------------
 * Radial Falloff Field
 * -----------------------------------------------------------------
 */

#define RADIAL_FALLOFF_MAGNITUDE 0
#define RADIAL_FALLOFF_MIN_RANGE 1
#define RADIAL_FALLOFF_MAX_RANGE 2
#define RADIAL_FALLOFF_DEFAULT 3
#define RADIAL_FALLOFF_RADIUS 4
#define RADIAL_FALLOFF_POSITIONX 5
#define RADIAL_FALLOFF_POSITIONY 6
#define RADIAL_FALLOFF_POSITIONZ 7
#define RADIAL_FALLOFF_FALLOFF 8

void EvaluateRadialFalloffScalar(in float3 SamplePosition, in int NodeOffset,
							inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	float ScalarDatas = NodesParams[NodeOffset + RADIAL_FALLOFF_DEFAULT];

	const float3 DeltaPosition = float3(NodesParams[NodeOffset + RADIAL_FALLOFF_POSITIONX],
									    NodesParams[NodeOffset + RADIAL_FALLOFF_POSITIONY],
										NodesParams[NodeOffset + RADIAL_FALLOFF_POSITIONZ]) - SamplePosition;
	const float LocalDistance = length(DeltaPosition);
	const float FieldRadius = NodesParams[NodeOffset + RADIAL_FALLOFF_RADIUS];
	
	if (FieldRadius > 0.0 && LocalDistance < FieldRadius)
	{
		const float DeltaDistance = 1.0 - LocalDistance / FieldRadius;

		SetFalloffValue(NodesParams[NodeOffset + RADIAL_FALLOFF_FALLOFF],
						NodesParams[NodeOffset + RADIAL_FALLOFF_MAGNITUDE],
						DeltaDistance, ScalarDatas);
	}
	ContextDatas[LocalIndex++] = ScalarDatas;
}

/* -----------------------------------------------------------------
 * Plane Falloff Field
 * -----------------------------------------------------------------
 */

#define PLANE_FALLOFF_MAGNITUDE 0
#define PLANE_FALLOFF_MIN_RANGE 1
#define PLANE_FALLOFF_MAX_RANGE 2
#define PLANE_FALLOFF_DEFAULT 3
#define PLANE_FALLOFF_DISTANCE 4
#define PLANE_FALLOFF_POSITIONX 5
#define PLANE_FALLOFF_POSITIONY 6
#define PLANE_FALLOFF_POSITIONZ 7
#define PLANE_FALLOFF_NORMALX 8
#define PLANE_FALLOFF_NORMALY 9
#define PLANE_FALLOFF_NORMALZ 10
#define PLANE_FALLOFF_FALLOFF 11

void EvaluatePlaneFalloffScalar(in float3 SamplePosition, in int NodeOffset,
					inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	float ScalarDatas = NodesParams[NodeOffset + RADIAL_FALLOFF_DEFAULT];

	const float3 PlaneBase = float3(NodesParams[NodeOffset + PLANE_FALLOFF_POSITIONX],
								    NodesParams[NodeOffset + PLANE_FALLOFF_POSITIONY],
								    NodesParams[NodeOffset + PLANE_FALLOFF_POSITIONZ]);

	const float3 PlaneNormal = float3(NodesParams[NodeOffset + PLANE_FALLOFF_NORMALX],
							          NodesParams[NodeOffset + PLANE_FALLOFF_NORMALY],
								      NodesParams[NodeOffset + PLANE_FALLOFF_NORMALZ]);

	const float PlaneOffset = dot(PlaneBase, PlaneNormal);

	const float LocalDistance = dot(PlaneNormal, SamplePosition) - PlaneOffset;
	const float PlaneDistance = NodesParams[NodeOffset + PLANE_FALLOFF_DISTANCE];

	if (PlaneDistance > 0.0 && LocalDistance > -PlaneDistance && LocalDistance < 0.0)
	{
		const float DeltaDistance = 1.0 + LocalDistance / PlaneDistance;
		
		SetFalloffValue(NodesParams[NodeOffset + PLANE_FALLOFF_FALLOFF],
						NodesParams[NodeOffset + PLANE_FALLOFF_MAGNITUDE], DeltaDistance,
						ScalarDatas);
	}
	ContextDatas[LocalIndex++] = ScalarDatas;
}

/* -----------------------------------------------------------------
 * Box Falloff Field
 * -----------------------------------------------------------------
 */

#define BOX_FALLOFF_MAGNITUDE 0
#define BOX_FALLOFF_MIN_RANGE 1
#define BOX_FALLOFF_MAX_RANGE 2
#define BOX_FALLOFF_DEFAULT 3
#define BOX_FALLOFF_ROTATIONX 4
#define BOX_FALLOFF_ROTATIONY 5
#define BOX_FALLOFF_ROTATIONZ 6
#define BOX_FALLOFF_ROTATIONW 7
#define BOX_FALLOFF_TRANSLATIONX 8
#define BOX_FALLOFF_TRANSLATIONY 9
#define BOX_FALLOFF_TRANSLATIONZ 10
#define BOX_FALLOFF_SCALEX 11
#define BOX_FALLOFF_SCALEY 12
#define BOX_FALLOFF_SCALEZ 13
#define BOX_FALLOFF_FALLOFF 14
 
void EvaluateBoxFalloffScalar(in float3 SamplePosition, in int NodeOffset,
					inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	float ScalarDatas = NodesParams[NodeOffset + RADIAL_FALLOFF_DEFAULT];

	const float4 BoxRotation = float4(NodesParams[NodeOffset + BOX_FALLOFF_ROTATIONX],
								      NodesParams[NodeOffset + BOX_FALLOFF_ROTATIONY],
								      NodesParams[NodeOffset + BOX_FALLOFF_ROTATIONZ],
									  NodesParams[NodeOffset + BOX_FALLOFF_ROTATIONW]);

	const float3 BoxTranslation = float3(NodesParams[NodeOffset + BOX_FALLOFF_TRANSLATIONX],
							             NodesParams[NodeOffset + BOX_FALLOFF_TRANSLATIONY],
								         NodesParams[NodeOffset + BOX_FALLOFF_TRANSLATIONZ]);

	const float3 BoxScale = float3(NodesParams[NodeOffset + BOX_FALLOFF_SCALEX],
							       NodesParams[NodeOffset + BOX_FALLOFF_SCALEY],
								   NodesParams[NodeOffset + BOX_FALLOFF_SCALEZ]);

	const float3 InverseScale = float3(BoxScale.x != 0.0 ? 1.0 / BoxScale.x : 0.0,
										BoxScale.y != 0.0 ? 1.0 / BoxScale.y : 0.0,
										BoxScale.z != 0.0 ? 1.0 / BoxScale.z : 0.0);

	const float3 LocalPosition = FieldUnRotateVectorByQuat(SamplePosition - BoxTranslation, BoxRotation) * InverseScale;

	const float3 DeltaPosition = abs(LocalPosition) - float3(1.0, 1.0, 1.0);
	const int ClosestAxis = ((DeltaPosition.x > DeltaPosition.y) && (DeltaPosition.x > DeltaPosition.z)) ? 0 : (DeltaPosition.y > DeltaPosition.z) ? 1 : 2;
	const float OutsideDistance = length(max(DeltaPosition, 0.0));

	const float LocalDistance = OutsideDistance + min(DeltaPosition[ClosestAxis], 0.0);

	if (LocalDistance < 0.0)
	{
		const float DeltaDistance = 1.0 + LocalDistance;
		
		SetFalloffValue(NodesParams[NodeOffset + BOX_FALLOFF_FALLOFF],
						NodesParams[NodeOffset + BOX_FALLOFF_MAGNITUDE],
						DeltaDistance, ScalarDatas);
	}
	ContextDatas[LocalIndex++] = ScalarDatas;
}

/* -----------------------------------------------------------------
 * Noise Field
 * -----------------------------------------------------------------
 */

#define NOISE_MIN_RANGE 0
#define NOISE_MAX_RANGE 1
#define NOISE_ROTATIONX 2
#define NOISE_ROTATIONY 3
#define NOISE_ROTATIONZ 4
#define NOISE_ROTATIONW 5
#define NOISE_TRANSLATIONX 6
#define NOISE_TRANSLATIONY 7
#define NOISE_TRANSLATIONZ 8
#define NOISE_SCALEX 9
#define NOISE_SCALEY 10
#define NOISE_SCALEZ 11
 
void EvaluateNoiseScalar( in float3 SamplePosition, in int NodeOffset, inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const float4 NoiseRotation = float4(NodesParams[NodeOffset + NOISE_ROTATIONX],
								        NodesParams[NodeOffset + NOISE_ROTATIONY],
								        NodesParams[NodeOffset + NOISE_ROTATIONZ],
									    NodesParams[NodeOffset + NOISE_ROTATIONW]);

	const float3 NoiseScale = float3(NodesParams[NodeOffset + NOISE_SCALEX],
							         NodesParams[NodeOffset + NOISE_SCALEY],
								     NodesParams[NodeOffset + NOISE_SCALEZ]);

	const float3 DeltaBound = ClipmapDistance * 2;
	const float3 MinBounds = ClipmapCenter - ClipmapDistance;
	const float3 LocalVector = FieldRotateVectorByQuat((SamplePosition - MinBounds) * NoiseScale, NoiseRotation);

	const float3 LocalCoord = float3((DeltaBound.x != 0.0) ? LocalVector.x / DeltaBound.x : 0.0,
									  (DeltaBound.y != 0.0) ? LocalVector.y / DeltaBound.y : 0.0,
									  (DeltaBound.z != 0.0) ? LocalVector.z / DeltaBound.z : 0.0);

	const float3 ReducedCoord = min(max(LocalCoord, 0.0), 1.0);

	const float NoiseValue = FastGradientPerlinNoise3D_TEX(ReducedCoord);
	ContextDatas[LocalIndex++] = NoiseValue * (NodesParams[NodeOffset + NOISE_MAX_RANGE] -
								  NodesParams[NodeOffset + NOISE_MIN_RANGE]) / 2.0
				+ NodesParams[NodeOffset + NOISE_MIN_RANGE];
}


/* -----------------------------------------------------------------
 * Uniform Vector Field
 * -----------------------------------------------------------------
 */

#define UNIFORM_VECTOR_MAGNITUDE 0
#define UNIFORM_VECTOR_DIRECTIONX 1
#define UNIFORM_VECTOR_DIRECTIONY 2
#define UNIFORM_VECTOR_DIRECTIONZ 3
 
void EvaluateUniformVector(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const float3 VectorDatas = NodesParams[NodeOffset + UNIFORM_VECTOR_MAGNITUDE] * float3(
										NodesParams[NodeOffset + UNIFORM_VECTOR_DIRECTIONX],
								        NodesParams[NodeOffset + UNIFORM_VECTOR_DIRECTIONY],
								        NodesParams[NodeOffset + UNIFORM_VECTOR_DIRECTIONZ]);

	ContextDatas[LocalIndex++] = VectorDatas.x;
	ContextDatas[LocalIndex++] = VectorDatas.y;
	ContextDatas[LocalIndex++] = VectorDatas.z;
}

/* -----------------------------------------------------------------
 * Radial Vector Field
 * -----------------------------------------------------------------
 */

#define RADIAL_VECTOR_MAGNITUDE 0
#define RADIAL_VECTOR_POSITIONX 1
#define RADIAL_VECTOR_POSITIONY 2
#define RADIAL_VECTOR_POSITIONZ 3
 
void EvaluateRadialVector(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const float3 RadialDirection = SamplePosition - float3(
										NodesParams[NodeOffset + RADIAL_VECTOR_POSITIONX],
								        NodesParams[NodeOffset + RADIAL_VECTOR_POSITIONY],
								        NodesParams[NodeOffset + RADIAL_VECTOR_POSITIONZ]);
	const float DirectionLength = length(RadialDirection);
	const float3 VectorDatas = (DirectionLength != 0.0) ? NodesParams[NodeOffset + RADIAL_VECTOR_MAGNITUDE] *
					RadialDirection / DirectionLength : float3(0, 0, 0);

	ContextDatas[LocalIndex++] = VectorDatas.x;
	ContextDatas[LocalIndex++] = VectorDatas.y;
	ContextDatas[LocalIndex++] = VectorDatas.z;
}

/* -----------------------------------------------------------------
 * Random Vector Field
 * -----------------------------------------------------------------
 */

#define RANDOM_VECTOR_MAGNITUDE 0
 
void EvaluateRandomVector(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const float3 RadialDirection = float3(Rand3DPCG16(int3(SamplePosition))) / 0xffff - 0.5;

	const float DirectionLength = length(RadialDirection);
	const float3 VectorDatas = (DirectionLength != 0.0) ? NodesParams[NodeOffset + RANDOM_VECTOR_MAGNITUDE] *
					RadialDirection / DirectionLength : float3(0, 0, 0);

	ContextDatas[LocalIndex++] = VectorDatas.x;
	ContextDatas[LocalIndex++] = VectorDatas.y;
	ContextDatas[LocalIndex++] = VectorDatas.z;
}

/* -----------------------------------------------------------------
 * Sum Scalar Field
 * -----------------------------------------------------------------
 */

#define SUM_SCALAR_MAGNITUDE 0
#define SUM_SCALAR_RIGHT 1
#define SUM_SCALAR_LEFT 2
#define SUM_SCALAR_OPERATION 3

void EvaluateSumScalar(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const bool HasRight = NodesParams[NodeOffset + SUM_SCALAR_RIGHT];
	const bool HasLeft = NodesParams[NodeOffset + SUM_SCALAR_LEFT];

	LocalIndex -= HasRight + HasLeft;

	const int FieldOperation = NodesParams[NodeOffset + SUM_SCALAR_OPERATION];

	int OffsetIndex = LocalIndex;
	const float ScalarRight = HasRight ? ContextDatas[OffsetIndex] : 0.0;
	OffsetIndex += HasRight;
	const float ScalarLeft = HasLeft ? ContextDatas[OffsetIndex] : 0.0;

	float ScalarDatas = 0.0;
	if (FieldOperation == MULTIPLY_OP)
	{
		ScalarDatas = ScalarRight * ScalarLeft;
	}
	else if (FieldOperation == DIVIDE_OP)
	{
		ScalarDatas = ScalarLeft / ScalarRight;
	}
	else if (FieldOperation == ADD_OP)
	{
		ScalarDatas = ScalarRight + ScalarLeft;
	}
	else if (FieldOperation == SUBTRACT_OP)
	{
		ScalarDatas = ScalarLeft - ScalarRight;
	}
	ContextDatas[LocalIndex++] = ScalarDatas * NodesParams[NodeOffset + SUM_SCALAR_MAGNITUDE];
}

/* -----------------------------------------------------------------
 * Sum Vector Field
 * -----------------------------------------------------------------
 */

#define SUM_VECTOR_MAGNITUDE 0
#define SUM_VECTOR_SCALAR 1
#define SUM_VECTOR_RIGHT 2
#define SUM_VECTOR_LEFT 3
#define SUM_VECTOR_OPERATION 4

void EvaluateSumVector(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const bool HasScalar = NodesParams[NodeOffset + SUM_VECTOR_SCALAR];
	const bool HasRight = NodesParams[NodeOffset + SUM_VECTOR_RIGHT];
	const bool HasLeft = NodesParams[NodeOffset + SUM_VECTOR_LEFT];

	LocalIndex -= HasScalar + HasRight * 3 + HasLeft * 3;

	const int FieldOperation = NodesParams[NodeOffset + SUM_VECTOR_OPERATION];

	int OffsetIndex = LocalIndex;
	const float ScalarMagnitude = HasScalar ? ContextDatas[OffsetIndex] : 1.0;
	OffsetIndex += HasScalar;
	const float3 VectorRight = HasRight ? float3(ContextDatas[OffsetIndex], ContextDatas[OffsetIndex + 1], ContextDatas[OffsetIndex + 2]) : float3(0, 0, 0);
	OffsetIndex += HasRight * 3;
	const float3 VectorLeft = HasLeft ? float3(ContextDatas[OffsetIndex], ContextDatas[OffsetIndex + 1], ContextDatas[OffsetIndex + 2]) : float3(0, 0, 0);

	float3 VectorDatas = float3(0.0, 0.0, 0.0);
	if (FieldOperation == MULTIPLY_OP)
	{
		VectorDatas = VectorRight * VectorLeft;
	}
	else if (FieldOperation == DIVIDE_OP)
	{
		VectorDatas = VectorLeft / VectorRight;
	}
	else if (FieldOperation == ADD_OP)
	{
		VectorDatas = VectorRight + VectorLeft;
	}
	else if (FieldOperation == SUBTRACT_OP)
	{
		VectorDatas = VectorLeft - VectorRight;
	}

	VectorDatas *= ScalarMagnitude * NodesParams[NodeOffset + SUM_VECTOR_MAGNITUDE];

	ContextDatas[LocalIndex++] = VectorDatas.x;
	ContextDatas[LocalIndex++] = VectorDatas.y;
	ContextDatas[LocalIndex++] = VectorDatas.z;
}

/* -----------------------------------------------------------------
 * Conversion Scalar
 * -----------------------------------------------------------------
 */
#define CONVERSION_INPUT 0

void EvaluateConversionScalar(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	// conversion in the same LocalIndex
}

/* -----------------------------------------------------------------
 * Conversion Integer
 * -----------------------------------------------------------------
 */

void EvaluateConversionInteger(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	// conversion in the same LocalIndex
}

/* -----------------------------------------------------------------
 * Culling Integer
 * -----------------------------------------------------------------
 */

#define CULLING_SCALAR 0
#define CULLING_INPUT 1
#define CULLING_OPERATION 2

void EvaluateCullingInteger(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const bool HasScalar = NodesParams[NodeOffset + CULLING_SCALAR];
	const bool HasInput = NodesParams[NodeOffset + CULLING_INPUT];

	LocalIndex -= HasScalar + HasInput;

	int OffsetIndex = LocalIndex;
	const float CullingScalar = HasScalar ? ContextDatas[OffsetIndex] : 0.0;
	OffsetIndex += CullingScalar;
	const int InputInteger = HasInput ? ContextDatas[OffsetIndex] : 0.0;

	const int CullingOperation = NodesParams[NodeOffset + CULLING_OPERATION];
	const bool ValidSample = ((CullingOperation == CULLING_OUTSIDE) && (CullingScalar != 0.0)) ||
							 ((CullingOperation == CULLING_INSIDE) && (CullingScalar == 0.0));

	ContextDatas[LocalIndex++] = ValidSample ? InputInteger : 0;
}

/* -----------------------------------------------------------------
 * Culling Scalar
 * -----------------------------------------------------------------
 */

void EvaluateCullingScalar(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const bool HasScalar = NodesParams[NodeOffset + CULLING_SCALAR];
	const bool HasInput = NodesParams[NodeOffset + CULLING_INPUT];

	LocalIndex -= HasScalar + HasInput;

	int OffsetIndex = LocalIndex;
	const float CullingScalar = HasScalar ? ContextDatas[OffsetIndex] : 0.0;
	OffsetIndex += CullingScalar;
	const float InputScalar = HasInput ? ContextDatas[OffsetIndex] : 0.0;

	const int CullingOperation = NodesParams[NodeOffset + CULLING_OPERATION];
	const bool ValidSample = ((CullingOperation == CULLING_OUTSIDE) && (CullingScalar != 0.0)) ||
							 ((CullingOperation == CULLING_INSIDE) && (CullingScalar == 0.0));

	ContextDatas[LocalIndex++] = ValidSample ? InputScalar : 0.0;
}

/* -----------------------------------------------------------------
 * Culling Vector
 * -----------------------------------------------------------------
 */

void EvaluateCullingVector(in float3 SamplePosition, in int NodeOffset,
				inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const bool HasScalar = NodesParams[NodeOffset + CULLING_SCALAR];
	const bool HasInput = NodesParams[NodeOffset + CULLING_INPUT];

	LocalIndex -= HasScalar + HasInput * 3;

	int OffsetIndex = LocalIndex;
	const float CullingScalar = HasScalar ? ContextDatas[OffsetIndex] : 0.0;
	OffsetIndex += CullingScalar;
	const float3 InputVector = HasInput ? float3(ContextDatas[OffsetIndex], ContextDatas[OffsetIndex + 1], ContextDatas[OffsetIndex + 2]) : float3(0, 0, 0);

	const int CullingOperation = NodesParams[NodeOffset + CULLING_OPERATION];
	const bool ValidSample = ((CullingOperation == CULLING_OUTSIDE) && (CullingScalar != 0.0)) ||
							 ((CullingOperation == CULLING_INSIDE) && (CullingScalar == 0.0));

	ContextDatas[LocalIndex++] = ValidSample ? InputVector.x : 0.0;
	ContextDatas[LocalIndex++] = ValidSample ? InputVector.y : 0.0;
	ContextDatas[LocalIndex++] = ValidSample ? InputVector.z : 0.0;
}

/* -----------------------------------------------------------------
 * Nodes evaluation
 * -----------------------------------------------------------------
 */

void EvaluateFieldNodeInteger(in float3 SamplePosition, in int NodeOffset,
		inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const int NodeType = NodesParams[NodeOffset];

	if (NodeType == UNIFORM_INTEGER)
	{
		EvaluateUniformInteger(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == RADIAL_MASK_INTEGER)
	{
		EvaluateRadialMaskInteger(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == CONVERSION_FIELD)
	{
		EvaluateConversionInteger(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == CULLING_FIELD)
	{
		EvaluateCullingInteger(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
}

void EvaluateFieldNodeScalar(in float3 SamplePosition, in int NodeOffset, inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const int NodeType = NodesParams[NodeOffset];

	if (NodeType == UNIFORM_SCALAR)
	{
		EvaluateUniformScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == RADIAL_FALLOFF_SCALAR)
	{
		EvaluateRadialFalloffScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == PLANE_FALLOFF_SCALAR)
	{
		EvaluatePlaneFalloffScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == BOX_FALLOFF_SCALAR)
	{
		EvaluateBoxFalloffScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == NOISE_SCALAR)
	{
		EvaluateNoiseScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == SUM_SCALAR)
	{
		EvaluateSumScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == CONVERSION_FIELD)
	{
		EvaluateConversionScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == CULLING_FIELD)
	{
		EvaluateCullingScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
}

void EvaluateFieldNodeVector(in float3 SamplePosition, in int NodeOffset,
				 inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const int NodeType = NodesParams[NodeOffset];

	if (NodeType == UNIFORM_VECTOR)
	{
		EvaluateUniformVector(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == RADIAL_VECTOR)
	{
		EvaluateRadialVector(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == RANDOM_VECTOR)
	{
		EvaluateRandomVector(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == SUM_VECTOR)
	{
		EvaluateSumVector(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (NodeType == CULLING_FIELD)
	{
		EvaluateCullingVector(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
}

void EvaluateFieldNodeDatas(in float3 SamplePosition, in int NodeOffset, inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const int DatasType = NodesParams[NodeOffset];

	if (DatasType == SCALAR_TYPE)
	{
		EvaluateFieldNodeScalar(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (DatasType == INTEGER_TYPE)
	{
		EvaluateFieldNodeInteger(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
	else if (DatasType == VECTOR_TYPE)
	{
		EvaluateFieldNodeVector(SamplePosition, NodeOffset + 1, ContextDatas, LocalIndex);
	}
}

void SampleFieldDatas(in float3 SamplePosition, inout float ContextDatas[MAX_DATAS], inout int LocalIndex)
{
	const int NodesBegin = TargetsOffsets[TargetType];
	const int NodesEnd = TargetsOffsets[TargetType + 1];
	const int NumNodes = NodesBegin - NodesEnd;

	for (int ContextIndex = 0; ContextIndex < MAX_DATAS; ++ContextIndex)
	{
		ContextDatas[ContextIndex] = 0;
	}
	if (NumNodes != 0)
	{
		for (int NodeIndex = NodesBegin; NodeIndex < NodesEnd; ++NodeIndex)
		{
			const int NodeOffset = NodesOffsets[NodeIndex];
			EvaluateFieldNodeDatas(SamplePosition, NodeOffset, ContextDatas, LocalIndex);
		}
	}
}

[numthreads(BUILD_FIELD_THREADGROUP_SIZEX, BUILD_FIELD_THREADGROUP_SIZEY, BUILD_FIELD_THREADGROUP_SIZEZ)]
void BuildPhysicsFieldClipmapCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID)
{
	if (all(DispatchThreadId.xyz < int3(ClipmapResolution, ClipmapResolution, ClipmapResolution)))
	{
		const float ClipmapExtent = ClipmapDistance * pow(ClipmapExponent, ClipmapIndex + 1 - ClipmapCount);
		
		const float3 SampleUV = (DispatchThreadId.xyz + 0.5) / ClipmapResolution;
		const float3 SamplePosition = ClipmapCenter + (SampleUV - 0.5) * 2.0 * ClipmapExtent;
		uint3 TextureCoordinates = DispatchThreadId;
	
		const int DatasOffset = ClipmapIndex + DatasIndex * ClipmapCount;
		TextureCoordinates.z += ClipmapResolution * DatasOffset + DatasOffset;
		
		float ContextDatas[MAX_DATAS];
		int LocalIndex = 0;

		SampleFieldDatas(SamplePosition, ContextDatas, LocalIndex);
		
		if (LocalIndex == 3)
		{
			FieldClipmap[TextureCoordinates] = ContextDatas[0];
			TextureCoordinates.z += (ClipmapResolution + 1) * ClipmapCount;
			FieldClipmap[TextureCoordinates] = ContextDatas[1];
			TextureCoordinates.z += (ClipmapResolution + 1) * ClipmapCount;
			FieldClipmap[TextureCoordinates] = ContextDatas[2];
		}
		else if (LocalIndex == 1)
		{
			FieldClipmap[TextureCoordinates] = ContextDatas[0];
		}
	}
}