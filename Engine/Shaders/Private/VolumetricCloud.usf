// Copyright Epic Games, Inc. All Rights Reserved.

/**
 * VolumetricCloud.usf: Render volumetric cloud on screen.
 */


#include "Common.ush"
#include "Random.ush"
#include "VolumetricCloudCommon.ush"

#if defined(SHADER_MAINVS) || defined(SHADER_RENDERVIEW_PS) || defined(SHADER_SHADOW_PS)

#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"

#include "ReflectionEnvironmentShared.ush"


struct RenderVolumetricCloudVSToPS
{
	FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
	float4 Position : SV_POSITION;
};

#if defined(SHADER_RENDERVIEW_PS) || defined(SHADER_SHADOW_PS)

float3 SampleExtinctionCoefficients(in FPixelMaterialInputs PixelMaterialInputs)
{
	return clamp(GetMaterialSubsurfaceDataRaw(PixelMaterialInputs).rgb, 0.0f, 65000.0f);
}

float3 SampleEmissive(in FPixelMaterialInputs PixelMaterialInputs)
{
	return USES_EMISSIVE_COLOR ? GetMaterialEmissive(PixelMaterialInputs) : 0.0f;
}

float3 SampleAlbedo(in FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(GetMaterialBaseColor(PixelMaterialInputs));
}

#endif

#endif



////////////////////////////////////////////////////////////
// When we get HZB.hlsl from Reverb, remove that and use common code. 
// Keeping duplicated code for now to avoid merge pain.
////////////////////////////////////////////////////////////

// Adapted from HZBOcclusion.usf.
// Rect contains screen coordinates as {minx, miny, maxx, maxy}. Those coordinates are not clamped to screen edges so they mnight be outside the [0,1]^2.
bool ViewHierarchicalZBufferMinDepth(float4 ScreenUVMinMax, const float MaxZDepth)
{
	float4 Rect = saturate(ScreenUVMinMax);
	float4 RectPixels = Rect * RenderVolumetricCloudParameters.HZBSize.xyxy;

	float2 RectSize = (RectPixels.zw - RectPixels.xy) * 0.5;	// 0.5 for 4x4
	float Level = max(ceil(log2(max(RectSize.x, RectSize.y))), RenderVolumetricCloudParameters.HZBUvFactor.z);

	// Check if we can drop one level lower
	float LevelLower = max(Level - 1, 0);
	float4 LowerRect = RectPixels * exp2(-LevelLower);
	float2 LowerRectSize = ceil(LowerRect.zw) - floor(LowerRect.xy);
	if (all(LowerRectSize <= 4))
	{
		Level = LevelLower;
	}

	// 4x4 samples
	float2 Scale = RenderVolumetricCloudParameters.HZBUvFactor.xy * (Rect.zw - Rect.xy) / 3;
	float2 Bias = RenderVolumetricCloudParameters.HZBUvFactor.xy * Rect.xy;

	float4 MinDepth = 1;
	/*UNROLL*/ for (int i = 0; i < 4; i++)
	{
		// TODO could vectorize this
		float4 Depth;
		Depth.x = RenderVolumetricCloudParameters.HZBTexture.SampleLevel(RenderVolumetricCloudParameters.HZBSampler, float2(i, 0) * Scale + Bias, Level).r;
		Depth.y = RenderVolumetricCloudParameters.HZBTexture.SampleLevel(RenderVolumetricCloudParameters.HZBSampler, float2(i, 1) * Scale + Bias, Level).r;
		Depth.z = RenderVolumetricCloudParameters.HZBTexture.SampleLevel(RenderVolumetricCloudParameters.HZBSampler, float2(i, 2) * Scale + Bias, Level).r;
		Depth.w = RenderVolumetricCloudParameters.HZBTexture.SampleLevel(RenderVolumetricCloudParameters.HZBSampler, float2(i, 3) * Scale + Bias, Level).r;
		MinDepth = min(MinDepth, Depth);
	}
	MinDepth.x = min(min(MinDepth.x, MinDepth.y), min(MinDepth.z, MinDepth.w));

	// Inverted Z buffer
	//return RectMax.z >= MinDepth.x ? true : false;
	return MaxZDepth >= MinDepth.x ? true : false;
}


////////////////////////////////////////////////////////////
// Single full screen triangle vertex shader
////////////////////////////////////////////////////////////

#ifdef SHADER_MAINVS

void MainVS(
	in FVertexFactoryInput FactoryInput,
	in uint VertexID : SV_VertexID,
	out RenderVolumetricCloudVSToPS Interpolants
)
{
	ResolvedView = ResolveView();

	// Full screen triangle
	Interpolants.Position = float4(VertexID == 2 || VertexID == 1 ? 1.0 : -3.0, VertexID == 1 ? -3.0 : 1.0, 0.5f, 1.0f);

	const float3 WorldPosition = 0.0f;
	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(FactoryInput);
	float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(FactoryInput, VFIntermediates);
	FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(FactoryInput, VFIntermediates, WorldPosition, TangentToLocal);
	Interpolants.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(FactoryInput, VFIntermediates, VertexParameters);

	OutputVertexID(Interpolants);
}

#endif // SHADER_MAINVS



////////////////////////////////////////////////////////////
// Common structures and functions
////////////////////////////////////////////////////////////

#if CLOUD_LAYER_PIXEL_SHADER

float3 HUEtoRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R, G, B));
}

float3 HSVtoRGB(in float3 HSV)
{
	float3 RGB = HUEtoRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}

float3 GetColorCode(float x)
{
	float c = (1 - saturate(x)) * 0.6; // Remap [0,1] to Blue-Red
	return x > 0 ? HSVtoRGB(float3(c, 1, 1)) : float3(0, 0, 0);
}

bool RayIntersectSphereSolution(float3 RayOrigin, float3 RayDirection, float4 Sphere, inout float2 Solutions)
{
	float3 LocalPosition = RayOrigin - Sphere.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);

	float3 QuadraticCoef;
	QuadraticCoef.x = dot(RayDirection, RayDirection);
	QuadraticCoef.y = 2 * dot(RayDirection, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - Sphere.w * Sphere.w;

	float Discriminant = QuadraticCoef.y * QuadraticCoef.y - 4 * QuadraticCoef.x * QuadraticCoef.z;

	// Only continue if the ray intersects the sphere
	FLATTEN
	if (Discriminant >= 0)
	{
		float SqrtDiscriminant = sqrt(Discriminant);
		Solutions = (-QuadraticCoef.y + float2(-1, 1) * SqrtDiscriminant) / (2 * QuadraticCoef.x);
		return true;
	}

	return false;
}

struct FCloudLayerParameters
{
	float3 CloudLayerCenter;
	float PlanetRadius;
	float BottomRadius;
	float TopRadius;
	float ToNormAltitude;
};

FCloudLayerParameters GetCloudLayerParams()
{
	FCloudLayerParameters CloudLayerParams;
	CloudLayerParams.CloudLayerCenter = RenderVolumetricCloudParameters.CloudLayerCenterKm * KILOMETER_TO_CENTIMETER;
	CloudLayerParams.PlanetRadius = RenderVolumetricCloudParameters.PlanetRadiusKm * KILOMETER_TO_CENTIMETER;
	CloudLayerParams.BottomRadius = RenderVolumetricCloudParameters.BottomRadiusKm * KILOMETER_TO_CENTIMETER;
	CloudLayerParams.TopRadius = RenderVolumetricCloudParameters.TopRadiusKm * KILOMETER_TO_CENTIMETER;
	CloudLayerParams.ToNormAltitude = 1.0 / (CloudLayerParams.TopRadius - CloudLayerParams.BottomRadius);
	return CloudLayerParams;
}

// Function to update the material parameter structure for an evaluation
void UpdateMaterialCloudParam(inout FMaterialPixelParameters MaterialParameters, 
	float3 AbsoluteWorldPosition, in ViewState InputView, in FCloudLayerParameters CloudLayerParams)
{
	MaterialParameters.AbsoluteWorldPosition = AbsoluteWorldPosition;
	MaterialParameters.WorldPosition_CamRelative = MaterialParameters.AbsoluteWorldPosition + InputView.PreViewTranslation.xyz;
	//MaterialParameters.WorldPosition_NoOffsets;				// TODO
	//MaterialParameters.WorldPosition_NoOffsets_CamRelative;	// TODO
	MaterialParameters.CameraVector = normalize(InputView.WorldCameraOrigin - MaterialParameters.AbsoluteWorldPosition);

	float CloudSampleAltitude = length(MaterialParameters.AbsoluteWorldPosition - CloudLayerParams.CloudLayerCenter);
	MaterialParameters.CloudSampleAltitude = CloudSampleAltitude - CloudLayerParams.PlanetRadius;
	MaterialParameters.CloudSampleAltitudeInLayer = CloudSampleAltitude - CloudLayerParams.BottomRadius;
	MaterialParameters.CloudSampleNormAltitudeInLayer = MaterialParameters.CloudSampleAltitudeInLayer * CloudLayerParams.ToNormAltitude;

	const float DefaultConservativeDensity = 1.0f;
	MaterialParameters.VolumeSampleConservativeDensity = DefaultConservativeDensity;								// This should not be used when evaluating density. But it still is initialised.
#if MATERIAL_VOLUMETRIC_ADVANCED_CONSERVATIVE_DENSITY
	MaterialParameters.VolumeSampleConservativeDensity = GetVolumetricAdvancedMaterialOutput6(MaterialParameters);	// Evaluate conservative density
#endif
}

#endif // CLOUD_LAYER_PIXEL_SHADER



////////////////////////////////////////////////////////////
// Single full screen triangle vertex shader
////////////////////////////////////////////////////////////

#ifdef SHADER_RENDERVIEW_PS

#include "/Engine/Private/SkyAtmosphereCommon.ush"

#ifndef MATERIAL_VOLUMETRIC_ADVANCED
#define MATERIAL_VOLUMETRIC_ADVANCED 0
#endif
#ifndef MATERIAL_VOLUMETRIC_ADVANCED_PHASE_PERPIXEL
#define MATERIAL_VOLUMETRIC_ADVANCED_PHASE_PERPIXEL 0
#endif
#ifndef MATERIAL_VOLUMETRIC_ADVANCED_PHASE_PERSAMPLE
#define MATERIAL_VOLUMETRIC_ADVANCED_PHASE_PERSAMPLE 0
#endif
#ifndef MATERIAL_VOLUMETRIC_ADVANCED_MULTISCATTERING_OCTAVE_COUNT
#define MATERIAL_VOLUMETRIC_ADVANCED_MULTISCATTERING_OCTAVE_COUNT 0
#endif


#if CLOUD_SAMPLE_ATMOSPHERIC_LIGHT_SHADOWMAP

#define DYNAMICALLY_SHADOWED 1
#define TREAT_MAXDEPTH_UNSHADOWED 1

#define SHADOW_QUALITY 2
#define NO_TRANSLUCENCY_AVAILABLE

#include "ShadowProjectionCommon.ush"
#include "ShadowFilteringCommon.ush"

#define VOLUME_SHADOW_SAMPLING_INPUT 0
// We cannot have Light0Shadow as an additional global parameter structure when rendering a MeshMaterialShader (only one PassUniformBuffer).
// So instead it has been included and redirected using a macro here. This however prevents us to have two atmospheric lights casting shadow at the same time...
#define Light0Shadow RenderVolumetricCloudParameters
#include "VolumeLightingCommonSampling.ush"
#undef VOLUME_SHADOW_SAMPLING_INPUT
#undef Light0Shadow

#endif

float IsotropicPhase()
{
	return 1.0f / (4.0f * PI);
}

// TODO MAKE all phase function common between sky, cloud anmd volumetric
float HgPhase(float G, float CosTheta)
{
	// Reference implementation (i.e. not schlick approximation). 
	// See http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html
	float Numer = 1.0f - G * G;
	float Denom = 1.0f + G * G + 2.0f * G * CosTheta;
	return Numer / (4.0f * PI * Denom * sqrt(Denom));
}

float SamplePhaseFunction(in float PhaseCosTheta, in float PhaseG, in float PhaseG2, in float PhaseBlend)
{
	PhaseG = clamp(PhaseG, -0.999f, 0.999f);
	PhaseG2 = clamp(PhaseG2, -0.999f, 0.999f);
	PhaseBlend = clamp(PhaseBlend, 0.0f, 1.0f);
	float MiePhaseValueLight0 = HgPhase(PhaseG, -PhaseCosTheta);	// negate cosTheta because due to WorldDir being a "in" direction. 
	float MiePhaseValueLight1 = HgPhase(PhaseG2, -PhaseCosTheta);
	const float Phase = MiePhaseValueLight0 + PhaseBlend * (MiePhaseValueLight1 - MiePhaseValueLight0);
	return Phase;
}


// Multi scattering approximation based on http://magnuswrenninge.com/wp-content/uploads/2010/03/Wrenninge-OzTheGreatAndVolumetric.pdf
// 1 is for the default single scattering look. Then [2,N] is for extra "octaves"
#ifndef MSCOUNT
#define MSCOUNT (1 + MATERIAL_VOLUMETRIC_ADVANCED_MULTISCATTERING_OCTAVE_COUNT)
#endif

struct ParticipatingMediaContext
{
	float3 ScatteringCoefficients[MSCOUNT];
	float3 ExtinctionCoefficients[MSCOUNT];

	float3 TransmittanceToLight[MSCOUNT];
};

ParticipatingMediaContext SetupParticipatingMediaContext(float3 BaseAlbedo, float3 BaseExtinctionCoefficients, float MsSFactor, float MsEFactor, float3 InitialTransmittanceToLight)
{
	const float3 ScatteringCoefficients = BaseAlbedo * BaseExtinctionCoefficients;
	//const float3 AbsorptionCoefficients = max(0.0f, BaseExtinctionCoefficients - ScatteringCoefficients);

	ParticipatingMediaContext PMC;
	PMC.ScatteringCoefficients[0] = ScatteringCoefficients;
	PMC.ExtinctionCoefficients[0] = BaseExtinctionCoefficients;
	PMC.TransmittanceToLight[0] = InitialTransmittanceToLight;

	[unroll]
	for (int ms = 1; ms < MSCOUNT; ++ms)
	{
		PMC.ScatteringCoefficients[ms] = PMC.ScatteringCoefficients[ms - 1] * MsSFactor;
		PMC.ExtinctionCoefficients[ms] = PMC.ExtinctionCoefficients[ms - 1] * MsEFactor;
		MsSFactor *= MsSFactor;
		MsEFactor *= MsEFactor;

		PMC.TransmittanceToLight[ms] = InitialTransmittanceToLight;
	}

	return PMC;
}


struct ParticipatingMediaPhaseContext
{
	float Phase[MSCOUNT];
};

ParticipatingMediaPhaseContext SetupParticipatingMediaPhaseContext(float BasePhase, float MsPhaseFactor)
{
	ParticipatingMediaPhaseContext PMPC;
	PMPC.Phase[0] = BasePhase;

	[unroll]
	for (int ms = 1; ms < MSCOUNT; ++ms)
	{
		PMPC.Phase[ms] = lerp(IsotropicPhase(), PMPC.Phase[0], MsPhaseFactor);
		MsPhaseFactor *= MsPhaseFactor;
	}

	return PMPC;
}

// When transmittance is below, end tracing and accept full opacity
#define TransmittanceCutThreshold 0.005f

bool TraceClouds(
	in float4 SvPosition,
	inout float4 OutColor0,
	inout float  OutColor1,
	inout float3 RayOrigin,
	inout float3 RayOriginKm,
	inout float3 Raydir,
	inout float TMin,
	inout float TMax,
	inout FMaterialPixelParameters MaterialParameters,
	inout FPixelMaterialInputs PixelMaterialInputs,
	inout float3 Luminance,
	inout float3 TransmittanceToView,
	inout float  tAPWeightedSum,
	inout float  tAPWeightsSum
	)
{
	//
	// Check tracing start and end position within the cloud layer
	//

	float2 tTop2 = 0.0f;
	if (RayIntersectSphereSolution(RayOriginKm, Raydir, float4(RenderVolumetricCloudParameters.CloudLayerCenterKm, RenderVolumetricCloudParameters.TopRadiusKm), tTop2))
	{
		float2 tBottom2 = 0.0f;
		if (RayIntersectSphereSolution(RayOriginKm, Raydir, float4(RenderVolumetricCloudParameters.CloudLayerCenterKm, RenderVolumetricCloudParameters.BottomRadiusKm), tBottom2))
		{
			// If we see both intersection in front of us, keep the min/closest, otherwise the max/furthest
			float TempTop = all(tTop2 > 0.0f) ? min(tTop2.x, tTop2.y) : max(tTop2.x, tTop2.y);
			float TempBottom = all(tBottom2 > 0.0f) ? min(tBottom2.x, tBottom2.y) : max(tBottom2.x, tBottom2.y);

			if (all(tBottom2 > 0.0f))
			{
				// But if we can see the bottom of the layer, make sure we use the camera or the highest top layer intersection
				TempTop = max(0.0f, min(tTop2.x, tTop2.y));
			}

			TMin = min(TempBottom, TempTop);
			TMax = max(TempBottom, TempTop);
		}
		else
		{
			// Only intersecting with the top atmosphere, we have our min and max t
			TMin = tTop2.x;
			TMax = tTop2.y;
		}
	}
	else
	{
		// No intersection with at least the top of the atmosphere
		//OutColor0 = float4(1.0f, 0.0f, 0.0f, 1.0f);
		return false;
	}
	TMin = max(0.0f, TMin) * KILOMETER_TO_CENTIMETER;
	TMax = max(0.0f, TMax) * KILOMETER_TO_CENTIMETER;


	//
	// Skip tracing if needed
	//

	if (!(TMax > TMin && TMin < RenderVolumetricCloudParameters.TracingStartMaxDistance))
	{
		// The tracing range is invalid or the position is too far to start tracing
		OutColor0 = float4(0.0f, 0.0f, 0.0f, 1.0f); // need to write again into OutColor0&1 otherwise the compiler was complaining...
		OutColor1 = MaxHalfFloat;
		return false;
	}



	//
	// Sample the depth buffer and update tracing distance
	//

	uint4 SubSetCoordToFullResolutionScaleBias = RenderVolumetricCloudParameters.SubSetCoordToFullResolutionScaleBias;
	float DeviceZ = RenderVolumetricCloudParameters.SceneDepthTexture.Load(uint3(uint2(SvPosition.xy) * SubSetCoordToFullResolutionScaleBias.xy + SubSetCoordToFullResolutionScaleBias.zw, 0)).r;
#if HAS_INVERTED_Z_BUFFER
	DeviceZ = max(0.000000000001, DeviceZ);
#endif
	float3 DepthBufferWorldPos = SvPositionToWorld(float4(SvPosition.xy, DeviceZ, 1.0));
	float TDepthBuffer = length(DepthBufferWorldPos - RayOrigin);

	if (RenderVolumetricCloudParameters.IntersectWithOpaque > 0)
	{
		if (TDepthBuffer < TMin)
		{
			// If there is an opaque object in front of the cloud layer, we wantto try to keep tracing near the edges to help with reprojection and upsampling quality.
			// At the same time, we want to  avoid tracing inside the opaque meshes as an optimisation. 
			// We also need to be carefull with meshes intersecting the layer to not see through them at edges.
		
			float3 DepthBufferPosition = RayOrigin + TDepthBuffer * Raydir;
			float3 CloudLayerFrontPosition = RayOrigin + TMin * Raydir;
			float4 CloudLayerFrontClipPosition = mul(float4((CloudLayerFrontPosition + ResolvedView.PreViewTranslation).xyz, 1.0f), ResolvedView.TranslatedWorldToClip);
			float CloudLayerFrontZDepth = (CloudLayerFrontClipPosition / CloudLayerFrontClipPosition.w).z;
		
			const float DistanceInFrontOfLayerCullingTracing = 50000.0f; // 500 meters
			float4 ScreenUVMinMax = saturate((SvPosition.xyxy + float4(-1.0f, -1.0f, 1.0f, 1.0f)) * RenderVolumetricCloudParameters.OutputSizeInvSize.zwzw);
			if (
				RenderVolumetricCloudParameters.HasValidHZB &&
				(
					// We are not conservatively being an opaque mesh (we are still going to trace around opaque mesh edges)
					!ViewHierarchicalZBufferMinDepth(ScreenUVMinMax, CloudLayerFrontZDepth) ||
					// Under the cloud layer, at the intersection between opaque and to the cloud bottom layer, we do not want to see through opaque object.
					// This is a bit arbitrary and assumes we are at the top of the planet but it helps a lot with quality.
					((CloudLayerFrontPosition.z - DepthBufferPosition.z) < DistanceInFrontOfLayerCullingTracing && CloudLayerFrontPosition.z > DepthBufferPosition.z)
				)
			)
			{
				// The sky is not visible when using conservative furthest depth so we do not trace cloud.
				OutColor0 = float4(0.0, 0.0, 0.0, 1.0);
				// We write depth as the cloud layer front interface when behind opaque objects. This is to help with bnilateral reconstruction later and obtain sharper edges around meshes.
				OutColor1 = max(TMin, TDepthBuffer) * CENTIMETER_TO_KILOMETER;
		
				return false; 
			}
		}
		else
		{
			// Only trace up to the closest between the cloud layer far distance and the depth buffer 
			TMax = min(TMax, TDepthBuffer);
		}
	}


	//
	// Prepare a bunch of variable for the tracing
	//

#if CLOUD_PER_SAMPLE_ATMOSPHERE_TRANSMITTANCE 
	const float3 Light0Illuminance = ResolvedView.AtmosphereLightColor[0].rgb;
#else
	const float3 Light0Illuminance = ResolvedView.AtmosphereLightColorGlobalPostTransmittance[0].rgb;
#endif
	const float3 Light0IlluminanceFinal = Light0Illuminance * (RenderVolumetricCloudParameters.EnableAtmosphericLightsSampling ? RenderVolumetricCloudParameters.AtmosphericLightsContributionFactor.rgb : float3(0.0f, 0.0f, 0.0f));
	const float3 Light0Direction = ResolvedView.AtmosphereLightDirection[0].xyz;

	const bool SkyAtmospherePresentInScene = ResolvedView.SkyAtmospherePresentInScene > 0.0f;

	// Clamp to max distance
	const float MarchingDistance = min(RenderVolumetricCloudParameters.TracingMaxDistance, TMax - TMin);
	TMax = TMin + MarchingDistance;

	const uint  IStepCount = RenderVolumetricCloudParameters.SampleCountMax * saturate((TMax - TMin) * RenderVolumetricCloudParameters.InvDistanceToSampleCountMax);
	const float StepCount = float(IStepCount);
	const float StepT = (TMax - TMin) / StepCount; // StepT is step distance in centimeters
	const float dtMeters = StepT * CENTIMETER_TO_METER;
	// TODO adaptive sample count based on distance

	// This is the scattered sky light luminance assuming a uniform phase function.
	// TODO Approximate some form of occlusion
	// TODO have some directionality: use SH from sky atmosphere? Or GetSkySHDiffuse/GetSkySHDiffuseSimple for dynamic SkyLightCapture.
	float3 DistantSkyLightLuminance = 0.0f;
	if (RenderVolumetricCloudParameters.EnableDistantSkyLightSampling)
	{
		if (SkyAtmospherePresentInScene)
		{
			// TODO Only works for ground view. This should be spatially varying for space viewsspace view. 
			// TODO Have a illuminance texture to get that overall ambient contribution? 
			// TODO An approximation would be to multiply it with sun transmittance?
			DistantSkyLightLuminance = Texture2DSampleLevel(View.DistantSkyLightLutTexture, View.DistantSkyLightLutTextureSampler, float2(0.5f, 0.5f), 0.0f).rgb;
		}
		else
		{
			// That unfortunately will create a bad feedback loop since clouds will be captured in the sky light.
			DistantSkyLightLuminance = GetSkySHDiffuseSimple(float3(0.0f, 0.0f, 0.0f)); // without SH directionality
		}
	}



	// Evalaute Factors once per pixel
#if MATERIAL_VOLUMETRIC_ADVANCED
	const float MsScattFactor = saturate(GetVolumetricAdvancedMaterialOutput3(MaterialParameters));
	const float MsExtinFactor = saturate(GetVolumetricAdvancedMaterialOutput4(MaterialParameters));
	const float MsPhaseFactor = saturate(GetVolumetricAdvancedMaterialOutput5(MaterialParameters));
#else
	const float MsScattFactor = 1.0f;
	const float MsExtinFactor = 1.0f;
	const float MsPhaseFactor = 1.0f;
#endif

	uint DebugPrimaryMaterialSampleCount = 0;
	uint DebugShadowSampleCount = 0;
	uint DebugShadowMaterialSampleCount = 0;
	uint DebugGroundShadowSampleCount = 0;
	uint DebugGroundShadowMaterialSampleCount = 0;

	const float3 wi = Light0Direction;
	const float3 wo = Raydir;
	const float PhaseCosTheta = dot(wi, wo);
#if MATERIAL_VOLUMETRIC_ADVANCED
#if MATERIAL_VOLUMETRIC_ADVANCED_PHASE_PERPIXEL
	const float Phase = SamplePhaseFunction(PhaseCosTheta, GetVolumetricAdvancedMaterialOutput0(MaterialParameters),
		GetVolumetricAdvancedMaterialOutput1(MaterialParameters), GetVolumetricAdvancedMaterialOutput2(MaterialParameters));
	ParticipatingMediaPhaseContext PMPC = SetupParticipatingMediaPhaseContext(Phase, MsPhaseFactor);
#endif
#else
	const float Phase = IsotropicPhase();
	ParticipatingMediaPhaseContext PMPC = SetupParticipatingMediaPhaseContext(Phase, MsPhaseFactor);
#endif

	FCloudLayerParameters CloudLayerParams = GetCloudLayerParams();

	const float3 PlanetSurfaceNormal = float3(0.0f, 0.0f, 1.0f);	// Ambient contribution from the clouds is only done on a plane above the planet, e.g. do not support space view yet
	const float3 GroundBrdfNdotL = saturate(dot(Light0Direction, PlanetSurfaceNormal)) * (RenderVolumetricCloudParameters.GroundAlbedo.rgb / PI); // Assuming pure Lambert diffuse surface.
	const float3 GroundHemisphereLuminanceIsotropic = (2.0f * PI) * IsotropicPhase(); // Assumes the ground is uniform luminance to the cloud and solid angle is bottom hemisphere 2PI
	const float3 GroundToCloudTransfertIsoScatter = GroundBrdfNdotL * GroundHemisphereLuminanceIsotropic;


	//
	// TRACING LOOP
	//

	float t = TMin + 0.5 * StepT;
	if (RenderVolumetricCloudParameters.IsReflectionRendering == 0)
	{
		// Using simple ALU based noise as it seems to work the best now. Mod8 is also used to stabilise the result when the amount of sample cannot converge to the correct integration.
		t = TMin + (float(Rand3DPCG16(int3(SvPosition.xy, View.StateFrameIndexMod8)).x) * rcp(65536.0)) * StepT;
		//const uint VolumetricRTMode = RenderVolumetricCloudParameters.VolumetricRenderTargetMode;
		/*t = TMin + StepT * InterleavedGradientNoise(
			VolumetricRTMode == 2 ? uint2(SvPosition.xy) * SubSetCoordToFullResolutionScaleBias.xy + SubSetCoordToFullResolutionScaleBias.zw	: uint2(SvPosition.xy),
			VolumetricRTMode == 2 ? float(RenderVolumetricCloudParameters.NoiseFrameIndexModPattern)											: float(View.StateFrameIndexMod8));
		*/
		/*t = TMin + RenderVolumetricCloudParameters.BlueNoise.Texture.Load(
			uint3(uint2(uint2(SvPosition.xy) * SubSetCoordToFullResolutionScaleBias.xy + SubSetCoordToFullResolutionScaleBias.zw) % RenderVolumetricCloudParameters.BlueNoise.Dimensions.xx
				+ uint2(0, ((RenderVolumetricCloudParameters.NoiseFrameIndexModPattern) % RenderVolumetricCloudParameters.BlueNoise.Dimensions.z) * RenderVolumetricCloudParameters.BlueNoise.Dimensions.y), 0)).r * StepT;
		*/
	}


	for (uint i = 0; i < IStepCount; ++i)
	{
		int ms;
		float3 SampleWorldPosition = RayOrigin + t * Raydir;


		//////////////////////////////
		// Update FMaterialPixelParameters according to current sample.
		//////////////////////////////
		UpdateMaterialCloudParam(MaterialParameters, SampleWorldPosition, ResolvedView, CloudLayerParams);

	#if MATERIAL_VOLUMETRIC_ADVANCED_CONSERVATIVE_DENSITY
		if (MaterialParameters.VolumeSampleConservativeDensity <= 0.0f)
		{
			t += StepT;
			continue; // Conservative density is 0 so skip and go to the next sample
		}
	#endif


		//////////////////////////////
		// Sample the participating media material at the sample position.
		//////////////////////////////
		DebugPrimaryMaterialSampleCount++;
		CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);
		const float3 ExtinctionCoefficients = SampleExtinctionCoefficients(PixelMaterialInputs);
		const float3 EmissiveLuminance = USES_EMISSIVE_COLOR ? SampleEmissive(PixelMaterialInputs) : 0.0f;
		const float3 Albedo = SampleAlbedo(PixelMaterialInputs);

	#if MATERIAL_VOLUMETRIC_ADVANCED_PHASE_PERSAMPLE
		const float Phase = SamplePhaseFunction(PhaseCosTheta, GetVolumetricAdvancedMaterialOutput0(MaterialParameters),
			GetVolumetricAdvancedMaterialOutput1(MaterialParameters), GetVolumetricAdvancedMaterialOutput2(MaterialParameters));
		ParticipatingMediaPhaseContext PMPC = SetupParticipatingMediaPhaseContext(Phase, MsPhaseFactor);
	#endif

	#if CLOUD_PER_SAMPLE_ATMOSPHERE_TRANSMITTANCE
		// Apply per sample change of transmittance due to atmosphere. More expenssive but higher quality, (and required for space view)
		const float3 PlanetCenterToWorldPos = (SampleWorldPosition - ResolvedView.SkyPlanetCenterAndViewHeight.xyz) * CM_TO_SKY_UNIT;
		const float3 AtmosphereTransmittanceToLight = GetAtmosphereTransmittance(
			PlanetCenterToWorldPos, Light0Direction, ResolvedView.SkyAtmosphereBottomRadiusKm, ResolvedView.SkyAtmosphereTopRadiusKm,
			View.TransmittanceLutTexture, View.TransmittanceLutTextureSampler);
	#else
		const float3 AtmosphereTransmittanceToLight = 1.0f;
	#endif


		ParticipatingMediaContext PMC = SetupParticipatingMediaContext(Albedo, ExtinctionCoefficients, MsScattFactor, MsExtinFactor, AtmosphereTransmittanceToLight);


		// We always apply the sky distant luminance as computed by the SkyAtmosphere component for a given altitude. TODO: this should be spatially varyinf accoring to height and sun angle.
		float3 DistantLightLuminance = DistantSkyLightLuminance;


		//////////////////////////////
		// Evaluate some data if there is medium causing scattering, e.g. shadow, ground lighting
		//////////////////////////////
		if (any(PMC.ScatteringCoefficients[0] > 0.0f))
		{
			const float MaxTransmittanceToView = max(max(TransmittanceToView.x, TransmittanceToView.y), TransmittanceToView.z);

			//
			// A- we compute lighting bouncing off the ground: affected by light direction, transmittance in the atmosphere and albedo.
			//
			const float3 ScatteredLightLuminance = AtmosphereTransmittanceToLight * Light0Illuminance * GroundToCloudTransfertIsoScatter;
			const float3 TransmittedScatteredLightLuminance = ScatteredLightLuminance * exp(-PMC.ExtinctionCoefficients[0] * MaterialParameters.CloudSampleAltitudeInLayer * CENTIMETER_TO_METER);
		#if MATERIAL_VOLUMETRIC_ADVANCED_GROUND_CONTRIBUTION
			if (MaxTransmittanceToView > 0.01f)
			{
				DebugGroundShadowSampleCount++;
				// Cheap approximation assuming a single transmittance using only current sample extinction value. If we are withint the AO texture bounds, we lerp towards its more accurate result.
				//DistantLightLuminance += TransmittedScatteredLightLuminance;

				float3 OpticalDepth = 0.0f;
				const float ShadowLengthTest = min(5.0 * KILOMETER_TO_CENTIMETER, MaterialParameters.CloudSampleAltitudeInLayer);
				const float ShadowStepCount = 5.0f;
				const float InvShadowStepCount = 1.0f / ShadowStepCount;

			#if 1
				// Non-linear shadow sample distribution, hardcoded to x^2
				float PreviousNormT = 0.0f;
				for (float ShadowT = InvShadowStepCount; ShadowT <= 1.0; ShadowT += InvShadowStepCount)
				{
					DebugGroundShadowMaterialSampleCount++;
					float CurrentNormT = ShadowT * ShadowT; // CurrentNormT is the end of the considered segment to integrate, PreviousNormT is its beginning.
					const float DetlaNormT = CurrentNormT - PreviousNormT;
					UpdateMaterialCloudParam(MaterialParameters, SampleWorldPosition + float3(0.0f, 0.0f, -1.0f) * ShadowLengthTest * (CurrentNormT - 0.5 * DetlaNormT), ResolvedView, CloudLayerParams);
					PreviousNormT = CurrentNormT;
				#if MATERIAL_VOLUMETRIC_ADVANCED_CONSERVATIVE_DENSITY
					if (MaterialParameters.VolumeSampleConservativeDensity <= 0.0f)
					{
						continue; // Conservative density is 0 so skip and go to the next sample
					}
				#endif
					CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);
					OpticalDepth += SampleExtinctionCoefficients(PixelMaterialInputs) * ShadowLengthTest * CENTIMETER_TO_METER * DetlaNormT;
				}
			#else
				// Linear shadow sample distribution.
				const float ShadowDtMeter = ShadowLengthTest * CENTIMETER_TO_METER / ShadowStepCount;
				const float ShadowJitteringSeed = float(ResolvedView.StateFrameIndexMod8) + PseudoRandom(SvPosition.xy) + i * 17;
				const float ShadowJitterNorm = InterleavedGradientNoise(SvPosition.xy, ShadowJitteringSeed) - 0.5f;
				for (float ShadowT = 0.5; ShadowT < ShadowStepCount; ShadowT += 1.0f)
				{
					UpdateMaterialCloudParam(MaterialParameters, SampleWorldPosition + float3(0.0f, 0.0f, -1.0f) * ShadowLengthTest * (ShadowT * InvShadowStepCount), ResolvedView, CloudLayerParams);
				#if MATERIAL_VOLUMETRIC_ADVANCED_CONSERVATIVE_DENSITY
					if (MaterialParameters.VolumeSampleConservativeDensity <= 0.0f)
					{
						continue; // Conservative density is 0 so skip and go to the next sample
					}
				#endif
					CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);
					OpticalDepth += SampleExtinctionCoefficients(PixelMaterialInputs) * ShadowDtMeter;
				}
			#endif

				DistantLightLuminance += ScatteredLightLuminance * exp(-OpticalDepth);
			}
		#endif // MATERIAL_VOLUMETRIC_ADVANCED_GROUND_CONTRIBUTION

		#if CLOUD_SAMPLE_ATMOSPHERIC_LIGHT_SHADOWMAP
			//
			// B- sample shadow from opaque if enabled
			//
			const float OpaqueShadow = ComputeLight0VolumeShadowing(SampleWorldPosition, false, false);
			[unroll]
			for (ms = 0; ms < MSCOUNT; ++ms)
			{
				PMC.TransmittanceToLight[ms] *= OpaqueShadow;
			}
		#endif // CLOUD_SAMPLE_ATMOSPHERIC_LIGHT_SHADOWMAP

			//
			// C- shadow from volumetric 
			//
		#if 0 // Use cloud shadowmap instead of ray marching
			float OutOpticalDepth = 0.0f;
			float CloudShadow = GetCloudVolumetricShadow(SampleWorldPosition, RenderVolumetricCloudParameters.CloudShadowmapWorldToLightClipMatrix, RenderVolumetricCloudParameters.CloudShadowmapFarDepthKm,
				RenderVolumetricCloudParameters.ShadowTexture, RenderVolumetricCloudParameters.CloudBilinearTextureSampler, OutOpticalDepth);
			[unroll]
			for (ms = 0; ms < MSCOUNT; ++ms)
			{
				PMC.TransmittanceToLight[ms] *= exp(-OutOpticalDepth * (ms == 0 ? 1.0f : pow(MsExtinFactor, ms)));
			}
		#else // Use cloud shadowmap
			DebugShadowSampleCount++;
			const float ShadowLengthTest = RenderVolumetricCloudParameters.ShadowTracingMaxDistance;
			const float ShadowStepCount = float(RenderVolumetricCloudParameters.ShadowSampleCountMax);
			const float InvShadowStepCount = 1.0f / ShadowStepCount;

			float3 ExtinctionAcc[MSCOUNT];
			[unroll]
			for (ms = 0; ms < MSCOUNT; ++ms)
			{
				ExtinctionAcc[ms] = 0.0f;
			}

			const float ShadowJitteringSeed = float(ResolvedView.StateFrameIndexMod8) + PseudoRandom(SvPosition.xy);
			const float ShadowJitterNorm = 0.5f; // InterleavedGradientNoise(SvPosition.xy, ShadowJitteringSeed); // Disabled jittering for now as this one cannot be hidden well by TAA in some cases.
		#if 0
			// Linear shadow samples (reference)
			const float ShadowDtMeter = ShadowLengthTest * CENTIMETER_TO_METER / ShadowStepCount;
			for (float ShadowT = ShadowJitterNorm; ShadowT < ShadowStepCount; ShadowT += 1.0f)
			{
				UpdateMaterialCloudParam(MaterialParameters, SampleWorldPosition + Light0Direction * ShadowLengthTest * (ShadowT * InvShadowStepCount), ResolvedView, CloudLayerParams);
				const float ExtinctionFactor = 1.0f;
		#else
			// Non-linear shadow sample distribution, hardcoded to x^2
			const float ShadowDtMeter = ShadowLengthTest * CENTIMETER_TO_METER;
			float PreviousNormT = 0.0f;
			for (float ShadowT = InvShadowStepCount; ShadowT <= 1.0; ShadowT += InvShadowStepCount)
			{
				float CurrentNormT = ShadowT * ShadowT; // CurrentNormT is the end of the considered segment to integrate, PreviousNormT is its beginning.
				const float DetlaNormT = CurrentNormT - PreviousNormT;
				const float ExtinctionFactor = DetlaNormT;
				UpdateMaterialCloudParam(MaterialParameters, SampleWorldPosition + Light0Direction * ShadowLengthTest * (PreviousNormT + DetlaNormT * ShadowJitterNorm), ResolvedView, CloudLayerParams);
				PreviousNormT = CurrentNormT;
		#endif

			#if MATERIAL_VOLUMETRIC_ADVANCED_CONSERVATIVE_DENSITY
				if (MaterialParameters.VolumeSampleConservativeDensity <= 0.0f)
				{
					continue; // Conservative density is 0 so skip and go to the next sample
				}
			#endif

				if (MaterialParameters.CloudSampleNormAltitudeInLayer < 0.0f || MaterialParameters.CloudSampleNormAltitudeInLayer > 1.0f)
				{
					break; // Ignore remaining samples since we have just traveld out of the cloud layer.
				}

				DebugShadowMaterialSampleCount++;
				CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);
				float3 ShadowExtinctionCoefficients = SampleExtinctionCoefficients(PixelMaterialInputs);

				ParticipatingMediaContext ShadowPMC = SetupParticipatingMediaContext(0.0f, ShadowExtinctionCoefficients, MsScattFactor, MsExtinFactor, 0.0f);

				[unroll]
				for (ms = 0; ms < MSCOUNT; ++ms)
				{
					ExtinctionAcc[ms] += ShadowPMC.ExtinctionCoefficients[ms] * ExtinctionFactor;
				}
			}

			[unroll]
			for (ms = 0; ms < MSCOUNT; ++ms)
			{
				PMC.TransmittanceToLight[ms] *= exp(-ExtinctionAcc[ms] * ShadowDtMeter);
			}
		#endif // Use cloud shadowmap
		}


		//
		// From this point, MaterialParameters and CloudLayerParams cannot be used because they have been corrupted by the ray marched volume shadow integrator above!
		//


		// Compute the weighted average of t for the aerial perspective evaluation.
		if (any(PMC.ExtinctionCoefficients[0]) > 0.0)
		{
			float tAPWeight = min(TransmittanceToView.r, min(TransmittanceToView.g, TransmittanceToView.b));
			tAPWeightedSum += t * tAPWeight;
			tAPWeightsSum += tAPWeight;
		}


		//////////////////////////////
		// Evaluate scattered luminance towards camera as well as view transmittance.
		//////////////////////////////
		[unroll]
		for (ms = 0; ms < MSCOUNT; ++ms)
		{
			const float3 ScatteringCoefficients = PMC.ScatteringCoefficients[ms];
			const float3 ExtinctionCoefficients = PMC.ExtinctionCoefficients[ms];
			const float3 TransmittanceToLight = PMC.TransmittanceToLight[ms];


			// *** EmissiveLuminance: it should be (EmissiveLuminance * AbsorptionCoefficients) but not intuitive for artist ==> can be added later as an option for consistency during path tracing. 
			// See "Production Volume Rendering", 2017, Section 2.2. So right now EmissiveLuminance is in fact LuminancePerMeter.
			// *** The distance sky lighting contribution is ignored from the multi scattering approximation today because occlusion is not correclty handled (and as a result it would make clouds looks flat).
			// This could be removed when occlusion is better handled or approximated with a simple/expenssive optional  tracing.
			const float3 SunSkyLuminance = TransmittanceToLight * Light0IlluminanceFinal * PMPC.Phase[ms] + (ms == 0 ? DistantLightLuminance : float3(0.0f, 0.0f, 0.0f));
			const float3 ScatteredLuminance = SunSkyLuminance * ScatteringCoefficients + EmissiveLuminance;// No dt, because it is part of the analytical integral below.

		#if 0
			// Default iterative integration
			const float3 PathSegmentTransmittance = exp(-ExtinctionCoefficients * dtMeters);
			Luminance += TransmittanceToView * ScatteredLuminance * dtMeters;

			if (ms == 0)
			{
				TransmittanceToView *= PathSegmentTransmittance;
			}
		#else
			// [1] Improved scattering integration. See slide 28 of "Physically Based and Unified Volumetric Rendering in Frostbite"
			// Automatically works with emission. Emissive color is considered as a constant luminance emitted in all direction uniformly.
			const float3 SafeExtinctionCoefficients = max(float3(0.000000001, 0.000000001, 0.000000001), ExtinctionCoefficients);
			const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * dtMeters);
			float3 LuminanceIntegral = (ScatteredLuminance - ScatteredLuminance * SafePathSegmentTransmittance) / SafeExtinctionCoefficients;

			Luminance += TransmittanceToView * LuminanceIntegral;

			if (ms == 0)
			{
				TransmittanceToView *= SafePathSegmentTransmittance;
			}
		#endif
		}

		// This is helpful for performance. Can result in less light pucnhing through clouds. Should be a setting.
		if (all(TransmittanceToView < TransmittanceCutThreshold))
		{
			break;
		}

		t += StepT;
	}

	return true;
}





void MainPS(
	  in FVertexFactoryInterpolantsVSToPS FactoryInterpolants
	, in float4 SvPosition : SV_Position
	, out float4 OutColor0 : SV_Target0
	, out float  OutColor1 : SV_Target1
)
{
	ResolvedView = ResolveView();

//#if 0
//	const float displaySize = 256.0f;
//	if(all(SvPosition.xy<displaySize))
//	{
//		OutColor0 = float4(RenderVolumetricCloudParameters.CloudShadowTexture.Load(uint3(SvPosition.xy,0), 0).rg, 0.0, 0.0f);
//		return;
//	}
//#endif


	//
	// Initialise all the parameters
	//
	
	OutColor0					= float4(0.0f, 0.0f, 0.0f, 1.0f);
	OutColor1					= MaxHalfFloat;

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(FactoryInterpolants, SvPosition);
	FPixelMaterialInputs PixelMaterialInputs	= (FPixelMaterialInputs)0;
	CalcMaterialParameters(MaterialParameters, PixelMaterialInputs, SvPosition, true);

	float3 RayOrigin			= ResolvedView.WorldCameraOrigin;
	float3 RayOriginKm			= RayOrigin * CENTIMETER_TO_KILOMETER;
	float3 Raydir				= -MaterialParameters.CameraVector;
	float TMin					= -999999999.0f;
	float TMax					= -999999999.0f;

	float3 Luminance			= 0.0f;
	float3 TransmittanceToView	= 1.0f;
	float tAPWeightedSum		= 0.0f;
	float tAPWeightsSum			= 0.0f;


	//
	// Trace and get the results
	//

	if (!TraceClouds(
		SvPosition,
		OutColor0,
		OutColor1,
		RayOrigin,
		RayOriginKm,
		Raydir,
		TMin,
		TMax,
		MaterialParameters,
		PixelMaterialInputs,
		Luminance,
		TransmittanceToView,
		tAPWeightedSum,
		tAPWeightsSum))
	{
		return;
	}


#if USE_PREEXPOSURE
	// Exposure used for regular views by the FastSky and AP LUTs.
	const float ViewPreExposure = ResolvedView.PreExposure;
	const float ViewOneOverPreExposure = ResolvedView.OneOverPreExposure;
	// When rendering a real time reflection capture (sky envmap) whe use a different exposure
	const float OutputPreExposure = (ResolvedView.RealTimeReflectionCapture ? ResolvedView.RealTimeReflectionCapturePreExposure : ViewPreExposure);
#else
	const float ViewPreExposure = 1.0f;
	const float ViewOneOverPreExposure = 1.0f;
	const float OutputPreExposure = 1.0f
#endif


	//
	// Apply aerial perspective if needed
	//

	// This is the default depth when no cloud has been intersected. 
	// It is better to limit depth to a close distance instead of max float to smooth out cloud edges when intersecting opaque meshes.
	// No visual issues have been noticed with reprojection+TAA so far.
	const float NoCloudDepth = TMax * CENTIMETER_TO_KILOMETER;

	const float tAP = tAPWeightsSum==0.0f ? NoCloudDepth : tAPWeightedSum / max(0.0000000001f, tAPWeightsSum);
	if (RenderVolumetricCloudParameters.EnableAerialPerspectiveSampling && tAPWeightsSum > 0.0f)
	{
		// Apply AP only once according to the mean position within the participating media weighted by transmittance/visibility.
		// This allows to apply AP only once per pixel instead of per sample.
		float3 AbsoluteWorldPositionAP = RayOrigin + tAP * Raydir;
		float4 NDCPositionAP = mul(float4(AbsoluteWorldPositionAP, 1.0f), ResolvedView.WorldToClip);
		float4 AerialPerspective = GetAerialPerspectiveLuminanceTransmittance(
			ResolvedView.RealTimeReflectionCapture, ResolvedView.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize,
			NDCPositionAP, AbsoluteWorldPositionAP * CM_TO_SKY_UNIT, ResolvedView.WorldCameraOrigin * CM_TO_SKY_UNIT,
			View.CameraAerialPerspectiveVolume, View.CameraAerialPerspectiveVolumeSampler,
			ResolvedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv,
			ResolvedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution,
			ResolvedView.SkyAtmosphereAerialPerspectiveStartDepthKm,
			ResolvedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm,
			ResolvedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv,
			ViewOneOverPreExposure);

		// Apply aerial perspective OVER the cloud, assiming coverage is from the full transmittance.
		float MeanTransmittance = dot(TransmittanceToView, 1.0f / 3.0f);
		// skip if MeanTransmittance is 1
		float MeanCoverage = 1.0 - MeanTransmittance;
		Luminance = AerialPerspective.rgb * MeanCoverage + AerialPerspective.a * Luminance;
	}


	//
	// Output result
	//

	float GreyScaleTransmittance = dot(TransmittanceToView, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
	GreyScaleTransmittance = GreyScaleTransmittance < TransmittanceCutThreshold ? 0.0f : GreyScaleTransmittance;
	OutColor0 = float4(Luminance * OutputPreExposure, GreyScaleTransmittance);
	OutColor1 = (GreyScaleTransmittance > 0.99) ? NoCloudDepth : tAP * CENTIMETER_TO_KILOMETER; // using a small threshold on transmittance

#if 0
	if (RenderVolumetricCloudParameters.SampleCountDebugMode > 0)
	{
		uint CountToDebug = 0;
		switch (RenderVolumetricCloudParameters.SampleCountDebugMode)
		{
		case 1:
			CountToDebug = DebugPrimaryMaterialSampleCount;
			break;
		case 2:
			CountToDebug = DebugShadowSampleCount;
			break;
		case 3:
			CountToDebug = DebugShadowMaterialSampleCount;
			break;
		case 4:
			CountToDebug = DebugGroundShadowSampleCount;
			break;
		case 5:
			CountToDebug = DebugGroundShadowMaterialSampleCount;
			break;
		}

		const bool bMediumHit = CountToDebug > 0;
		OutColor0 = float4(bMediumHit ? GetColorCode(saturate(float(CountToDebug) / 64.0f)) : float3(0.0f, 0.0f, 0.0), bMediumHit ? 0.0f : 1.0f); 
		OutColor1 = bMediumHit ? OutColor1 : MaxHalfFloat;
	}
#endif
}

#endif // SHADER_RENDERVIEW_PS



#if SHADER_SHADOW_PS

struct CloudShadowTraceContext
{
	float		FarDepthKm;
	float		Strength;
	float		SampleClount;
	float4		SizeInvSize;
	float4x4	WorldToLightClipMatrix;
	float4x4	WorldToLightClipMatrixInv;
	float3		Trace0Dir;
};

void MainPS(
	in FVertexFactoryInterpolantsVSToPS FactoryInterpolants
	, in float4 SvPosition : SV_Position
	, out float2 OutColor0 : SV_Target0
)
{
	ResolvedView = ResolveView();

	CloudShadowTraceContext TraceContext;
	if (RenderVolumetricCloudParameters.TraceShadowmap==1)
	{
		TraceContext.FarDepthKm					= RenderVolumetricCloudParameters.CloudShadowmapFarDepthKm;
		TraceContext.Strength					= RenderVolumetricCloudParameters.CloudShadowmapStrength;
		TraceContext.SampleClount				= RenderVolumetricCloudParameters.CloudShadowmapSampleClount;
		TraceContext.SizeInvSize				= RenderVolumetricCloudParameters.CloudShadowmapSizeInvSize;
		TraceContext.WorldToLightClipMatrix		= RenderVolumetricCloudParameters.CloudShadowmapWorldToLightClipMatrix;
		TraceContext.WorldToLightClipMatrixInv	= RenderVolumetricCloudParameters.CloudShadowmapWorldToLightClipMatrixInv;
		TraceContext.Trace0Dir					= RenderVolumetricCloudParameters.CloudShadowmapLight0Dir;
	}
	else
	{
		TraceContext.FarDepthKm					= RenderVolumetricCloudParameters.CloudSkyAOFarDepthKm;
		TraceContext.Strength					= RenderVolumetricCloudParameters.CloudSkyAOStrength;
		TraceContext.SampleClount				= RenderVolumetricCloudParameters.CloudSkyAOSampleClount;
		TraceContext.SizeInvSize				= RenderVolumetricCloudParameters.CloudSkyAOSizeInvSize;
		TraceContext.WorldToLightClipMatrix		= RenderVolumetricCloudParameters.CloudSkyAOWorldToLightClipMatrix;
		TraceContext.WorldToLightClipMatrixInv	= RenderVolumetricCloudParameters.CloudSkyAOWorldToLightClipMatrixInv;
		TraceContext.Trace0Dir					= RenderVolumetricCloudParameters.CloudSkyAOTrace0Dir;
	}

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(FactoryInterpolants, SvPosition);
	FPixelMaterialInputs PixelMaterialInputs;
	CalcMaterialParameters(MaterialParameters, PixelMaterialInputs, SvPosition, true);

	FCloudLayerParameters CloudLayerParams = GetCloudLayerParams();
	float2 UV = float2(SvPosition.xy) * TraceContext.SizeInvSize.zw;

	const float NearZDepth = 1.0f; // using FReversedZOrthoMatrix
	float3 NearClipPlaneWorldPos = CloudShadowUvToWorldSpace(NearZDepth, UV, TraceContext.WorldToLightClipMatrixInv);
	const float3 Light0Direction = TraceContext.Trace0Dir; // It points from light to surface


	// Compute the min and max distance to trace (in the cloud layer)
	float TMin = -999999999.0f;
	float TMax = -999999999.0f;
	float3 RayOrigin = NearClipPlaneWorldPos;
	float3 RayOriginKm = RayOrigin * CENTIMETER_TO_KILOMETER;
	float2 tTop2 = 0.0f;
	bool bTraceTop = false;
	if (RayIntersectSphereSolution(RayOriginKm, Light0Direction, float4(RenderVolumetricCloudParameters.CloudLayerCenterKm, RenderVolumetricCloudParameters.TopRadiusKm), tTop2))
	{
		bTraceTop = true;
		float2 tBottom2 = 0.0f;
		if (RayIntersectSphereSolution(RayOriginKm, Light0Direction, float4(RenderVolumetricCloudParameters.CloudLayerCenterKm, RenderVolumetricCloudParameters.BottomRadiusKm), tBottom2))
		{
			// If we see both intersection in front of us, keep the min/closest, otherwise the max/furthest
			float TempTop = all(tTop2 > 0.0f) ? min(tTop2.x, tTop2.y) : max(tTop2.x, tTop2.y);
			float TempBottom = all(tBottom2 > 0.0f) ? min(tBottom2.x, tBottom2.y) : max(tBottom2.x, tBottom2.y);

			if (all(tBottom2 > 0.0f))
			{
				// But if we can see the bottom of the layer, make sure we use the camera or the highest top layer intersection
				TempTop = max(0.0f, min(tTop2.x, tTop2.y));
			}
			else
			{
				// We are inside under the cloud layer, we simply skip shadowing evaluation and mark near clip as front depth (remove >50% of the cost at dusk/dawn time)
				OutColor0 = float2(0.0f, 0.0f);
				return;
			}

			TMin = min(TempBottom, TempTop);
			TMax = max(TempBottom, TempTop);
		}
		else
		{
			// Only intersecting with the top atmosphere, we have our min and max t
			TMin = tTop2.x;
			TMax = tTop2.y;
		}
	}
	else
	{
		// No intersection with the top of the cloud layer
		OutColor0 = float2(TraceContext.FarDepthKm, 0.0f);
		return;
	}

	TMin = max(0.0f, TMin) * KILOMETER_TO_CENTIMETER;
	TMax = max(0.0f, TMax) * KILOMETER_TO_CENTIMETER;
	float ClosestIntersection = TMin; // Stay on the near clip plane if we are under the top layer.
	float3 WorldPosOnLayer = NearClipPlaneWorldPos + Light0Direction * ClosestIntersection;



	float3 ExtinctionAcc = 0.0f;
	float ExtinctionAccCount = 0.0f;
	const float DefaultFarDepth = TraceContext.FarDepthKm * KILOMETER_TO_CENTIMETER;
	float NearDepth = DefaultFarDepth;

	const float LayerHeight = CloudLayerParams.TopRadius - CloudLayerParams.BottomRadius;
	const float ShadowLengthTest = TMax - TMin;
	const float ShadowStepCount = TraceContext.SampleClount;
	const float InvShadowStepCount = 1.0f / ShadowStepCount;
	const float ShadowDtMeter = ShadowLengthTest * CENTIMETER_TO_METER / ShadowStepCount;
	if (bTraceTop)
	{
		// Linear shadow samples (reference)
		for (float ShadowT = 0.5; ShadowT < ShadowStepCount; ShadowT += 1.0f)
		{
			const float SampleT = ShadowLengthTest * (ShadowT * InvShadowStepCount);
			UpdateMaterialCloudParam(MaterialParameters, WorldPosOnLayer + Light0Direction * SampleT, ResolvedView, CloudLayerParams);

		#if MATERIAL_VOLUMETRIC_ADVANCED_CONSERVATIVE_DENSITY
			if (MaterialParameters.VolumeSampleConservativeDensity <= 0.0f)
			{
				continue; // Conservative density is 0 so skip and go to the next sample
			}
		#endif

			CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);

			float3 ShadowExtinctionCoefficients = SampleExtinctionCoefficients(PixelMaterialInputs);

			bool MediumPresent = any(ShadowExtinctionCoefficients > 0.0f);
			NearDepth = MediumPresent ? min(NearDepth, SampleT) : NearDepth;

			ExtinctionAcc += ShadowExtinctionCoefficients;
			ExtinctionAccCount += MediumPresent ? 1.0f : 0.0f;
		}
	}

	// We output front depth and also the mean path extinction that is going to be scaled later by the real path length behind the front depth.
	const float MeanGreyExtinction = dot(ExtinctionAcc / max(1.0f, ExtinctionAccCount), float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
	const bool NoHit = NearDepth == DefaultFarDepth;
	const float FrontDepth = NoHit ? TMax * CENTIMETER_TO_KILOMETER : (ClosestIntersection + NearDepth) * CENTIMETER_TO_KILOMETER;
	OutColor0 = float2(FrontDepth, MeanGreyExtinction * TraceContext.Strength);
}

#endif // SHADER_SHADOW_PS



#if SHADER_SHADOW_FILTER_CS

#include "ShaderDrawDebug.ush"

SamplerState BilinearSampler;
Texture2D<float2> CloudShadowTexture;
RWTexture2D<float2> OutCloudShadowTexture;
float4 CloudTextureSizeInvSize;
float SkyAOMinTransmittanceClamp;
float CloudLayerStartHeightMeters;

struct CloudShadowData
{
	float DepthKm;
	float Extinction;
};

void CloudShadowData_LoadSrc(inout CloudShadowData Self, uint2 Coord)
{
	float2 TexData = CloudShadowTexture.Load(uint3(Coord, 0));
	Self.DepthKm = TexData.x;
	Self.Extinction = TexData.y;
}

void CloudShadowData_Sample(inout CloudShadowData Self, float2 Coord)
{
	float2 TexData = CloudShadowTexture.SampleLevel(BilinearSampler, Coord, 0);
	Self.DepthKm = TexData.x;
	Self.Extinction = TexData.y;
}

void CloudShadowData_WriteDst(in CloudShadowData Self, uint2 Coord)
{
	OutCloudShadowTexture[Coord] = float2(Self.DepthKm, Self.Extinction);
}

[numthreads(8, 8, 1)]
void MainShadowFilterCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	ResolvedView = ResolveView();


	if (all(DispatchThreadId.xy < uint2(CloudTextureSizeInvSize.xy)))
	{
		const int2 CenterCoord = int2(DispatchThreadId.xy);

		CloudShadowData Center;
		CloudShadowData_LoadSrc(Center, CenterCoord);


		float DepthKm = 0.0f;
		float SampleCount = 0.0f;

#if PERMUTATION_SKYAO
		// Wide dilation is only allowed for top down Sky AO because when use for atmospheric lights, their shadow would not match cloud edges anymore.
		// PCSSF would be a better solution in this case.

		// SkyAO filters transmittance, and not extinctions because it is transmittance used when integrating the hemisphere around a probe on the ground.
		// Because we do not take into account in scattering, we use a clamp of the SkyAO transmittance to not always get to 0 contribution under clouds. 
		// To control that transmittance on the ground, we apply that on transmittance over the CloudLayerStartHeightMeters range.
		// TODO: integrate over the hemisphere would be more representative and not resolution dependent (also more expenssive).
		float Transmittance = 0.0f;
		
		// Center sample
		DepthKm = Center.DepthKm;
		Transmittance = exp(-Center.Extinction * CloudLayerStartHeightMeters);
		SampleCount++;

		// Samples leverage hardware bilinear filtering to sample 4 texels at once. they will all be averaged
		CloudShadowData Data = (CloudShadowData)0;

		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2( 1.5f, 0.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2(-0.5f, 1.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2(-1.5f,-0.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2( 0.5f,-1.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;

		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2( 1.5f, 2.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2(-2.5f, 1.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2(-1.5f,-2.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2( 2.5f,-1.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;

		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2( 3.5f, 0.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2(-0.5f, 3.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2(-3.5f,-0.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;
		CloudShadowData_Sample(Data, float2(CenterCoord + 0.5 + float2( 0.5f,-3.5f)) * CloudTextureSizeInvSize.zw); DepthKm += Data.DepthKm; Transmittance += exp(-Data.Extinction * CloudLayerStartHeightMeters); SampleCount++;

		Center.DepthKm = DepthKm / SampleCount;
		Transmittance = saturate(max(SkyAOMinTransmittanceClamp, Transmittance / SampleCount));
		Center.Extinction = Transmittance<0.00001f ? MaxHalfFloat : -log(Transmittance) / CloudLayerStartHeightMeters;

#else

		float GaussianBlur[5][5] =
		{
			{1.0f / 256.0f,  4.0f / 256.0f,  6.0f / 256.0f,  4.0f / 256.0f, 1.0f / 256.0f},
			{4.0f / 256.0f, 16.0f / 256.0f, 24.0f / 256.0f, 16.0f / 256.0f, 4.0f / 256.0f},
			{6.0f / 256.0f, 24.0f / 256.0f, 36.0f / 256.0f, 24.0f / 256.0f, 6.0f / 256.0f},
			{4.0f / 256.0f, 16.0f / 256.0f, 24.0f / 256.0f, 16.0f / 256.0f, 4.0f / 256.0f},
			{1.0f / 256.0f,  4.0f / 256.0f,  6.0f / 256.0f,  4.0f / 256.0f, 1.0f / 256.0f}
		};

		float Extinction = 0.0f;
		if (Center.Extinction > 0.0f)
		{
			const float Weight = GaussianBlur[2][2]; // center
			DepthKm = Weight * Center.DepthKm;
			Extinction = Weight * Center.Extinction;
			SampleCount = Weight;
		}
		if (Center.Extinction > 0.0f)
		{
			// 5x5 Gaussian blur
			UNROLL
			for (int i = -2; i <= 2; ++i)
			{
				for (int j = -2; j <= 2; ++j)
				{
					if (i == 0 && j == 0)
						continue;

					CloudShadowData Data;
					CloudShadowData_LoadSrc(Data, CenterCoord + int2(i, j));
					if (Data.Extinction > 0.0f)
					{
						const float Weight = GaussianBlur[2 + i][2 + j];
						DepthKm += Data.DepthKm * Weight;
						Extinction += Data.Extinction * Weight;
						SampleCount += Weight;
					}
				}
			}
		}

		if (SampleCount > 0.0f)
		{
			Center.DepthKm = DepthKm / SampleCount;
			Center.Extinction = Extinction / SampleCount;
		}

#endif

		CloudShadowData_WriteDst(Center, CenterCoord);  
	}


}

#endif // SHADER_SHADOW_FILTER_CS



#if SHADER_DEBUG_SHADOW_CS

#include "ShaderDrawDebug.ush"

Texture2D<float2> CloudTracedTexture;
float4 CloudTextureSizeInvSize;
float3 CloudTraceDirection;
float4x4 CloudWorldToLightClipMatrixInv;

[numthreads(8, 8, 1)]
void MainDrawDebugShadowCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	//ResolvedView = ResolveView();

	if (all(DispatchThreadId.xy < uint2(CloudTextureSizeInvSize.xy)))
	{
		float2 CloudShadowData = CloudTracedTexture.Load(uint3(DispatchThreadId.xy, 0));
		float NearDepth = CloudShadowData.x * KILOMETER_TO_CENTIMETER;
		float OpticalDepth = CloudShadowData.y;

		const float NearZDepth = 1.0f; // using FReversedZOrthoMatrix
		float3 NearClipPlaneWorldPos00 = CloudShadowUvToWorldSpace(NearZDepth, float2(DispatchThreadId.xy+uint2(0,0)) * CloudTextureSizeInvSize.zw, CloudWorldToLightClipMatrixInv);
		float3 NearClipPlaneWorldPos01 = CloudShadowUvToWorldSpace(NearZDepth, float2(DispatchThreadId.xy+uint2(0,1)) * CloudTextureSizeInvSize.zw, CloudWorldToLightClipMatrixInv);
		float3 NearClipPlaneWorldPos11 = CloudShadowUvToWorldSpace(NearZDepth, float2(DispatchThreadId.xy+uint2(1,1)) * CloudTextureSizeInvSize.zw, CloudWorldToLightClipMatrixInv);
		float3 NearClipPlaneWorldPos10 = CloudShadowUvToWorldSpace(NearZDepth, float2(DispatchThreadId.xy+uint2(1,0)) * CloudTextureSizeInvSize.zw, CloudWorldToLightClipMatrixInv);

		//

		NearClipPlaneWorldPos00 += CloudTraceDirection * NearDepth;
		NearClipPlaneWorldPos01 += CloudTraceDirection * NearDepth;
		NearClipPlaneWorldPos11 += CloudTraceDirection * NearDepth;
		NearClipPlaneWorldPos10 += CloudTraceDirection * NearDepth;

		float4 DebugColor = OpticalDepth > 0.0f ? float4(float2(DispatchThreadId.xy) * CloudTextureSizeInvSize.zw, 0.1f, 1.0f)
			: float4(0.0f, 0.0f, 0.0f, 0.20f);

		if (OpticalDepth > 0.0f)
		{
			AddQuad(NearClipPlaneWorldPos00, NearClipPlaneWorldPos01, NearClipPlaneWorldPos11, NearClipPlaneWorldPos10, DebugColor);
		}
	}
}

#endif // SHADER_DEBUG_SHADOW_CS



