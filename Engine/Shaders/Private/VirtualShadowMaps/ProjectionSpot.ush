// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ProjectionSpot.ush: 
=============================================================================*/
#pragma once

#include "../DeferredShadingCommon.ush"
#include "../SceneTexturesCommon.ush"
#include "../LightShaderParameters.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "PageAccessCommon.ush"
#include "ProjectionCommon.ush"

/** Return float multiplier to scale RayStepScreen such that it clip it right at the edge of the screen. */
float GetStepScreenFactorToClipAtScreenEdge(float2 RayStartScreen, float2 RayStepScreen)
{
	// Computes the scale down factor for RayStepScreen required to fit on the X and Y axis in order to clip it in the viewport
	const float RayStepScreenInvFactor = 0.5 * length(RayStepScreen);
	const float2 S = 1 - max(abs(RayStepScreen + RayStartScreen * RayStepScreenInvFactor) - RayStepScreenInvFactor, 0.0f) / abs(RayStepScreen);

	// Rescales RayStepScreen accordingly
	const float RayStepFactor = min(S.x, S.y) / RayStepScreenInvFactor;

	return RayStepFactor;
}

bool ShadowRayCastSpotlight(
	int VirtualShadowMapId,
	float3 RayStart,
	float3 RayEnd,
	int NumSteps,
	float StepOffset,
	int DebugOutputType,
	inout float3 DebugOutput,
	inout float OccluderDistance)
{
	FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	// Spot light
	float4 RayStartUVz = mul(float4(RayStart + BaseProjectionData.ShadowPreViewTranslation, 1), BaseProjectionData.TranslatedWorldToShadowUVMatrix).xyzw;
	float4 RayEndUVz   = mul(float4(RayEnd   + BaseProjectionData.ShadowPreViewTranslation, 1), BaseProjectionData.TranslatedWorldToShadowUVMatrix).xyzw;

	if (RayEndUVz.w <= 0)
	{
		RayEndUVz = lerp(RayStartUVz, RayEndUVz, -RayStartUVz.w / (RayEndUVz.w - RayStartUVz.w));
	}

	RayStartUVz.xyz = RayStartUVz.xyz / RayStartUVz.w;
	RayEndUVz.xyz = RayEndUVz.xyz / RayEndUVz.w;

	float3 RayStepUVz = RayEndUVz.xyz - RayStartUVz.xyz;

	/*
#if 0
	float ClipToEdgeScale = GetStepScreenFactorToClipAtScreenEdge( RayStartScreen.xy, RayStepScreen.xy );
	RayStepScreen *= saturate( ClipToEdgeScale );
#else
	if( any( abs( RayEndScreen.xy ) > 1 ) )
	{
		const float Epsilon = 1e-4;
		float2 Replacement = RayStepScreen.xy > 0 ? Epsilon : -Epsilon;
		RayStepScreen.xy = abs( RayStepScreen.xy ) < Epsilon ? Replacement : RayStepScreen.xy;

		float2 InvDir = rcp( RayStepScreen.xy );
		float2 Center = -RayStartScreen.xy * InvDir;
		float2 MinIntersection = Center - abs( InvDir );
		float2 MaxIntersection = Center + abs( InvDir );

		float Time0 = max( MinIntersection.x, MinIntersection.y );
		float Time1 = min( MaxIntersection.x, MaxIntersection.y );
		RayStepScreen *= Time1;
	}
#endif
*/

	// Normalize 2D length
	const float MaxPenumbra = 0.01;
	RayStepUVz.xyz *= saturate(MaxPenumbra / length(RayStepUVz.xy));

	const float CompareScale = RayStepUVz.z * 2.0 / Pow2(NumSteps);
	const float CompareBias = -CompareScale * (NumSteps - StepOffset + 1.0f);

	float DepthHistory = -1;
	int SampleMissCount = 0;

	bool bValidHit = false;
	for (int i = 0; i <= NumSteps; i++)
	{
		//SampleTime = Pow2( 1.0 - (float)i / NumSteps ) * RayScale;
		float SampleTime = Pow2(saturate((-1.0f / NumSteps) * i + 1.0f - (StepOffset - 0.5f) / NumSteps));
		float3 SampleUVz = RayStartUVz.xyz + RayStepUVz.xyz * SampleTime;
		FVirtualSmSample SmSample = SampleVirtualSm(VirtualShadowMapId, SampleUVz.xy);

		if (SmSample.bValid)
		{
			const float SampleDepth = SmSample.Depth;
			const float ReferenceDepth = SampleUVz.z;
			if (DepthHistory < 0)
			{
				// First valid sample we've seen. Do a regular depth compare.
				DepthHistory = SampleDepth;
				if( SampleDepth > ReferenceDepth )
				{
					float ReceiverDistance = length( RayStart + BaseProjectionData.ShadowPreViewTranslation );
					OccluderDistance = ComputeOccluderDistancePerspective(
						BaseProjectionData.ShadowViewToClipMatrix,
						SmSample.Depth,
						SampleUVz.z,
						ReceiverDistance);

					bValidHit = true;
					break;
				}
			}
			else
			{
				const float CompareTolerance = abs(CompareScale * i + CompareBias);

				bool bBehind = (SampleDepth - ReferenceDepth) > (2.0f * CompareTolerance);
				float DepthSample = bBehind ? DepthHistory : SampleDepth;
				DepthHistory = DepthSample;

				float DepthDiff = ReferenceDepth - DepthSample;
				bool bHit = abs(DepthDiff + CompareTolerance) < CompareTolerance;
				if (bHit)
				{
					OccluderDistance = length(RayEnd - RayStart) * SampleTime;

					bValidHit = true;
					break;
				}
			}
		}
		else
		{
			++SampleMissCount;
		}
	}

	float OutputDebugSignal = bValidHit ? 0.0f : 1.0f;
	if (DebugOutputType == 1)	// Invalid page
	{
		DebugOutput = lerp(OutputDebugSignal.xxx, lerp(float3(0, 1, 0), float3(1, 0, 1), saturate(SampleMissCount / 4.0f)), 0.75f);
	}

	return bValidHit;
}


float TraceSpotLight(
	int VirtualShadowMapId,
	FLightShaderParameters Light,
	float4 SvPosition,
	const float SceneDepth,
	float3 TranslatedWorldPosition,
	float RayStartOffset,
	int RayCount,
	int SamplesPerRay,
	int DebugOutputType,
	inout float3 DebugOutput,
	inout float InOutHitDistance)
{
	FGBufferData GBufferData = GetGBufferDataUint( uint2( SvPosition.xy ), true );
	const float3 WorldPosition = TranslatedWorldPosition - View.PreViewTranslation;

	float3 ToLight = Light.Position - WorldPosition;
	float DistSqr = dot(ToLight, ToLight);
	float Falloff = rcp(DistSqr + 1);

	float SinAlphaSqr = saturate(Pow2(Light.SourceRadius) * Falloff);
	float SinAlpha = sqrt(SinAlphaSqr);
	bool bBackFace = dot(GBufferData.WorldNormal, normalize(ToLight)) < -SinAlpha;

	float RayMissFactor = 0;
	uint SampleCount = 0;
	if (!bBackFace)
	{
		uint2 SobolBase = SobolPixel(SvPosition.xy);
		uint2 SobolFrame = SobolIndex(SobolBase, View.StateFrameIndexMod8, 3);

		float StepOffset = InterleavedGradientNoise(SvPosition.xy, View.StateFrameIndexMod8);

		uint i = 0;
		for( ; i < uint(RayCount); i++ )
		{
			RandomSequence RandSequence;
			RandomSequence_Initialize( RandSequence, uint2( SvPosition.xy ), i, View.StateFrameIndexMod8, RayCount );

#if 1
			float2 E = RandomSequence_GenerateSample2D(RandSequence);
#else
			// NOTE: 1-X to avoid 0/0 issues with UniformSampleDiskConcentric
			float2 E = float2( SobolIndex( SobolFrame, i << 3 ) ) / 0x10000;
#endif

			// NOTE: Avoid 0/0 issues with UniformSampleDiskConcentric
			float2 LightUV = UniformSampleDiskConcentricApprox( E ) * Light.SourceRadius;

			float3 RayEnd =
				Light.Position +
				LightUV.x * Light.Tangent +
				LightUV.y * cross( Light.Direction, Light.Tangent );

			float3 Dir = normalize( RayEnd - WorldPosition );
			float3 RayStart = WorldPosition + Dir * RayStartOffset;

			RayEnd = lerp( RayStart, RayEnd, 0.75 );

			bool bHit = ShadowRayCastSpotlight(
				VirtualShadowMapId,
				RayStart,
				RayEnd,
				SamplesPerRay,
				StepOffset,
				DebugOutputType,
				DebugOutput,
				InOutHitDistance);

			RayMissFactor += bHit ? 0 : 1;
			
#if COMPILER_SUPPORTS_WAVE_VOTE
			if( i == 0 )
			{
				if( bHit )
				{
					float WorldBluringRadius = ComputeLightSampleWorldBluringRadius( TranslatedWorldPosition, LIGHT_TYPE_SPOT, Light, InOutHitDistance );
					float PixelBluringRadius = ProjectWorldDistanceToPixelDistance( SceneDepth, WorldBluringRadius );
					bHit = PixelBluringRadius > 2;
				}

				// All lanes miss or hit something close enough to not be noisy.
				bool bAllLanesMiss = WaveActiveAllTrue( !bHit );
				if( bAllLanesMiss )
				{
					break;
				}
			}
			else if( i == 1 )
			{
				// After 2 iterations and all have hit, must be in umbra.
				bool bAllLanesHit = WaveActiveAllTrue( RayMissFactor == 0 );
				if( bAllLanesHit )
				{
					break;
				}
			}
#endif
		}
		SampleCount = min(i + 1, uint(RayCount));		// break vs regular for loop exit
		RayMissFactor /= float(SampleCount);
	}

	if (DebugOutputType == 2)	// Sample count
	{
		float Ratio = float(SampleCount) / float(RayCount);
		DebugOutput = lerp(RayMissFactor.xxx, lerp(float3(0, 1, 0), float3(1, 0, 0), Ratio), 1.0f);
	}

	return RayMissFactor;
}
