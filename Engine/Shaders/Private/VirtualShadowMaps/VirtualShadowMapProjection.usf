// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	VirtualShadowMapProjection.usf: 
=============================================================================*/

#define SUPPORT_CONTACT_SHADOWS 1

#include "../Common.ush"
#include "../SceneTexturesCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../DeferredLightingCommon.ush"
#include "../ScreenSpaceDenoise/SSDPublic.ush"
#include "../ScreenSpaceDenoise/SSDDefinitions.ush"
#include "../ScreenSpaceDenoise/SSDPublicHarmonics.ush"
#include "../LightShaderParameters.ush"
#include "../LightGridCommon.ush"
#include "../HairStrands/HairStrandsVisibilityCommon.ush"
#include "PageAccessCommon.ush"
#include "ProjectionCommon.ush"
#include "ProjectionDirectional.ush"
#include "ProjectionSpot.ush"

// See VirtualShadowMapProjection.cpp
// 0 = Output to denoiser
// 1 = Output to screen shadow mask
// 2 = Output debug
#ifndef OUTPUT_TYPE
#define OUTPUT_TYPE 0
#endif

int VirtualShadowMapId;		// For the first layer for clipmaps
int DebugOutputType;
float ContactShadowLength;
float NormalOffsetWorld;	// Normal offset in world space

int SMRTRayCount;	// 0 = off
int SMRTSamplesPerRay;
float SMRTRayLengthScale;			// Directional lights
float SMRTCotMaxRayAngleFromLight;	// Spot/point lights

#define CONTACT_SHADOW_SAMPLES 8


// Returns hit distance or negative if miss
float VirtualShadowMapScreenRayCast(
	float3 RayOriginTranslatedWorld, float3 RayDirection, float RayLength,
	int NumSteps, float StepOffset)
{
	bool bHitCastContactShadow = true;
	float HitDistance = ShadowRayCast(
		RayOriginTranslatedWorld, RayDirection, RayLength,
		NumSteps, StepOffset, bHitCastContactShadow);

	return (bHitCastContactShadow) ? HitDistance : -1.0f;
}


float ProjectSingleSample(
	int VirtualShadowMapId,
	float3 L,
	float3 TranslatedWorldPosition,
	float3 EstimatedGeoWorldNormal,
	float ContactShadowLengthWorld,
	inout float3 DebugOutput,
	inout float InOutHitDistance)
{
	// NOTE: Could skip most of the rest of the shader if contact shadows say we're shadowed, but likely to be small, incoherent branching

	float3 WorldPosition = TranslatedWorldPosition - View.PreViewTranslation;

	// Offset ray to start at the end of the contact shadow trace
	FVirtualShadowMapSampleResult VirtualShadowMapSample =
		SampleVirtualShadowMap(VirtualShadowMapId, WorldPosition, EstimatedGeoWorldNormal, ContactShadowLengthWorld);

	float RayMissFactor = 1.0f;
	if (VirtualShadowMapSample.bOccluded)
	{
		RayMissFactor = 0.0f;
		InOutHitDistance = VirtualShadowMapSample.OccluderDistance;
	}

	if (DebugOutputType == 1)	// Invalid page
	{
		DebugOutput = VirtualShadowMapSample.bValid ? (0.25f * RayMissFactor) : float3(1, 0, 1);
	}
	else if (DebugOutputType == 2)	// ClipmapIndex/Mip
	{
		DebugOutput = lerp(RayMissFactor, VirtualShadowMapDebugIntToColor(VirtualShadowMapSample.ClipmapIndexOrMipLevel), 0.75f);
	}
	else if (DebugOutputType == 3) // Occluder distance
	{
		DebugOutput = lerp(RayMissFactor, InOutHitDistance.xxx / 1000.0f, 0.75f);
	}

	return RayMissFactor;
}


float4 EncodeLightAttenuationFromMask(float ShadowMask)
{
	const float ShadowFadeFraction = 1;
	float SSSTransmission = ShadowMask;

	// 0 is shadowed, 1 is unshadowed
	// RETURN_COLOR not needed unless writing to SceneColor;
	//float FadedShadow = lerp(1.0f, Square(ShadowMask), ShadowFadeFraction);
	//float FadedSSSShadow = lerp(1.0f, Square(SSSTransmission), ShadowFadeFraction);
	float FadedShadow = lerp(1.0f, ShadowMask, ShadowFadeFraction);
	float FadedSSSShadow = lerp(1.0f, SSSTransmission, ShadowFadeFraction);

	// the channel assignment is documented in ShadowRendering.cpp (look for Light Attenuation channel assignment)
	return EncodeLightAttenuation(half4(FadedShadow, FadedSSSShadow, FadedShadow, FadedSSSShadow));
}

float4 EncodeOutput(
	float3 TranslatedWorldPosition,
	FLightShaderParameters Light,
	uint LightType,
	float RayMissFactor,
	float HitDistance,
	int SampleCount,
	float3 DebugOutput)
{
	// See signal encoding for SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION in SSDSignalBufferEncoding.ush
	// We fuse that logic in here to avoid needing another pass, but it's hard to call the functions directly as they depend on a large
	// number of preprocessor defines and logic that we don't want to mirror here.
	// Unfortunately that means this logic can get out of date when the denoiser changes, but that's the trade-off for now.
	float4 OutputSignal = float4(0, 0, 0, 0);
	if (RayMissFactor < 1.0f)
	{
		float WorldBluringRadius = ComputeLightSampleWorldBluringRadius(TranslatedWorldPosition, LightType, Light, HitDistance);
		OutputSignal = float4(RayMissFactor, SampleCount, WorldBluringRadius, RayMissFactor);
	}
	else
	{
		// Miss
		OutputSignal = float4(1, SampleCount, WORLD_RADIUS_MISS, 1);
	}

#if OUTPUT_TYPE == 0
	// Output feeds into denoiser
	return OutputSignal;
#elif OUTPUT_TYPE == 1
	// Output to screen shadow mask
	return EncodeLightAttenuationFromMask(OutputSignal.r);
#elif OUTPUT_TYPE == 2
	// Output debug for "vis".
	return float4(DebugOutput, 1.0f);
#endif // OUTPUT_TYPE
}


float3 GetEstimatedGeoWorldNormal(float3 TranslatedWorldPosition, float2 ScreenUV)
{
	// Figure out slope, we do world space since that is the space where we might override using the shading normal...
	float3 TranslatedWorldPositionDDX = DDX(TranslatedWorldPosition);
	float3 TranslatedWorldPositionDDY = DDY(TranslatedWorldPosition);
	float3 EstimatedGeoWorldNormal = cross(TranslatedWorldPositionDDX, TranslatedWorldPositionDDY);

	// Handle NaNs; will cause it to revert to shading normal below
	float LengthSq = dot(EstimatedGeoWorldNormal, EstimatedGeoWorldNormal);
	EstimatedGeoWorldNormal = LengthSq > 1e-8f ? normalize(EstimatedGeoWorldNormal) : float3(0, 0, 0);

#if 1
	// NOTE: Gbuffer normal is not the surface normal for hair; hair lighting takes a different path but possibly
	// necessary to do some sort of special casing here (disable normal offset and biasing entirely?).
	FGBufferData GBufferData = GetGBufferData(ScreenUV);
	// If the estimated geo normal is too far out we assume it's broken (derivative includes other surfaces or background) and fall back to the shading normal
	if (dot(GBufferData.WorldNormal, EstimatedGeoWorldNormal) < 0.25f)
	{
		EstimatedGeoWorldNormal = GBufferData.WorldNormal;
	}
#endif

	return EstimatedGeoWorldNormal;
}


void VirtualShadowMapProjectionSpotPS(
	in float4 SvPosition : SV_Position,
	out float4 OutputTarget : SV_Target)
{
	// TODO: Unify this with the logic in PageManagement.usf - we need to get the same values in both passes
	const float2 ScreenUV = SvPositionToBufferUV(SvPosition);
	const float DeviceZ = LookupDeviceZ(ScreenUV);
	const float SceneDepth = ConvertFromDeviceZ(DeviceZ);	
	float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(float4(SvPosition.xy, DeviceZ, 1.0f));
	
	FLightShaderParameters Light = GetRootLightShaderParameters();

	// Early out if we're outside the spot light cone		
	float3 ToLight = Light.Position - (TranslatedWorldPosition - View.PreViewTranslation);
	bool bInLightRadius = length(ToLight) <= rcp(Light_InvRadius);
	float3 L = normalize(ToLight);
	bool bInLightCone = dot(L, Light.Direction) >= Light.SpotAngles.x;
	bool bInLightRegion = bInLightRadius && bInLightCone;

	float3 DebugOutput = float3(0, 0, 0);
	int SampleCount = 1;
	float HitDistance = WORLD_RADIUS_MISS;
	float RayMissFactor = 0.0f;

	uint LightType = Light.SpotAngles.x > -2.0f ? LIGHT_TYPE_SPOT : LIGHT_TYPE_POINT;

	if (bInLightRadius && bInLightCone)
	{
		const float ContactShadowLengthWorld = ContactShadowLength * View.ClipToView[1][1] * SceneDepth;

		float3 EstimatedGeoWorldNormal = GetEstimatedGeoWorldNormal(TranslatedWorldPosition, ScreenUV);

		if (SMRTRayCount > 0)
		{
			RayMissFactor = TraceLocalLight(
				VirtualShadowMapId,
				Light,
				LightType,
				SvPosition,
				SceneDepth,
				TranslatedWorldPosition + EstimatedGeoWorldNormal * NormalOffsetWorld,
				ContactShadowLengthWorld,
				SMRTRayCount,
				SMRTSamplesPerRay,
				SMRTCotMaxRayAngleFromLight,
				DebugOutputType,
				DebugOutput,
				HitDistance);
		}
		else
		{
			RayMissFactor = ProjectSingleSample(
				VirtualShadowMapId,
				L,
				TranslatedWorldPosition + EstimatedGeoWorldNormal * NormalOffsetWorld,
				EstimatedGeoWorldNormal,
				ContactShadowLengthWorld,
				/* out */ DebugOutput,
				HitDistance);
		}

		if (ContactShadowLengthWorld > 0.0f)
		{
			float StepOffset = InterleavedGradientNoise(SvPosition.xy, View.StateFrameIndexMod8);
			float ContactShadowHitDistance = VirtualShadowMapScreenRayCast(TranslatedWorldPosition, L, ContactShadowLengthWorld, CONTACT_SHADOW_SAMPLES, StepOffset);		
			if (ContactShadowHitDistance >= 0.0f)
			{
				RayMissFactor = 0.0f;
				HitDistance = ContactShadowHitDistance;
			}
		}
	}

	OutputTarget = EncodeOutput(TranslatedWorldPosition, Light, LightType, RayMissFactor, HitDistance, SampleCount, DebugOutput);
}

// HAIR_TODO: move all data into a HairStrands UB
uint bUseHairData;
Texture2D<uint4> HairCategorizationTexture;

void VirtualShadowMapProjectionDirectionalPS(
	in float4 SvPosition : SV_Position,
	out float4 OutputTarget : SV_Target
)
{
	// TODO: Unify this with the logic in PageManagement.usf - we need to get the same values in both passes
	const float2 ScreenUV = SvPositionToBufferUV(SvPosition);
	float DeviceZ = LookupDeviceZ(ScreenUV);
	if (bUseHairData > 0)
	{
		FCategorizationData CatData = DecodeCategorizationData(HairCategorizationTexture.Load(uint3(SvPosition.xy, 0)));
		DeviceZ = CatData.ClosestDepth;
	}
	const float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(float4(SvPosition.xy, DeviceZ, 1.0f));

	FLightShaderParameters Light = GetRootLightShaderParameters();
		
	float3 L = Light.Direction;
	
	float3 DebugOutput = float3(0, 0, 0);
	int SampleCount = 1;
	float HitDistance = WORLD_RADIUS_MISS;
	float RayMissFactor = 0.0f;

	// NOTE: This logic is unreliable for hair and potentially other materials with alternate gbuffer encodings	
	// TODO: Revisit other ways to get performance back here.
	//bool bFrontFace = dot(ToLightDir, GBufferData.WorldNormal) > 0.0f;
	//if (bFrontFace)
	{
		const float ContactShadowLengthWorld = ContactShadowLength * View.ClipToView[1][1] * SceneDepth;

		float3 EstimatedGeoWorldNormal = GetEstimatedGeoWorldNormal(TranslatedWorldPosition, ScreenUV);
		if (bUseHairData > 0)
		{			
			EstimatedGeoWorldNormal = L;
		}

		if (SMRTRayCount > 0)
		{
			SampleCount = SMRTRayCount;
			RayMissFactor = TraceDirectional(
				VirtualShadowMapId,
				Light,
				SvPosition,
				SceneDepth,
				TranslatedWorldPosition + EstimatedGeoWorldNormal * NormalOffsetWorld,
				ContactShadowLengthWorld,
				SMRTRayCount,
				SMRTSamplesPerRay,
				SMRTRayLengthScale,
				DebugOutputType,
				DebugOutput,
				HitDistance);
		}
		else
		{
			SampleCount = 1;
			RayMissFactor = ProjectSingleSample(
				VirtualShadowMapId,
				L,
				TranslatedWorldPosition + EstimatedGeoWorldNormal * NormalOffsetWorld,
				EstimatedGeoWorldNormal,
				ContactShadowLengthWorld,
				/* out */ DebugOutput,
				HitDistance);
		}

		if (ContactShadowLengthWorld > 0.0f)
		{
			float StepOffset = InterleavedGradientNoise(SvPosition.xy, View.StateFrameIndexMod8);
			float ContactShadowHitDistance = VirtualShadowMapScreenRayCast(TranslatedWorldPosition, L, ContactShadowLengthWorld, CONTACT_SHADOW_SAMPLES, StepOffset);		
			if (ContactShadowHitDistance >= 0.0f)
			{
				RayMissFactor = 0.0f;
				HitDistance = ContactShadowHitDistance;
			}
		}
	}

	OutputTarget = EncodeOutput(TranslatedWorldPosition, Light, LIGHT_TYPE_DIRECTIONAL, RayMissFactor, HitDistance, SampleCount, DebugOutput);
}






Texture2D<float4> InputSignal;

void VirtualShadowMapCompositePS(
	in float4 SvPosition : SV_Position,
	out float4 OutShadowMask : SV_Target
	)
{
	// NOTE: The signal is encoded as per SSDSignalBufferEncoding.ush, SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION
	float4 Input = InputSignal.Load(int3(SvPosition.xy, 0));
	float SampleCount = Input.g;
	float MissFactor = Input.r;
	float Shadow = (SampleCount > 0 ? MissFactor : 1.0f);
	
	OutShadowMask = EncodeLightAttenuationFromMask(Shadow);
}

FLightShaderParameters ConvertFromLocal( const FLocalLightData LightData )
{
	FLightShaderParameters Light = (FLightShaderParameters)0;
	Light.Position			= LightData.LightPositionAndInvRadius.xyz;
	Light.InvRadius			= LightData.LightPositionAndInvRadius.w;
	Light.Color				= LightData.LightColorAndFalloffExponent.xyz;
	Light.FalloffExponent	= LightData.LightColorAndFalloffExponent.w;
	Light.Direction			= LightData.LightDirectionAndShadowMask.xyz;
	Light.Tangent			= LightData.LightTangentAndSoftSourceRadius.xyz;
	Light.SpotAngles		= LightData.SpotAnglesAndSourceRadiusPacked.xy;
	Light.SpecularScale		= 1;
	Light.SourceRadius		= LightData.SpotAnglesAndSourceRadiusPacked.z;
	Light.SoftSourceRadius	= LightData.LightTangentAndSoftSourceRadius.w;
	Light.SourceLength		= f16tof32(asuint(LightData.SpotAnglesAndSourceRadiusPacked.w));
	return Light;
}

uint EncodeBlurRadius( float Radius )
{
	// Does WORLD_RADIUS_MISS really need to be that big?
	const float Scale = 254 / log2( WORLD_RADIUS_MISS + 0.5 );
	return max( Scale * log2( Radius + 0.5 ), 254 );
}

StructuredBuffer< int > VirtualShadowMapIdRemap;
uint NumDirectionalLightSmInds;

RWTexture2D< uint > RWShadowMaskBits;

[numthreads(8, 8, 1)]
void VirtualShadowMapProjection(
	uint3	GroupId				: SV_GroupID,
	uint	GroupIndex			: SV_GroupIndex,
	uint3	DispatchThreadId	: SV_DispatchThreadID )
{
	// Morton order within a group so page access/atomics are more coherent and wave-swizzled gradients are possible.
	uint2 LocalPixelPos = 8 * GroupId.xy + MortonDecode(GroupIndex);
	uint2 PixelPos = LocalPixelPos + uint2( View.ViewRectMin.xy );

	if (any(LocalPixelPos >= uint2(View.ViewSizeAndInvSize.xy)))
	{
		return;
	}
	
	const float DeviceZ = SceneTexturesStruct.SceneDepthTexture.Load( int3( PixelPos, 0 ) ).r;
	const float SceneDepth = ConvertFromDeviceZ( DeviceZ );

	const float4 SvPosition = float4( float2( PixelPos ) + 0.5, DeviceZ, 1.0f );
	const float2 ScreenUV = SvPositionToBufferUV( SvPosition );

	const float3 TranslatedWorldPosition = SvPositionToTranslatedWorld( SvPosition );
	const float3 WorldPosition = TranslatedWorldPosition - View.PreViewTranslation;

	const float ContactShadowLengthWorld = ContactShadowLength * View.ClipToView[1][1] * SceneDepth;
	const float Noise = InterleavedGradientNoise( SvPosition.xy, View.StateFrameIndexMod8 );

	const float3 EstimatedGeoWorldNormal = GetEstimatedGeoWorldNormal(TranslatedWorldPosition, ScreenUV);

	uint ShadowMask = 0xffffffff;
	uint ShadowIndexes = 0xffffffff;
	uint ShadowValues = 0;
	
	uint EyeIndex = 0; // ??
	uint GridLinearIndex = ComputeLightGridCellIndex( LocalPixelPos, SceneDepth, EyeIndex );
	const FCulledLightsGridData CulledLightGridData = GetCulledLightsGrid( GridLinearIndex, EyeIndex );

	LOOP
	for (uint Index = 0; Index < CulledLightGridData.NumLocalLights; ++Index)
	{
		const FLocalLightData LightData = GetLocalLightData(CulledLightGridData.DataStartIndex + Index, EyeIndex);
		const uint LightGridLightIndex = ForwardLightData.CulledLightDataGrid[CulledLightGridData.DataStartIndex + Index];

		// The Virtual Shadow Remap stores directional lights first
		int VirtualShadowMapId = VirtualShadowMapIdRemap[NumDirectionalLightSmInds + LightGridLightIndex];
		if (VirtualShadowMapId != INDEX_NONE)
		{
			float3 DebugOutput = float3(0, 0, 0);
			int SampleCount = 1;
			float HitDistance = WORLD_RADIUS_MISS;
			float RayMissFactor = 0.0f;

			float3 ToLight = LightData.LightPositionAndInvRadius.xyz - WorldPosition;
			float d2 = dot( ToLight, ToLight );
			float InvDist = rsqrt( d2 );
			float3 L = ToLight * InvDist;
			
			bool bInLightRadius = InvDist >= LightData.LightPositionAndInvRadius.w;
			bool bInLightCone = dot( L, LightData.LightDirectionAndShadowMask.xyz ) >= LightData.SpotAnglesAndSourceRadiusPacked.x;

			if (bInLightRadius && bInLightCone)
			{
				FLightShaderParameters Light = ConvertFromLocal( LightData );

				uint LightType = Light.SpotAngles.x > -2.0f ? LIGHT_TYPE_SPOT : LIGHT_TYPE_POINT;

				if (SMRTRayCount > 0)
				{
					RayMissFactor = TraceLocalLight(
						VirtualShadowMapId,
						Light,
						LightType,
						SvPosition,
						SceneDepth,
						TranslatedWorldPosition + EstimatedGeoWorldNormal * NormalOffsetWorld,
						ContactShadowLengthWorld,
						SMRTRayCount,
						SMRTSamplesPerRay,
						SMRTCotMaxRayAngleFromLight,
						DebugOutputType,
						DebugOutput,
						HitDistance);
				}
				else
				{
					RayMissFactor = ProjectSingleSample(
						VirtualShadowMapId,
						L,
						TranslatedWorldPosition + EstimatedGeoWorldNormal * NormalOffsetWorld,
						EstimatedGeoWorldNormal,
						ContactShadowLengthWorld,
						/* out */ DebugOutput,
						HitDistance);
				}

				if (ContactShadowLengthWorld > 0.0f)
				{
					float ContactShadowHitDistance = VirtualShadowMapScreenRayCast(TranslatedWorldPosition, L, ContactShadowLengthWorld, CONTACT_SHADOW_SAMPLES, Noise);		
					if (ContactShadowHitDistance >= 0.0f)
					{
						RayMissFactor = 0.0f;
						HitDistance = ContactShadowHitDistance;
					}
				}

				//ShadowMask ^= uint( RayMissFactor < 1.0 ) << Index;
				ShadowMask ^= ( ~uint( round( RayMissFactor * 7.0 ) ) & 7 ) << (Index*3);

				if( Index < 4 && LightGridLightIndex < 255 )
				{
					float WorldBluringRadius = ComputeLightSampleWorldBluringRadius(TranslatedWorldPosition, LightType, Light, HitDistance);
					uint EncodedValue = RayMissFactor < 1.0 ? EncodeBlurRadius( WorldBluringRadius ) : 255;

					ShadowIndexes = ( ShadowIndexes << 8 ) | LightGridLightIndex;
					ShadowValues = ( ShadowValues << 8 ) | EncodedValue;
				}
			}

			//OutputTarget = EncodeOutput(TranslatedWorldPosition, Light, LIGHT_TYPE_SPOT, RayMissFactor, HitDistance, SampleCount, DebugOutput);
		}
	}

	RWShadowMaskBits[ PixelPos ] = ~ShadowMask;
}