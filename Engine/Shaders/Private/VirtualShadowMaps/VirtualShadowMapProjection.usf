// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	VirtualShadowMapProjection.usf: 
=============================================================================*/

#include "../Common.ush"
#include "../SceneTexturesCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../ScreenSpaceDenoise/SSDPublic.ush"
#include "../ScreenSpaceDenoise/SSDDefinitions.ush"
#include "../ScreenSpaceDenoise/SSDPublicHarmonics.ush"
#include "../LightShaderParameters.ush"
#include "PageAccessCommon.ush"
#include "ProjectionCommon.ush"
#include "ProjectionDirectional.ush"

// See VirtualShadowMapProjection.cpp
// 0 = Output to denoiser
// 1 = Output to screen shadow mask
// 2 = Output debug LOD
#ifndef OUTPUT_TYPE
#define OUTPUT_TYPE 0
#endif

int VirtualShadowMapId;		// For the first layer for clipmaps
int DebugOutputType;
float ContactShadowLength;

int SMRTRayCount;	// 0 = off
int SMRTSamplesPerRay;
float SMRTRayLengthScale;


float VirtualShadowMapScreenRayCast(
	float3 RayOriginTranslatedWorld, float3 RayDirection, float RayLength,
	int NumSteps, float StepOffset)
{
	// Just to make calling code a bit cleaner
	if (RayLength == 0.0f)
	{
		return 0.0f;
	}

	float4 RayStartClip	= mul( float4( RayOriginTranslatedWorld, 1 ), View.TranslatedWorldToClip );
	float4 RayDirClip	= mul( float4( RayDirection * RayLength, 0 ), View.TranslatedWorldToClip );
	float4 RayEndClip	= RayStartClip + RayDirClip;

	float3 RayStartScreen = RayStartClip.xyz / RayStartClip.w;
	float3 RayEndScreen = RayEndClip.xyz / RayEndClip.w;

	float3 RayStepScreen = RayEndScreen - RayStartScreen;

	float3 RayStartUVz = float3( RayStartScreen.xy * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz, RayStartScreen.z );
	float3 RayStepUVz = float3( RayStepScreen.xy * View.ScreenPositionScaleBias.xy, RayStepScreen.z );

	float4 RayDepthClip	= RayStartClip + mul( float4( 0, 0, RayLength, 0 ), View.ViewToClip );
	float3 RayDepthScreen = RayDepthClip.xyz / RayDepthClip.w;

	const float Step = 1.0 / NumSteps;

	// *2 to get less moire pattern in extreme cases, larger values make object appear not grounded in reflections
	const float CompareTolerance = abs( RayDepthScreen.z - RayStartScreen.z ) * Step * 2;

	float SampleTime = StepOffset * Step + Step;

	float FirstHitTime = -1.0;

	for( int i = 0; i < NumSteps; i++ )
	{
		float3 SampleUVz = RayStartUVz + RayStepUVz * SampleTime;
		float SampleDepth = SceneTexturesStruct.SceneDepthTexture.SampleLevel( SceneTexturesStruct_SceneDepthTextureSampler, SampleUVz.xy, 0 ).r;

		float DepthDiff = SampleUVz.z - SampleDepth;
		bool Hit = abs( DepthDiff + CompareTolerance ) < CompareTolerance;

		FirstHitTime = (Hit && FirstHitTime < 0.0) ? SampleTime : FirstHitTime;

		SampleTime += Step;
	}

	float Shadow = FirstHitTime > 0.0f ? 1.0f : 0.0f;

	// Off screen masking
	bool bValidUV = all( abs( RayStartScreen.xy + RayStepScreen.xy * FirstHitTime ) < 1.0f );
	Shadow = bValidUV ? Shadow : 0.0f;	

	return 1.0f - Shadow;
}


float ProjectSingleSample(
	FLightShaderParameters Light,
	float3 L,
	uint LightType,
	const float4 SvPosition,
	const float SceneDepth,
	float3 TranslatedWorldPosition,
	float3 EstimatedGeoWorldNormal,
	float ContactShadowLengthWorld,
	inout float3 DebugOutput,
	out float OutHitDistance)
{
	float StepOffset = InterleavedGradientNoise(SvPosition.xy, View.StateFrameIndexMod8);

	// NOTE: Could skip most of the rest of the shader if contact shadows say we're shadowed, but likely to be small, incoherent branching

	float3 WorldPosition = TranslatedWorldPosition - View.PreViewTranslation;

	// Offset ray to start at the end of the contact shadow trace
	FVirtualShadowMapSampleResult VirtualShadowMapSample =
		SampleVirtualShadowMap(VirtualShadowMapId, WorldPosition, EstimatedGeoWorldNormal, ContactShadowLengthWorld);

	float RayMissFactor = VirtualShadowMapSample.bOccluded ? 0.0f : 1.0f;
	float HitDistance = VirtualShadowMapSample.OccluderDistance;

	if (DebugOutputType == 1)	// Invalid page
	{
		DebugOutput = VirtualShadowMapSample.bValid ? (0.25f * RayMissFactor) : float3(1, 0, 1);
	}
	else if (DebugOutputType == 2)	// ClipmapIndex/Mip
	{
		DebugOutput = lerp(RayMissFactor, VirtualShadowMapDebugIntToColor(VirtualShadowMapSample.ClipmapIndexOrMipLevel), 0.75f);
	}
	else if (DebugOutputType == 3) // Occluder distance
	{
		DebugOutput = lerp(RayMissFactor, HitDistance.xxx / 1000.0f, 0.75f);
	}

	OutHitDistance = HitDistance;
	return RayMissFactor;
}


float4 EncodeLightAttenuationFromMask(float ShadowMask)
{
	const float ShadowFadeFraction = 1;
	float SSSTransmission = ShadowMask;

	// 0 is shadowed, 1 is unshadowed
	// RETURN_COLOR not needed unless writing to SceneColor;
	float FadedShadow = lerp(1.0f, Square(ShadowMask), ShadowFadeFraction);
	float FadedSSSShadow = lerp(1.0f, Square(SSSTransmission), ShadowFadeFraction);

	// the channel assignment is documented in ShadowRendering.cpp (look for Light Attenuation channel assignment)
	return EncodeLightAttenuation(half4(FadedShadow, FadedSSSShadow, FadedShadow, FadedSSSShadow));
}

float4 EncodeOuput(float4 OutputSignal, float3 DebugOutput)
{
#if OUTPUT_TYPE == 0
	// Output feeds into denoiser
	return OutputSignal;
#elif OUTPUT_TYPE == 1
	// Output to screen shadow mask
	return EncodeLightAttenuationFromMask(OutputSignal.r);
#elif OUTPUT_TYPE == 2
	// Output debug for "vis".
	return float4(DebugOutput, 1.0f);
#endif // OUTPUT_TYPE
}


float3 GetEstimatedGeoWorldNormal(float3 TranslatedWorldPosition, float2 ScreenUV)
{
	// Figure out slope, we do world space since that is the space where we might override using the shading normal...
	float3 TranslatedWorldPositionDDX = DDX(TranslatedWorldPosition);
	float3 TranslatedWorldPositionDDY = DDY(TranslatedWorldPosition);
	float3 EstimatedGeoWorldNormal = normalize(cross(TranslatedWorldPositionDDX, TranslatedWorldPositionDDY));

#if 1
	FGBufferData GBufferData = GetGBufferData(ScreenUV);
	// If the estimated geo normal is too far out we assume it's broken (derivative includes other surfaces or background) and fall back to the shading normal
	if (dot(GBufferData.WorldNormal, EstimatedGeoWorldNormal) < 0.25f)
	{
		EstimatedGeoWorldNormal = GBufferData.WorldNormal;
	}
#endif

	return EstimatedGeoWorldNormal;
}


void VirtualShadowMapProjectionSpotPS(
	in float4 SvPosition : SV_Position,
	out float4 OutputTarget : SV_Target)
{
	// TODO: Unify this with the logic in PageManagement.usf - we need to get the same values in both passes
	const float2 ScreenUV = SvPositionToBufferUV(SvPosition);
	const float DeviceZ = LookupDeviceZ(ScreenUV);
	const float SceneDepth = ConvertFromDeviceZ(DeviceZ);	
	float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(float4(SvPosition.xy, DeviceZ, 1.0f));
	
	FLightShaderParameters Light = GetRootLightShaderParameters();

	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	// Early out if we're outside the spot light cone		
	float3 ToLight = Light.Position - (TranslatedWorldPosition - View.PreViewTranslation);
	bool bInLightRadius = length(ToLight) <= rcp(Light_InvRadius);
	float3 ToLightDir = normalize(ToLight);
	bool bInLightCone = dot(ToLightDir, Light.Direction) >= Light.SpotAngles.x;
	bool bInLightRegion = bInLightRadius && bInLightCone;

	float3 DebugOutput = float3(0, 0, 0);
	int SampleCount = 1;
	float HitDistance = 100000;	// TODO
	float RayMissFactor = 0.0f;

	if (bInLightRadius && bInLightCone)
	{
		const float ContactShadowLengthWorld = ContactShadowLength * View.ClipToView[1][1] * SceneDepth;
#if 0
		if (SMRTRayCount > 0)
		{
			OutputSignal = TraceSpotLight(
				Light,
				SvPosition,
				SceneDepth,
				TranslatedWorldPosition,
				DebugOutput);
		}
		else
#endif
		{
			float3 EstimatedGeoWorldNormal = GetEstimatedGeoWorldNormal(TranslatedWorldPosition, ScreenUV);

			RayMissFactor = ProjectSingleSample(
				Light,
				ToLightDir,
				LIGHT_TYPE_SPOT,
				SvPosition,
				SceneDepth,
				TranslatedWorldPosition,
				EstimatedGeoWorldNormal,
				ContactShadowLengthWorld,
				/* out */ DebugOutput,
				HitDistance);
		}

		if (ContactShadowLengthWorld > 0.0f)
		{
			// TODO: Unify this with the random sampling inside SMRT
			uint2 SobolBase = SobolPixel(SvPosition.xy);
			uint2 SobolFrame = SobolIndex(SobolBase, View.StateFrameIndexMod8, 3);
			float StepOffset = InterleavedGradientNoise(SvPosition.xy, View.StateFrameIndexMod8);

			float2 E = float2(SobolIndex(SobolFrame, 8 << 3)) / 0x10000;	// TODO

			float ContactShadow = VirtualShadowMapScreenRayCast(TranslatedWorldPosition, ToLightDir, ContactShadowLengthWorld, 12, StepOffset);		
			if (ContactShadow < 1.0f)
			{
				RayMissFactor *= ContactShadow;
				HitDistance = ContactShadowLengthWorld;
			}
		}
	}

	float4 OutputSignal = float4(0, 0, 0, 0);
	if (RayMissFactor < 1.0f)
	{
		float WorldBluringRadius = ComputeLightSampleWorldBluringRadius(TranslatedWorldPosition, LIGHT_TYPE_SPOT, Light, HitDistance);
		OutputSignal = float4(RayMissFactor, SampleCount, WorldBluringRadius, RayMissFactor);
	}
	else
	{
		// Miss
		OutputSignal = float4(1, SampleCount, WORLD_RADIUS_MISS, 1);
	}

	OutputTarget = EncodeOuput(OutputSignal, DebugOutput);
}


void VirtualShadowMapProjectionDirectionalPS(
	in float4 SvPosition : SV_Position,
	out float4 OutputTarget : SV_Target
)
{
	// TODO: Unify this with the logic in PageManagement.usf - we need to get the same values in both passes
	const float2 ScreenUV = SvPositionToBufferUV(SvPosition);
	const float DeviceZ = LookupDeviceZ(ScreenUV);
	const float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(float4(SvPosition.xy, DeviceZ, 1.0f));

	FLightShaderParameters Light = GetRootLightShaderParameters();
		
	FGBufferData GBufferData = GetGBufferData(ScreenUV);
	float3 ToLightDir = normalize(Light.Direction);
	bool bFrontFace = dot(ToLightDir, GBufferData.WorldNormal) > 0.0f;
	
	float3 DebugOutput = float3(0, 0, 0);
	int SampleCount = 1;
	float HitDistance = 100000;	// TODO
	float RayMissFactor = 0.0f;

	if (bFrontFace)
	{
		const float ContactShadowLengthWorld = ContactShadowLength * View.ClipToView[1][1] * SceneDepth;

		if (SMRTRayCount > 0)
		{
			SampleCount = SMRTRayCount;
			RayMissFactor = TraceDirectional(
				VirtualShadowMapId,
				Light,
				SvPosition,
				SceneDepth,
				TranslatedWorldPosition,
				ContactShadowLengthWorld,
				SMRTRayCount,
				SMRTSamplesPerRay,
				SMRTRayLengthScale,
				DebugOutputType,
				DebugOutput,
				HitDistance);
		}
		else
		{
			float3 EstimatedGeoWorldNormal = GetEstimatedGeoWorldNormal(TranslatedWorldPosition, ScreenUV);

			SampleCount = 1;
			RayMissFactor = ProjectSingleSample(
				Light,
				Light.Direction,
				LIGHT_TYPE_DIRECTIONAL,
				SvPosition,
				SceneDepth,
				TranslatedWorldPosition,
				EstimatedGeoWorldNormal,
				ContactShadowLengthWorld,
				/* out */ DebugOutput,
				HitDistance);
		}

		if (ContactShadowLengthWorld > 0.0f)
		{
			// TODO: Unify this with the random sampling inside SMRT
			uint2 SobolBase = SobolPixel(SvPosition.xy);
			uint2 SobolFrame = SobolIndex(SobolBase, View.StateFrameIndexMod8, 3);
			float StepOffset = InterleavedGradientNoise(SvPosition.xy, View.StateFrameIndexMod8);

			float2 E = float2(SobolIndex(SobolFrame, 8 << 3)) / 0x10000;	// TODO

			float ContactShadow = VirtualShadowMapScreenRayCast(TranslatedWorldPosition, ToLightDir, ContactShadowLengthWorld, 12, StepOffset);		
			if (ContactShadow < 1.0f)
			{
				RayMissFactor *= ContactShadow;
				HitDistance = ContactShadowLengthWorld;
			}
		}
	}

	// See signal encoding for SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION in SSDSignalBufferEncoding.ush
	// We fuse that logic in here to avoid needing another pass, but it's hard to call the functions directly as they depend on a large
	// number of preprocessor defines and logic that we don't want to mirror here.
	// Unfortunately that means this logic can get out of date when the denoiser changes, but that's the trade-off for now.
	float4 OutputSignal = float4(0, 0, 0, 0);
	if (RayMissFactor < 1.0f)
	{
		float WorldBluringRadius = ComputeLightSampleWorldBluringRadius(TranslatedWorldPosition, LIGHT_TYPE_DIRECTIONAL, Light, HitDistance);
		OutputSignal = float4(RayMissFactor, SampleCount, WorldBluringRadius, RayMissFactor);
	}
	else
	{
		// Miss
		OutputSignal = float4(1, SampleCount, WORLD_RADIUS_MISS, 1);
	}

	OutputTarget = EncodeOuput(OutputSignal, DebugOutput);
}






Texture2D<float4> InputSignal;

void VirtualShadowMapCompositePS(
	in float4 SvPosition : SV_Position,
	out float4 OutShadowMask : SV_Target
	)
{
	// NOTE: The signal is encoded as per SSDSignalBufferEncoding.ush, SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION
	float4 Input = InputSignal.Load(int3(SvPosition.xy, 0));
	float SampleCount = Input.g;
	float MissFactor = Input.r;
	float Shadow = (SampleCount > 0 ? MissFactor : 1.0f);
	
	OutShadowMask = EncodeLightAttenuationFromMask(Shadow);
}
