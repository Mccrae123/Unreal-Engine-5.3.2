// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ProjectionCommon.ush:
=============================================================================*/
#pragma once

#include "../Common.ush"
#include "../ScreenSpaceDenoise/SSDDefinitions.ush"		// For LIGHT_TYPE's
#include "PageAccessCommon.ush"

#define VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE 1e-6f

// Must match C++ structure in VirtualShadowMapArray.h
struct FVirtualShadowMapProjectionShaderData
{
	float4x4 ShadowViewToClipMatrix;
	float4x4 TranslatedWorldToShadowUVMatrix;
	float4x4 TranslatedWorldToShadowUVNormalMatrix;
	float3 ShadowPreViewTranslation;
	uint LightType;		// Matches ELightComponentType via defines in SSDDefinitions.ush

	float3 ClipmapWorldOrigin;
	int VirtualShadowMapId;

	int ClipmapLevel;
	int ClipmapLevelCount;
	float ClipmapResolutionLodBias;

	// Seems the FMatrix forces 16-byte alignment, so we need to pad
	float Padding[1];
};

// FVirtualShadowMapProjectionParameters
StructuredBuffer< FVirtualShadowMapProjectionShaderData > VirtualShadowMapProjectionData;
Texture2D< uint > PhysicalPagePool;

FVirtualShadowMapProjectionShaderData GetVirtualShadowMapProjectionData(int VirtualShadowMapId)
{
	return VirtualShadowMapProjectionData[VirtualShadowMapId];
}

uint CalcMipLevelFromFootprint(float Footprint, uint MipLevelCount = VSM_MAX_MIP_LEVELS)
{
	float MipLevelFloat = log2(max(1.0f, Footprint));
	uint MipLevel = min(MipLevelCount - 1, uint(floor(MipLevelFloat)));
	return MipLevel;
}

float CalcClipmapLevelFloat(FVirtualShadowMapProjectionShaderData BaseProjectionData, float3 WorldPosition)
{
	float DistanceToClipmapOrigin = length(WorldPosition - BaseProjectionData.ClipmapWorldOrigin);
	float Log2Distance = log2(DistanceToClipmapOrigin);
	float AbsoluteLevel = Log2Distance + BaseProjectionData.ClipmapResolutionLodBias;
	return AbsoluteLevel;
}
int CalcClipmapLevel(FVirtualShadowMapProjectionShaderData BaseProjectionData, float3 WorldPosition)
{
	return int(floor(CalcClipmapLevelFloat(BaseProjectionData, WorldPosition)));
}

struct FVirtualSmSample
{
	float Depth;
	uint MipLevel;
	bool bValid;
	uint2 VirtualTexelAddress;
	float2 VirtualTexelAddressFloat;
	uint2 PhysicalTexelAddress;
};

FVirtualSmSample InitVirtualSmSample()
{
	FVirtualSmSample Result;
	Result.Depth = 0.0f;
	Result.MipLevel = 0;
	Result.bValid = false;
	return Result;
}

FVirtualSmSample SampleVirtualSmLevel(int VirtualShadowMapId, float2 ShadowMapUV, uint VSMLevel)
{
	FVirtualSmSample Result = InitVirtualSmSample();

	Result.VirtualTexelAddressFloat = ShadowMapUV * float(CalcLevelDimsTexels(VSMLevel));
	Result.VirtualTexelAddress = uint2(Result.VirtualTexelAddressFloat);

	// Page map to physical address
	uint2 PhysicalTexelAddress = uint2(0, 0);
	bool PagePresent = VirtualToPhysicalTexel(VirtualShadowMapId, VSMLevel, Result.VirtualTexelAddress, Result.PhysicalTexelAddress);
	if (PagePresent)
	{
		// TODO: maybe store metadata about Max depth (and/or use sparse HZB) for each tile, and early out if completely in shadow (must test using kernel size).
		Result.Depth = asfloat(PhysicalPagePool.Load(int3(Result.PhysicalTexelAddress, 0)));
		Result.MipLevel = VSMLevel;
		Result.bValid = true;
	}
	
	return Result;
}

FVirtualSmSample SampleVirtualSm(int VirtualShadowMapId, float2 ShadowMapUV)
{
	for (uint VSMLevel = 0; VSMLevel < VSM_MAX_MIP_LEVELS; ++VSMLevel)
	{
		FVirtualSmSample Result = SampleVirtualSmLevel(VirtualShadowMapId, ShadowMapUV, VSMLevel);
		if (Result.bValid)
		{
			return Result;
		}
	}

	return InitVirtualSmSample();
}

float ComputeVirtualShadowMapOptimalSlopeBias(FVirtualShadowMapProjectionShaderData ProjectionData, FVirtualSmSample SmSample, float3 WorldPosition, float3 EstimatedGeoWorldNormal)
{
	// Transform geometry world-space plane eq to shadow 'UV' texture space [0-1] ranges
	float4 NormalPlaneTranslatedWorld = float4(EstimatedGeoWorldNormal, -dot(EstimatedGeoWorldNormal, WorldPosition + ProjectionData.ShadowPreViewTranslation));
	float4 NormalPlaneUV = mul(NormalPlaneTranslatedWorld, ProjectionData.TranslatedWorldToShadowUVNormalMatrix);

	float2 DepthSlopeUV = -NormalPlaneUV.xy / NormalPlaneUV.z;
	float MipLevelDim = float(CalcLevelDimsTexels(SmSample.MipLevel));
	float2 TexelCenter = float2(SmSample.VirtualTexelAddress) + 0.5;
	float2 TexelCenterOffset = TexelCenter - SmSample.VirtualTexelAddressFloat;
	float2 TexelCenterOffsetUV = TexelCenterOffset / MipLevelDim;
	// 2x factor due to lack of precision (probably)
	float OptimalSlopeBias = 2.0f * max(0.0f, dot(DepthSlopeUV, TexelCenterOffsetUV));
	// Clamp to avoid excessive degenerate slope biases causing flickering lit pixels
	OptimalSlopeBias = min(OptimalSlopeBias, abs(10.0f * ProjectionData.ShadowViewToClipMatrix._33));

	return OptimalSlopeBias;
}

struct FVirtualShadowMapSampleResult
{
	bool bValid;
	bool bOccluded;
	float OccluderDistance;

	// Debug data	
	int ClipmapIndexOrMipLevel;
};

// Used for orthographic projections (i.e. directional lights)
// Receiver depth is post-projection-divide.
float ComputeOccluderDistanceOrtho(float4x4 ShadowViewToClip, float OccluderDepth, float ReceiverDepth)
{
	float OccluderViewZ = (OccluderDepth - ShadowViewToClip._43) / ShadowViewToClip._33;
	float ReceiverViewZ = (ReceiverDepth - ShadowViewToClip._43) / ShadowViewToClip._33;

	// No perspective projection, so simple difference gets us the distance
	float Result = ReceiverViewZ - OccluderViewZ;
	return max(VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE, Result);
}

// Used for perspective projections (i.e. spot lights)
// Receiver depth is post-projection-divide.
float ComputeOccluderDistancePerspective(float4x4 ShadowViewToClip, float OccluderDepth, float ReceiverDepth, float ReceiverDistance)
{
	float OccluderViewZ = ShadowViewToClip._43 / (OccluderDepth - ShadowViewToClip._33);
	float ReceiverViewZ = ShadowViewToClip._43 / (ReceiverDepth - ShadowViewToClip._33);

	// Similar triangles to compute euclidean distance in view/world space
	float OccluderDistance = (ReceiverDistance / ReceiverViewZ) * OccluderViewZ;
	float Result = ReceiverDistance - OccluderDistance;	
	return max(VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE, Result);
}

uint GetCubeFace( float3 Dir )
{
	// TODO use v_cubeid_f32( Dir )
	if( abs(Dir.x) >= abs(Dir.y) && abs(Dir.x) >= abs(Dir.z) )
		return Dir.x > 0 ? 0 : 1;
	else if( abs(Dir.y) > abs(Dir.z) )
		return Dir.y > 0 ? 2 : 3;
	else
		return Dir.z > 0 ? 4 : 5;
}

/**
* VirtualShadowMapId is the ID of the virtual shadow map to sample
* WorldPosition is the sample position in world space to project into the shadow map
* EstimatedGeoWorldNormal is ideally the geometric (flat) normal of the sample point in world space
*   - This is used to compute a receiver-plane-based bias for the sample point
*   - The shading normal can be used if the geometric normal is not available, but divergence from the geometric normal can cause biasing issues.
* RayStartDistance is an optional offset to move the lookup along the shadow ray towards the light
*   - Should zero or positive
*   - This offset is useful in that it does *not* affect the selection of clipmap level, unlike offsetting the WorldPosition itself
*   - OccluderDistance will still be relative to the original sample position
*/
FVirtualShadowMapSampleResult SampleVirtualShadowMap(int VirtualShadowMapId, float3 WorldPosition, float3 EstimatedGeoWorldNormal, float RayStartDistance = 0.0f)
{
	RayStartDistance = max(RayStartDistance, 0.0f);

	FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	if (BaseProjectionData.LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		const int FirstClipmapLevel = BaseProjectionData.ClipmapLevel;
		const int ClipmapLevel = CalcClipmapLevel(BaseProjectionData, WorldPosition);
		int ClipmapIndex = max(0, ClipmapLevel - FirstClipmapLevel);

		// Check if sample is within the clipmap range (from camera)
		if (ClipmapIndex < BaseProjectionData.ClipmapLevelCount)
		{
			// NOTE: Clipmap levels are contiguous in the virtual shadow map list
			int ClipmapLevelVirtualShadowMapId = VirtualShadowMapId + ClipmapIndex;
			FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(ClipmapLevelVirtualShadowMapId);

			// No perspective divided needed for ortho projection
			float4 ShadowUVz = mul(float4(WorldPosition + ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix);

			FVirtualSmSample SmSample = SampleVirtualSmLevel(ClipmapLevelVirtualShadowMapId, ShadowUVz.xy, 0);
			if (SmSample.bValid)
			{
				FVirtualShadowMapSampleResult Result;
				Result.bValid = true;
				Result.bOccluded = false;
				Result.OccluderDistance = -1.0f;
				Result.ClipmapIndexOrMipLevel = ClipmapIndex;

				float OptimalSlopeBias = ComputeVirtualShadowMapOptimalSlopeBias(ProjectionData, SmSample, WorldPosition, EstimatedGeoWorldNormal);
				float RayStartBias = -RayStartDistance * ProjectionData.ShadowViewToClipMatrix._33;
				float BiasedDepth = SmSample.Depth - OptimalSlopeBias - RayStartBias;

				if (BiasedDepth > ShadowUVz.z)
				{
					Result.bOccluded = true;
					Result.OccluderDistance = ComputeOccluderDistanceOrtho(
						ProjectionData.ShadowViewToClipMatrix,
						SmSample.Depth,
						ShadowUVz.z);
				}

				return Result;
			}
		}
	}
	else
	{
		float3 TranslatedWorldPosition = WorldPosition + BaseProjectionData.ShadowPreViewTranslation;

		if( BaseProjectionData.LightType != LIGHT_TYPE_SPOT )
		{
			VirtualShadowMapId += GetCubeFace( -TranslatedWorldPosition );
			BaseProjectionData = GetVirtualShadowMapProjectionData( VirtualShadowMapId );
		}

		// TODO cubemap math directly instead of vector fetching matrix
		float4 ShadowUVz = mul(float4(TranslatedWorldPosition, 1.0f), BaseProjectionData.TranslatedWorldToShadowUVMatrix);
		ShadowUVz.xyz /= ShadowUVz.w;

		FVirtualSmSample SmSample = SampleVirtualSm(VirtualShadowMapId, ShadowUVz.xy);
		if (SmSample.bValid)
		{
			FVirtualShadowMapSampleResult Result;
			Result.bValid = true;
			Result.bOccluded = false;
			Result.OccluderDistance = -1.0f;
			Result.ClipmapIndexOrMipLevel = SmSample.MipLevel;

			float OptimalSlopeBias = ComputeVirtualShadowMapOptimalSlopeBias(BaseProjectionData, SmSample, WorldPosition, EstimatedGeoWorldNormal);
			float RayStartBias = -RayStartDistance * BaseProjectionData.ShadowViewToClipMatrix._33 / ShadowUVz.w;
			float BiasedDepth = SmSample.Depth - OptimalSlopeBias - RayStartBias;

			if (BiasedDepth > ShadowUVz.z)
			{
				Result.bOccluded = true;
				// Shadow view matrix is rotation
				float ReceiverDistance = length(TranslatedWorldPosition);
				Result.OccluderDistance = RayStartDistance + ComputeOccluderDistancePerspective(
					BaseProjectionData.ShadowViewToClipMatrix,
					SmSample.Depth,
					ShadowUVz.z,
					ReceiverDistance);
			}

			return Result;
		}
	}

	// Invalid
	FVirtualShadowMapSampleResult Result;
	Result.bValid = false;
	Result.bOccluded = false;
	Result.OccluderDistance = -1.0f;
	Result.ClipmapIndexOrMipLevel = -1;
	return Result;
}

// Helper for debug mostly
float3 VirtualShadowMapDebugIntToColor(uint Index)
{
	const float3 ColorTable[8] = {
		float3(1.0f, 0.0f, 0.0f),
		float3(0.0f, 1.0f, 0.0f),
		float3(0.0f, 0.0f, 1.0f),

		float3(1.0f, 1.0f, 0.0f),
		float3(0.0f, 1.0f, 1.0f),
		float3(1.0f, 0.0f, 1.0f),

		float3(0.5f, 0.7f, 0.1f),
		float3(1.0f, 1.0f, 1.0f)
	};
	return ColorTable[Index % 8];
}