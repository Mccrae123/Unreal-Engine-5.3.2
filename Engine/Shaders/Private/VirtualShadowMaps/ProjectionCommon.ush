// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ProjectionCommon.ush:
=============================================================================*/
#pragma once

// Must match C++ structure in VirtualShadowMapArray.h
struct FVirtualShadowMapProjectionShaderData
{
	// From shadow-pretranslated world-space to shadow view space, example use: (WorldSpacePos + ShadowPreViewTranslation) * TranslatedWorldToShadowViewMatrix
	float4x4 TranslatedWorldToShadowViewMatrix;
	float4x4 ShadowViewToClipMatrix;
	float4x4 TranslatedWorldToShadowUvNormalMatrix;
	float3 ShadowPreViewTranslation;
	float Dummy;
	uint VirtualShadowMapId;	
	int ClipmapLevel;
	int ClipmapLevelCount;
	float ClipmapResolutionLodBias;

	float MinSceneDepth;
	float MaxSceneDepth;
	
	// Seems the FMatrix forces 16-byte alignment, so we need to pad
	float Padding[2];
};

uint CalcMipLevelFromFootprint(float Footprint, uint MipLevelCount = VSM_MAX_MIP_LEVELS)
{
	float MipLevelFloat = log2(max(1.0f, Footprint));
	uint MipLevel = min(MipLevelCount - 1, uint(floor(MipLevelFloat)));
	return MipLevel;
}

int CalcClipmapLevel(float3 ViewPosition, float ResolutionLodBias)
{
	float Log2Distance = log2(length(ViewPosition));
	int AbsoluteLevel = int(floor(Log2Distance + ResolutionLodBias));
	return AbsoluteLevel;
}

// Small wrapper for point transformed into shadow space
struct FShadowPosition
{
	float3 View;		// Shadow view space
	float4 ClipH;		// NOT divided by W
	float2 UV;
	float Depth;
};

FShadowPosition WorldToShadow(FVirtualShadowMapProjectionShaderData ProjectionData, float3 WorldPosition)
{
	FShadowPosition ShadowPosition;
	// 
	ShadowPosition.View = mul(float4(WorldPosition + ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowViewMatrix).xyz;

	ShadowPosition.ClipH = mul(float4(ShadowPosition.View, 1.0f), ProjectionData.ShadowViewToClipMatrix);

	float3 Clip = ShadowPosition.ClipH.xyz / ShadowPosition.ClipH.w;
	ShadowPosition.UV = float2(0.5f, -0.5f) * Clip.xy + float2(0.5f, 0.5f);
	ShadowPosition.Depth = Clip.z;

	return ShadowPosition;
}
