// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../ShaderDrawDebug.ush"
#include "../MonteCarlo.ush"

#include "HairStrandsVisibilityCommon.ush"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float2 LineLineIntersect(float3 p1, float3 p2, float3 p3, float3 p4)
{
	float3 p13, p43, p21;
	float d1343, d4321, d1321, d4343, d2121;
	float numer, denom;
	float mua;

	p13 = p1 - p3;
	p43 = p4 - p3;
	p21 = p2 - p1;

	d1343 = dot(p13, p43);
	d4321 = dot(p43, p21);
	d1321 = dot(p13, p21);
	d4343 = dot(p43, p43);
	d2121 = dot(p21, p21);

	denom = d2121 * d4343 - d4321 * d4321;
	//if (abs(denom) < 0.0000001)//almost impossible: view ray perfectly aligned with line direction (and it would only affect one pixel)
	//	return float2(0.0,0.0);
	numer = d1343 * d4321 - d1321 * d4343;

	mua = numer / denom;
	mua = clamp(mua, 0.0, 1.0);
	return float2(mua, (d1343 + d4321 * mua) / d4343); //return (mua,mub)
}

float Intersection(float3 InP0, float3 InP1, float3 RayP0, float3 RayP1, float Radius, inout float OutU)
{
	float3 P1 = InP0;
	float3 P2 = InP1;
	float3 P3 = RayP0;
	float3 P4 = RayP1;

	//compute the two closest points on the volumetric line and current view ray
	float2 muab = LineLineIntersect(P1, P2, P3, P4);

	//pa and pb, the two closest points
	float3 pa = P1 + muab.x * (P2 - P1);
	float3 pb = P3 + muab.y * (P4 - P3);

	//texture sample coordinate
	const float sample = length(pa - pb) / Radius;
	OutU = muab.x;

	return sample < 1 ? muab.y : -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_VERTEX

int2 AtlasResolution;
uint VertexCount;
uint PrimitiveCount;

Buffer<float4> VertexBuffer;
Buffer<float4> NormalsBuffer;
Buffer<float2> UVsBuffer;

Buffer<uint4> CardRectBuffer;

void MainVS(
	uint VertexId			: SV_VertexID,
	out float4 Position		: SV_POSITION,
	out uint OutCardIndex	: CARD_ID,
	out uint OutCardVertexIndex : CARD_VERTEX_ID,
	out float2 OutCardUV	: CARD_UV,
	out float2 OutAtlasUV	: ATLAS_UV, 
	out float3 OutPosition	: CARD_POSITION,
	out float3 OutNormal	: CARD_NORMAL)
{
	const float4 PackedP = VertexBuffer.Load(VertexId);
	const float3 P = PackedP.xyz;

	const uint CardId = asuint(PackedP.w);
	const float4 CardRect = CardRectBuffer.Load(CardId);

	const float2 AtlasUV = UVsBuffer.Load(VertexId).xy;
	const float2 CardUV = (AtlasUV * AtlasResolution - CardRect.xy) / CardRect.zw;

	//const float2 Pos = AtlasResolution * UV;
	//Position = float4(Pos, 0.5f, 1);
	Position	= float4(AtlasUV*2-1, 0.5f, 1);
	OutAtlasUV	= AtlasUV;
	OutCardUV	= CardUV;
	OutPosition = P;
	OutNormal	= NormalsBuffer.Load(VertexId * 2/* + 1*/);
	OutCardIndex= CardId;
	OutCardVertexIndex = VertexId;
}

#endif // VERTEXSHADER

#if SHADER_PIXEL

#include "HairStrandsVertexFactoryCommon.ush"

int2 AtlasResolution;
uint VertexCount;
uint PrimitiveCount;
uint BoundCount;
uint DebugCardIndex;

Buffer<uint4> InVF_PositionBuffer;
Buffer<uint4> InVF_AttributeBuffer;
float3 InVF_PositionOffset;
float InVF_Radius;
float InVF_Length;

Buffer<float4> VertexBuffer;
Buffer<float4> NormalsBuffer;
Buffer<float2> UVsBuffer;
Buffer<uint2>  CardItToClusterBuffer;
Buffer<uint2>  ClusterIdToVerticesBuffer;
Buffer<float4> ClusterBoundBuffer;

Buffer<uint4> CardRectBuffer;

void MainPS(
	in float4 SvPosition	: SV_Position,
	in nointerpolation uint	InCardIndex : CARD_ID,
	in nointerpolation uint	InCardVertexIndex : CARD_VERTEX_ID,
	in float2  InCardUV		: CARD_UV,
	in float2  InAtlasUV	: ATLAS_UV,
	in float3  InPosition	: CARD_POSITION,
	in float3  InNormal		: CARD_NORMAL,
	out float  OutDepth		: SV_Target0,
	out float  OutCoverage	: SV_Target1,
	out float4 OutTangent	: SV_Target2)
{
	const float3 N = normalize(InNormal);

	OutDepth = 0;
	OutCoverage = 0;
	OutTangent = float4(InCardUV,0,0);

	const uint SampleCount = 1;

	const uint2 CurveOffsetAndCount = CardItToClusterBuffer[InCardIndex];

	const int2 PixelCoord = int2(SvPosition.xy);

//	const bool bDebugEnable = all(PixelCoord == GetCursorPos());
//	const bool bDebugEnable = DebugCardIndex == InCardIndex;

	// TODO: cast multiple sample per pixe in order to s
	const float3 RayO = InPosition;
	const float3 RayD = -N;

	bool bDebugEnable = false;
	{
		// This need to be similar to the debug shader
		const int2 Debug_Offset = 50;
		const int2 Debug_Resolution = 1500 * float2(AtlasResolution.x, AtlasResolution.y) / max(AtlasResolution.x, AtlasResolution.y);

		const float2 CursorUV = float2(GetCursorPos() - Debug_Offset) / float2(Debug_Resolution);
		if (all(CursorUV >= 0) && all(CursorUV < 1))
		{
			const float2 DistanceThreshold = 1.f / float2(Debug_Resolution);
			if (distance(InAtlasUV, CursorUV) < max(DistanceThreshold.x, DistanceThreshold.y))
			{
				bDebugEnable = true;
			}
		}
	}

	if (bDebugEnable)
	{
		// Texel ray
		{
			const float4 Color = float4(1, 1, 0, 1);
			AddLine(RayO - RayD*2, RayO + RayD*10, Color, Color);
		}

		// Main strand/guide vertices
		{

			const uint VertexItEnd = min(InCardVertexIndex + 18, VertexCount);
			for (uint VertexIt = InCardVertexIndex; VertexIt < VertexItEnd; ++VertexIt)
			{
				const float4 PackedP = VertexBuffer.Load(VertexIt);
				const float3 P = PackedP.xyz;

				//const float3 VN = NormalsBuffer.Load(VertexIt * 2 + 1).xyz;
				const float3 VN = NormalsBuffer.Load(VertexIt * 2).xyz;

				const float4 ColorP = float4(1, 0, 1, 1);
				AddCross(P, 0.5, ColorP);
				const float4 ColorN = float4(1, 0, 0, 1);
				AddLine(P, P+ VN * 2, ColorN, ColorN);
			}
		}

		// Bound
		{		
			const uint BIndex = InCardIndex * 4;
			//const uint BIndex = BoundIndex * 4;
			const float3 C = ClusterBoundBuffer[BIndex + 0].xyz;
			const float3 X = ClusterBoundBuffer[BIndex + 1].xyz;
			const float3 Y = ClusterBoundBuffer[BIndex + 2].xyz;
			const float3 Z = ClusterBoundBuffer[BIndex + 3].xyz;

			//const float Scalar = 8;
			//const float3 X = Scalar * float3(1,0,0);
			//const float3 Y = Scalar * float3(0,1,0);
			//const float3 Z = Scalar * float3(0,0,1);

			const float3 P00 = C - X - Y - Z;
			const float3 P10 = C + X - Y - Z;
			const float3 P20 = C + X + Y - Z;
			const float3 P30 = C - X + Y - Z;

			const float3 P01 = C - X - Y + Z;
			const float3 P11 = C + X - Y + Z;
			const float3 P21 = C + X + Y + Z;
			const float3 P31 = C - X + Y + Z;

			const float S = 0; // BoundIndex / float(LocalBoundCount);
			const float4 Color0 = float4(1, 0, 0, 1);
			const float4 Color1 = float4(0, 1, 0, 1);
			const float4 ColorB = lerp(Color0, Color1, S);

			AddLine(P00, P10, ColorB, ColorB);
			AddLine(P10, P20, ColorB, ColorB);
			AddLine(P20, P30, ColorB, ColorB);
			AddLine(P30, P00, ColorB, ColorB);

			AddLine(P01, P11, ColorB, ColorB);
			AddLine(P11, P21, ColorB, ColorB);
			AddLine(P21, P31, ColorB, ColorB);
			AddLine(P31, P01, ColorB, ColorB);

			AddLine(P00, P01, ColorB, ColorB);
			AddLine(P10, P11, ColorB, ColorB);
			AddLine(P20, P21, ColorB, ColorB);
			AddLine(P30, P31, ColorB, ColorB);
		}
	}

	const float FarDistance = 100000;
	float ClosestDepth = FarDistance;
	float3 ClosestTangent = 0;
	for (uint CurveIt=0;CurveIt< CurveOffsetAndCount.y;++CurveIt)
	{
		const uint CurveIndex = CurveOffsetAndCount.x + CurveIt;

		const uint2 PointOffsetAndCount = ClusterIdToVerticesBuffer[CurveIndex];
		for (uint PointIt = 0; PointIt < PointOffsetAndCount.y-1; ++PointIt)
		{
			const uint PointIndex = PointOffsetAndCount.x + PointIt;
			const uint4 PackedCP0 = InVF_PositionBuffer[PointIndex];
			const uint4 PackedCP1 = InVF_PositionBuffer[PointIndex+1];

			const FHairControlPoint CP0	= UnpackHairControlPoint(PackedCP0, InVF_PositionOffset, InVF_Radius, InVF_Length);
			const FHairControlPoint CP1 = UnpackHairControlPoint(PackedCP1, InVF_PositionOffset, InVF_Radius, InVF_Length);

			const float3 Tangent = normalize(CP1.Position - CP0.Position);

			if (bDebugEnable)
			{
				const float4 Color = float4(0, 1, 0, 1);
				//AddLine(CP0.Position, CP1.Position, Color, Color);
				AddCross(CP0.Position, 0.1f, Color);
			}

			const float MaxDistance = 10;
			const float3 RayP0 = RayO;
			const float3 RayP1 = RayO + RayD * MaxDistance;

			float VertexU = 0;
			const float WorldRadius = max(CP0.WorldRadius, CP1.WorldRadius); //  0.05f;
			const float Distance = Intersection(CP0.Position, CP1.Position, RayP0, RayP1, WorldRadius, VertexU) * MaxDistance;
			if (Distance > 0 && Distance < ClosestDepth)
			{
				OutCoverage = 1;
				ClosestTangent = Tangent;
				ClosestDepth   = Distance;
				//break;
			}
		}
	}
	

	const float3 NColor = (ClosestTangent + 1) * 0.5f;
//	OutTangent = float4(NColor, 0);
	OutDepth = ClosestDepth < FarDistance ? ClosestDepth : 0;
}

#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_VERTEX_RECT

int2 Atlas_Resolution;
int2 Atlas_RectOffset;
int2 Atlas_RectResolution;

float3 Rect_MinBound;
float3 Rect_MaxBound;

void MainVS(
	uint VertexId : SV_VertexID,
	out float4  OutPosition : SV_Position,
	out float2  OutCardUV : CARD_UV,
	out float2  OutAtlasUV : ATLAS_UV)

{
	float3 P = 0;
	if (VertexId == 0) P = float3(0, 0, 0);
	if (VertexId == 1) P = float3(1, 0, 0);
	if (VertexId == 2) P = float3(1, 1, 0);

	if (VertexId == 3) P = float3(0, 0, 0);
	if (VertexId == 4) P = float3(1, 1, 0);
	if (VertexId == 5) P = float3(0, 1, 0);


	OutAtlasUV = P.xy * Atlas_RectResolution + Atlas_RectOffset;
	OutAtlasUV /= Atlas_Resolution;

	OutCardUV = P.xy;
	OutPosition = float4(OutAtlasUV * 2 - 1, 0.5f, 1);
}

#endif // VERTEXSHADER



#if SHADER_PIXEL_RECT

#include "HairStrandsVertexFactoryCommon.ush"

int2 Atlas_Resolution;
int2 Atlas_RectOffset;
int2 Atlas_RectResolution;

float3 Raster_AxisX; // Not normalized, contains AABB (full) length
float3 Raster_AxisY; // Not normalized, contains AABB (full) length
float3 Raster_AxisZ; // Not normalized, contains AABB (full) length

float3 Rect_MinBound;
float3 Rect_MaxBound;

// Offset to the first strands vertex
// Count of all vertex belonging to this cluster
uint Curve_VertexOffset;
uint Curve_VertexCount;

Buffer<float4> Curve_PositionBuffer;
Buffer<float4> Curve_AttributeBuffer;

#define DEBUG_ENABLE 0
void MainPS(
	in float4  SvPosition : SV_Position,
	in float2  InCardUV : CARD_UV,
	in float2  InAtlasUV : ATLAS_UV,
	out float  OutDepth : SV_Target0,
	out float  OutCoverage : SV_Target1,
	out float4 OutTangent : SV_Target2,
	out float4 OutAttribute : SV_Target3)
{

	OutDepth = 0;
	OutCoverage = 0;
	OutTangent = float4(InCardUV, 0, 0);
	OutAttribute = 0;

	const float3 Center = (Rect_MaxBound + Rect_MinBound) * 0.5f;
	const float3 CardWorldPos =
		(InCardUV.x * 2 - 1) * Raster_AxisX * 0.5f +
		(InCardUV.y * 2 - 1) * Raster_AxisY * 0.5f +
		-0.5f * Raster_AxisZ +
		Center;

	const int2 PixelCoord = int2(SvPosition.xy);

	#if DEBUG_ENABLE
	bool bDebugEnable = false;// all(PixelCoord == int2(1600, 10));
	{
		// This need to be similar to the debug shader
		const int2 Debug_Offset = 50;
		const int2 Debug_Resolution = 1500 * float2(Atlas_Resolution.xy) / max(Atlas_Resolution.x, Atlas_Resolution.y);
	
		const float2 CursorUV = float2(GetCursorPos() - Debug_Offset) / float2(Debug_Resolution);
		if (all(CursorUV >= 0) && all(CursorUV < 1))
		{
			const float2 DistanceThreshold = 1.f / float2(Debug_Resolution);
			if (distance(InAtlasUV, CursorUV) < max(DistanceThreshold.x, DistanceThreshold.y))
			{
				bDebugEnable = true;
			}
		}
	}
	if (bDebugEnable)
	{
		const float4 Color = float4(1, 1, 0, 1);
		AddAABB(Rect_MinBound, Rect_MaxBound, Color);
	}
	#endif 

	const float3 RayO = CardWorldPos;
	const float3 RayD = normalize(Raster_AxisZ);

	const uint SampleCount = 4;
	const float FarDistance = 100000;
	float ClosestDepth = FarDistance;
	float3 ClosestTangent = 0;
	float4 ClosestAttribute = 0;

	for (uint VertexIt = 0; VertexIt < Curve_VertexCount-1; ++VertexIt)
	{
		const uint VertexIndex = VertexIt + Curve_VertexOffset;
		const float4 Data0 = Curve_PositionBuffer[VertexIndex];
		const float4 Data1 = Curve_PositionBuffer[VertexIndex+1];

		const float4 Attributes0 = Curve_AttributeBuffer[VertexIndex];
		const float4 Attributes1 = Curve_AttributeBuffer[VertexIndex+1];

		const float3 CP0 = Data0.xyz;
		const float3 CP1 = Data1.xyz;

		const float R0 = Data0.w;
		const float R1 = Data1.w;

		// Invalid selction, i.e., a segment connecting the end of a strands to the beginning of another strands.
		if (Data0.w == 0)
			continue;

		#if DEBUG_ENABLE
		if (bDebugEnable)
		{
			const float4 Color = float4(0, 1, 0, 1);
			AddLine(CP0, CP1, Color, Color);
		}
		#endif

		const float PixelRadius = 0.5f * max(length(Raster_AxisX) / float(Atlas_RectResolution.x), length(Raster_AxisY) / float(Atlas_RectResolution.y));

		const float3 WorldTangent = normalize(CP1 - CP0);
		const float3 LocalTangent = float3(
			dot(WorldTangent, Raster_AxisX),
			dot(WorldTangent, Raster_AxisY),
			dot(WorldTangent, -Raster_AxisZ));

		for (uint SampleIt = 0; SampleIt < SampleCount; ++SampleIt)
		{
			const float2 U = Hammersley(SampleIt, SampleCount, 0) * 2 - 1;

			const float3 Jitter = 
				U.x * (0.5f * Raster_AxisX / float(Atlas_RectResolution.x)) +
				U.y * (0.5f * Raster_AxisY / float(Atlas_RectResolution.y));

			const float MaxDistance = 10;
			const float3 RayP0 = RayO + Jitter;
			const float3 RayP1 = RayO + Jitter + RayD * MaxDistance;

			// Scale radius in order to avoid having 0 coverage when hair are too thin
			float VertexU = 0;
			const float RadiusScaleFactor = 1.5f;
			const float Distance = Intersection(CP0, CP1, RayP0, RayP1, R0, VertexU) * MaxDistance;
			if (Distance > 0 && Distance < ClosestDepth)
			{
				OutCoverage += saturate(R0* RadiusScaleFactor / PixelRadius);
				ClosestTangent = LocalTangent;
				ClosestDepth = Distance;
				ClosestAttribute = lerp(Attributes0, Attributes1, VertexU);
			}
		}
	}

	OutCoverage /= SampleCount;
	const float3 NColor = (ClosestTangent + 1) * 0.5f;
	OutTangent = float4(NColor, 0);
	OutDepth = ClosestDepth < FarDistance ? ClosestDepth : 0;
	OutAttribute = ClosestAttribute;
}

#endif