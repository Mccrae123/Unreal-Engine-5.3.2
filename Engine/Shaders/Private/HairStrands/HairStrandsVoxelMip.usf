// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "HairStrandsVoxelPageCommon.ush"

uint ComputeMipDensity(
	const uint RawDensity0,
	const uint RawDensity1,
	const uint RawDensity2,
	const uint RawDensity3,
	const uint RawDensity4,
	const uint RawDensity5,
	const uint RawDensity6,
	const uint RawDensity7)
{
	const float TotalOpaque =
		((RawDensity0 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity1 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity2 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity3 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity4 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity5 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity6 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT) +
		((RawDensity7 & VOXEL_OPAQUE_MASK) >> VOXEL_OPAQUE_SHIFT);
	const uint OutTotalOpaque = uint(clamp(TotalOpaque / 8.f, TotalOpaque > 0 ? 1 : 0, 0xFF)) << VOXEL_OPAQUE_SHIFT;

	uint TotalHair = 
		(RawDensity0 & VOXEL_HAIR_MASK) +
		(RawDensity1 & VOXEL_HAIR_MASK) +
		(RawDensity2 & VOXEL_HAIR_MASK) +
		(RawDensity3 & VOXEL_HAIR_MASK) +
		(RawDensity4 & VOXEL_HAIR_MASK) +
		(RawDensity5 & VOXEL_HAIR_MASK) +
		(RawDensity6 & VOXEL_HAIR_MASK) +
		(RawDensity7 & VOXEL_HAIR_MASK);
	TotalHair /= 8;

	return min(VOXEL_HAIR_MASK, TotalHair) | OutTotalOpaque;
}

#if SHADER_MIP_VOXEL

uint VoxelResolution;
uint SourceMip;
uint TargetMip;

Texture3D<uint> InDensityTexture;
RWTexture3D<uint> OutDensityTexture0;


// Write two levels at a time, and store/cache thread result within LDS
#if PERMUTATION_METHOD == 1
RWTexture3D<uint> OutDensityTexture1;
groupshared uint Values0[64];
groupshared uint Values1[8];

uint ToMorton(uint3 Index)
{
	return (Index.x & 0x1) | ((Index.y & 0x1)<<1) | ((Index.z& 0x1)<<2);
}

uint3 FromMorton(uint Index)
{
	return uint3((Index & 0x1) > 0 ? 1 : 0, (Index & 0x2) > 0 ? 1 : 0, (Index & 0x4) > 0 ? 1 : 0);
}

[numthreads(4, 4, 4)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID, uint3 GroupThreadId : SV_GroupThreadID , uint GroupIndex : SV_GroupIndex, uint3 GroupId : SV_GroupId)
{
	{
		const uint3 LocalBase	= uint3(GroupThreadId.x >> 1, GroupThreadId.y >> 1, GroupThreadId.z>> 1);
		const uint3 LocalOffset = uint3(GroupThreadId.x % 2,  GroupThreadId.y % 2,  GroupThreadId.z % 2);

		const uint Base   = ToMorton(LocalBase);
		const uint Offset = ToMorton(LocalOffset);
		const uint OutLocal = Base*8 + Offset;
		Values0[OutLocal] = InDensityTexture[DispatchThreadId];
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupIndex < 8)
	{
		const uint3 OutLocalCoord = FromMorton(GroupIndex);
		const uint3 OutVoxelCoord = (GroupId << 1) + OutLocalCoord;

		const uint Offset = GroupIndex * 8;
		const uint Total = ComputeMipDensity(
			Values0[Offset + 0],
			Values0[Offset + 1],
			Values0[Offset + 2],
			Values0[Offset + 3],
			Values0[Offset + 4],
			Values0[Offset + 5],
			Values0[Offset + 6],
			Values0[Offset + 7]);
		Values1[GroupIndex] = Total;
		OutDensityTexture0[OutVoxelCoord] = Total;
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupIndex == 0)
	{
		const uint3 OutVoxelCoord = GroupId;
		const uint Total = ComputeMipDensity(
			Values1[0],
			Values1[1],
			Values1[2],
			Values1[3],
			Values1[4],
			Values1[5],
			Values1[6],
			Values1[7]);
		OutDensityTexture1[OutVoxelCoord] = Total;
	}
}
#endif

#if PERMUTATION_METHOD == 0
[numthreads(4, 4, 4)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint3 OutVoxelCoord = DispatchThreadId;

	const uint3 InVoxelCoord0 = uint3(OutVoxelCoord.x << 1, OutVoxelCoord.y << 1, OutVoxelCoord.z << 1);
	const uint3 InVoxelCoord1 = InVoxelCoord0 + uint3(1,0,0);
	const uint3 InVoxelCoord2 = InVoxelCoord0 + uint3(0,1,0);
	const uint3 InVoxelCoord3 = InVoxelCoord0 + uint3(1,1,0);
	const uint3 InVoxelCoord4 = InVoxelCoord0 + uint3(0,0,1);
	const uint3 InVoxelCoord5 = InVoxelCoord0 + uint3(1,0,1);
	const uint3 InVoxelCoord6 = InVoxelCoord0 + uint3(0,1,1);
	const uint3 InVoxelCoord7 = InVoxelCoord0 + uint3(1,1,1);


	const uint RawDensity0 = InDensityTexture[InVoxelCoord0];
	const uint RawDensity1 = InDensityTexture[InVoxelCoord1];
	const uint RawDensity2 = InDensityTexture[InVoxelCoord2];
	const uint RawDensity3 = InDensityTexture[InVoxelCoord3];
	const uint RawDensity4 = InDensityTexture[InVoxelCoord4];
	const uint RawDensity5 = InDensityTexture[InVoxelCoord5];
	const uint RawDensity6 = InDensityTexture[InVoxelCoord6];
	const uint RawDensity7 = InDensityTexture[InVoxelCoord7];

	const uint Total = ComputeMipDensity(
		RawDensity0,
		RawDensity1,
		RawDensity2,
		RawDensity3,
		RawDensity4,
		RawDensity5,
		RawDensity6,
		RawDensity7);

	OutDensityTexture0[OutVoxelCoord] = Total;
}
#endif

#endif

#if SHADER_MIP_VIRTUALVOXEL
int3 PageCountResolution;
uint PageResolution;
uint SourceMip;
uint TargetMip;

Texture3D<uint>   InDensityTexture;
RWTexture3D<uint> OutDensityTexture;

[numthreads(1, 1, 64)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint  MaxDispatchCountPerDim = 65535;
	const uint  PageIndex = DispatchThreadId.x + DispatchThreadId.y * MaxDispatchCountPerDim;
	const uint3 PageCoord = IndexToCoord(PageIndex, PageCountResolution);

	const uint  InPageResolution = PageResolution >> SourceMip;
	const uint OutPageResolution = PageResolution >> TargetMip;
	const uint TotalVoxelPerOutPageResolution = OutPageResolution * OutPageResolution * OutPageResolution;
	const uint VoxelIndex = DispatchThreadId.z;
	if (VoxelIndex >= TotalVoxelPerOutPageResolution)
		return;

	const uint3 OutVoxelCoordOffset = IndexToCoord(VoxelIndex, OutPageResolution);
	const uint3  InVoxelCoordOffset = OutVoxelCoordOffset << 1;

	const uint3 OutVoxelCoord = PageCoord * OutPageResolution + OutVoxelCoordOffset;
	const uint3  InVoxelCoord = PageCoord *  InPageResolution +  InVoxelCoordOffset;

	const uint3 InVoxelCoord0 = InVoxelCoord;
	const uint3 InVoxelCoord1 = InVoxelCoord0 + uint3(1, 0, 0);
	const uint3 InVoxelCoord2 = InVoxelCoord0 + uint3(0, 1, 0);
	const uint3 InVoxelCoord3 = InVoxelCoord0 + uint3(1, 1, 0);
	const uint3 InVoxelCoord4 = InVoxelCoord0 + uint3(0, 0, 1);
	const uint3 InVoxelCoord5 = InVoxelCoord0 + uint3(1, 0, 1);
	const uint3 InVoxelCoord6 = InVoxelCoord0 + uint3(0, 1, 1);
	const uint3 InVoxelCoord7 = InVoxelCoord0 + uint3(1, 1, 1);

	const uint RawDensity0 = InDensityTexture[InVoxelCoord0];
	const uint RawDensity1 = InDensityTexture[InVoxelCoord1];
	const uint RawDensity2 = InDensityTexture[InVoxelCoord2];
	const uint RawDensity3 = InDensityTexture[InVoxelCoord3];
	const uint RawDensity4 = InDensityTexture[InVoxelCoord4];
	const uint RawDensity5 = InDensityTexture[InVoxelCoord5];
	const uint RawDensity6 = InDensityTexture[InVoxelCoord6];
	const uint RawDensity7 = InDensityTexture[InVoxelCoord7];

	const uint Total = ComputeMipDensity(
		RawDensity0,
		RawDensity1,
		RawDensity2,
		RawDensity3,
		RawDensity4,
		RawDensity5,
		RawDensity6,
		RawDensity7);

	OutDensityTexture[OutVoxelCoord] = Total;
}
#endif

#if SHADER_MIP_INDIRECTARGS
#include "HairStrandsVoxelPageCommon.ush"

uint PageResolution;
uint TargetMipIndex;
uint DispatchGroupSize;

Buffer<uint>   InIndirectArgs;
RWBuffer<uint> OutIndirectArgs;

[numthreads(1, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint MacroGroupId = DispatchThreadId.x;

	const uint TargetPageResolution = PageResolution >> TargetMipIndex;
	const uint TotalVoxelCount = TargetPageResolution * TargetPageResolution * TargetPageResolution;
	const uint DispatchZ = ceil(TotalVoxelCount / float(DispatchGroupSize));

	OutIndirectArgs[0] = InIndirectArgs[0];
	OutIndirectArgs[1] = InIndirectArgs[1];
	OutIndirectArgs[2] = DispatchZ;
}

#endif


#if SHADER_UPDATE_PAGEINDEX
int3 PageCountResolution;
uint PageResolution;
uint MipIt;

Texture3D<uint>	  DensityTexture;
Buffer<uint>	  PageToPageIndexBuffer;
RWBuffer<uint>	  OutPageIndexBuffer;

[numthreads(1, 1, 64)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint  MaxDispatchCountPerDim = 65535;
	const uint  PageIndex = DispatchThreadId.x + DispatchThreadId.y * MaxDispatchCountPerDim;
	const uint3 PageCoord = IndexToCoord(PageIndex, PageCountResolution);

	const uint OutPageResolution = PageResolution >> MipIt;
	const uint TotalVoxelPerOutPageResolution = OutPageResolution * OutPageResolution * OutPageResolution;
	const uint VoxelIndex = DispatchThreadId.z;
	if (VoxelIndex >= TotalVoxelPerOutPageResolution)
		return;

	const uint3 OutVoxelCoordOffset = IndexToCoord(VoxelIndex, OutPageResolution);
	const uint3 OutVoxelCoord = PageCoord * OutPageResolution + OutVoxelCoordOffset;

	const uint Density = DensityTexture.Load(uint4(OutVoxelCoord, MipIt));
	// Update the page index with invalid page index if the voxel does not contain any data.
	// This allow to save tracing cost when evaluating the transmittance.
	if (Density == 0)
	{
		const uint PageIndexOffset = PageToPageIndexBuffer[PageIndex];
		OutPageIndexBuffer[PageIndexOffset] = INVALID_VOXEL_PAGE_INDEX;
	}
}
#endif

