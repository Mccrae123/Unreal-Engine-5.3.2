// Copyright Epic Games, Inc. All Rights Reserved.

//#include "HairStrandsVoxelPageCommonStruct.ush"

#include "../Common.ush"
#include "../Matrices.ush"
#include "HairStrandsDeepShadowCommonStruct.ush"
#include "HairStrandsAABBCommon.ush"

#if SHADER_ALLOCATE

#ifndef MAX_SLOT_COUNT
#error MAX_SLOT_COUNT needs to be defined
#endif

float4				LightDirections[MAX_SLOT_COUNT];
float4				LightPositions[MAX_SLOT_COUNT];
uint4				MacroGroupIndices[MAX_SLOT_COUNT];

// For testing parity with CPU version
float3				CPU_MinAABB;
uint				CPU_bUseCPUData;
float3				CPU_MaxAABB;
float				RasterizationScale;

int2				SlotResolution;
uint				SlotIndexCount;
uint				MacroGroupCount;

Buffer<int>								MacroGroupAABBBuffer;
RWStructuredBuffer<FDeepShadowViewInfo>	OutShadowViewInfoBuffer;
RWStructuredBuffer<FDeepShadowTransform>OutShadowWorldToLightTransformBuffer;


float DegreesToRadians(float InDeg)
{
	return InDeg / 180.f * PI;
}

float ComputeMinStrandRadiusAtDepth1(const int2 Resolution, const float FOV, const float InRasterizationScale)
{
	const float DiameterToRadius = 0.5f;
	const float vFOV = DegreesToRadians(FOV);
	const float StrandDiameterAtDepth1 = tan(vFOV * 0.5f) / (0.5f * Resolution.y);
	return DiameterToRadius * InRasterizationScale * StrandDiameterAtDepth1;
}

// This function is equivalent of the CPU version in HairStrandsDeepShadow.cpp
// TODO: create a tighter bound
void ComputeWorldToLightClip(
	inout float4x4	OutWorldToClipTransform,
	inout float		OutMinStrandRadiusAtDepth1,
	inout float3	OutLightDirection,
	const FHairAABB Aabb,
	const uint		SlotIndex)
{
	const float3 Extents = GetExtents(Aabb);
	const float3 Center  = GetCenter(Aabb);
	const float  Radius  = length(Extents);

	const float3 LightDirection = LightDirections[SlotIndex].xyz;
	const float3 LightPosition  = LightPositions[SlotIndex].xyz;
	const uint bIsDirectional	= LightPositions[SlotIndex].w == 0;

	const float MinZ = max(0.1f, length(LightPosition - Center)) - Radius;
	const float MaxZ = max(0.2f, length(LightPosition - Center)) + Radius;

	const float StrandHairStableRasterizationScale = max(RasterizationScale, 1.0f);
	OutMinStrandRadiusAtDepth1 = 1;
	OutWorldToClipTransform = 0;

	if (bIsDirectional) // (LightType == LightType_Directional)
	{
		OutLightDirection			= LightDirection;

		const float4x4 ProjMatrix	= ReversedZOrthoMatrix(Radius, Radius, 1.f / (2 * Radius), 0);
		const float4x4 WorldToLight	= LookAtMatrix(Center - LightDirection * Radius, Center, float3(0, 0, 1));
		OutWorldToClipTransform		= mul(WorldToLight, ProjMatrix);

		const float RadiusAtDepth1	= Radius / min(SlotResolution.x, SlotResolution.y);
		OutMinStrandRadiusAtDepth1	= RadiusAtDepth1 * RasterizationScale;
	}
	else // if (LightType == LightType_Spot || LightType == LightType_Point || LightType == LightType_Rect)
	{
		OutLightDirection			= normalize(LightPosition - Center);

		const float SphereDistance	= length(LightPosition - Center);
		const float HalfFov			= asin(Radius / SphereDistance);

		const float4x4 ProjMatrix	= ReversedZPerspectiveMatrix(HalfFov, 1, 1, MinZ, MaxZ);
		const float4x4 WorldToLight = LookAtMatrix(LightPosition, Center, float3(0, 0, 1));
		OutWorldToClipTransform		= mul(WorldToLight, ProjMatrix);

		OutMinStrandRadiusAtDepth1 = ComputeMinStrandRadiusAtDepth1(SlotResolution, 2 * HalfFov, RasterizationScale);
	}
}

// This code assume we have less than 32 macro group (which fit into a single CU/SM)
[numthreads(MAX_SLOT_COUNT, 1, 1)]
void CreateViewInfo(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const uint SlotIndex = DispatchThreadId.x;

	if (SlotIndex > SlotIndexCount)
		return;

	const uint MacroGroupId = MacroGroupIndices[SlotIndex].x;

	FHairAABB Bound = InitHairAABB();
	if (MacroGroupId < MacroGroupCount)
	{
		Bound = ReadHairAABB(MacroGroupId, MacroGroupAABBBuffer);
	}

	FDeepShadowViewInfo ViewInfo;
	ComputeWorldToLightClip(ViewInfo.WorldToClip, ViewInfo.MinRadiusAtDepth1, ViewInfo.ViewForward, Bound, SlotIndex);

	FDeepShadowTransform Transform;
	Transform.WorldToClip = ViewInfo.WorldToClip;

	OutShadowViewInfoBuffer[SlotIndex] = ViewInfo;
	OutShadowWorldToLightTransformBuffer[SlotIndex] = Transform;
}
#endif
