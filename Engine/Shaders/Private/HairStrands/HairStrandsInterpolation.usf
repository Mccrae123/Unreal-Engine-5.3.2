// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "HairStrandsMeshProjectionCommon.ush"

uint VertexCount;
uint DispatchCountX;
float3 HairWorldOffset;

Buffer<uint4>  RenderRestPosePositionBuffer;
Buffer<uint4>  SimRestPosePositionBuffer;
Buffer<uint4>  DeformedSimPositionBuffer;
Buffer<uint4>  Interpolation0Buffer;
Buffer<uint4>  Interpolation1Buffer;

float3			OutRenderDeformedPositionCenter; 
RWBuffer<uint4> OutRenderDeformedPositionBuffer;

#if PERMUTATION_DYNAMIC_GEOMETRY == 1

// Compact all these buffers into 2 buffers: translation + quaternion
float3			RestPositionWorldCenter;
Buffer<float4>  RestPosition0Buffer;
Buffer<float4>  RestPosition1Buffer;
Buffer<float4>  RestPosition2Buffer;

float3			DeformedPositionWorldCenter;
Buffer<float4>  DeformedPosition0Buffer;
Buffer<float4>  DeformedPosition1Buffer;
Buffer<float4>  DeformedPosition2Buffer;

Buffer<uint>	RootBarycentricBuffer;
Buffer<uint>	RootToTriangleIndex;
Buffer<uint>	VertexToRootIndexBuffer;
#endif

#if PERMUTATION_DEBUG == 1
Buffer<float4>	 SimAttributeBuffer;
RWBuffer<float4> OutRenderAttributeBuffer;
#endif

#if PERMUTATION_GROUP_SIZE == 0
	#define GROUP_SIZE 64
#elif PERMUTATION_GROUP_SIZE == 1
	#define GROUP_SIZE 32
#else
	#error Unknown group size	
#endif

[numthreads(GROUP_SIZE, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const uint VertexIndex = DispatchThreadId.x + DispatchThreadId.y * DispatchCountX * GROUP_SIZE;
	if (VertexIndex < VertexCount)
	{
		const uint4 InterpolationData0	= Interpolation0Buffer[VertexIndex];
		const uint4 InterpolationData1	= Interpolation1Buffer[VertexIndex];		

		uint3 GuideVertexIndices = 0;
		GuideVertexIndices.x = InterpolationData0.x | (InterpolationData1.x << 16);
		GuideVertexIndices.y = InterpolationData0.y | (InterpolationData1.y << 16);
		GuideVertexIndices.z = InterpolationData0.z | (InterpolationData1.z << 16);

		float3 GuideVertexWeights = float3(saturate((InterpolationData0.w & 0xFF) / 255.f), saturate(((InterpolationData0.w >> 8) & 0xFF) / 255.f), 0);
		GuideVertexWeights.z = saturate(1.0f - (GuideVertexWeights.x + GuideVertexWeights.y));

		float3 CurrOffset = 0;
		float3 ControlPoint = f16tof32(RenderRestPosePositionBuffer[VertexIndex].xyz);
		[unroll]
		for (uint K = 0; K < 3; ++K)
		{
			const uint GuideIndex = GuideVertexIndices[K];
			const float3 RestGuidePoint	= f16tof32(SimRestPosePositionBuffer[GuideIndex].xyz);

			const float3 DeformedGuidePoint	= f16tof32(DeformedSimPositionBuffer[GuideIndex].xyz);
			CurrOffset += (DeformedGuidePoint - RestGuidePoint) * GuideVertexWeights[K];

		}

		// Apply dynamic mesh deformation (translation / rotation)
		// hair_todo: applied the transformation in local space and then rotation everything in global space
		#if PERMUTATION_DYNAMIC_GEOMETRY == 1
		{
			const uint RootIndex						= VertexToRootIndexBuffer[VertexIndex];
			const float3 RootBarycentric				= DecodeBarycentrics(RootBarycentricBuffer[RootIndex]);
			const FHairMeshTriangle RestTriangle		= GetTriangleTransformation(RootIndex, RestPosition0Buffer, RestPosition1Buffer, RestPosition2Buffer, RestPositionWorldCenter);
			const FHairMeshTriangle DeformedTriangle	= GetTriangleTransformation(RootIndex, DeformedPosition0Buffer, DeformedPosition1Buffer, DeformedPosition2Buffer, DeformedPositionWorldCenter);

			ControlPoint = TransformPoint(ControlPoint + HairWorldOffset, RootBarycentric, RestTriangle, DeformedTriangle) - HairWorldOffset;

			// Debug
			#if 0
			{
				// Show the triangle normal use by hair fiber
				//ControlPoint = VertexIndex % 2 == 0 ? RestTriangle.P0 : RestTriangle.P0 + RestTriangle.N;

				// Measure the stretch of the projection (to identify if there any local transform issue during the projeciton steps
				ControlPoint = VertexIndex % 2 == 0 ? ControlPoint  : RestTriangle.P0 - HairWorldOffset;
			}
			#endif
		}
		#endif	

		OutRenderDeformedPositionBuffer[VertexIndex] = float4(f32tof16(ControlPoint + CurrOffset - OutRenderDeformedPositionCenter), RenderRestPosePositionBuffer[VertexIndex].w);

		#if PERMUTATION_DEBUG == 1
		{
			const uint GuideIndex = GuideVertexIndices[0]; // Take the closest guide
			const float4 GuideAttribute = SimAttributeBuffer[GuideIndex];
			OutRenderAttributeBuffer[VertexIndex] = GuideAttribute;
		}
		#endif
	}
}