// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "HairStrandsMeshProjectionCommon.ush"

uint VertexCount;
uint DispatchCountX;
float3 InHairPositionOffset;
float3 OutHairPositionOffset;

Buffer<uint4>  RenderRestPosePositionBuffer;
Buffer<uint4>  SimRestPosePositionBuffer;
Buffer<uint4>  DeformedSimPositionBuffer;
Buffer<uint4>  Interpolation0Buffer;
Buffer<uint4>  Interpolation1Buffer;

RWBuffer<uint4> OutRenderDeformedPositionBuffer;

#if PERMUTATION_DYNAMIC_GEOMETRY == 1

// Compact all these buffers into 2 buffers: translation + quaternion
float3			RestPositionOffset;
Buffer<float4>  RestPosition0Buffer;
Buffer<float4>  RestPosition1Buffer;
Buffer<float4>  RestPosition2Buffer;

float3			DeformedPositionOffset;
Buffer<float4>  DeformedPosition0Buffer;
Buffer<float4>  DeformedPosition1Buffer;
Buffer<float4>  DeformedPosition2Buffer;

Buffer<uint>	RootBarycentricBuffer;
Buffer<uint>	RootToTriangleIndex;
Buffer<uint>	VertexToRootIndexBuffer;

float3			SimRestPositionOffset;
Buffer<float4>  SimRestPosition0Buffer;
Buffer<float4>  SimRestPosition1Buffer;
Buffer<float4>  SimRestPosition2Buffer;

float3			SimDeformedPositionOffset;
Buffer<float4>  SimDeformedPosition0Buffer;
Buffer<float4>  SimDeformedPosition1Buffer;
Buffer<float4>  SimDeformedPosition2Buffer;

Buffer<uint>	SimRootBarycentricBuffer;
Buffer<uint>	SimRootToTriangleIndex;
Buffer<uint>	SimVertexToRootIndexBuffer;
#endif

#if PERMUTATION_DEBUG == 1
Buffer<float4>	 SimAttributeBuffer;
RWBuffer<float4> OutRenderAttributeBuffer;
#endif

#if PERMUTATION_GROUP_SIZE == 0
	#define GROUP_SIZE 64
#elif PERMUTATION_GROUP_SIZE == 1
	#define GROUP_SIZE 32
#else
	#error Unknown group size	
#endif

[numthreads(GROUP_SIZE, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const uint VertexIndex = DispatchThreadId.x + DispatchThreadId.y * DispatchCountX * GROUP_SIZE;
	if (VertexIndex < VertexCount)
	{
		const uint4 InterpolationData0	= Interpolation0Buffer[VertexIndex];
		const uint4 InterpolationData1	= Interpolation1Buffer[VertexIndex];		

		uint3 GuideVertexIndices = 0;
		GuideVertexIndices.x = InterpolationData0.x | (InterpolationData1.x << 16);
		GuideVertexIndices.y = InterpolationData0.y | (InterpolationData1.y << 16);
		GuideVertexIndices.z = InterpolationData0.z | (InterpolationData1.z << 16);

		float3 GuideVertexWeights = float3(saturate((InterpolationData0.w & 0xFF) / 255.f), saturate(((InterpolationData0.w >> 8) & 0xFF) / 255.f), 0);
		GuideVertexWeights.z = saturate(1.0f - (GuideVertexWeights.x + GuideVertexWeights.y));

		// ControlPoint is in the local hair referential
		float3 CurrOffset = 0;
		float3 ControlPoint = f16tof32(RenderRestPosePositionBuffer[VertexIndex].xyz) + InHairPositionOffset;
		[unroll]
		for (uint K = 0; K < 3; ++K)
		{
			const uint GuideIndex = GuideVertexIndices[K];
			const float3 RestGuidePoint	= f16tof32(SimRestPosePositionBuffer[GuideIndex].xyz) + InHairPositionOffset;

			const float3 DeformedGuidePoint	= f16tof32(DeformedSimPositionBuffer[GuideIndex].xyz) + OutHairPositionOffset;
			CurrOffset += (DeformedGuidePoint - RestGuidePoint) * GuideVertexWeights[K];
		}
		OutRenderDeformedPositionBuffer[VertexIndex] = float4(f32tof16(ControlPoint + CurrOffset - OutHairPositionOffset), RenderRestPosePositionBuffer[VertexIndex].w);

		// Apply dynamic mesh deformation (translation / rotation)
		// hair_todo: applied the transformation in local space and then rotation everything in global space
		#if PERMUTATION_DYNAMIC_GEOMETRY == 1
		{
			#if PERMUTATION_LOCAL_INTERPOLATION == 1
			{
				CurrOffset = 0;
				for (uint K = 0; K < 3; ++K)
				{
					const uint GuideIndex = GuideVertexIndices[K];
					const uint RootIndex = SimVertexToRootIndexBuffer[GuideIndex];
					const float3 RootBarycentric = DecodeBarycentrics(SimRootBarycentricBuffer[RootIndex]);

					const FHairMeshTriangle RestTriangle		= GetTriangleTransformation(RootIndex, SimRestPosition0Buffer, SimRestPosition1Buffer, SimRestPosition2Buffer, SimRestPositionOffset);
					const FHairMeshTriangle DeformedTriangle	= GetTriangleTransformation(RootIndex, SimDeformedPosition0Buffer, SimDeformedPosition1Buffer, SimDeformedPosition2Buffer, SimDeformedPositionOffset);

					const float3 RestGuidePoint	= f16tof32(SimRestPosePositionBuffer[GuideIndex].xyz) + InHairPositionOffset;
					const float3 LocalRestGuidePoint = ToTriangle(RestGuidePoint,RootBarycentric,RestTriangle);

					const float3 DeformedGuidePoint	= f16tof32(DeformedSimPositionBuffer[GuideIndex].xyz) + OutHairPositionOffset;
					const float3 LocalDeformedGuidePoint = ToTriangle(DeformedGuidePoint,RootBarycentric,DeformedTriangle);
					CurrOffset += (LocalDeformedGuidePoint - LocalRestGuidePoint) * GuideVertexWeights[K];
				}
			
				const uint RootIndex						= VertexToRootIndexBuffer[VertexIndex];
				const float3 RootBarycentric				= DecodeBarycentrics(RootBarycentricBuffer[RootIndex]);
				const FHairMeshTriangle RestTriangle		= GetTriangleTransformation(RootIndex, RestPosition0Buffer, RestPosition1Buffer, RestPosition2Buffer, RestPositionOffset);
				const FHairMeshTriangle DeformedTriangle	= GetTriangleTransformation(RootIndex, DeformedPosition0Buffer, DeformedPosition1Buffer, DeformedPosition2Buffer, DeformedPositionOffset);

				ControlPoint = ToTriangle(ControlPoint,RootBarycentric,RestTriangle) + CurrOffset;
				ControlPoint = ToWorld(ControlPoint,RootBarycentric,DeformedTriangle);
			}
			#endif	

			#if PERMUTATION_LOCAL_INTERPOLATION == 0
			{
				const uint RootIndex						= VertexToRootIndexBuffer[VertexIndex];
				const float3 RootBarycentric				= DecodeBarycentrics(RootBarycentricBuffer[RootIndex]);
				const FHairMeshTriangle RestTriangle		= GetTriangleTransformation(RootIndex, RestPosition0Buffer, RestPosition1Buffer, RestPosition2Buffer, RestPositionOffset);
				const FHairMeshTriangle DeformedTriangle	= GetTriangleTransformation(RootIndex, DeformedPosition0Buffer, DeformedPosition1Buffer, DeformedPosition2Buffer, DeformedPositionOffset);

				ControlPoint = TransformPoint(ControlPoint, RootBarycentric, RestTriangle, DeformedTriangle);
			}
			#endif

			OutRenderDeformedPositionBuffer[VertexIndex] = float4(f32tof16(ControlPoint - OutHairPositionOffset), RenderRestPosePositionBuffer[VertexIndex].w);

			// Debug
			#if 0
			{
				// Show the triangle normal use by hair fiber
				//ControlPoint = VertexIndex % 2 == 0 ? RestTriangle.P0 : RestTriangle.P0 + RestTriangle.N;

				// Measure the stretch of the projection (to identify if there any local transform issue during the projeciton steps
				ControlPoint = VertexIndex % 2 == 0 ? ControlPoint  : RestTriangle.P0;
			}
			#endif
		}
		#endif	

		#if PERMUTATION_DEBUG == 1
		{
			const uint GuideIndex = GuideVertexIndices[0]; // Take the closest guide
			const float4 GuideAttribute = SimAttributeBuffer[GuideIndex];
			OutRenderAttributeBuffer[VertexIndex] = GuideAttribute;
		}
		#endif
	}
}