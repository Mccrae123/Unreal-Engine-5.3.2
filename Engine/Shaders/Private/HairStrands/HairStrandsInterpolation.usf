// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"

uint VertexCount;
uint DispatchCountX;

Buffer<uint4>  RenderRestPosePositionBuffer;
Buffer<uint4>  SimRestPosePositionBuffer;
Buffer<uint4>  DeformedSimPositionBuffer;
Buffer<uint4>  Interpolation0Buffer;
Buffer<uint4>  Interpolation1Buffer;

float3			OutRenderDeformedPositionCenter; 
RWBuffer<uint4> OutRenderDeformedPositionBuffer;

#if PERMUTATION_DYNAMIC_GEOMETRY == 1

// Compact all these buffers into 2 buffers: translation + quaternion
float3			RestPositionWorldCenter;
Buffer<float4>  RestPosition0Buffer;
Buffer<float4>  RestPosition1Buffer;
Buffer<float4>  RestPosition2Buffer;

float3			DeformedPositionWorldCenter;
Buffer<float4>  DeformedPosition0Buffer;
Buffer<float4>  DeformedPosition1Buffer;
Buffer<float4>  DeformedPosition2Buffer;

Buffer<uint>	RootToTriangleIndex;
Buffer<uint>	VertexToRootIndexBuffer;

#define QUATERNION_IDENTITY float4(0,0,0,1)
#define SMALL_NUMBER 1e-8

float4 NormalizeQuat(in float4 Quat)
{
	float SquaredNorm = dot(Quat, Quat);
	return (SquaredNorm >= SMALL_NUMBER) ? Quat / sqrt(SquaredNorm) : QUATERNION_IDENTITY;
}

float4 InverseQuat(in float4 Quat)
{
	return float4(-Quat.x, -Quat.y, -Quat.z, Quat.w);
}

float4 MultiplyQuat(in float4 QuatA, in float4 QuatB)
{
	return float4(
		QuatB.xyz * QuatA.w + QuatA.xyz * QuatB.w + cross(QuatA.xyz, QuatB.xyz),
		QuatA.w * QuatB.w - dot(QuatA.xyz, QuatB.xyz));
}

float3 RotateVectorByQuat(in float3 Vector, in float4 Quat)
{
	float3 T = 2.0 * cross(Quat.xyz, Vector);
	return Vector + Quat.w * T + cross(Quat.xyz, T);
}

float3 UnrotateVectorByQuat(in float3 Vector, in float4 Quat)
{
	float3 T = 2.0 * cross(Quat.xyz, Vector);
	return Vector - Quat.w * T + cross(Quat.xyz, T);
}

float4 FindQuatBetweenHelper(in float3 A, in float3 B, in float NormAB)
{
	float W = NormAB + dot(A, B);
	float4 Quat = (W > 1e-6*NormAB) ? float4(A.y*B.z - A.z*B.y, A.z*B.x - A.x*B.z, A.x*B.y - A.y*B.x, W) :
		(abs(A.x) > abs(A.y)) ? float4(-A.z, 0.0, A.x, 0.0) : float4(0.0, -A.z, A.y, 0.0);
	return NormalizeQuat(Quat);
}

float4 FindQuatBetweenNormals(in float3 NormalA, in float3 NormalB)
{
	float NormAB = 1.0;
	return FindQuatBetweenHelper(NormalA, NormalB, NormAB);
}

void GetTriangleTransformation(uint VertexIndex, out float3 T, out float4 Q)
{
	const uint RootIndex = VertexToRootIndexBuffer[VertexIndex];
//	const uint TriangleIndex = RootToTriangleIndex[RootIndex];

	float3 Rest_P1 = RestPosition1Buffer[RootIndex].xyz + RestPositionWorldCenter;
	float3 Rest_P0 = RestPosition0Buffer[RootIndex].xyz + RestPositionWorldCenter;
	float3 Rest_P2 = RestPosition2Buffer[RootIndex].xyz + RestPositionWorldCenter;
	float3 Rest_E0 = Rest_P1 - Rest_P0;
	float3 Rest_E1 = Rest_P2 - Rest_P0;
	float3 Rest_N = normalize(cross(Rest_E0, Rest_E1));

	float3 Deformed_P0	= DeformedPosition0Buffer[RootIndex].xyz + DeformedPositionWorldCenter;
	float3 Deformed_P1	= DeformedPosition1Buffer[RootIndex].xyz + DeformedPositionWorldCenter;
	float3 Deformed_P2	= DeformedPosition2Buffer[RootIndex].xyz + DeformedPositionWorldCenter;
	float3 Deformed_E0	= Deformed_P1 - Deformed_P0;
	float3 Deformed_E1	= Deformed_P2 - Deformed_P0;
	float3 Deformed_N	= normalize(cross(Deformed_E0, Deformed_E1));

	T = Deformed_P0 - Rest_P0;
	Q = FindQuatBetweenNormals(Rest_N, Deformed_N);
}
#endif

#if PERMUTATION_DEBUG == 1
Buffer<float4>	 SimAttributeBuffer;
RWBuffer<float4> OutRenderAttributeBuffer;
#endif

#if PERMUTATION_GROUP_SIZE == 0
	#define GROUP_SIZE 64
#elif PERMUTATION_GROUP_SIZE == 1
	#define GROUP_SIZE 32
#else
	#error Unknown group size	
#endif

[numthreads(GROUP_SIZE, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const uint VertexIndex = DispatchThreadId.x + DispatchThreadId.y * DispatchCountX * GROUP_SIZE;
	if (VertexIndex < VertexCount)
	{
		const uint4 InterpolationData0	= Interpolation0Buffer[VertexIndex];
		const uint4 InterpolationData1	= Interpolation1Buffer[VertexIndex];		

		uint3 GuideVertexIndices = 0;
		GuideVertexIndices.x = InterpolationData0.x | (InterpolationData1.x << 16);
		GuideVertexIndices.y = InterpolationData0.y | (InterpolationData1.y << 16);
		GuideVertexIndices.z = InterpolationData0.z | (InterpolationData1.z << 16);

		float3 GuideVertexWeights = float3(saturate((InterpolationData0.w & 0xFF) / 255.f), saturate(((InterpolationData0.w >> 8) & 0xFF) / 255.f), 0);
		GuideVertexWeights.z = saturate(1.0f - (GuideVertexWeights.x + GuideVertexWeights.y));

		float3 CurrOffset = 0;
		float3 PrevOffset = 0;
		const float3 ControlPoint = f16tof32(RenderRestPosePositionBuffer[VertexIndex].xyz);
		[unroll]
		for (uint K = 0; K < 3; ++K)
		{
			const uint GuideIndex = GuideVertexIndices[K];
			const float3 RestGuidePoint	= f16tof32(SimRestPosePositionBuffer[GuideIndex].xyz);

			const float3 DeformedGuidePoint	= f16tof32(DeformedSimPositionBuffer[GuideIndex].xyz);
			CurrOffset += (DeformedGuidePoint - RestGuidePoint) * GuideVertexWeights[K];

		}

		// Apply dynamic mesh deformation (translation / rotation)
		// hair_todo: applied the transformation in local space and then rotation everything in global space
		#if PERMUTATION_DYNAMIC_GEOMETRY == 1
		{
			float3 DynTranslation = 0;
			float4 DynRotation = 0;
			GetTriangleTransformation(VertexIndex, DynTranslation, DynRotation);
			CurrOffset += DynTranslation;
		}
		#endif	

		OutRenderDeformedPositionBuffer[VertexIndex] = float4(f32tof16(ControlPoint + CurrOffset - OutRenderDeformedPositionCenter), RenderRestPosePositionBuffer[VertexIndex].w);

		#if PERMUTATION_DEBUG == 1
		{
			const uint GuideIndex = GuideVertexIndices[0]; // Take the closest guide
			const float4 GuideAttribute = SimAttributeBuffer[GuideIndex];
			OutRenderAttributeBuffer[VertexIndex] = GuideAttribute;
		}
		#endif
	}
}