// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"

uint VertexCount;
uint DispatchCountX;

Buffer<uint4>  RenderRestPosePositionBuffer;
Buffer<uint4>  SimRestPosePositionBuffer;
Buffer<uint4>  DeformedSimPositionBuffer;
Buffer<uint4>  Interpolation0Buffer;
Buffer<uint4>  Interpolation1Buffer;

RWBuffer<uint4>  OutRenderDeformedPositionBuffer;

#if PERMUTATION_DEBUG == 1
Buffer<float4>	 SimAttributeBuffer;
RWBuffer<float4> OutRenderAttributeBuffer;
#endif

#if PERMUTATION_GROUP_SIZE == 0
	#define GROUP_SIZE 64
#elif PERMUTATION_GROUP_SIZE == 1
	#define GROUP_SIZE 32
#else
	#error Unknown group size	
#endif

[numthreads(GROUP_SIZE, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	const uint VertexIndex = DispatchThreadId.x + DispatchThreadId.y * DispatchCountX * GROUP_SIZE;
	if (VertexIndex < VertexCount)
	{
		const uint4 InterpolationData0	= Interpolation0Buffer[VertexIndex];
		const uint4 InterpolationData1	= Interpolation1Buffer[VertexIndex];		

		uint3 GuideVertexIndices = 0;
		GuideVertexIndices.x = InterpolationData0.x | (InterpolationData1.x << 16);
		GuideVertexIndices.y = InterpolationData0.y | (InterpolationData1.y << 16);
		GuideVertexIndices.z = InterpolationData0.z | (InterpolationData1.z << 16);

		float3 GuideVertexWeights = float3(saturate((InterpolationData0.w & 0xFF) / 255.f), saturate(((InterpolationData0.w >> 8) & 0xFF) / 255.f), 0);
		GuideVertexWeights.z = saturate(1.0f - (GuideVertexWeights.x + GuideVertexWeights.y));

		float3 CurrOffset = 0;
		float3 PrevOffset = 0;
		const float3 ControlPoint = f16tof32(RenderRestPosePositionBuffer[VertexIndex].xyz);
		[unroll]
		for (uint K = 0; K < 3; ++K)
		{
			const uint GuideIndex = GuideVertexIndices[K];
			const float3 RestGuidePoint	= f16tof32(SimRestPosePositionBuffer[GuideIndex].xyz);

			const float3 DeformedGuidePoint	= f16tof32(DeformedSimPositionBuffer[GuideIndex].xyz);
			CurrOffset += (DeformedGuidePoint - RestGuidePoint) * GuideVertexWeights[K];

		}

		OutRenderDeformedPositionBuffer[VertexIndex] = float4(f32tof16(ControlPoint + CurrOffset), RenderRestPosePositionBuffer[VertexIndex].w);

		#if PERMUTATION_DEBUG == 1
		{
			const uint GuideIndex = GuideVertexIndices[0]; // Take the closest guide
			const float4 GuideAttribute = SimAttributeBuffer[GuideIndex];
			OutRenderAttributeBuffer[VertexIndex] = GuideAttribute;
		}
		#endif
	}
}