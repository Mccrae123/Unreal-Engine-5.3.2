// Copyright Epic Games, Inc. All Rights Reserved.

//#define SCENE_TEXTURES_DISABLED 1

#include "../Common.ush"
#include "HairStrandsMeshProjectionCommon.ush" 
#include "../ShaderPrint.ush"

#define INPUT_ROOT_FRAME 0
#define INPUT_ROOT_TRIANGLE 1
#define INPUT_ROOT_SAMPLES 2

uint MaxRootCount;
float4x4 RootLocalToWorld;
uint DeformedFrameEnable;

#if PERMUTATION_INPUT_TYPE == INPUT_ROOT_FRAME
Buffer<uint>   RootBarycentricBuffer;
#endif

Buffer<float4>  RestPosition0Buffer;
Buffer<float4>  RestPosition1Buffer;
Buffer<float4>  RestPosition2Buffer;

Buffer<float4>  DeformedPosition0Buffer;
Buffer<float4>  DeformedPosition1Buffer;
Buffer<float4>  DeformedPosition2Buffer;

Buffer<float4> RestSamplePositionsBuffer;
Buffer<float4> DeformedSamplePositionsBuffer;

[numthreads(256, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	ResolvedView = ResolveView();

#if PERMUTATION_INPUT_TYPE == INPUT_ROOT_FRAME  
	const uint LineIndex = DispatchThreadId.x;

	if (LineIndex > MaxRootCount) return;
	{
		const FHairMeshTriangleWithUVs RestTriangle		= GetTriangleWithUVsTransformation(LineIndex, RestPosition0Buffer, RestPosition1Buffer, RestPosition2Buffer);
		const FHairMeshTriangleWithUVs DeformedTriangle = GetTriangleWithUVsTransformation(LineIndex, DeformedPosition0Buffer, DeformedPosition1Buffer, DeformedPosition2Buffer);

		FHairMeshTriangleWithUVs Tri;
		if (DeformedFrameEnable > 0)
			Tri = DeformedTriangle;
		else
			Tri = RestTriangle;

		const float3 B  = DecodeBarycentrics(RootBarycentricBuffer[LineIndex]);
		float3 P0 = B.x * Tri.P0 + B.y * Tri.P1 + B.z * Tri.P2;
		float3 P1 = P0 + Tri.N;

		const float2 UVs = 
			B.x * Tri.UV0 +
			B.y * Tri.UV1 +
			B.z * Tri.UV2;

		P0 = mul(float4(P0, 1), RootLocalToWorld).xyz;
		P1 = mul(float4(P1, 1), RootLocalToWorld).xyz;

		const float3 N = normalize(P0 - P1);
		const float4 Color = float4(UVs, 0, 1);
		//Color = float4(N* 0.5f + 0.5f, 1);
		AddLineWS(P0, P1, Color);
	}
#endif // INPUT_ROOT_FRAME

#if PERMUTATION_INPUT_TYPE == INPUT_ROOT_TRIANGLE
	const uint TriangleIndex = DispatchThreadId.x;

	if (TriangleIndex > MaxRootCount) return;

	const FHairMeshTriangleWithUVs RestTriangle		= GetTriangleWithUVsTransformation(TriangleIndex, RestPosition0Buffer, RestPosition1Buffer, RestPosition2Buffer);
	const FHairMeshTriangleWithUVs DeformedTriangle = GetTriangleWithUVsTransformation(TriangleIndex, DeformedPosition0Buffer, DeformedPosition1Buffer, DeformedPosition2Buffer);

	FHairMeshTriangleWithUVs Tri;
	if (DeformedFrameEnable > 0)
		Tri = DeformedTriangle;
	else
		Tri = RestTriangle;
	

	// Debug: To test if the rest-triangle-to-deformed-triangle transformation works correctly
	#if 0
	if (DeformedFrameEnable > 0)
	{
		float3 Barycentric = 0;
		if (TriangleVertex == 0)
		{
			P = RestTriangle.P0;
			Barycentric = float3(1, 0, 0);
		}
		if (TriangleVertex == 1)
		{
			P = RestTriangle.P1;
			Barycentric = float3(0, 1, 0);
		}
		if (TriangleVertex == 2)
		{
			P = RestTriangle.P2;
			Barycentric = float3(0, 0, 1);
		}
		P = TransformPoint(P, Barycentric, RestTriangle, DeformedTriangle);
	}
	#endif

	float4 Color = float4(Tri.UV0, 0, 1);
	// Color = float4((Tri.N + 1) * 0.5f, 1);

	AddFilledTriangleWS(
		mul(float4(Tri.P0, 1), RootLocalToWorld).xyz, 
		mul(float4(Tri.P1, 1), RootLocalToWorld).xyz, 
		mul(float4(Tri.P2, 1), RootLocalToWorld).xyz, 
		Color);
#endif // INPUT_ROOT_TRIANGLE

#if PERMUTATION_INPUT_TYPE == INPUT_ROOT_SAMPLES 
	const uint PointIndex = DispatchThreadId.x;
	
	if (PointIndex > MaxRootCount) return;

	float3 P = (DeformedFrameEnable > 0) ? DeformedSamplePositionsBuffer[PointIndex].xyz : RestSamplePositionsBuffer[PointIndex].xyz;
	P = mul(float4(P, 1), RootLocalToWorld).xyz;

	AddCrossWS(P, 1.f, ColorYellow);
#endif // INPUT_ROOT_SAMPLES
}