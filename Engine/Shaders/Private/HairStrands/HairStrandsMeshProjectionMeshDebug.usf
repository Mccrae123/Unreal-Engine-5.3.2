// Copyright Epic Games, Inc. All Rights Reserved.

//#define SCENE_TEXTURES_DISABLED 1

#include "../Common.ush"
#include "HairStrandsMeshProjectionCommon.ush"
#include "../ShaderPrint.ush"

float4x4 LocalToWorld;
uint VertexOffset;
uint IndexOffset;
uint MaxIndexCount;
uint MaxVertexCount;
uint MeshUVsChannelOffset;
uint MeshUVsChannelCount;
uint bOutputInUVsSpace;
uint MeshType;
uint SectionIndex;
float2 OutputResolution;

Buffer<float> InputVertexPositionBuffer;
Buffer<float2> InputVertexUVsBuffer;
#if PERMUTATION_INPUT_TYPE == 1
Buffer<uint> InputIndexBuffer;
#endif

#define REST_MESH 0
#define DEFORMED_MESH 1
#define SOURCE_MESH 2
#define TARGET_MESH 3

[numthreads(256, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	ResolvedView = ResolveView();

	float4 Color = 0;
	if (MeshType == REST_MESH)		Color = float4(1, 0, 0, 1);
	if (MeshType == DEFORMED_MESH)	Color = float4(0, 1, 0, 1);
	if (MeshType == SOURCE_MESH)	Color = float4(0, 0, 1, 1);
	if (MeshType == TARGET_MESH)	Color = float4(1, 1, 0, 1);

#if PERMUTATION_INPUT_TYPE == 0
	const uint VertexId = DispatchThreadId.x * 3;
	const uint VertexIndex0 = min(VertexOffset + VertexId, MaxVertexCount-1);

	FHairMeshTriangleWithUVs Tri = (FHairMeshTriangleWithUVs)0;
	Tri.P0 = InputVertexPositionBuffer[VertexIndex0 + 0];
	Tri.P1 = InputVertexPositionBuffer[VertexIndex0 + 1];
	Tri.P2 = InputVertexPositionBuffer[VertexIndex0 + 2];

	Tri.UV0 = InputVertexUVsBuffer[VertexIndex0 + 0];
	Tri.UV1 = InputVertexUVsBuffer[VertexIndex0 + 1];
	Tri.UV2 = InputVertexUVsBuffer[VertexIndex0 + 2];

	Tri.N = cross(Tri.P1 - Tri.P0, Tri.P2 - Tri.P0);
#endif

#if PERMUTATION_INPUT_TYPE == 1
	const uint TriangleIndex = DispatchThreadId.x;
	const FHairMeshTriangleWithUVs Tri = GetTriangleData(TriangleIndex, InputVertexPositionBuffer, InputVertexUVsBuffer, InputIndexBuffer, IndexOffset, MaxIndexCount, MaxVertexCount, MeshUVsChannelOffset, MeshUVsChannelCount);
#endif

	// Quick filter
#if 0
	//if (MeshType != REST_MESH)
	//if (MeshType != DEFORMED_MESH)
	//if (MeshType != SOURCE_MESH)
	//if (MeshType != TARGET_MESH)
	if (MeshType != SOURCE_MESH && MeshType != TARGET_MESH || SectionIndex != 0)
	{
		return;
	}
#endif

	Color.xyz *= Tri.N * 0.5f + 0.5f;

	if (bOutputInUVsSpace)
	{
		AddFilledTriangleWS(float3(Tri.UV0, 0), float3(Tri.UV1, 0), float3(Tri.UV2, 0), Color);
	}
	else
	{
		AddFilledTriangleWS(
			mul(float4(Tri.P0, 1), LocalToWorld).xyz, 
			mul(float4(Tri.P1, 1), LocalToWorld).xyz, 
			mul(float4(Tri.P2, 1), LocalToWorld).xyz,
			Color);
	}
}
