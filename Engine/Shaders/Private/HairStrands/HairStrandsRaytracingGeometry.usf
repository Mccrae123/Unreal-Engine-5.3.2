// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush" 
#include "HairStrandsClusterCommon.ush"
#include "HairStrandsVertexFactoryCommon.ush"

///////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_RT_GEOMETRY

uint VertexCount;
uint DispatchCountX;

float HairStrandsVF_HairRadius;
float HairStrandsVF_HairRootScale;
float HairStrandsVF_HairTipScale;

Buffer<float4>	 PositionOffsetBuffer;
Buffer<uint4> 	 PositionBuffer;
RWBuffer<float4> OutputPositionBuffer;

uint HairStrandsVF_bIsCullingEnable;
#if PERMUTATION_CULLING == 1
Buffer<uint>	HairStrandsVF_CullingIndirectBuffer;
Buffer<uint>	HairStrandsVF_CullingIndexBuffer;
Buffer<float>	HairStrandsVF_CullingRadiusScaleBuffer;
Buffer<uint>	HairStrandsVF_CullingIndirectBufferArgs;
#endif

#if PERMUTATION_GROUP_SIZE == 64
	#define GROUP_SIZE 64
#elif PERMUTATION_GROUP_SIZE == 32
	#define GROUP_SIZE 32
#else
	#error Unknown group size	
#endif

FHairControlPoint GetControlPoint(uint ControlPointId)
{
	FHairControlPoint Out = (FHairControlPoint)0;

	if (ControlPointId < VertexCount)
	{
		Out = UnpackHairControlPoint(
			PositionBuffer[ControlPointId],
			PositionOffsetBuffer[0].xyz,
			HairStrandsVF_HairRadius,
			HairStrandsVF_HairRootScale,
			HairStrandsVF_HairTipScale);
	}

	return Out;
}

float4 PackNormal(float3 V, uint A)
{
	return float4(clamp(V,float(-1).xxx,float(1).xxx), 1.0f);
}

void SetInvalidSegment(uint InVertexIndex)
{
	const float NaN = sqrt(-1);
	const float4 InvalidPoint = float4(NaN, NaN, NaN, NaN);

	const uint BaseOutIndex = InVertexIndex * 12;
	OutputPositionBuffer[BaseOutIndex]      = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 1]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 2]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 3]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 4]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 5]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 6]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 7]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 8]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 9]  = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 10] = InvalidPoint;
	OutputPositionBuffer[BaseOutIndex + 11] = InvalidPoint;
}

[numthreads(GROUP_SIZE, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	uint VertexIndex0 = GetHairStrandsVertexFetchIndex(DispatchThreadId, GROUP_SIZE, DispatchCountX);
	uint VertexIndex1 = VertexIndex0 + 1;
	float LodRadiusScale0 = 1;
	float LodRadiusScale1 = 1;

#if PERMUTATION_CULLING == 1
	if (HairStrandsVF_bIsCullingEnable)
	{
		const uint VertexCountAfterCulling = HairStrandsVF_CullingIndirectBuffer[3];
		uint FetchIndex0 = GetHairStrandsVertexFetchIndex_Culled(DispatchThreadId, GROUP_SIZE);
		if (FetchIndex0 >= VertexCountAfterCulling)
		{
			SetInvalidSegment(VertexIndex0);
			return;
		}
		uint FetchIndex1 = min(FetchIndex0 + 1, VertexCountAfterCulling - 1);

		VertexIndex0 = HairStrandsVF_CullingIndexBuffer[FetchIndex0];
		LodRadiusScale0 = HairStrandsVF_CullingRadiusScaleBuffer[FetchIndex0];

		VertexIndex1 = HairStrandsVF_CullingIndexBuffer[FetchIndex1];
		LodRadiusScale1 = HairStrandsVF_CullingRadiusScaleBuffer[FetchIndex1];

		if (LodRadiusScale0 <= 0.0f)
		{
			SetInvalidSegment(VertexIndex0);
			return;
		}
	}
#endif

	FHairControlPoint P0 = GetControlPoint(VertexIndex0);

	// Point at the end of a strand is filled with invalid position. The positions/triangle are 
	// ignored by DXR during BVH building
	if (P0.Type == 2)
	{
		SetInvalidSegment(VertexIndex0);
		return;
	}
}

#endif // SHADER_RT_GEOMETRY

///////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_POSITION_CHANGED

#include "../ShaderPrintCommon.ush"
#include "../ShaderDrawDebug.ush"
#include "HairStrandsAABBCommon.ush"

uint VertexCount;
uint bDrawInvalidElement;
uint DispatchCountX;
float PositionThreshold2;

uint HairStrandsVF_bIsCullingEnable;
Buffer<uint> 	 HairStrandsVF_CullingIndirectBuffer;
Buffer<uint> 	 HairStrandsVF_CullingIndexBuffer;
Buffer<uint4> 	 CurrPositionBuffer;
Buffer<uint4> 	 PrevPositionBuffer;
Buffer<int> 	 GroupAABBBuffer;
RWBuffer<uint> 	 InvalidationBuffer;
RWBuffer<uint> 	 InvalidationPrintCounter;

#define GROUP_SIZE 64
groupshared uint s_InvalidMask[GROUP_SIZE];

[numthreads(GROUP_SIZE, 1, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID, uint LinearIndex : SV_GroupIndex)
{
	// Early out: avoid full comparison if previous groom have already invalidated the frame
	const bool bIsAlreadyInvalid = InvalidationBuffer[0] > 0;
	s_InvalidMask[LinearIndex] = 0;

	if (!bIsAlreadyInvalid)
	{
		// Fetch vertex index if culling is enabled
		uint VertexIndex0 = GetHairStrandsVertexFetchIndex(DispatchThreadId, GROUP_SIZE, DispatchCountX);
		if (HairStrandsVF_bIsCullingEnable)
		{
			const uint VertexCountAfterCulling = HairStrandsVF_CullingIndirectBuffer[3];
			uint FetchIndex0 = VertexIndex0;
			if (FetchIndex0 < VertexCountAfterCulling)
			{
				VertexIndex0 = HairStrandsVF_CullingIndexBuffer[FetchIndex0];
			}
		}

		// Position comparison
		if (VertexIndex0 < VertexCount)
		{
			const FHairControlPoint Curr = UnpackHairControlPoint(CurrPositionBuffer[VertexIndex0], float3(0, 0, 0), 1, 1, 1);
			const FHairControlPoint Prev = UnpackHairControlPoint(PrevPositionBuffer[VertexIndex0], float3(0, 0, 0), 1, 1, 1);
			const float3 Diff = Curr.Position - Prev.Position;
			const bool bIsInvalid = dot(Diff, Diff) > PositionThreshold2;

			// Draw red bounding box around the groom having some changed position 
			if (bIsInvalid && bDrawInvalidElement)
			{
				uint Offset = 0;
				InterlockedAdd(InvalidationPrintCounter[0], 1, Offset);
				if (Offset < 2)
				{
					const FHairAABB Bound = ReadHairAABB(0, GroupAABBBuffer);
					AddAABB(Bound.Min, Bound.Max, ColorRed);
				}
			}
			s_InvalidMask[LinearIndex] = bIsInvalid ? 1u : 0u;
		}
	}

	// Reduction
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 32)
	{
		s_InvalidMask[LinearIndex] = s_InvalidMask[LinearIndex] | s_InvalidMask[LinearIndex + 32];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 16)
	{
		s_InvalidMask[LinearIndex] = s_InvalidMask[LinearIndex] | s_InvalidMask[LinearIndex + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	if (LinearIndex < 8)
	{
		s_InvalidMask[LinearIndex] = s_InvalidMask[LinearIndex] | s_InvalidMask[LinearIndex + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 4)
	{
		s_InvalidMask[LinearIndex] = s_InvalidMask[LinearIndex] | s_InvalidMask[LinearIndex + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 2)
	{
		s_InvalidMask[LinearIndex] = s_InvalidMask[LinearIndex] | s_InvalidMask[LinearIndex + 2];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 1)
	{
		const uint InvalidMask = s_InvalidMask[LinearIndex] | s_InvalidMask[LinearIndex + 1];
		if (InvalidMask > 0)
		{
			InterlockedOr(InvalidationBuffer[0], 1u);
		}
	}
}

#endif // SHADER_POSITION_CHANGED
