// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#define DEBUG_MODE 0

// Note: in the following functions, InLayerDepths are Layers' depths in clip space (prior to inverse Z)

bool IsDepthCloser(float a, float b)
{
	return a < b;
}

float ComputeDOMWeight(float DistanceToFrontDepth, float LayerDepth)
{
	return IsDepthCloser(DistanceToFrontDepth, LayerDepth) ? 1 : 0;
}

float4 ComputeDOMWeights(float DistanceToFrontDepth, float4 InLayerDepths)
{
	float4 Weigths = 0;
	Weigths[0] = ComputeDOMWeight(DistanceToFrontDepth, InLayerDepths[0]);
	Weigths[1] = ComputeDOMWeight(DistanceToFrontDepth, InLayerDepths[1]);
	Weigths[2] = ComputeDOMWeight(DistanceToFrontDepth, InLayerDepths[2]);
	Weigths[3] = ComputeDOMWeight(DistanceToFrontDepth, InLayerDepths[3]);
	return Weigths;
}	

float3 HairDebugColor(float DistanceToFrontDepth, float4 InLayerDepths)
{
	float3 color = 0;
	if (DistanceToFrontDepth < InLayerDepths[3]) color = float3(0, 0, 1);
	if (DistanceToFrontDepth < InLayerDepths[2]) color = float3(0, 1, 0);
	if (DistanceToFrontDepth < InLayerDepths[1]) color = float3(1, 1, 0);
	if (DistanceToFrontDepth < InLayerDepths[0]) color = float3(1,0,0);
	return color;
}

float InterpolateCount(float DepthToFrontDepth, float Layer0Depth, float Layer1Depth)
{
	return saturate((DepthToFrontDepth - Layer0Depth) / (Layer1Depth - Layer0Depth));
}

float ComputeHairCount(float4 DomValue, float DistanceToFrontDepth, float4 InLayerDepths)
{
	float OutCount = 0;
	
	if (DistanceToFrontDepth < InLayerDepths[0])
		OutCount = lerp(          0, DomValue[0], InterpolateCount(DistanceToFrontDepth, 0, InLayerDepths[0]));
	else if (DistanceToFrontDepth < InLayerDepths[1])
		OutCount = lerp(DomValue[0], DomValue[1], InterpolateCount(DistanceToFrontDepth, InLayerDepths[0], InLayerDepths[1]));
	else if (DistanceToFrontDepth < InLayerDepths[2])
		OutCount = lerp(DomValue[1], DomValue[2], InterpolateCount(DistanceToFrontDepth, InLayerDepths[1], InLayerDepths[2]));
	else if (DistanceToFrontDepth < InLayerDepths[3])
		OutCount = lerp(DomValue[2], DomValue[3], InterpolateCount(DistanceToFrontDepth, InLayerDepths[2], InLayerDepths[3]));
	else 
		OutCount = DomValue[3];
	return OutCount;
}

float GetDomDistanceToFrontDepth(float FrontDepth, float LightSpaceZ)
{
#if HAS_INVERTED_Z_BUFFER
	return max(0.0f, FrontDepth - LightSpaceZ);
#else
	return max(0.0f, LightSpaceZ - FrontDepth);
#endif
}

float GetDomDistanceToFrontDepthWithBias(float FrontDepth, float LightSpaceZ, float DepthBias)
{
#if HAS_INVERTED_Z_BUFFER
	return max(0.0f, FrontDepth - LightSpaceZ - DepthBias);
#else
	return max(0.0f, LightSpaceZ - FrontDepth - DepthBias);
#endif
}
