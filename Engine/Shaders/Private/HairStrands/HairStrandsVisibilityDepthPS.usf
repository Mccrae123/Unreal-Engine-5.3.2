// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"

#include "../SceneTexturesCommon.ush"
#include "HairStrandsDeepShadowCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "HairStrandsVisibilityCommon.ush"

#if PERMUTATION_PPLL
Texture2D<uint4> CategorisationTexture;
#else
Texture2DMS<float, HAIR_VISIBILITY_MAXSAMPLECOUNT> HairVisibilityDepthTexture;
#endif

#if PERMUTATION_COVERAGE == 1
Texture2D<float> CoverageTexture;
#endif

void MainPS(
	in FScreenVertexOutput Input,
	out float SvDepth		: SV_Depth,
	out float4  OutGBufferB	: SV_Target0,
	out float4 OutColor		: SV_Target1
)
{
#if PERMUTATION_PPLL

	const FCategorizationData CategorisationData = DecodeCategorizationData(CategorisationTexture.Load(uint3(Input.Position.xy, 0)));
	if (CategorisationData.PixelCoverage < 1.0f)
	{
		discard;
	}
	SvDepth = CategorisationData.ClosestDepth;

#else // PERMUTATION_PPLL

	// HAS_INVERTED_Z_BUFFER
	float ClosestDepth = 0;
	float FarthestDepth = 1;

	const uint2 PixelCoord = floor(Input.Position.xy);
	uint ValidSampleCount = 0;
	for (uint SampleIt=0; SampleIt<HAIR_VISIBILITY_MAXSAMPLECOUNT; ++SampleIt)
	{
		const float SampleDepth = HairVisibilityDepthTexture.Load(PixelCoord, SampleIt).x;
		FarthestDepth = min(FarthestDepth, SampleDepth);
		ClosestDepth  = max(ClosestDepth, SampleDepth);
		const bool bIsValid = SampleDepth > 0.0f;
		ValidSampleCount += bIsValid ? 1 : 0;
	}

#if PERMUTATION_COVERAGE == 1
	if (CoverageTexture.Load(uint3(PixelCoord, 0)) < 1.0f || ValidSampleCount == 0)
	{
		discard; // If coverage is 1. we skip writting depth to match all the other passes relying on coverage==1 meaning opaque.
	}
	SvDepth = ClosestDepth; // Keep closest sample (some mayb be far plane but we only want hair samples)
#else
	if (ValidSampleCount < HAIR_VISIBILITY_MAXSAMPLECOUNT)
	{
		discard; // If we do not have all samples we skip to ignore depth from far clip plane
	}
	SvDepth = FarthestDepth; // Farthest is fine to keep because all samples contains hair data
#endif

#endif // PERMUTATION_PPLL

	OutGBufferB = 0;
	OutColor = 0;
}


