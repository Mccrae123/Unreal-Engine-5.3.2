// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "HybridIndirectLighting.ush"
#include "Lumen/LumenBufferEncoding.ush"

RWTexture2D<float4> Output_SphericalHarmonic_0;
RWTexture2D<float4> Output_SphericalHarmonic_1;


[numthreads(8, 8, 1)]
void MainCS(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	uint2 TracingPixelCoord = DispatchThreadId;
	//float2 BufferUV = TracingPixelCoordToSceneBufferUV(TracingPixelCoord);
	//FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);
	
	float2 BufferUV = TracingPixelCoordToSceneBufferUV(TracingPixelCoord);
	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);

	float3 Lighting = 0;
	FTwoBandSHVectorRGB LightingSH;
	LightingSH.R = (FTwoBandSHVector)0;
	LightingSH.G = (FTwoBandSHVector)0;
	LightingSH.B = (FTwoBandSHVector)0;

	// TODO(Guillaume): Permutation to do overlapped texture fetches.
	// TODO(Guillaume): Permutation that encode directionality.
	LOOP
	for (uint PixelRayIndex = 0; PixelRayIndex < RayCountPerPixel; PixelRayIndex++)
	{
		uint2 RayStorageCoord = GetRayStorageCoords(TracingPixelCoord, PixelRayIndex);
		float3 RayHitRadiance = HitRadiance[RayStorageCoord].rgb;
		
		float3 WorldDirection = GetDiffuseWorldRayDirection(GBuffer.WorldNormal, TracingPixelCoord, PixelRayIndex);
		
		{
			float NoL = saturate(dot(GBuffer.WorldNormal, WorldDirection));
			Lighting += RayHitRadiance * NoL;
		}

		{
			FTwoBandSHVector DirectionSH = SHBasisFunction(WorldDirection);
			LightingSH = AddSH(MulSH(DirectionSH, RayHitRadiance), LightingSH);
		}
	}

	{
		float NormalizationFactor = rcp(float(RayCountPerPixel));

		Lighting *= NormalizationFactor;
		LightingSH.R = MulSH(LightingSH.R, NormalizationFactor);
		LightingSH.G = MulSH(LightingSH.G, NormalizationFactor);
		LightingSH.B = MulSH(LightingSH.B, NormalizationFactor);
	}

	//LightingOutput[TracingPixelCoord] = float4(Lighting, 1.0);

	EncodeLumenDiffuseLighting(
		LightingSH,
		/* out */ Output_SphericalHarmonic_0[TracingPixelCoord],
		/* out */ Output_SphericalHarmonic_1[TracingPixelCoord]);
}
