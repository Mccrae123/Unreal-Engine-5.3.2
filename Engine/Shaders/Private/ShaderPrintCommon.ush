/*=============================================================================
	ShaderPrintCommon.ush:
	Include this to be able to call ShaderPrint() from arbitrary shaders
=============================================================================*/

#pragma once

// Include the MiniFont symbol definitions
#include "MiniFontCommon.ush"

// --------------------------------------------------------------------------
// Uniforms and structures

// Needs to match C++ code in ShaderPrintUniform.cpp
struct FShaderPrintItem
{
	float2 ScreenPos; // Position in normalized coordinates
	int Value;        // Cast to value or symbol
	int Type;         // SHADER_PRINT_TYPE_* defines how to read Value
	float3 Color;	  // Color 
	uint Metadata;	  // Metadata (used for widget to store extra state data
};

struct FPackedShaderPrintItem
{
	uint ScreenPos16bits; // Position in normalized coordinates
	int Value;            // Cast to value or symbol
	uint TypeAndColor;    //
	uint Metadata;	      //
};

StructuredBuffer<uint> StateBuffer;
RWStructuredBuffer<FPackedShaderPrintItem> RWValuesBuffer;

// --------------------------------------------------------------------------
// Input types

// Content of FShaderPrintItem.Type defines what to cast FShaderPrintItem.Value as
#define SHADER_PRINT_TYPE_SYMBOL 0
#define SHADER_PRINT_TYPE_FLOAT  1
#define SHADER_PRINT_TYPE_INT    2
#define SHADER_PRINT_TYPE_UINT   3
#define SHADER_PRINT_TYPE_HEX    4

#define SHADER_PRINT_TYPE_SLIDER 5
#define SHADER_PRINT_TYPE_CHECK  6

#define SHADER_PRINT_COUNT_OFFSET 0
#define SHADER_PRINT_VALUE_OFFSET 1

// --------------------------------------------------------------------------
// State 
#define SHADER_PRINT_STATE_STRIDE 3
#define SHADER_PRINT_STATE_INDEX_METADATA 0
#define SHADER_PRINT_STATE_INDEX_VALUE 1
#define SHADER_PRINT_STATE_INDEX_FRAME 2

#define SHADER_PRINT_STATE_INVALID_INDEX 0xFF
#define SHADER_PRINT_STATE_HASH_MASK 0xFFFFFF

// --------------------------------------------------------------------------
// Font Color

struct FFontColor
{
	float3 Color;
};

FFontColor InitFontColor(float InX, float InY, float InZ)	{ FFontColor Out; Out.Color = float3(InX, InY, InZ); return Out; }
FFontColor InitFontColor(float3 In)							{ FFontColor Out; Out.Color = In; return Out; }
FFontColor GetDefaultFontColor()							{ FFontColor Out; Out.Color = float3(1,1,1); return Out; }

// Certain shader compiler does not support static initialization with complex type. 
// In the meantime, using define to provide default color initialization
#if 1 
#define FontWhite		InitFontColor(1, 1, 1)
#define FontBlack		InitFontColor(0, 0, 0)
#define FontRed			InitFontColor(1, 0, 0)
#define FontGreen		InitFontColor(0, 1, 0)
#define FontBlue		InitFontColor(0, 0, 1)
#define FontYellow		InitFontColor(1, 1, 0)
#define FontCyan		InitFontColor(0, 1, 1)
#define FontMagenta		InitFontColor(1, 0, 1)
#define FontOrange		InitFontColor(243.f / 255.f, 156.f / 255.f, 18.f / 255.f)
#define FontPurple		InitFontColor(169.f / 255.f, 7.f / 255.f, 228.f / 255.f)
#define FontTurquoise	InitFontColor(26.f / 255.f, 188.f / 255.f, 156.f / 255.f)
#define FontSilver		InitFontColor(189.f / 255.f, 195.f / 255.f, 199.f / 255.f)
#define FontEmerald		InitFontColor(46.f / 255.f, 204.f / 255.f, 113.f / 255.f)
#else
static const FFontColor FontWhite		= InitFontColor(1, 1, 1);
static const FFontColor FontBlack		= InitFontColor(0, 0, 0);
static const FFontColor FontRed			= InitFontColor(1, 0, 0);
static const FFontColor FontGreen		= InitFontColor(0, 1, 0);
static const FFontColor FontBlue		= InitFontColor(0, 0, 1);
static const FFontColor FontYellow		= InitFontColor(1, 1, 0);
static const FFontColor FontCyan		= InitFontColor(0, 1, 1);
static const FFontColor FontMagenta		= InitFontColor(1, 0, 1);
static const FFontColor FontOrange		= InitFontColor(243.f / 255.f, 156.f / 255.f,  18.f / 255.f);
static const FFontColor FontPurple		= InitFontColor(169.f /255.f,    7.f / 255.f, 228.f / 255.f);
static const FFontColor FontTurquoise	= InitFontColor( 26.f / 255.f, 188.f / 255.f, 156.f / 255.f);
static const FFontColor FontSilver		= InitFontColor(189.f / 255.f, 195.f / 255.f, 199.f / 255.f);
static const FFontColor FontEmerald		= InitFontColor( 46.f / 255.f, 204.f / 255.f, 113.f / 255.f);
#endif

// --------------------------------------------------------------------------
// Util pack/unpac functions

FPackedShaderPrintItem PackShaderPrintItem(FShaderPrintItem In)
{
	const uint3 Color8bits = saturate(In.Color) * 0xFF;
	const uint2 ScreenPos16bit = f32tof16(In.ScreenPos);

	FPackedShaderPrintItem Out;
	Out.ScreenPos16bits = ScreenPos16bit.x | (ScreenPos16bit.y<<16);
	Out.Value = In.Value;
	Out.TypeAndColor = (Color8bits.z << 24) | (Color8bits.y << 16) | (Color8bits.x << 8) | (In.Type & 0xFF);
	Out.Metadata = In.Metadata;
	return Out;
}

FShaderPrintItem UnpackShaderPrintItem(FPackedShaderPrintItem In)
{
	const uint2 ScreenPos16bits = uint2(In.ScreenPos16bits & 0xFFFF, (In.ScreenPos16bits>>16) & 0xFFFF);

	FShaderPrintItem Out;
	Out.ScreenPos = f16tof32(ScreenPos16bits);
	Out.Value	  = In.Value;
	Out.Type	  = (In.TypeAndColor) & 0xFF;
	Out.Color.x   = float((In.TypeAndColor >>  8) & 0xFF) / 255.f;
	Out.Color.y   = float((In.TypeAndColor >> 16) & 0xFF) / 255.f;
	Out.Color.z   = float((In.TypeAndColor >> 24) & 0xFF) / 255.f;
	Out.Metadata  = In.Metadata;
	return Out;
}

// --------------------------------------------------------------------------
// Global variables

#include "/Engine/Generated/UniformBuffers/ShaderPrintUniform.ush"

static const float2 ShaderPrintCursorStart = float2(0.05f, 0.05f);
static const float ShaderPrintTabCount = 12.f;

// 'Global' values for tracking printing state (per thread)
static float2 ShaderPrintCursorPos = ShaderPrintCursorStart;
static bool ShaderPrintFilterEnable = true;

// --------------------------------------------------------------------------
// Internal helpers

void ShaderPrint_Internal(in FShaderPrintItem Item)
{
	// If MaxValueCount is 0 then we don't reset the buffer counter so early out here
	if (ShaderPrintUniform.MaxValueCount == 0)
	{
		return;
	}

	// Buffer counter is stored in first element .Value
	int IndexToStore = 0;
	InterlockedAdd(RWValuesBuffer[SHADER_PRINT_COUNT_OFFSET].Value, 1, IndexToStore);

	// Prevent writing off the buffer
	// Note that counter still increases so need clamp when reading it in later passes
	if (IndexToStore >= ShaderPrintUniform.MaxValueCount)
	{
		return;
	}

	// Because counter is in first element, read/writes need to be offset by 1
	RWValuesBuffer[IndexToStore + SHADER_PRINT_VALUE_OFFSET] = PackShaderPrintItem(Item);
}

void ShaderPrint_Internal(in float2 ScreenPos, in int Value, in FFontColor FontColor, in int Type)
{
	FShaderPrintItem Item;
	Item.ScreenPos = ScreenPos;
	Item.Value = Value;
	Item.Type = Type;
	Item.Color = FontColor.Color;
	Item.Metadata = 0u;
	ShaderPrint_Internal(Item);
}

// --------------------------------------------------------------------------
// Symbol printing

float2 ShaderPrintSymbol(in float2 ScreenPos, in int Symbol, in FFontColor Color)
{
	if (ShaderPrintFilterEnable)
	{
		ShaderPrint_Internal(ScreenPos, Symbol, Color, SHADER_PRINT_TYPE_SYMBOL);
		ScreenPos.x += ShaderPrintUniform.FontSpacing.x;
	}
	return ScreenPos;
}

float2 ShaderPrintSymbol(in float2 ScreenPos, in int Symbol)
{
	return ShaderPrintSymbol(ScreenPos, Symbol, GetDefaultFontColor());
}

void ShaderPrintSymbol(in int symbol, in FFontColor Color)
{
	ShaderPrintCursorPos = ShaderPrintSymbol(ShaderPrintCursorPos, symbol, Color);
}

void ShaderPrintSymbol(in int symbol)
{
	ShaderPrintCursorPos = ShaderPrintSymbol(ShaderPrintCursorPos, symbol, GetDefaultFontColor());
}

// Function for reading global TEXT string. 
// The data and function are generated by the shader compiler. These functions are used to access the text data:
// - uint ShaderPrintGetChar(uint InIndex);
// - uint ShaderPrintGetOffset(uint InTextEntry);
// - uint ShaderPrintGetHash(uint InTextEntry);
GENERATED_SHADER_PRINT

// Function for reading global TEXT string
float2 ShaderPrintText(float2 Pos, uint InTextEntry, FFontColor InColor)
{
	uint Begin = ShaderPrintGetOffset(InTextEntry);
	uint End = ShaderPrintGetOffset(InTextEntry + 1);
	for (uint i = Begin; i < End; ++i)
	{
		Pos = ShaderPrintSymbol(Pos, ShaderPrintGetChar(i), InColor);
	}
	return Pos;
}
float2 ShaderPrintText(float2 Pos, uint InTextEntry) { return ShaderPrintText(Pos, InTextEntry, GetDefaultFontColor()); }

float2 ShaderPrintHelloWorld(in float2 ScreenPos)
{
	if (ShaderPrintFilterEnable)
	{
		ScreenPos = ShaderPrintSymbol(ScreenPos, _H_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _E_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _L_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _L_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _O_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _SPC_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _W_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _O_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _R_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _L_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _D_);
		ScreenPos = ShaderPrintSymbol(ScreenPos, _SPC_);
	}
	return ScreenPos;
}

void ShaderPrintHelloWorld()
{
	ShaderPrintCursorPos = ShaderPrintHelloWorld(ShaderPrintCursorPos);
}


// --------------------------------------------------------------------------
// Value printing (common value printing)

// float
float2 ShaderPrintValue(in float2 ScreenPos, in float Value, in FFontColor Color)
{
	ShaderPrint_Internal(ScreenPos, asint(Value), Color, SHADER_PRINT_TYPE_FLOAT);
	ScreenPos.x += ShaderPrintUniform.FontSpacing.x * ShaderPrintTabCount;
	return ScreenPos;
}

// int
float2 ShaderPrintValue(in float2 ScreenPos, in int Value, in FFontColor Color)
{
	ShaderPrint_Internal(ScreenPos, Value, Color, SHADER_PRINT_TYPE_INT);
	ScreenPos.x += ShaderPrintUniform.FontSpacing.x * ShaderPrintTabCount;
	return ScreenPos;
}

// uint
float2 ShaderPrintValue(in float2 ScreenPos, in uint Value, in FFontColor Color)
{
	ShaderPrint_Internal(ScreenPos, asint(Value), Color, SHADER_PRINT_TYPE_UINT);
	ScreenPos.x += ShaderPrintUniform.FontSpacing.x * ShaderPrintTabCount;
	return ScreenPos;
}

// bool
float2 ShaderPrintValue(in float2 ScreenPos, in bool Value, in FFontColor Color)
{
	ShaderPrint_Internal(ScreenPos, asint(Value ? 1u : 0u), Color, SHADER_PRINT_TYPE_UINT);
	ScreenPos.x += ShaderPrintUniform.FontSpacing.x * ShaderPrintTabCount;
	return ScreenPos;
}

// --------------------------------------------------------------------------
// Scalar type printing

#define SHADER_PRINT_OVERLOAD_1(InNumComponent, InType) \
float2 ShaderPrint(in float2 ScreenPos, in InType Value, in FFontColor Color) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		ScreenPos = ShaderPrintValue(ScreenPos, Value, Color); \
	} \
	return ScreenPos; \
} \
float2 ShaderPrint(in float2 ScreenPos, in InType Value) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		ScreenPos = ShaderPrint(ScreenPos, Value, GetDefaultFontColor()); \
	} \
	return ScreenPos; \
} \
void ShaderPrint(in InType Value, in FFontColor Color) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		ShaderPrintCursorPos = ShaderPrint(ShaderPrintCursorPos, Value, Color); \
	} \
} \
void ShaderPrint(in InType Value) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		ShaderPrintCursorPos = ShaderPrint(ShaderPrintCursorPos, Value, GetDefaultFontColor()); \
	} \
}

// --------------------------------------------------------------------------
// Vector type printing

#define SHADER_PRINT_OVERLOAD_N(InNumComponent, InType) \
float2 ShaderPrint(in float2 ScreenPos, in InType Value, in FFontColor Color) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompIt = 0; CompIt < InNumComponent; ++CompIt) \
		{ \
			ScreenPos = ShaderPrintValue(ScreenPos, Value[CompIt], Color); \
		} \
	} \
	return ScreenPos; \
} \
float2 ShaderPrint(in float2 ScreenPos, in InType Value) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompIt=0;CompIt<InNumComponent;++CompIt) \
		{ \
			ScreenPos = ShaderPrint(ScreenPos, Value[CompIt], GetDefaultFontColor()); \
		} \
	} \
	return ScreenPos; \
} \
void ShaderPrint(in InType Value, in FFontColor Color) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompIt=0;CompIt<InNumComponent;++CompIt) \
		{ \
			ShaderPrintCursorPos = ShaderPrint(ShaderPrintCursorPos, Value[CompIt], Color); \
		} \
	} \
} \
void ShaderPrint(in InType Value) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompIt=0;CompIt<InNumComponent;++CompIt) \
		{ \
			ShaderPrintCursorPos = ShaderPrint(ShaderPrintCursorPos, Value[CompIt], GetDefaultFontColor()); \
		} \
	} \
}

SHADER_PRINT_OVERLOAD_1(1, float)
SHADER_PRINT_OVERLOAD_N(2, float2)
SHADER_PRINT_OVERLOAD_N(3, float3)
SHADER_PRINT_OVERLOAD_N(4, float4)

SHADER_PRINT_OVERLOAD_1(1, uint)
SHADER_PRINT_OVERLOAD_N(2, uint2)
SHADER_PRINT_OVERLOAD_N(3, uint3)
SHADER_PRINT_OVERLOAD_N(4, uint4)

SHADER_PRINT_OVERLOAD_1(1, int)
SHADER_PRINT_OVERLOAD_N(2, int2)
SHADER_PRINT_OVERLOAD_N(3, int3)
SHADER_PRINT_OVERLOAD_N(4, int4)

SHADER_PRINT_OVERLOAD_1(1, bool)

// --------------------------------------------------------------------------
// Matrix type printing

#define SHADER_PRINT_OVERLOAD_NN(InNumComponentX, InNumComponentY, InType) \
float2 ShaderPrint(in float2 ScreenPos, in InType Value, in FFontColor Color) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompY=0;CompY<InNumComponentY;++CompY) \
		{ \
			ScreenPos = ShaderPrint(ScreenPos, Value[CompY], Color); \
			ScreenPos += float2(0.f, ShaderPrintUniform.FontSpacing.y); \
		} \
	} \
	return ScreenPos; \
} \
float2 ShaderPrint(in float2 ScreenPos, in InType Value) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompY = 0; CompY < InNumComponentY; ++CompY) \
		{ \
			ScreenPos = ShaderPrint(ScreenPos, Value[CompY], GetDefaultFontColor()); \
			ScreenPos += float2(0.f, ShaderPrintUniform.FontSpacing.y); \
		} \
	} \
	return ScreenPos; \
} \
void ShaderPrint(in InType Value, in FFontColor Color) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompY = 0; CompY < InNumComponentY; ++CompY) \
		{ \
			ShaderPrintCursorPos = ShaderPrint(ShaderPrintCursorPos, Value[CompY], Color); \
			ShaderPrintCursorPos += float2(0.f, ShaderPrintUniform.FontSpacing.y); \
		} \
	} \
} \
void ShaderPrint(in InType Value) \
{ \
	if (ShaderPrintFilterEnable) \
	{ \
		UNROLL \
		for (uint CompY = 0; CompY < InNumComponentY; ++CompY) \
		{ \
			ShaderPrintCursorPos = ShaderPrint(ShaderPrintCursorPos, Value[CompY], GetDefaultFontColor()); \
			ShaderPrintCursorPos += float2(0.f, ShaderPrintUniform.FontSpacing.y); \
		} \
	} \
	}

SHADER_PRINT_OVERLOAD_NN(3, 3, float3x3)
SHADER_PRINT_OVERLOAD_NN(4, 3, float4x3)
SHADER_PRINT_OVERLOAD_NN(4, 4, float4x4)

// --------------------------------------------------------------------------
// Formating helpers

float2 ShaderPrintSpace(in float2 ScreenPos, in float Count = 1)
{
	if (ShaderPrintFilterEnable)
	{
		ScreenPos.x += ShaderPrintUniform.FontSpacing.x * Count;
	}
	return ScreenPos;

}

void ShaderPrintSpace(in float Count = 1)
{
	ShaderPrintCursorPos = ShaderPrintSpace(ShaderPrintCursorPos, Count);
}

float2 ShaderPrintNewline(in float2 ScreenPos)
{
	if (ShaderPrintFilterEnable)
	{
		ScreenPos.x = ShaderPrintCursorStart.x;
		ScreenPos.y += ShaderPrintUniform.FontSpacing.y;
	}
	return ScreenPos;
}

void ShaderPrintNewline()
{
	ShaderPrintCursorPos = ShaderPrintNewline(ShaderPrintCursorPos);
}

float2 ShaderPrintGetCursorPos()
{
	return ShaderPrintCursorPos;
}

float2 ShaderPrintSetCursorPos(in float2 ScreenPos)
{
	float2 PrevScreenPos = ShaderPrintCursorPos;
	ShaderPrintCursorPos = ScreenPos;
	return PrevScreenPos;
}

float2 ShaderPrintGetPos(in uint2 PixelCoord)
{
	return float2(PixelCoord) / float2(ShaderPrintUniform.Resolution);
}

// --------------------------------------------------------------------------
// Filter helpers
// Use these to restrict ShaderPrint to a subset of active threads
// The filter functions can be called once at the start of the shader to filter all later printing
//
// Example use cases would be:
//
// ShaderPrintFilter(all(SvPosition.xy == float2(100, 100)));
// to debug a single pixel
//
// ShaderPrintFilter(all(DispatchThreadId == uint3(0, 0, 0)));
// to debug a single compute shader thread
//
// ShaderPrintFilterOneThread()
// to debug a single random active thread
// Note that ShaderPrintFilterOneThread() only works for one shader invocation in a view since it relies on a global memory location

void ShaderPrintFilter(bool bFilter)
{
	ShaderPrintFilterEnable = bFilter;
}

void ShaderPrintFilterOneThread()
{
	// Atomic flag is stored in first element .Type Value
	uint PrevValue;
	InterlockedCompareExchange(RWValuesBuffer[SHADER_PRINT_COUNT_OFFSET].TypeAndColor, 0, 1, PrevValue);
	ShaderPrintFilter(PrevValue == 0);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Widgets (experimental)

uint2 GetCheckboxWidgetSize()
{
	return uint(ShaderPrintUniform.FontSpacing.x * ShaderPrintUniform.Resolution.x).xx;
}

uint2 GetSliderWidgetSize()
{
	return uint2(10,1) * uint(ShaderPrintUniform.FontSpacing.x * ShaderPrintUniform.Resolution.x);
}

struct FShaderPrintContext
{
	bool bIsActive;
	float2 StartPos;
	float2 Pos;
};

FShaderPrintContext InitShaderPrintContext(bool bActive, float2 InStartPos)
{
	FShaderPrintContext Out;
	Out.bIsActive = bActive;
	Out.StartPos = InStartPos;
	Out.Pos = InStartPos;
	return Out;
}
FShaderPrintContext InitShaderPrintContext(bool bActive, uint2 InStartCoord) { return InitShaderPrintContext(bActive, float2(InStartCoord) / float2(ShaderPrintUniform.Resolution)); }

void Newline(inout FShaderPrintContext InContext)
{
	InContext.Pos.x  = InContext.StartPos.x;
	InContext.Pos.y += ShaderPrintUniform.FontSpacing.y;
}

struct FShaderPrintMetadata
{
	uint Hash;
	uint Index;
};

uint ShaderPrintPackMetadata(uint InHash, uint InIndex)
{
	return ((InIndex & 0xFFu) << 24) | (InHash & SHADER_PRINT_STATE_HASH_MASK);
}
uint ShaderPrintPackMetadata(FShaderPrintMetadata In) { return ShaderPrintPackMetadata(In.Hash, In.Index); }

FShaderPrintMetadata ShaderPrintUnpackMetadata(uint Metadata)
{
	FShaderPrintMetadata Out;
	Out.Hash = (Metadata & SHADER_PRINT_STATE_HASH_MASK);
	Out.Index= (Metadata >> 24) & 0xFF;
	return Out;
}

// Return true if found, false otherwise
bool ShaderPrintGetStateValue(in uint InHash, inout uint OutIndex, inout uint OutValue)
{
	OutIndex = SHADER_PRINT_STATE_INVALID_INDEX;
	OutValue = 0;

	// Slow linear search among all widget states
	const uint MaxCount = min(StateBuffer[0], ShaderPrintUniform.MaxStateCount);
	for (uint Index = 0; Index < MaxCount; ++Index)
	{
		const uint Index3 = Index * SHADER_PRINT_STATE_STRIDE + 1u;
		const FShaderPrintMetadata Metadata = ShaderPrintUnpackMetadata(StateBuffer[Index3 + SHADER_PRINT_STATE_INDEX_METADATA]);
		if (Metadata.Hash == InHash)
		{
			OutIndex = Metadata.Index;
			OutValue = StateBuffer[Index3 + SHADER_PRINT_STATE_INDEX_VALUE];
			return true;
		}
	}
	return false;
}

// Add a checkbox widget 
bool AddCheckbox(inout FShaderPrintContext InContext, uint InTextEntry, bool bDefault, in FFontColor InColor)
{
	uint Index = 0;
	uint RawValue = 0;
	const uint Hash = ShaderPrintGetHash(InTextEntry) & SHADER_PRINT_STATE_HASH_MASK; // Trunk hask since metadata has limited storage
	const bool bIsValid = ShaderPrintGetStateValue(Hash, Index, RawValue);
	RawValue = bIsValid ? RawValue : (bDefault ? 0x1 : 0x0);

	if (InContext.bIsActive)
	{
		const uint2 Coord = InContext.Pos * ShaderPrintUniform.Resolution;
		const uint2 Cusor = ShaderPrintUniform.CursorCoord;
		const uint2 WidgetSize = GetCheckboxWidgetSize();
		const uint2 WidgetMax = uint2(Coord.x + WidgetSize.x, Coord.y + WidgetSize.y / 2);
		const uint2 WidgetMin = uint2(Coord.x, Coord.y - WidgetSize.y / 2);
		const bool  bIsInside = all(Cusor >= WidgetMin) && all(Cusor <= WidgetMax);

		const bool bWasInside = RawValue & 0x2;

		// Update checkbox value 
		// Track if the cursor was already within the box or not
		if (bIsInside)
		{
			if (!bWasInside)
			{
				// First time the cursor is within the checkbox
				RawValue = ((RawValue & 0x1) == 1 ? 0x0 : 0x1) | 0x2;
			}
		}
		else
		{
			RawValue = (RawValue & 0x1);
		}

		FShaderPrintItem E;
		E.ScreenPos = InContext.Pos;
		E.Value = RawValue;
		E.Type = SHADER_PRINT_TYPE_CHECK;
		E.Color = bIsInside ? FontYellow.Color : FontWhite.Color;// InColor.Color;
		E.Metadata = ShaderPrintPackMetadata(Hash, Index);
		ShaderPrint_Internal(E);

		InContext.Pos.x += (WidgetSize.x * ShaderPrintUniform.Resolution.x) + ShaderPrintUniform.FontSpacing.x;

		// Text
		float2 Pos = ShaderPrintText(InContext.Pos, InTextEntry, InColor);
		InContext.Pos.x += ShaderPrintUniform.FontSpacing.x;
	}

	return RawValue & 0x1;
}

// Add a slider widget  
float AddSlider(inout FShaderPrintContext InContext, uint InTextEntry, float bDefault, in FFontColor InColor, float InMin = 0.f, float InMax = 1.f)
{
	// The value is stored as normalized, for displaying slide value correctly. This is not idealy
	// as it implies some precision lost due to back&forth conversion between normalized/non-normalized value.
	uint Index = 0;
	uint RawValue = 0;
	const uint Hash = ShaderPrintGetHash(InTextEntry) & SHADER_PRINT_STATE_HASH_MASK; // Trunk hask since metadata has limited storage
	const bool bIsValid = ShaderPrintGetStateValue(Hash, Index, RawValue);
	float NormalizedValue = bIsValid ? asfloat(RawValue) : bDefault; 
	float Value = NormalizedValue * (InMax - InMin) + InMin;

	if (InContext.bIsActive)
	{
		const uint2 Coord = InContext.Pos * ShaderPrintUniform.Resolution;
		const uint2 Cusor = ShaderPrintUniform.CursorCoord;
		const uint2 WidgetSize = GetSliderWidgetSize();
		const uint2 WidgetMax = uint2(Coord.x + WidgetSize.x, Coord.y + WidgetSize.y / 2);
		const uint2 WidgetMin = uint2(Coord.x, Coord.y - WidgetSize.y / 2);
		const bool  bIsInside = all(Cusor >= WidgetMin) && all(Cusor <= WidgetMax);

		// Update slider value
		if (bIsInside)
		{
			const float S = saturate(float(Cusor.x - WidgetMin.x) / float(WidgetMax.x - WidgetMin.x));
			Value = lerp(InMin, InMax, S);
		}

		NormalizedValue = saturate((Value - InMin) / (InMax - InMin));

		FShaderPrintItem E;
		E.ScreenPos = InContext.Pos;
		E.Value = asint(NormalizedValue);
		E.Type = SHADER_PRINT_TYPE_SLIDER;
		E.Color = bIsInside ? FontYellow.Color : FontWhite.Color; // InColor.Color;
		E.Metadata = ShaderPrintPackMetadata(Hash, Index);
		ShaderPrint_Internal(E);

		InContext.Pos.x += (WidgetSize.x * ShaderPrintUniform.Resolution.x) + ShaderPrintUniform.FontSpacing.x;

		// Text
		float2 Pos = ShaderPrintText(InContext.Pos, InTextEntry, InColor);
		InContext.Pos.x += ShaderPrintUniform.FontSpacing.x;
	}

	return Value;
}