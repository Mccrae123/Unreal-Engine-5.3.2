// Copyright Epic Games, Inc. All Rights Reserved.

#define CONFIG_RAY_STEPS 16

#define DEBUG_SSRT 0

#include "SSRTRayCast.ush"
#include "SSRTTileClassificationBuffer.ush"
#include "../HybridIndirectLighting.ush"


Texture2D FurthestHZBTexture;
Texture2D ColorTexture;

#if SUPPORTS_INDEPENDENT_SAMPLERS

#define FurthestHZBTextureSampler GlobalPointClampedSampler
#define ColorTextureSampler GlobalBilinearClampedSampler

#else

SamplerState FurthestHZBTextureSampler;
SamplerState ColorTextureSampler;

#endif

float4 HZBUvFactorAndInvFactor;
float4 ColorBufferScaleBias;
float2 ReducedColorUVMax;

float PixelPositionToFullResPixel;
float2 FullResPixelOffset;


[numthreads(8, 8, 1)]
void MainCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	uint2 TracingPixelCoord = DispatchThreadId.xy;
	uint PixelRayIndex = DispatchThreadId.z; 

	float2 BufferUV = TracingPixelCoordToSceneBufferUV(TracingPixelCoord);
	float2 ViewportUV = BufferUVToViewportUV(BufferUV);
	float2 ScreenPos = ViewportUVToScreenPos(ViewportUV);

	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);
	
	bool bOutsideViewport = any(TracingPixelCoord >= TracingViewportSize);
	bool bTraceRay = !bOutsideViewport && GBuffer.ShadingModelID != SHADINGMODELID_UNLIT && GBuffer.ShadingModelID != SHADINGMODELID_SUBSURFACE_PROFILE;
				
	// Shoot ray
	float3 Lighting;
	float HitDistance;
	float Transparency;

	BRANCH
	if (bTraceRay)
	{
		float SceneDepth = GBuffer.Depth;
		float3 N = GBuffer.WorldNormal;

		float3 PositionTranslatedWorld = mul(float4(ScreenPos * SceneDepth, SceneDepth, 1), View.ScreenToTranslatedWorld).xyz;

		float3 L = GetDiffuseWorldRayDirection(N, TracingPixelCoord, PixelRayIndex);
		
		float StepOffset = InterleavedGradientNoise(TracingPixelCoord + 0.5, View.StateFrameIndexMod8);
	
		#if !SSGI_TRACE_CONE
			StepOffset -= 0.9;
		#endif

        bool bDebugPrint = false;

		bool bRayWasClipped;
		FSSRTRay Ray = InitScreenSpaceRayFromWorldSpace(
			PositionTranslatedWorld, L,
			/* WorldTMax = */ SceneDepth,
			/* SceneDepth = */ SceneDepth,
			/* bExtendRayToScreenBorder = */ true,
			/* out */ bRayWasClipped);

		float Level;
		float3 HitUVz;
		bool bHit;
		bool bUncertain;
		float3 DebugOutput;
		CastScreenSpaceRay(
			FurthestHZBTexture, FurthestHZBTextureSampler,
			/* StartMipLevel = */ 1.0,
			CreateDefaultCastSettings(),
			Ray, 1, CONFIG_RAY_STEPS, StepOffset,
			HZBUvFactorAndInvFactor, bDebugPrint,
			/* out */ DebugOutput,
			/* out */ HitUVz,
			/* out */ Level,
			/* out */ bHit,
			/* out */ bUncertain);

		#if 1 // Backface check
		if (bHit)
		{
			float3 SampleNormal = GetGBufferDataFromSceneTextures(HitUVz.xy).WorldNormal;
			bHit = dot(SampleNormal, L) < 0;
		}
		#endif
			
		// if there was a hit
		BRANCH
		if (bHit)
		{
			float2 ReducedColorUV =  HitUVz.xy * ColorBufferScaleBias.xy + ColorBufferScaleBias.zw;
			ReducedColorUV = min(ReducedColorUV, ReducedColorUVMax);

			Lighting = ColorTexture.SampleLevel(ColorTextureSampler, ReducedColorUV, Level).rgb;
			HitDistance = -1.0;
			Transparency = 0.0;
		}
		else
		{
			Lighting = 0.0;
			HitDistance = sqrt(ComputeRayHitSqrDistance(PositionTranslatedWorld, HitUVz));
			Transparency = 1.0;
		}
	}
	else // if (!bTraceRay)
	{
		Lighting = 0.0;
		HitDistance = -1.0;
		Transparency = 1.0;
	}
	
	// To compensate for Lumen's SampleWeight = 2.0f * PI, with PI getting cancelled out by the Diffuse_Lambert().
	Lighting *= 0.5;
	
	// Uncomment me to disable SSGI
	//if (View.GeneralPurposeTweak > 0.5)
	//{
	//	Lighting = 0.0;
	//	HitDistance = -1.0;
	//	Transparency = 1.0;
	//}

	uint2 RayStorageCoord = GetRayStorageCoords(TracingPixelCoord, PixelRayIndex);

	if (!bOutsideViewport)
	{
		HitDistanceOutput[RayStorageCoord] = HitDistance;
		HitRadianceOutput[RayStorageCoord] = float4(Lighting, Transparency);
	}
} // MainCS()
