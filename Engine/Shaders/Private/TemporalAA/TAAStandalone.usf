// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../Random.ush"
#include "../EyeAdaptationCommon.ush"
#include "../TextureSampling.ush"

//------------------------------------------------------- COMPILER CONFIG   

// Generate vector truncation warnings to errors.
#pragma warning(error: 3206)


//------------------------------------------------------- ENUM VALUES

/** Payload of the history. History might still have addtional TAA internals. */
	// Only have RGB.
	#define HISTORY_PAYLOAD_RGB 0
	
	// Have RGB and translucency in alpha.
	#define HISTORY_PAYLOAD_RGB_TRANSLUCENCY 1
	
	// Have RGB and opacity in alpha.
	#define HISTORY_PAYLOAD_RGB_OPACITY (HISTORY_PAYLOAD_RGB_TRANSLUCENCY)
	
	// Have RGB and DOF's CocRadius in alpha.
	#define HISTORY_PAYLOAD_RGB_COC 2
	
	// Have RGB, opacity in alpha and DOF's CocRadius in separate's Red.
	#define HISTORY_PAYLOAD_RGB_OPACITY_COC 3
	

/** Caching method for scene color. */
	// Disable any in code cache.
	#define AA_SAMPLE_CACHE_METHOD_DISABLE 0
	
	// Caches 3x3 Neighborhood into VGPR (although my have corner optimised away).
	#define AA_SAMPLE_CACHE_METHOD_VGPR_3X3 1
	

/** Clamping method for scene color. */
	// Min max neighboorhing samples.
	#define HISTORY_CLAMPING_BOX_MIN_MAX 0
	
	// Variance computed from neighboorhing samples.
	#define HISTORY_CLAMPING_BOX_VARIANCE 1

	// Min max samples that are within distance from output pixel. 
	#define HISTORY_CLAMPING_BOX_SAMPLE_DISTANCE 2


//------------------------------------------------------- CONFIGS

// Compute shaders always do responsive TAA in a single pass.
#if COMPUTESHADER
	#define AA_SINGLE_PASS_RESPONSIVE 1
#endif

#if TAA_PASS_CONFIG == 0 // Main
	#if POST_PROCESS_ALPHA
		#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB_TRANSLUCENCY)
	#else
		#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB)
	#endif
	#define AA_BICUBIC 1
	#define AA_BORDER 1
	#define AA_CROSS 2
	#define AA_DYNAMIC 1
	#define AA_FILTERED 1
	#define AA_MANUALLY_CLAMP_HISTORY_UV 1
	#define AA_TONE 1
	#define AA_YCOCG 1

	#if !TAA_FAST
		#define AA_DYNAMIC_ANTIGHOST 1
	#endif

#elif TAA_PASS_CONFIG == 3 // Used for SSR
	#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB_OPACITY)
	#define AA_DYNAMIC 1
	#define AA_FILTERED 1
	#define AA_LERP 8
	#define AA_MANUALLY_CLAMP_HISTORY_UV 1
	#define AA_YCOCG 1
	#define AA_BORDER 1

#elif TAA_PASS_CONFIG == 4 // Used for LightShaft
	#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB_OPACITY)
	#define AA_FILTERED 1
	#define AA_LERP 64
	#define AA_MANUALLY_CLAMP_HISTORY_UV 1
	#define AA_YCOCG 1
	#define AA_LOWER_RESOLUTION 1
	#define AA_BORDER 1

#elif TAA_PASS_CONFIG == 1 || TAA_PASS_CONFIG == 2 // MainUpsampling & MainSuperSampling
	#if POST_PROCESS_ALPHA
		#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB_TRANSLUCENCY)
	#else
		#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB)
	#endif
	#define AA_BICUBIC 1
	#define AA_BORDER 2
	#define AA_CROSS 1
	#define AA_DYNAMIC 1
	#define AA_FILTERED TAA_UPSAMPLE_FILTERED
	#define AA_MANUALLY_CLAMP_HISTORY_UV 1
	#define AA_TONE 1
	#if SWITCH_PROFILE || SWITCH_PROFILE_FORWARD
		#define AA_YCOCG 0
	#else
		#define AA_YCOCG 1
	#endif
	
	#define AA_UPSAMPLE 1
	#define AA_UPSAMPLE_ADAPTIVE_FILTERING 1
	
	#if TAA_FAST
		// When doing TAA downsampling, still need the 9 samples.
		#if AA_DOWNSAMPLE
			#define AA_SAMPLES 9
		#else
			#if SWITCH_PROFILE || SWITCH_PROFILE_FORWARD
				#define AA_SAMPLES 5
			#else
				#define AA_SAMPLES 6
			#endif
		#endif

	#else
		//#define AA_HISTORY_CLAMPING_BOX (HISTORY_CLAMPING_BOX_SAMPLE_DISTANCE)
		#define AA_ANTIFLICKER 1
		#define AA_DYNAMIC_ANTIGHOST 1
		#define AA_SAMPLES 6

	#endif

	#if !COMPUTESHADER
		#error "Upsampling is only available for CS because of the resceponsive stencil bit."
	#endif
	
#elif TAA_PASS_CONFIG == 5 || TAA_PASS_CONFIG == 6 // Used for diaphragm DOF pre-filtering.
	#if POST_PROCESS_ALPHA
		#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB_OPACITY_COC)
	#else
		#define AA_HISTORY_PAYLOAD (HISTORY_PAYLOAD_RGB_COC)
	#endif
	#define AA_CROSS 4 // because running at half res.
	#define AA_DYNAMIC 1
	#define AA_FORCE_ALPHA_CLAMP 1
	#define AA_MANUALLY_CLAMP_HISTORY_UV 1
	#define AA_LOWER_RESOLUTION 1

	#if TAA_PASS_CONFIG == 6
		#define AA_BORDER 2
		#define AA_UPSAMPLE 1
		#define AA_UPSAMPLE_ADAPTIVE_FILTERING 1
	#else
		#define AA_BORDER 1
		#define AA_UPSAMPLE 0
	#endif
	
	#if !TAA_FAST
		#define AA_BICUBIC 1
		#define AA_FILTERED 1
		#define AA_YCOCG 1
	#elif AA_UPSAMPLE
		#define AA_BICUBIC 1
		#define AA_FILTERED 1
	#endif
	
#else
	#error Unknown TAA pass config. Have you changed ETAAPassConfig without updating me?

#endif

#if TAA_SCREEN_PERCENTAGE_RANGE == 2
	#define AA_DOWNSAMPLE 1
#else
	#define AA_DOWNSAMPLE 0
#endif


//------------------------------------------------------- CONFIG DISABLED DEFAULTS

// Num samples of current frame
#ifndef AA_SAMPLES
	#define AA_SAMPLES 5
#endif

// 1 = Use tighter AABB clamp for history.
// 0 = Use simple min/max clamp.
#ifndef AA_CLIP
	#define AA_CLIP 0
#endif

// Cross distance in pixels used in depth search X pattern.
// 0 = Turn this feature off.
// 2 = Is required for standard temporal AA pass.
#ifndef AA_CROSS
	#define AA_CROSS 0
#endif

// 1 = Use dynamic motion.
// 0 = Skip dynamic motion, currently required for half resolution passes.
#ifndef AA_DYNAMIC
	#define AA_DYNAMIC 0
#endif

// 0 = Dynamic motion based lerp value (default).
// non-zero = Use 1/LERP fixed lerp value (used for reflections).
#ifndef AA_LERP
	#define AA_LERP 0
#endif

// Fix for lack of borders during current frame filter.
#ifndef AA_BORDER
	#define AA_BORDER 0
#endif

// Force clamp on alpha.
#ifndef AA_FORCE_ALPHA_CLAMP
	#define AA_FORCE_ALPHA_CLAMP 0
#endif

// Use YCoCg path.
#ifndef AA_YCOCG
	#define AA_YCOCG 0
#endif

// Bicubic filter history
#ifndef AA_BICUBIC
	#define AA_BICUBIC 0
#endif

// Tone map to kill fireflies
#ifndef AA_TONE
	#define AA_TONE 0
#endif

// Antighosting using dynamic mask
#ifndef AA_DYNAMIC_ANTIGHOST
	#define AA_DYNAMIC_ANTIGHOST 0
#endif

// Sample the stencil buffer inline rather than multiple masked passes.
#ifndef AA_SINGLE_PASS_RESPONSIVE
	#define AA_SINGLE_PASS_RESPONSIVE	0
#endif

// Upsample the output.
#ifndef AA_UPSAMPLE
	#define AA_UPSAMPLE 0
#endif

// Method used for generating the history clamping box.
#ifndef AA_HISTORY_CLAMPING_BOX
	#define AA_HISTORY_CLAMPING_BOX (HISTORY_CLAMPING_BOX_MIN_MAX)
#endif

// Change the upsampling filter size when history is rejected that reduce blocky output pixels.
#ifndef AA_UPSAMPLE_ADAPTIVE_FILTERING
	#define AA_UPSAMPLE_ADAPTIVE_FILTERING 0
#endif

// Whether this pass run at lower resolution than main view rectangle.
#ifndef AA_LOWER_RESOLUTION
	#define AA_LOWER_RESOLUTION 0
#endif

// Whether the history buffer UV should be manually clamped.
#ifndef AA_MANUALLY_CLAMP_HISTORY_UV
	#define AA_MANUALLY_CLAMP_HISTORY_UV 0
#endif

#ifndef AA_ANTIFLICKER
	#define AA_ANTIFLICKER 0
#endif


//------------------------------------------------------- CONFIG ENABLED DEFAULTS

// Always enable scene color filtering
// 1 = Use filtered sample.
// 0 = Use center sample.
#ifndef AA_FILTERED
	#define AA_FILTERED 1
#endif

// Always enable AA_NAN to avoid all NAN in all TAA pass that is more convenient considering the amount of / 0 we can have.
// 0 = Don't use.
// 1 = Use extra clamp to avoid NANs
#ifndef AA_NAN
	#define AA_NAN 1
#endif

// Neighborhood clamping. Disable for testing reprojection. Always enabled, well because TAA is totally broken otherwise.
#ifndef AA_CLAMP
	#define AA_CLAMP 1
#endif

// By default, always cache neighbooring samples into VGPR.
#ifndef AA_SAMPLE_CACHE_METHOD
	#define AA_SAMPLE_CACHE_METHOD (AA_SAMPLE_CACHE_METHOD_VGPR_3X3)
#endif


//------------------------------------------------------- MENDATORY CONFIG

#ifndef AA_HISTORY_PAYLOAD
	#error You forgot to defines the history payload.
#endif


//------------------------------------------------------- DERIVES

// Defines number of component in history payload.
#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB
	#define HISTORY_PAYLOAD_COMPONENTS 3
#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
	#define HISTORY_PAYLOAD_COMPONENTS 5
#else
	#define HISTORY_PAYLOAD_COMPONENTS 4
#endif

// Defines the number of render target input to TAA.
#if HISTORY_PAYLOAD_COMPONENTS > 4
	#define INPUT_RENDER_TARGETS 2
#else
	#define INPUT_RENDER_TARGETS 1
#endif

// Defines the number of render target to store TAA's history.
#if 1
	#define HISTORY_RENDER_TARGETS (INPUT_RENDER_TARGETS)
#endif


//------------------------------------------------------- CONFIG CHECKS

#if AA_SAMPLES != 9 && AA_SAMPLES != 5 && AA_SAMPLES != 6
	#error Samples must be 5, (6 for TAAU) or 9
#endif


//------------------------------------------------------- CONSTANTS

// K = Center of the nearest input pixel.
// O = Center of the output pixel.
//
//          |           |
//    0     |     1     |     2
//          |           |
//          |           |
//  --------+-----------+--------
//          |           |
//          | O         |
//    3     |     K     |     5
//          |           |
//          |           |
//  --------+-----------+--------
//          |           |
//          |           |
//    6     |     7     |     8
//          |           |
//
static const int2 kOffsets3x3[9] =
{
	int2(-1, -1),
	int2( 0, -1),
	int2( 1, -1),
	int2(-1,  0),
	int2( 0,  0), // K
	int2( 1,  0),
	int2(-1,  1),
	int2( 0,  1),
	int2( 1,  1),
};
	
// Indexes of the 3x3 square.
static const uint kSquareIndexes3x3[9] = { 4, 0, 1, 2, 3, 5, 6, 7, 8 };

// Indexes of the offsets to have plus + shape.
static const uint kPlusIndexes3x3[5] = { 4, 1, 3, 5, 7 };

#if AA_UPSAMPLE
	// T = Center of the nearest top left pixel input pixel.
	// O = Center of the output pixel.
	//
	//          | 
	//    T     |     .
	//          | 
	//       O  | 
	//  --------+--------
	//          | 
	//          | 
	//    .     |     .
	//          | 
	static const int2 Offsets2x2[4] =
	{
		int2( 0,  0), // T
		int2( 1,  0),
		int2( 0,  1),
		int2( 1,  1),
	};
		
	// Indexes of the 2x2 square.
	static const uint SquareIndexes2x2[4] = { 0, 1, 2, 3 };

#endif // AA_UPSAMPLE


//------------------------------------------------------- PARAMETERS

float HistoryPreExposureCorrection;
float CurrentFrameWeight;
int bCameraCut;

float SampleWeights[9];
float PlusWeights[5];

float4 ViewportUVToInputBufferUV;
float4 MaxViewportUVAndSvPositionToViewportUV;

float2 ScreenPosAbsMax;
float4 ScreenPosToHistoryBufferUV;

float4 InputSceneColorSize;
int2 InputMinPixelCoord;
int2 InputMaxPixelCoord;
Texture2D<half4> InputSceneColor;
Texture2D<half4> InputSceneMetadata;

Texture2D<half4> SceneDepthBuffer;

Texture2D SceneVelocityBuffer;
SamplerState SceneVelocityBufferSampler;

Texture2D<uint2> StencilTexture;

Texture2D<half4> HistoryBuffer_0;
Texture2D<half4> HistoryBuffer_1;
Texture2D<half4> HistoryBuffer_2;
Texture2D<half4> HistoryBuffer_3;
SamplerState HistoryBufferSampler_0;
SamplerState HistoryBufferSampler_1;
SamplerState HistoryBufferSampler_2;
SamplerState HistoryBufferSampler_3;
float4 HistoryBufferSize;
float4 HistoryBufferUVMinMax;

float4 OutputViewportSize;
float4 OutputViewportRect; // TODO:Reverb: int

RWTexture2D<half4> OutComputeTex_0;
RWTexture2D<half4> OutComputeTex_1;
RWTexture2D<half4> OutComputeTex_2;
RWTexture2D<half4> OutComputeTex_3;

RWTexture2D<float4> DebugOutput;

#if TAA_DOWNSAMPLE 
// This shader permutation outputs half resolution image in addition to main full-res one.
// It is more efficient than performing a separate downsampling pass afterwards.
RWTexture2D<half4> OutComputeTexDownsampled;
groupshared half4 GroupSharedDownsampleArray[THREADGROUP_SIZEX*THREADGROUP_SIZEY]; // TODO: share this with GroupSharedArrayF4 when possible
#endif // TAA_DOWNSAMPLE

// Temporal upsample specific params.
#if AA_UPSAMPLE

float2 InputViewMin;
float4 InputViewSize;

// Temporal jitter at the pixel scale.
float2 TemporalJitterPixels;

float ScreenPercentage;
float UpscaleFactor; // = 1 / ScreenPercentage

#endif // AA_UPSAMPLE


//------------------------------------------------------- FUNCTIONS

half3 RGBToYCoCg(half3 RGB )
{
	half Y  = dot( RGB, half3(  1, 2,  1 ) );
	half Co = dot( RGB, half3(  2, 0, -2 ) );
	half Cg = dot( RGB, half3( -1, 2, -1 ) );
	
	half3 YCoCg = half3( Y, Co, Cg );
	return YCoCg;
}

half3 YCoCgToRGB(half3 YCoCg )
{
	half Y  = YCoCg.x * 0.25;
	half Co = YCoCg.y * 0.25;
	half Cg = YCoCg.z * 0.25;

	half R = Y + Co - Cg;
	half G = Y + Cg;
	half B = Y - Co - Cg;

	half3 RGB = half3( R, G, B );
	return RGB;
}

// Faster but less accurate luma computation. 
// Luma includes a scaling by 4.
half Luma4(half3 Color)
{
	return (Color.g * half(2.0)) + (Color.r + Color.b);
}

// Optimized HDR weighting function.
half HdrWeight4(half3 Color, half Exposure)
{
	return rcp(Luma4(Color * Exposure) + half(4.0));
}

half HdrWeightY(half Color, half Exposure)
{
	return rcp(Color * Exposure + half(4.0));
}

// Intersect ray with AABB, knowing there is an intersection.
//   Dir = Ray direction.
//   Org = Start of the ray.
//   Box = Box is at {0,0,0} with this size.
// Returns distance on line segment.
half IntersectAABB(half3 Dir, half3 Org, half3 Box)
{
	#if PS4_PROFILE
		// This causes flicker, it should only be used on PS4 until proper fix is in.
		if(min(min(abs(Dir.x), abs(Dir.y)), abs(Dir.z)) < half3(1.0/65536.0)) return 1.0;
	#endif
	half3 RcpDir = rcp(Dir);
	half3 TNeg = (  Box  - Org) * RcpDir;
	half3 TPos = ((-Box) - Org) * RcpDir;
	return max(max(min(TNeg.x, TPos.x), min(TNeg.y, TPos.y)), min(TNeg.z, TPos.z));
}

half HistoryClip(half3 History, half3 Filtered, half3 NeighborMin, half3 NeighborMax)
{
#if 0
	half3 Min = min(Filtered, min(NeighborMin, NeighborMax));
	half3 Max = max(Filtered, max(NeighborMin, NeighborMax));	
	half3 Avg2 = Max + Min;
	half3 Dir = Filtered - History;
	half3 Org = History - Avg2 * half(0.5);
	half3 Scale = Max - Avg2 * half(0.5);
	return saturate(IntersectAABB(Dir, Org, Scale));
#else
	half3 BoxMin = NeighborMin;
	half3 BoxMax = NeighborMax;
	//half3 BoxMin = min( Filtered, NeighborMin );
	//half3 BoxMax = max( Filtered, NeighborMax );

	half3 RayOrigin = History;
	half3 RayDir = Filtered - History;
	RayDir.x = abs(RayDir.x) < half(1.0 / 65536.0) ? half(1.0 / 65536.0) : RayDir.x;
	RayDir.y = abs(RayDir.y) < half(1.0 / 65536.0) ? half(1.0 / 65536.0) : RayDir.y;
	RayDir.z = abs(RayDir.z) < half(1.0 / 65536.0) ? half(1.0 / 65536.0) : RayDir.z;
	half3 InvRayDir = rcp( RayDir );

	half3 MinIntersect = (BoxMin - RayOrigin) * InvRayDir;
	half3 MaxIntersect = (BoxMax - RayOrigin) * InvRayDir;
	half3 EnterIntersect = min( MinIntersect, MaxIntersect );
	return max3( EnterIntersect.x, EnterIntersect.y, EnterIntersect.z );
#endif
}

half2 WeightedLerpFactors(half WeightA, half WeightB, half Blend)
{
	half BlendA = (half(1.0) - Blend) * WeightA;
	half BlendB =        Blend  * WeightB;
	half RcpBlend = rcp(BlendA + BlendB);
	BlendA *= RcpBlend;
	BlendB *= RcpBlend;
	return half2(BlendA, BlendB);
}

#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC || AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC

// Computes the bilateral weight according to two Coc radii.
half ComputeBilateralWeight(half RefCocRadius, half SampleCocRadius)
{
	half Factor = (abs(RefCocRadius) > 1 ? rcp(abs(RefCocRadius)) : 1.0);
	return saturate(1 - abs(RefCocRadius - SampleCocRadius) * Factor);
}

half ComputeNeightborSampleBilateralWeight(half CenterCocRadius, half SampleCocRadius)
{
	half Factor = (abs(CenterCocRadius) > 1 ? rcp(abs(CenterCocRadius)) : 1.0);
	return saturate(1 - (CenterCocRadius - SampleCocRadius) * Factor);
}


#endif


//------------------------------------------------------- TAA's PAYLOAD

// Payload of the TAA's history.
struct FTAAPayload
{
	// Transformed scene color and alpha channel.
	half4 Color;

	// Radius of the circle of confusion for DOF.
	half CocRadius;
};

FTAAPayload MulPayload(in FTAAPayload Payload, in half x)
{
	Payload.Color *= x;
	Payload.CocRadius *= x;
	return Payload;
}

FTAAPayload AddPayload(in FTAAPayload Payload0, in FTAAPayload Payload1)
{
	Payload0.Color += Payload1.Color;
	Payload0.CocRadius += Payload1.CocRadius;
	return Payload0;
}

FTAAPayload MinPayload(in FTAAPayload Payload0, in FTAAPayload Payload1)
{
	Payload0.Color = min(Payload0.Color, Payload1.Color);
	Payload0.CocRadius = min(Payload0.CocRadius, Payload1.CocRadius);
	return Payload0;
}

FTAAPayload MaxPayload(in FTAAPayload Payload0, in FTAAPayload Payload1)
{
	Payload0.Color = max(Payload0.Color, Payload1.Color);
	Payload0.CocRadius = max(Payload0.CocRadius, Payload1.CocRadius);
	return Payload0;
}

FTAAPayload MinPayload3(in FTAAPayload Payload0, in FTAAPayload Payload1, in FTAAPayload Payload2)
{
	Payload0.Color = min3(Payload0.Color, Payload1.Color, Payload2.Color);
	Payload0.CocRadius = min3(Payload0.CocRadius, Payload1.CocRadius, Payload2.CocRadius);
	return Payload0;
}

FTAAPayload MaxPayload3(in FTAAPayload Payload0, in FTAAPayload Payload1, in FTAAPayload Payload2)
{
	Payload0.Color = max3(Payload0.Color, Payload1.Color, Payload2.Color);
	Payload0.CocRadius = max3(Payload0.CocRadius, Payload1.CocRadius, Payload2.CocRadius);
	return Payload0;
}


//------------------------------------------------------- TAA INTERMEDIARY STRUCTURES

// Output pixel parameters. Should not be modified once setup.
struct FTAAInputParameters
{
	// Viewport UV of the output pixel.
	float2 ViewportUV;

	// Position of the output pixel on screen.
	float2 ScreenPos;

	// Buffer UV of the nearest input pixel.
	float2 NearestBufferUV;
	
	// Whether this pixel should be responsive.
	bool bIsResponsiveAAPixel;

	// Frame exposure's scale.
	half FrameExposureScale;
	
	// Cache of neightbors' transformed scene color.
	#if AA_SAMPLE_CACHE_METHOD == AA_SAMPLE_CACHE_METHOD_VGPR_3X3
		half4 CachedNeighbors0[AA_SAMPLES];

		#if INPUT_RENDER_TARGETS == 2
			half CachedNeighbors1[AA_SAMPLES];
		#endif
	#endif
};

struct FTAAHistoryInformation
{
	bool bIsDynamicPixel;
};

FTAAHistoryInformation CreateHistoryInformation()
{
	FTAAHistoryInformation HistoryInfo;
	HistoryInfo.bIsDynamicPixel = false;
	return HistoryInfo;
}


// Intermediary results for major function to conveniently share values between them.
//
// it is allowed to passdown this guy to major function with still unitialized variables.
struct FTAAIntermediaryResult
{
	// The filtered input.
	FTAAPayload Filtered;

	// Temporal weight of the filtered input.
	half FilteredTemporalWeight;

	// 1 / filtering kernel scale factor for AA_UPSAMPLE_ADAPTIVE_FILTERING.
	half InvFilterScaleFactor;
};


// Create intermediary result.
FTAAIntermediaryResult CreateIntermediaryResult()
{
	// Disable warning X4008: floating point division by zero
	#pragma warning(disable:4008)
	FTAAIntermediaryResult IntermediaryResult = (FTAAIntermediaryResult) (1.0 / 0.0);
	#pragma warning(default:4008)

	IntermediaryResult.FilteredTemporalWeight = 1;
	IntermediaryResult.InvFilterScaleFactor = 1;
	return IntermediaryResult;
}


// Transformed scene color's data for a sample.
struct FTAASceneColorSample
{
	// Payload of the sample.
	FTAAPayload Payload;

	// HDR weight of the scene color sample.
	half HdrWeight;

	// Pixel offset of the sample
	int2 SampleOffset;
};


//------------------------------------------------------- SCENE COLOR SPACE MANAGMENT

// Transform RAW linear scene color RGB to TAA's working color space.
half4 TransformSceneColor(half4 RawLinearSceneColorRGBA)
{
	#if AA_YCOCG
		return half4(RGBToYCoCg(RawLinearSceneColorRGBA.rgb), RawLinearSceneColorRGBA.a);
	#endif
	return RawLinearSceneColorRGBA;
}

// Reciprocal of TransformSceneColor().
half4 TransformBackToRawLinearSceneColor(half4 SceneColor)
{
	#if AA_YCOCG
		return half4(YCoCgToRGB(SceneColor.xyz), SceneColor.a);
	#endif
	return SceneColor;
}

// Transform current frame's RAW scene color RGB to TAA's working color space.
half4 TransformCurrentFrameSceneColor(half4 RawSceneColorRGBA)
{
	// This min is to avoid large values causing NaN/black pixels resulting in bloom flickering on the sun due to half values and high pixel luminance.
	// It is safe to clamp this way here because SceneColor in Unreal is always pre-exposed. We can accumulate up to 9 samples so MaxHalfFloat/9 ~= 7000.
	half4 SafeRawSceneColorRGBA = min(RawSceneColorRGBA, half4(7000.0f, 7000.0f, 7000.0f, 7000.0f));
	return TransformSceneColor(SafeRawSceneColorRGBA);
}

// Get the Luma4 of the sceneColor
half GetSceneColorLuma4(half4 SceneColor)
{
	#if AA_YCOCG
		return SceneColor.x;
	#endif
	return Luma4(SceneColor.rgb);
}

// Get the HDR weight of the transform scene color.
half GetSceneColorHdrWeight(
	in FTAAInputParameters InputParams,
	half4 SceneColor)
{
	#if AA_YCOCG
		return HdrWeightY(SceneColor.x, InputParams.FrameExposureScale);
	#endif
	return HdrWeight4(SceneColor.rgb, InputParams.FrameExposureScale);
}

int2 GetNeighborSampleOffset(in FTAAInputParameters InputParams, uint NeighborId)
{
	#if AA_UPSAMPLE
		// Pixel coordinate of the center of output pixel O in the input viewport.
		float2 PPCo = InputParams.ViewportUV * InputViewSize.xy + TemporalJitterPixels;

		// Pixel coordinate of the center of the nearest input pixel K.
		float2 PPCk = floor(PPCo) + 0.5;
		
		// Vector in pixel between pixel K -> O.
		half2 dKO = half2(PPCo - PPCk);
	#endif

	#if AA_SAMPLES == 9
		const uint SampleIndexes[9] = kSquareIndexes3x3;
	#elif AA_SAMPLES == 5 || AA_SAMPLES == 6
		const uint SampleIndexes[5] = kPlusIndexes3x3;
	#endif

	// Get the sample offset from the nearest input pixel.
	int2 SampleOffset;
			
	#if AA_UPSAMPLE && AA_SAMPLES == 6
	if (NeighborId == 5)
	{
		SampleOffset = SignFastInt(dKO);
	}
	else
	#endif
	{
		const uint SampleIndex = SampleIndexes[NeighborId];
		SampleOffset = kOffsets3x3[SampleIndex];
	}

	return SampleOffset;
}


//------------------------------------------------------- INPUT SAMPLE CACHING.
// API to sample input scene color and depth through caching system.
// 
// Precache scene color or depth:
//		PrecacheInputSceneColor(InputParams);
//
// Then sample scene color or depth:
//		SampleCachedSceneColorTexture(InputParams, /* Offset = */ int2(-1, -1));
//
//		<Offset> parameter is meant to be compile time constant of the pixel offset from nearest input sample.

#if AA_SAMPLE_CACHE_METHOD == AA_SAMPLE_CACHE_METHOD_VGPR_3X3
//------------------------------------------------------- 3x3 NEIGHTBORS CACHING

	#define AA_PRECACHE_SCENE_COLOR 1
	
	ISOLATE
	void PrecacheInputSceneColor(inout FTAAInputParameters InputParams)
	{
		// Precache 3x3 input scene color into FTAAInputParameters::CachedNeighbors.
		UNROLL_N(AA_SAMPLES)
		for (uint NeighborId = 0; NeighborId < AA_SAMPLES; NeighborId++)
		{
			int2 SampleOffset = GetNeighborSampleOffset(InputParams, NeighborId);

			int2 Coord = int2(InputParams.NearestBufferUV * InputSceneColorSize.xy) + SampleOffset;

			#if AA_BORDER == 2
				Coord = clamp(Coord, InputMinPixelCoord, InputMaxPixelCoord);
			#endif

			InputParams.CachedNeighbors0[NeighborId] = TransformCurrentFrameSceneColor(InputSceneColor[Coord]);
	
			#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
				InputParams.CachedNeighbors1[NeighborId] = InputSceneMetadata[Coord].r;
			#endif
		}
	}

	FTAASceneColorSample SampleCachedSceneColorTexture(in FTAAInputParameters InputParams, uint NeighborId)
	{
		FTAASceneColorSample Sample;
		Sample.SampleOffset = GetNeighborSampleOffset(InputParams, NeighborId);

		Sample.Payload.Color = InputParams.CachedNeighbors0[NeighborId];
		Sample.Payload.CocRadius = 0;
		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC
			Sample.Payload.CocRadius = Sample.Payload.Color.a;
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
			Sample.Payload.CocRadius = InputParams.CachedNeighbors1[NeighborId];
		#endif

		Sample.HdrWeight = GetSceneColorHdrWeight(InputParams, Sample.Payload.Color);
		return Sample;
	}

#else // AA_SAMPLE_CACHE_METHOD != AA_SAMPLE_CACHE_METHOD_VGPR_3X3

	// Silently do no scene color precaching.
	void PrecacheInputSceneColor(in FTAAInputParameters InputParams)
	{ }


	// Sample and transform scene color.
	FTAASceneColorSample SampleCachedSceneColorTexture(in FTAAInputParameters InputParams, uint NeighborId)
	{
		FTAASceneColorSample Sample;
		Sample.SampleOffset = GetNeighborSampleOffset(InputParams, NeighborId);

		int2 Coord = int2(InputParams.NearestBufferUV * InputSceneColorSize.xy) + Sample.SampleOffset;
		
		#if AA_BORDER == 2
			Coord = clamp(Coord, InputMinPixelCoord, InputMaxPixelCoord);
		#endif

		Sample.Payload.Color = TransformCurrentFrameSceneColor(InputSceneColor[Coord]);
		Sample.Payload.CocRadius = 0;
		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC
			Sample.Payload.CocRadius = Sample.Color.a;
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
			Sample.Payload.CocRadius = InputSceneMetadata[Coord].r;
		#endif

		Sample.HdrWeight = GetSceneColorHdrWeight(InputParams, Sample.Payload.Color);
		return Sample;
	}

#endif // AA_SAMPLE_CACHE_METHOD != AA_SAMPLE_CACHE_METHOD_VGPR_3X3

// Sample depth.
half SampleSceneDepthTexture(in FTAAInputParameters InputParams, int2 PixelOffset)
{
	int2 Coord = int2(InputParams.NearestBufferUV * InputSceneColorSize.xy) + PixelOffset;

	#if AA_BORDER == 2
		Coord = clamp(Coord, InputMinPixelCoord, InputMaxPixelCoord);
	#endif

	return SceneDepthBuffer[Coord].r;
}


//------------------------------------------------------- TEMPORAL UPSAMPLING

#if AA_UPSAMPLE

// Returns the weight of a pixels at a coordinate <PixelDelta> from the PDF highest point.
half ComputeSampleWeigth(in FTAAIntermediaryResult IntermediaryResult, float2 PixelDelta)
{
	half u2 = UpscaleFactor * UpscaleFactor; // TODO: shader parameter

	// The point of InvFilterScaleFactor is to blur current frame scene color when upscaling.
	// Therefore there is no need to do it when downscaling.
	if (!AA_DOWNSAMPLE)
	{
		u2 *= (IntermediaryResult.InvFilterScaleFactor * IntermediaryResult.InvFilterScaleFactor);
	}

	#if 1
		// 1 - 1.9 * x^2 + 0.9 * x^4
		half x2 = saturate(u2 * dot(PixelDelta, PixelDelta));
		return (0.905 * x2 - 1.9) * x2 + 1;

	#else
		// original e ^ (- x^2 / (2 * s^2))
		const half Sigma = 0.47;
		const half ExponentInputFactor = (-0.5 / (Sigma * Sigma));
		
		half x2 = dot(PixelDelta, PixelDelta) * u2;
		return exp(ExponentInputFactor * x2);

	#endif
}


// Returns the weight of a pixels at a coordinate <PixelDelta> from the PDF highest point.
half ComputePixelWeigth(in FTAAIntermediaryResult IntermediaryResult, half2 PixelDelta)
{
	half u2 = UpscaleFactor * UpscaleFactor;

	// The point of InvFilterScaleFactor is to blur current frame scene color when upscaling.
	// Therefore there is no need to do it when downscaling.
	if (!AA_DOWNSAMPLE)
	{
		u2 *= (IntermediaryResult.InvFilterScaleFactor * IntermediaryResult.InvFilterScaleFactor);
	}

	#if 1
		// 1 - 1.9 * x^2 + 0.9 * x^4
		half x2 = saturate(u2 * dot(PixelDelta, PixelDelta));
		half r = (0.905 * x2 - 1.9) * x2 + 1;

	#else
		// original e ^ (- x^2 / (2 * s^2))
		const half Sigma = 0.47;
		const half ExponentInputFactor = (-0.5 / (Sigma * Sigma));
		
		half x2 = dot(PixelDelta, PixelDelta);
		half r = exp(ExponentInputFactor * x2);

	#endif

	if (!AA_DOWNSAMPLE)
	{
		// Multiply pixel weight ^ 2 by upscale factor because have only a probability = screen percentage ^ 2 to return 1.
		// Only do it for upsampling to not converge slower than if doing screen percentage 100%.
		return u2 * r;
	}
	return r;
}

#endif // AA_UPSAMPLE


//------------------------------------------------------- TAA MAJOR FUNCTIONS

// Filter input pixels.
void FilterCurrentFrameInputSamples(
	in FTAAInputParameters InputParams,
	inout FTAAIntermediaryResult IntermediaryResult)
{
	#if !AA_FILTERED
	{
		IntermediaryResult.Filtered = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0).Payload;
		return;
	}
	#endif

	FTAAPayload Filtered;

	{
		#if AA_UPSAMPLE
			// Pixel coordinate of the center of output pixel O in the input viewport.
			float2 PPCo = InputParams.ViewportUV * InputViewSize.xy + TemporalJitterPixels;

			// Pixel coordinate of the center of the nearest input pixel K.
			float2 PPCk = floor(PPCo) + 0.5;
		
			// Vector in pixel between pixel K -> O.
			half2 dKO = half2(PPCo - PPCk);
		#endif

		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC || AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
			// Fetches center pixel's Coc for the bilateral filtering.
			half CenterCocRadius = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0).Payload.CocRadius;
		#endif

		half NeighborsHdrWeight = 0;
		half NeighborsFinalWeight = 0;
		half4 NeighborsColor = 0;

		UNROLL
		for (uint NeighborId = 0; NeighborId < AA_SAMPLES; NeighborId++)
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, NeighborId);

			// Finds out the spatial weight of this input sample.
			#if AA_UPSAMPLE
				// Compute the pixel delta between output pixels and input pixel I.
				//  Note: abs() is unecessary because of the dot(dPP, dPP) latter on.
				half2 dPP = half2(Sample.SampleOffset) - dKO;

				half SampleSpatialWeight = ComputeSampleWeigth(IntermediaryResult, dPP);

			#elif AA_SAMPLES == 9
				half SampleSpatialWeight = SampleWeights[NeighborId];

			#elif AA_SAMPLES == 5
				half SampleSpatialWeight = PlusWeights[NeighborId];

			#else
				#error Do not know how to compute filtering sample weight.

			#endif

			// Finds out the sample's HDR weight.
			#if AA_TONE
				half SampleHdrWeight = Sample.HdrWeight;
			#else
				half SampleHdrWeight = 1;
			#endif

			// Finds out the sample's bilateral weight according to the payload.
			#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC
				half BilateralWeight = ComputeNeightborSampleBilateralWeight(CenterCocRadius, Sample.Payload.CocRadius);

			#else
				half BilateralWeight = 1;

			#endif

			half SampleFinalWeight = SampleSpatialWeight * SampleHdrWeight * BilateralWeight;

			// Apply pixel.
			NeighborsColor       += SampleFinalWeight * Sample.Payload.Color;
			NeighborsFinalWeight += SampleFinalWeight;

			NeighborsHdrWeight   += SampleSpatialWeight * SampleHdrWeight;
		}
		
		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC || AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0);
			
			#if AA_UPSAMPLE
				half SampleWeight = ComputeSampleWeigth(IntermediaryResult, -dKO);

			#elif AA_SAMPLES == 9
				half SampleWeight = SampleWeights[0];

			#else
				half SampleWeight = PlusWeights[0];

			#endif
			
			if (AA_TONE)
			{
				SampleWeight *= Sample.HdrWeight;
			}

			// TODO: it feels wrong...
			//Filtered = NeighborsColor * (NeighborsHdrWeight * rcp(NeighborsFinalWeight)) + Sample.Color * SampleWeight;
			Filtered.Color = NeighborsColor * rcp(NeighborsFinalWeight);
			Filtered.CocRadius = CenterCocRadius;
		}
		#elif AA_TONE || AA_UPSAMPLE
		{
			// Reweight because SampleFinalWeight does not that have total sum = 1.
			Filtered.Color = NeighborsColor * rcp(NeighborsFinalWeight);
			Filtered.CocRadius = 0;
		}
		#else
		{
			Filtered.Color = NeighborsColor;
			Filtered.CocRadius = 0;
		}
		#endif
		
		#if AA_UPSAMPLE
			// Compute the temporal weight of the output pixel.
			IntermediaryResult.FilteredTemporalWeight = ComputePixelWeigth(IntermediaryResult, dKO);
		#endif
	}
	
	#if AA_BORDER == 1
	{
		#if AA_UPSAMPLE
			#error AA_BORDER == 1 does not work for TAA upsample because also needs to be done in color clamping box.
		#else
			// Use unfiltered for 1 pixel border.
			float2 TestPos = abs(InputParams.ScreenPos) + OutputViewportSize.zw * 2.0;
			
			if(max(TestPos.x, TestPos.y) >= 1.0) 
			{
				Filtered = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0).Payload;
			}
		#endif
	}
	#endif

	Filtered.Color.rgb = clamp(Filtered.Color.rgb, -half(MaxHalfFloat), half(MaxHalfFloat));

	IntermediaryResult.Filtered = Filtered;
}


// Compute the neighborhood bounding box used to reject history.
void ComputeNeighborhoodBoundingbox(
	in FTAAInputParameters InputParams,
	in FTAAIntermediaryResult IntermediaryResult,
	out FTAAPayload OutNeighborMin,
	out FTAAPayload OutNeighborMax)
{
	FTAAPayload NeighborMin;
	FTAAPayload NeighborMax;

	#if AA_HISTORY_CLAMPING_BOX == HISTORY_CLAMPING_BOX_VARIANCE
	{
		half4 m1 = 0;
		half4 m2 = 0;
		UNROLL
		for(uint NeighborId = 0; NeighborId < AA_SAMPLES; NeighborId++)
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, NeighborId);

			m1 += Sample.Payload.Color;
			m2 += Pow2(Sample.Payload.Color);
		}

		m1 *= half(1.0 / AA_SAMPLES);
		m2 *= half(1.0 / AA_SAMPLES);

		half4 StdDev = sqrt( abs(m2 - m1 * m1) );
		NeighborMin = m1 - 1.25 * StdDev;
		NeighborMax = m1 + 1.25 * StdDev;

		NeighborMin = min( NeighborMin, IntermediaryResult.Filtered );
		NeighborMax = max( NeighborMax, IntermediaryResult.Filtered );
	}
	#elif AA_HISTORY_CLAMPING_BOX == HISTORY_CLAMPING_BOX_SAMPLE_DISTANCE
	// Do color clamping only within a radius.
	{
		float2 PPCo = InputParams.ViewportUV * InputViewSize.xy + TemporalJitterPixels;
		float2 PPCk = floor(PPCo) + 0.5;
		half2 dKO = half2(PPCo - PPCk);
		
		// Sample 4 is is always going to be considered anyway.
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0);
			NeighborMin = Sample.Payload;
			NeighborMax = Sample.Payload;
		}
		
		// Reduce distance threshold as upsacale factor increase to reduce ghosting.
		half DistthresholdLerp = UpscaleFactor - 1;
		half DistThreshold = lerp(1.51, 1.3, DistthresholdLerp); // TODO(REVERB): ShaderParameter
		half DistThresholdSqr = ToScalarMemory(DistThreshold * DistThreshold);

		UNROLL
		for(uint NeighborId = 1; NeighborId < AA_SAMPLES; NeighborId++)
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, NeighborId);

			half2 dPP = half2(Sample.SampleOffset) - dKO; // TODO(REVERB)

			FLATTEN
			if (dot(dPP, dPP) < DistThresholdSqr)
			{
				NeighborMin = MinPayload(NeighborMin, Sample.Payload);
				NeighborMax = MaxPayload(NeighborMax, Sample.Payload);
			}
		}
	}
	#elif AA_HISTORY_CLAMPING_BOX == HISTORY_CLAMPING_BOX_MIN_MAX
	{
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0);
			NeighborMin = Sample.Payload;
			NeighborMax = Sample.Payload;
		}
		
		UNROLL
		for(uint NeighborId = 1; NeighborId < AA_SAMPLES; NeighborId++)
		{
			FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, NeighborId);

			NeighborMin = MinPayload(NeighborMin, Sample.Payload);
			NeighborMax = MaxPayload(NeighborMax, Sample.Payload);
		}
	}
	#else
		#error Unknown history clamping box.
	#endif

	OutNeighborMin = NeighborMin;
	OutNeighborMax = NeighborMax;
}


// Sample history.
void SampleHistory(
	in float2 HistoryScreenPosition,
	out FTAAPayload HistoryPayload,
	out FTAAHistoryInformation HistoryInfo)
{
	half4 RawHistory0 = 0;
	half4 RawHistory1 = 0;
	half4 RawHistory2 = 0;
	half4 RawHistory3 = 0;

	// Sample the history using Catmull-Rom to reduce blur on motion.
	#if AA_BICUBIC
	{
		float2 HistoryBufferUV = HistoryScreenPosition * ScreenPosToHistoryBufferUV.xy + ScreenPosToHistoryBufferUV.zw;

		// Clamp HistoryBufferUV so that we don't have to do it entirely for each samples.
		#if AA_MANUALLY_CLAMP_HISTORY_UV
			HistoryBufferUV = clamp(HistoryBufferUV, HistoryBufferUVMinMax.xy, HistoryBufferUVMinMax.zw);
		#endif

		FCatmullRomSamples Samples = GetBicubic2DCatmullRomSamples(HistoryBufferUV, HistoryBufferSize.xy, HistoryBufferSize.zw);
		for (uint i = 0; i < Samples.Count; i++)
		{
			float2 SampleUV = Samples.UV[i];

			// Clamp SampleUV within HistoryBufferUVMinMax to avoid sampling potential NaN outside view rect.
			// This may look expensive, but Samples.UVDir is actually compile time constant to give a hint on what and how each component can be optimally clamped.
			if (AA_MANUALLY_CLAMP_HISTORY_UV)
			{
				if (Samples.UVDir[i].x < 0)
				{
					SampleUV.x = max(SampleUV.x, HistoryBufferUVMinMax.x);
				}
				else if (Samples.UVDir[i].x > 0)
				{
					SampleUV.x = min(SampleUV.x, HistoryBufferUVMinMax.z);
				}

				if (Samples.UVDir[i].y < 0)
				{
					SampleUV.y = max(SampleUV.y, HistoryBufferUVMinMax.y);
				}
				else if (Samples.UVDir[i].y > 0)
				{
					SampleUV.y = min(SampleUV.y, HistoryBufferUVMinMax.w);
				}
			}

			RawHistory0 += HistoryBuffer_0.SampleLevel(HistoryBufferSampler_0, SampleUV, 0) * Samples.Weight[i];
			
			#if HISTORY_RENDER_TARGETS >= 1
				RawHistory1 += HistoryBuffer_1.SampleLevel(HistoryBufferSampler_1, SampleUV, 0) * Samples.Weight[i];
			#endif
			
			#if HISTORY_RENDER_TARGETS >= 2
				RawHistory2 += HistoryBuffer_2.SampleLevel(HistoryBufferSampler_2, SampleUV, 0) * Samples.Weight[i];
			#endif
			
			#if HISTORY_RENDER_TARGETS >= 3
				RawHistory3 += HistoryBuffer_3.SampleLevel(HistoryBufferSampler_3, SampleUV, 0) * Samples.Weight[i];
			#endif
		} // for (uint i = 0; i < Samples.Count; i++)

		RawHistory0 *= half(Samples.FinalMultiplier);
		
		#if HISTORY_RENDER_TARGETS >= 1
			RawHistory1 *= half(Samples.FinalMultiplier);
		#endif
		
		#if HISTORY_RENDER_TARGETS >= 2
			RawHistory2 *= half(Samples.FinalMultiplier);
		#endif
		
		#if HISTORY_RENDER_TARGETS >= 3
			RawHistory3 *= half(Samples.FinalMultiplier);
		#endif
	}

	// Sample the history using bilinear sampler.
	#else
	{
		// Clamp HistoryScreenPosition to be within viewport.
		if (AA_MANUALLY_CLAMP_HISTORY_UV)
		{
			HistoryScreenPosition = clamp(HistoryScreenPosition, -ScreenPosAbsMax, ScreenPosAbsMax);
		}

		float2 HistoryBufferUV = HistoryScreenPosition * ScreenPosToHistoryBufferUV.xy + ScreenPosToHistoryBufferUV.zw;

		RawHistory0 = HistoryBuffer_0.SampleLevel(HistoryBufferSampler_0, HistoryBufferUV, 0);
		
		#if HISTORY_RENDER_TARGETS >= 1
			RawHistory1 = HistoryBuffer_1.SampleLevel(HistoryBufferSampler_1, HistoryBufferUV, 0);
		#endif

		#if HISTORY_RENDER_TARGETS >= 2
			RawHistory2 = HistoryBuffer_2.SampleLevel(HistoryBufferSampler_2, HistoryBufferUV, 0);
		#endif

		#if HISTORY_RENDER_TARGETS >= 3
			RawHistory3 = HistoryBuffer_3.SampleLevel(HistoryBufferSampler_3, HistoryBufferUV, 0);
		#endif
	}
	#endif

	#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
	{
		if (AA_MANUALLY_CLAMP_HISTORY_UV)
		{
			HistoryScreenPosition = clamp(HistoryScreenPosition, -ScreenPosAbsMax, ScreenPosAbsMax);
		}

		float2 HistoryBufferUV = HistoryScreenPosition * ScreenPosToHistoryBufferUV.xy + ScreenPosToHistoryBufferUV.zw;

		RawHistory1 = HistoryBuffer_1.SampleLevel(HistoryBufferSampler_1, HistoryBufferUV, 0);

		#if HISTORY_RENDER_TARGETS >= 3
			RawHistory2 = HistoryBuffer_2.SampleLevel(HistoryBufferSampler_2, HistoryBufferUV, 0);
		#endif

		#if HISTORY_RENDER_TARGETS >= 4
			RawHistory3 = HistoryBuffer_3.SampleLevel(HistoryBufferSampler_3, HistoryBufferUV, 0);
		#endif
	}
	#endif
	
	// Decode history payload
	{
		HistoryPayload.Color = 0;
		HistoryPayload.CocRadius = 0;

		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB
		{
			HistoryPayload.Color.rgb = RawHistory0.rgb;
		}
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY
		{
			HistoryPayload.Color = RawHistory0;
		}
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC
		{
			HistoryPayload.Color.rgb = RawHistory0.rgb;
			HistoryPayload.CocRadius = RawHistory0.a;
		}
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
		{
			HistoryPayload.Color = RawHistory0;
			HistoryPayload.CocRadius = RawHistory1.r;
		}
		#else
			#error Unknown history payload
		#endif

		#if USE_PREEXPOSURE
			HistoryPayload.Color.rgb *= half(HistoryPreExposureCorrection);
		#endif

		HistoryPayload.Color = TransformSceneColor(HistoryPayload.Color);
		HistoryPayload.Color.rgb = clamp(HistoryPayload.Color.rgb, -half(MaxHalfFloat), half(MaxHalfFloat));
	}

	// Decode history infos
	{
		HistoryInfo = CreateHistoryInformation();

		#if AA_DYNAMIC_ANTIGHOST && AA_DYNAMIC
		{
			HistoryInfo.bIsDynamicPixel = RawHistory0.a > 0;
		}
		#endif
	}
}


// Clamp history.
FTAAPayload ClampHistory(FTAAPayload History, FTAAPayload NeighborMin, FTAAPayload NeighborMax)
{
	#if !AA_CLAMP
		return History;
	
	#elif AA_CLIP
		// Clip history, this uses color AABB intersection for tighter fit.
		//half4 TargetColor = half(0.5) * ( NeighborMin + NeighborMax );
		half4 TargetColor = Filtered;

		half ClipBlend = HistoryClip( HistoryColor.rgb, TargetColor.rgb, NeighborMin.rgb, NeighborMax.rgb );
		
		//half DistToClamp = saturate(-ClipBlend) / ( saturate(-ClipBlend) + 1 );
		//half DistToClamp = abs( ClipBlend ) / ( 1 - ClipBlend );
		ClipBlend = saturate( ClipBlend );

		HistoryColor = lerp( HistoryColor, TargetColor, ClipBlend );

		#if AA_FORCE_ALPHA_CLAMP
			HistoryColor.a = clamp( HistoryColor.a, NeighborMin.a, NeighborMax.a );
		#endif

		return HistoryColor;

	#else //!AA_CLIP
		History.Color = clamp(History.Color, NeighborMin.Color, NeighborMax.Color);
		History.CocRadius = clamp(History.CocRadius, NeighborMin.CocRadius, NeighborMax.CocRadius);
		return History;
	#endif
}




//------------------------------------------------------- TAA MAIN FUNCTION

void TemporalAASample(
	uint2 GroupId, uint GroupThreadIndex, 
	out FTAAPayload OutputPayload,
	out FTAAHistoryInformation OutputHistoryInfo)
{
	OutputHistoryInfo = CreateHistoryInformation();

	// SETUP
	// -----
	FTAAInputParameters InputParams;

	// Per frame setup.
	{
		float FrameExposureScale = EyeAdaptationLookup();
		#if USE_PREEXPOSURE
			InputParams.FrameExposureScale = ToScalarMemory(half(FrameExposureScale * View.OneOverPreExposure));
		#else
			InputParams.FrameExposureScale = ToScalarMemory(half(FrameExposureScale));
		#endif
	}

	// Per pixel setup.
	uint2 DebugOutputCoord;
	{
		{
			uint2 DispatchThreadId = uint2(GroupThreadIndex % THREADGROUP_SIZEX, GroupThreadIndex / THREADGROUP_SIZEX) + GroupId * uint2(THREADGROUP_SIZEX, THREADGROUP_SIZEY);

			DebugOutputCoord = DispatchThreadId;

			#if AA_LOWER_RESOLUTION
			{
				InputParams.ViewportUV = (float2(DispatchThreadId) + 0.5f) * MaxViewportUVAndSvPositionToViewportUV.zw;
				InputParams.ViewportUV = min(InputParams.ViewportUV, MaxViewportUVAndSvPositionToViewportUV.xy);
			}
			#else
			{
				InputParams.ViewportUV = (float2(DispatchThreadId) + 0.5f) * OutputViewportSize.zw;
			}
			#endif
		}

		InputParams.ScreenPos = ViewportUVToScreenPos(InputParams.ViewportUV);
		
		#if AA_UPSAMPLE
		{
			// Pixel coordinate of the center of output pixel O in the input viewport.
			float2 PPCo = InputParams.ViewportUV * InputViewSize.xy + TemporalJitterPixels;
		
			// Pixel coordinate of the center of the nearest input pixel K.
			float2 PPCk = floor(PPCo) + 0.5;
		
			InputParams.NearestBufferUV = InputSceneColorSize.zw * (InputViewMin + PPCk);

			// TODO: because use nearest sampler, can be faster in this computation.
		}
		#else
		{
			InputParams.NearestBufferUV = InputParams.ViewportUV * ViewportUVToInputBufferUV.xy + ViewportUVToInputBufferUV.zw;
		}
		#endif

		// Handle single or multi-pass responsive AA
		#if AA_SINGLE_PASS_RESPONSIVE
		{
			const uint kResponsiveStencilMask = 1 << 3;
			
			int2 SceneStencilUV = (int2)trunc(InputParams.NearestBufferUV * InputSceneColorSize.xy);
			uint SceneStencilRef = StencilTexture.Load(int3(SceneStencilUV, 0)) STENCIL_COMPONENT_SWIZZLE;

			InputParams.bIsResponsiveAAPixel = (SceneStencilRef & kResponsiveStencilMask) != 0;
		}
		#elif TAA_RESPONSIVE
			InputParams.bIsResponsiveAAPixel = true;
		#else
			InputParams.bIsResponsiveAAPixel = false;
		#endif
	}

	// Setup intermediary results.
	FTAAIntermediaryResult IntermediaryResult = CreateIntermediaryResult();

	// FIND MOTION OF PIXEL AND NEAREST IN NEIGHBORHOOD
	// ------------------------------------------------
	float3 PosN; // Position of this pixel, possibly later nearest pixel in neighborhood.
	PosN.xy = InputParams.ScreenPos;

	PosN.z = SampleSceneDepthTexture(InputParams, int2(0, 0));

	// Screen position of minimum depth.
	float2 VelocityOffset = float2(0.0, 0.0);
	#if AA_CROSS // TODO: 2x2.
	{
		// For motion vector, use camera/dynamic motion from min depth pixel in pattern around pixel.
		// This enables better quality outline on foreground against different motion background.
		// Larger 2 pixel distance "x" works best (because AA dilates surface).
		half4 Depths;
		Depths.x = SampleSceneDepthTexture(InputParams, int2(-AA_CROSS, -AA_CROSS));
		Depths.y = SampleSceneDepthTexture(InputParams, int2( AA_CROSS, -AA_CROSS));
		Depths.z = SampleSceneDepthTexture(InputParams, int2(-AA_CROSS,  AA_CROSS));
		Depths.w = SampleSceneDepthTexture(InputParams, int2( AA_CROSS,  AA_CROSS));

		float2 DepthOffset = float2(AA_CROSS, AA_CROSS);
		float DepthOffsetXx = float(AA_CROSS);
		#if HAS_INVERTED_Z_BUFFER
			// Nearest depth is the largest depth (depth surface 0=far, 1=near).
			if(Depths.x > Depths.y) 
			{
				DepthOffsetXx = -AA_CROSS;
			}
			if(Depths.z > Depths.w) 
			{
				DepthOffset.x = -AA_CROSS;
			}
			half DepthsXY = max(Depths.x, Depths.y);
			half DepthsZW = max(Depths.z, Depths.w);
			if(DepthsXY > DepthsZW) 
			{
				DepthOffset.y = -AA_CROSS;
				DepthOffset.x = DepthOffsetXx; 
			}
			half DepthsXYZW = max(DepthsXY, DepthsZW);
			if(DepthsXYZW > PosN.z) 
			{
				// This is offset for reading from velocity texture.
				// This supports half or fractional resolution velocity textures.
				// With the assumption that UV position scales between velocity and color.
				VelocityOffset = DepthOffset * InputSceneColorSize.zw;
				// This is [0 to 1] flipped in Y.
				//PosN.xy = ScreenPos + DepthOffset * OutputViewportSize.zw * 2.0;
				PosN.z = DepthsXYZW;
			}
		#else // !HAS_INVERTED_Z_BUFFER
			#error Fix me!
		#endif // !HAS_INVERTED_Z_BUFFER
	}
	#endif	// AA_CROSS

	// Camera motion for pixel or nearest pixel (in ScreenPos space).
	bool OffScreen = false;
	half Velocity = 0;
	half HistoryBlur = 0;
	float2 HistoryScreenPosition = InputParams.ScreenPos;

	#if 1
	{
		float4 ThisClip = float4( PosN.xy, PosN.z, 1 );
		float4 PrevClip = mul( ThisClip, View.ClipToPrevClip );
		float2 PrevScreen = PrevClip.xy / PrevClip.w;
		float2 BackN = PosN.xy - PrevScreen;

		float2 BackTemp = BackN * OutputViewportSize.xy;

		#if AA_DYNAMIC
		{
			float2 VelocityN;
			VelocityN = SceneVelocityBuffer.SampleLevel(SceneVelocityBufferSampler, InputParams.NearestBufferUV + VelocityOffset, 0).xy;
			bool DynamicN = VelocityN.x > 0.0;
			if(DynamicN)
			{
				BackN = DecodeVelocityFromTexture(float3(VelocityN, 0.0)).xy;
			}
			BackTemp = BackN * OutputViewportSize.xy;
		}
		#endif

		Velocity = half(sqrt(dot(BackTemp, BackTemp)));
		#if !AA_BICUBIC
			// Save the amount of pixel offset of just camera motion, used later as the amount of blur introduced by history.
			float HistoryBlurAmp = 2.0;
			HistoryBlur = half(saturate(abs(BackTemp.x) * HistoryBlurAmp + abs(BackTemp.y) * HistoryBlurAmp));
		#endif
		// Easier to do off screen check before conversion.
		// BackN is in units of 2pixels/viewportWidthInPixels
		// This converts back projection vector to [-1 to 1] offset in viewport.
		HistoryScreenPosition = InputParams.ScreenPos - BackN;

		// Detect if HistoryBufferUV would be outside of the viewport.
		OffScreen = max(abs(HistoryScreenPosition.x), abs(HistoryScreenPosition.y)) >= 1.0;
	}
	#endif

	// Precache input scene color.
	PrecacheInputSceneColor(/* inout = */ InputParams);

	// Filter input.
	#if AA_UPSAMPLE_ADAPTIVE_FILTERING == 0
		FilterCurrentFrameInputSamples(
			InputParams,
			/* inout = */ IntermediaryResult);
	#endif
	
	// Compute neighborhood bounding box.
	FTAAPayload NeighborMin;
	FTAAPayload NeighborMax;

	ComputeNeighborhoodBoundingbox(
		InputParams,
		/* inout = */ IntermediaryResult,
		NeighborMin, NeighborMax);

	// Sample history.
	FTAAPayload History;
	FTAAHistoryInformation HistoryInfo;
	SampleHistory(HistoryScreenPosition, /* out */ History, /* out */ HistoryInfo);

	// Whether the feedback needs to be reset.
	bool bIgnoreHistory = OffScreen || bCameraCut;

	// DYNAMIC ANTI GHOSTING
	// ---------------------
	#if AA_DYNAMIC_ANTIGHOST && AA_DYNAMIC
	{
		#if !AA_DYNAMIC
			#error AA_DYNAMIC_ANTIGHOST requires AA_DYNAMIC
		#endif
		// TODO: try a 2x2 for AA_UPSAMPLE
		bool Dynamic1 = SceneVelocityBuffer.SampleLevel(SceneVelocityBufferSampler, InputParams.NearestBufferUV, 0, int2( 0, -1)).x > 0;
		bool Dynamic3 = SceneVelocityBuffer.SampleLevel(SceneVelocityBufferSampler, InputParams.NearestBufferUV, 0, int2(-1,  0)).x > 0;
		bool Dynamic4 = SceneVelocityBuffer.SampleLevel(SceneVelocityBufferSampler, InputParams.NearestBufferUV, 0).x > 0;
		bool Dynamic5 = SceneVelocityBuffer.SampleLevel(SceneVelocityBufferSampler, InputParams.NearestBufferUV, 0, int2( 1,  0)).x > 0;
		bool Dynamic7 = SceneVelocityBuffer.SampleLevel(SceneVelocityBufferSampler, InputParams.NearestBufferUV, 0, int2( 0,  1)).x > 0;

		bool Dynamic = Dynamic1 || Dynamic3 || Dynamic4 || Dynamic5 || Dynamic7;
		bIgnoreHistory = bIgnoreHistory || !Dynamic && HistoryInfo.bIsDynamicPixel;
		
		OutputHistoryInfo.bIsDynamicPixel = Dynamic4;
	}
	#endif
	
	// Save off luma of history before the clamp.
	half LumaMin     = GetSceneColorLuma4(NeighborMin.Color);
	half LumaMax     = GetSceneColorLuma4(NeighborMax.Color);
	half LumaHistory = GetSceneColorLuma4(History.Color);
	
	// Clamp history.
	FTAAPayload PreClampingHistoryColor = History;
	History = ClampHistory(History, NeighborMin, NeighborMax);
	
	// Filter input after color clamping.
	#if AA_UPSAMPLE_ADAPTIVE_FILTERING == 1
	{
		#if AA_VARIANCE
			#error AA_VARIANCE and AA_UPSAMPLE_ADAPTIVE_FILTERING are not compatible because of circular code dependency.
		#endif

		if (bIgnoreHistory) // || any(HistoryColor != PreClampingHistoryColor))
		{
			// Set the input filter infinitely large when we know need to rely on it.
			IntermediaryResult.InvFilterScaleFactor = 0;
		}

		// Blur input according to input pixel velocity to reduce blocky filtering cause by narrow filter on low screen percentage.
		// Multiplied by upscale factor because Velocity is in output resolution based pixel velocity.
		IntermediaryResult.InvFilterScaleFactor -= (Velocity * UpscaleFactor) * 0.1;

		// Set a minimal filtering scale to screen percentage to not unecessarily blur the input more than the screen percentage.
		IntermediaryResult.InvFilterScaleFactor = max(IntermediaryResult.InvFilterScaleFactor, ScreenPercentage);

		FilterCurrentFrameInputSamples(
			InputParams,
			/* inout = */ IntermediaryResult);
	}
	#endif

	// ADD BACK IN ALIASING TO SHARPEN
	// -------------------------------
	#if AA_FILTERED && !AA_BICUBIC
	{
		#if AA_UPSAMPLE
			#error Temporal upsample does not support sharpen.
		#endif
		
		// Blend in non-filtered based on the amount of sub-pixel motion.
		half AddAliasing = saturate(HistoryBlur) * 0.5;
		half LumaContrastFactor = 32.0;
		#if AA_YCOCG // TODO: Probably a bug arround here because using Luma4() even with YCOCG=0.
			// 1/4 as bright.
			LumaContrastFactor *= 4.0;
		#endif
		half LumaContrast = LumaMax - LumaMin;
		AddAliasing = saturate(AddAliasing + rcp(1.0 + LumaContrast * LumaContrastFactor));

		FTAASceneColorSample Sample = SampleCachedSceneColorTexture(InputParams, /* NeighborId = */ 0);
		IntermediaryResult.Filtered.Color = lerp(IntermediaryResult.Filtered.Color, Sample.Payload.Color, AddAliasing);
	}
	#endif
	
	// COMPUTE BLEND AMOUNT 
	// --------------------
	half BlendFinal;
	{
		half LumaFiltered = GetSceneColorLuma4(IntermediaryResult.Filtered.Color);

		BlendFinal = IntermediaryResult.FilteredTemporalWeight * CurrentFrameWeight;

		BlendFinal = lerp(BlendFinal, half(0.2), saturate(Velocity / 40.0));

		#if AA_ANTIFLICKER
			half DistToClamp = min( abs(LumaHistory - LumaMin), abs(LumaHistory - LumaMax) ) / max3( LumaHistory, LumaFiltered, 1e-4 );
			BlendFinal *= 0.2 + 0.8 * saturate( 0.5 * DistToClamp );
		#endif

		// Make sure to have at least some small contribution
		BlendFinal = max( BlendFinal, saturate( half(0.01) * LumaHistory / abs( LumaFiltered - LumaHistory ) ) );

		#if AA_NAN && (COMPILER_GLSL || COMPILER_METAL)
			// The current Metal & GLSL compilers don't handle saturate(NaN) -> 0, instead they return NaN/INF.
			BlendFinal = -min(-BlendFinal, half(0.0));
		#endif

		// Responsive forces 1/4 of new frame.
		BlendFinal = InputParams.bIsResponsiveAAPixel ? half(1.0/4.0) : BlendFinal;

		#if AA_LERP 
			BlendFinal = half(1.0/half(AA_LERP));
		#endif
	
		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC || AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
		{
			half BilateralWeight = ComputeBilateralWeight(IntermediaryResult.Filtered.CocRadius, History.CocRadius);

			BlendFinal = lerp(half(1), BlendFinal, BilateralWeight);
		}
		#endif
		
		if (bCameraCut)
		{
			BlendFinal = half(1.0);
		}
	}

	// Offscreen feedback resets.
	if (bIgnoreHistory)
	{
		History = IntermediaryResult.Filtered;
	}
	
	// DO FINAL BLEND BETWEEN HISTORY AND FILTERED COLOR
	// -------------------------------------------------
	{
		// Luma weighted blend
		half FilterWeight = GetSceneColorHdrWeight(InputParams, IntermediaryResult.Filtered.Color.x);
		half HistoryWeight = GetSceneColorHdrWeight(InputParams, History.Color.x);

		half2 Weights = WeightedLerpFactors(HistoryWeight, FilterWeight, BlendFinal);
		OutputPayload = AddPayload(MulPayload(History, Weights.x), MulPayload(IntermediaryResult.Filtered, Weights.y));
	}

	{
		OutputPayload.Color = TransformBackToRawLinearSceneColor(OutputPayload.Color);
		
		// Ensure that alpha values that are expected to be opaque (but are only close to opaque) are forced to be opaque.
		// (0.995 chosen to accomodate handling of 254/255)
		if (OutputPayload.Color.a > half(0.995))
		{
			OutputPayload.Color.a = half(1);
		}
	}
}

//------------------------------------------------------- ENTRY POINT

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	FTAAPayload OutputPayload;
	FTAAHistoryInformation OutputHistoryInfo;

	TemporalAASample(
		GroupId, GroupThreadIndex,
		/* out */ OutputPayload,
		/* out */ OutputHistoryInfo);

	half4 OutColor0 = 0;
	half4 OutColor1 = 0;
	half4 OutColor2 = 0;
	half4 OutColor3 = 0;

	// Encode history
	{
		// Transform NaNs to black, transform negative colors to black.
		#if AA_NAN
			OutputPayload.Color = -min(-OutputPayload.Color, half(0.0));
			OutputPayload.CocRadius = isnan(OutputPayload.CocRadius) ? 0.0 : OutputPayload.CocRadius;
		#endif

		OutputPayload.Color.rgb = min(OutputPayload.Color.rgb, half(MaxHalfFloat));

		#if AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB
		{
			OutColor0.rgb = OutputPayload.Color.rgb;
		}
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY
		{
			OutColor0 = OutputPayload.Color;
		}
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_COC
		{
			OutColor0.rgb = OutputPayload.Color.rgb;
			OutColor0.a = OutputPayload.CocRadius;
		}
		#elif AA_HISTORY_PAYLOAD == HISTORY_PAYLOAD_RGB_OPACITY_COC
		{
			OutColor0 = OutputPayload.Color;
			OutColor1.r = OutputPayload.CocRadius;
		}
		#else
			#error Unknown history payload
		#endif
		
		#if AA_DYNAMIC_ANTIGHOST && AA_DYNAMIC
		{
			#if HISTORY_PAYLOAD_COMPONENTS == 3
				OutColor0.a = OutputHistoryInfo.bIsDynamicPixel ? 1 : 0;
			#else
				#error "Can't encode AA_DYNAMIC_ANTIGHOST"
			#endif
		}
		#endif
	}

	// Output history
	ISOLATE
	{
		// Avoid keeping a VGPR for GroupThreadIndex.
		#if COMPILER_SUPPORTS_WAVE_ONCE
		ISOLATE
		{
			GroupThreadIndex = WaveGetLaneIndex();
		}
		#endif

		// Compute new pixel position to avoid keeping VGPR.
		uint2 OutputPixelPos;
		ISOLATE
		{
			OutputPixelPos = (
				uint2(GroupThreadIndex % THREADGROUP_SIZEX, GroupThreadIndex / THREADGROUP_SIZEX) +
				GroupId * uint2(THREADGROUP_SIZEX, THREADGROUP_SIZEY) +
				OutputViewportRect.xy);
		}

		if (all(OutputPixelPos < OutputViewportRect.zw))
		{
			OutComputeTex_0[OutputPixelPos] = OutColor0;

			#if HISTORY_RENDER_TARGETS >= 2
				OutComputeTex_1[OutputPixelPos] = OutColor1;
			#endif

			#if HISTORY_RENDER_TARGETS >= 3
				OutComputeTex_2[OutputPixelPos] = OutColor2;
			#endif

			#if HISTORY_RENDER_TARGETS == 4
				OutComputeTex_3[OutputPixelPos] = OutColor3;
			#endif
		}

		#if TAA_DOWNSAMPLE
		{
			// This shader permutation outputs half resolution image in addition to main full-res one.
			// It is more efficient than performing a separate downsampling pass afterwards.
			// Assumes output resolution is always even.

			uint2 GroupThreadId = uint2(GroupThreadIndex % THREADGROUP_SIZEX, GroupThreadIndex / THREADGROUP_SIZEX);

			uint P0 = GroupThreadId.x + GroupThreadId.y * THREADGROUP_SIZEX;
			uint P1 = P0 + 1;
			uint P2 = P0 + THREADGROUP_SIZEX;
			uint P3 = P2 + 1;

			GroupSharedDownsampleArray[P0] = OutColor0;

			GroupMemoryBarrierWithGroupSync();

			if (((GroupThreadId.x | GroupThreadId.y) & 1) == 0)
			{
				OutComputeTexDownsampled[OutputPixelPos / 2] =
					(OutColor0 + GroupSharedDownsampleArray[P1] + GroupSharedDownsampleArray[P2] + GroupSharedDownsampleArray[P3]) * 0.25;
			}
		}
		#endif //TAA_DOWNSAMPLE
	}
}
