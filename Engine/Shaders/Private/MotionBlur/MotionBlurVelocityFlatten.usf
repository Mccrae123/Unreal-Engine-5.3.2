// Copyright Epic Games, Inc. All Rights Reserved.

#define CONFIG_MAX_RANGE_SIZE DIM_BLUR_DIRECTIONS

#include "MotionBlurVelocityFlatten.ush"


//------------------------------------------------------- CONSTANTS

#define THREADGROUP_SIZEX		16
#define THREADGROUP_SIZEY		16
#define THREADGROUP_TOTALSIZE	(THREADGROUP_SIZEX * THREADGROUP_SIZEY)

#ifndef CAMERA_MOTION_BLUR_MODE
// 0-off; 1-on; 2-override
#define CAMERA_MOTION_BLUR_MODE 1
#endif


//------------------------------------------------------- PARAMETERS

SCREEN_PASS_TEXTURE_VIEWPORT(Velocity)
SCREEN_PASS_TEXTURE_VIEWPORT(VelocityTile)

#if CAMERA_MOTION_BLUR_MODE == 2
float4x4 ClipToPrevClipOverride;
#endif

float MotionBlur_AspectRatio;
float MotionBlur_VelocityScale;
float MotionBlur_VelocityScaleForTiles;
float MotionBlur_VelocityMax;

Texture2D VelocityTexture;
Texture2D VelocityTileTexture;
Texture2D DepthTexture;

RWTexture2D<float4>	OutVelocityFlatTexture;
RWTexture2D<float4>	OutVelocityTile_Textures_0;
RWTexture2D<float4>	OutVelocityTile_Textures_1;

RWTexture2D<float4>	DebugOutput;


//------------------------------------------------------- LDS

#if DEBUG_OUTPUT
groupshared float4 Debug[THREADGROUP_TOTALSIZE];
#endif

groupshared float4 SharedArray0[THREADGROUP_TOTALSIZE];
groupshared float2 SharedArray1[THREADGROUP_TOTALSIZE];


//------------------------------------------------------- FUNCTIONS

void WritePolarVelocityRangeToLDS(uint LDSSlotId, FVelocityRange V)
{
	SharedArray0[LDSSlotId] = float4(V.Max[0], V.Min);
	
	#if CONFIG_MAX_RANGE_SIZE > 1
		SharedArray1[LDSSlotId] = V.Max[1];
	#endif
}

FVelocityRange ReadPolarVelocityRangeFromLDS(uint LDSSlotId)
{
	FVelocityRange V;
	V.Max[0] = SharedArray0[LDSSlotId].xy;
	#if CONFIG_MAX_RANGE_SIZE > 1
		V.Max[1] = SharedArray1[LDSSlotId].xy;
	#endif
	V.Min = SharedArray0[LDSSlotId].zw;
	return V;
}

void VelovityFlattenStep(uint GroupIndex, const uint GroupSize, inout FVelocityRange V)
{
	if (GroupIndex < GroupSize)
	{
		FVelocityRange V1 = ReadPolarVelocityRangeFromLDS(GroupIndex + GroupSize);
		
		//if (GroupSize == uint(View.GeneralPurposeTweak))
		//{
		//	Debug[GroupIndex].r = V.Max[1].g;
		//}

		V = ReducePolarVelocityRange(V, V1);
		
		//if (GroupSize == uint(View.GeneralPurposeTweak))
		//{
		//	Debug[GroupIndex].g = V.Max[1].g;
		//}

		WritePolarVelocityRangeToLDS(GroupIndex, V);
	}
}

float2 GetCameraMotionVelocity(uint3 DispatchThreadId, float Depth, float4x4 ClipToPrevClip)
{
	// Compute velocity due to camera motion.
	float2 ViewportUV = ((float2)DispatchThreadId.xy + 0.5) / Velocity_ViewportSize;
	float2 ScreenPos = 2 * float2(ViewportUV.x, 1 - ViewportUV.y) - 1;
	float4 ThisClip = float4(ScreenPos, Depth, 1);
	float4 PrevClip = mul(ThisClip, ClipToPrevClip);
	float2 PrevScreen = PrevClip.xy / PrevClip.w;
	return ScreenPos - PrevScreen;
}


//------------------------------------------------------- ENTRY POINT

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex) 
{ 
#if DEBUG_OUTPUT
	Debug[GroupIndex] = 0.0;
#endif

	int2 PixelPos = min(DispatchThreadId.xy + Velocity_ViewportMin, Velocity_ViewportMax - 1);
	int2 DepthOffset = 0;

	{
		const int Cross = 1;
		// For motion vector, use camera/dynamic motion from min depth pixel in pattern around pixel.
		// This enables better quality outline on foreground against different motion background.
		
		half4 Depths;
		Depths.x = DepthTexture[ PixelPos + int2(-Cross, -Cross) ].x;
		Depths.y = DepthTexture[ PixelPos + int2( Cross, -Cross) ].x;
		Depths.z = DepthTexture[ PixelPos + int2(-Cross,  Cross) ].x;
		Depths.w = DepthTexture[ PixelPos + int2( Cross,  Cross) ].x;

		DepthOffset = Cross;
		int DepthOffsetXx = Cross;

		// Nearest depth is the largest depth (depth surface 0=far, 1=near).
		if(Depths.x > Depths.y) 
		{
			DepthOffsetXx = -Cross;
		}
		if(Depths.z > Depths.w) 
		{
			DepthOffset.x = -Cross;
		}
		half DepthsXY = max(Depths.x, Depths.y);
		half DepthsZW = max(Depths.z, Depths.w);
		if(DepthsXY > DepthsZW) 
		{
			DepthOffset.y = -Cross;
			DepthOffset.x = DepthOffsetXx; 
		}
	}

	float4 EncodedVelocity = VelocityTexture[ PixelPos + DepthOffset ];
	float Depth = DepthTexture[ PixelPos + DepthOffset ].x;

	float2 Velocity = 0.0f;
	if (EncodedVelocity.x > 0.0)
	{
		Velocity = DecodeVelocityFromTexture(EncodedVelocity).xy;
#if CAMERA_MOTION_BLUR_MODE != 1
		// Cancel motion blur caused by the current camera movements
		Velocity -= GetCameraMotionVelocity(DispatchThreadId, Depth, View.ClipToPrevClip);
#endif
#if CAMERA_MOTION_BLUR_MODE == 2
		// Apply motion blur caused by the custom camera movements
		Velocity += GetCameraMotionVelocity(DispatchThreadId, Depth, ClipToPrevClipOverride);
#endif
	}
#if CAMERA_MOTION_BLUR_MODE > 0
	else
	{
#if CAMERA_MOTION_BLUR_MODE == 2
		// Apply motion blur caused by the custom camera movements
		Velocity = GetCameraMotionVelocity(DispatchThreadId, Depth, ClipToPrevClipOverride);
#else
		// Apply motion blur caused by the current camera movements
		Velocity = GetCameraMotionVelocity(DispatchThreadId, Depth, View.ClipToPrevClip);
#endif
	}
#endif

	Velocity.y *= -MotionBlur_AspectRatio;

	float2 VelocityPolar = CartesianToPolar(Velocity);

	// If the velocity vector was zero length, VelocityPolar will contain NaNs.
	if (any(isnan(VelocityPolar)))
	{
		VelocityPolar = float2(0.0f, 0.0f);
	}

	bool bInsideViewport = all(PixelPos.xy < Velocity_ViewportMax);

	// 11:11:10  (VelocityLength, VelocityAngle, Depth)
	{
		float2 EncodedPolarVelocity;
		EncodedPolarVelocity.x = VelocityPolar.x;
		EncodedPolarVelocity.y = VelocityPolar.y * (0.5 / PI) + 0.5;

		BRANCH
		if (bInsideViewport)
		{
			OutVelocityFlatTexture[PixelPos] = float3(EncodedPolarVelocity, ConvertFromDeviceZ(Depth)).xyzz;
		}
	}

	// Limit velocity
	VelocityPolar.x = min(VelocityPolar.x, MotionBlur_VelocityMax / MotionBlur_VelocityScale);

	FVelocityRange VelocityPolarRange = SetupPolarVelocityRange(VelocityPolar);

	// TODO
	//float4 VelocityMinMax = VelocityPolar.xyxy;
	//VelocityMinMax.x = bInsideViewport ? VelocityMinMax.x : 2;
	//VelocityMinMax.z = bInsideViewport ? VelocityMinMax.z : 0;

	WritePolarVelocityRangeToLDS(GroupIndex, VelocityPolarRange);

	GroupMemoryBarrierWithGroupSync();

#if THREADGROUP_TOTALSIZE > 512
	VelovityFlattenStep(GroupIndex, /* GroupSize = */ 512, /* inout */ VelocityPolarRange);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 256
	VelovityFlattenStep(GroupIndex, /* GroupSize = */ 256, /* inout */ VelocityPolarRange);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 128
	VelovityFlattenStep(GroupIndex, /* GroupSize = */ 128, /* inout */ VelocityPolarRange);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 64
	VelovityFlattenStep(GroupIndex, /* GroupSize = */ 64, /* inout */ VelocityPolarRange);
	GroupMemoryBarrierWithGroupSync();
#endif

	// Safe for vector sizes 32 or larger, AMD and NV
	// TODO Intel variable size vector
	VelovityFlattenStep(GroupIndex, /* GroupSize = */ 32, /* inout */ VelocityPolarRange);
	VelovityFlattenStep(GroupIndex, /* GroupSize = */ 16, /* inout */ VelocityPolarRange);
	VelovityFlattenStep(GroupIndex, /* GroupSize = */  8, /* inout */ VelocityPolarRange);
	VelovityFlattenStep(GroupIndex, /* GroupSize = */  4, /* inout */ VelocityPolarRange);
	VelovityFlattenStep(GroupIndex, /* GroupSize = */  2, /* inout */ VelocityPolarRange);
	VelovityFlattenStep(GroupIndex, /* GroupSize = */  1, /* inout */ VelocityPolarRange);

	if (GroupIndex == 0)
	{
		StoreVelocityRange(OutVelocityTile_Textures_0, OutVelocityTile_Textures_1, GroupId, PolarToCartesian(VelocityPolarRange));
	}
	
#if DEBUG_OUTPUT
	DebugOutput[PixelPos] = Debug[GroupIndex];
#endif
}
