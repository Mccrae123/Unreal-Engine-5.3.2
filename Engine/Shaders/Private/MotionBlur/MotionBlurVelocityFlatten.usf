// Copyright Epic Games, Inc. All Rights Reserved.

#include "MotionBlurVelocityFlatten.ush"


//------------------------------------------------------- CONSTANTS

#define THREADGROUP_SIZEX		16
#define THREADGROUP_SIZEY		16
#define THREADGROUP_TOTALSIZE	(THREADGROUP_SIZEX * THREADGROUP_SIZEY)

#ifndef CAMERA_MOTION_BLUR_MODE
// 0-off; 1-on; 2-override
#define CAMERA_MOTION_BLUR_MODE 1
#endif


//------------------------------------------------------- PARAMETERS

SCREEN_PASS_TEXTURE_VIEWPORT(Velocity)
SCREEN_PASS_TEXTURE_VIEWPORT(VelocityTile)

#if CAMERA_MOTION_BLUR_MODE == 2
float4x4 ClipToPrevClipOverride;
#endif

float MotionBlur_AspectRatio;
float MotionBlur_VelocityScale;
float MotionBlur_VelocityScaleForTiles;
float MotionBlur_VelocityMax;

Texture2D VelocityTexture;
Texture2D VelocityTileTexture;
Texture2D DepthTexture;

RWTexture2D<float4>	OutVelocityFlatTexture;
RWTexture2D<float4>	OutVelocityTileTexture;

//------------------------------------------------------- LDS

groupshared float4 Shared[THREADGROUP_TOTALSIZE];


//------------------------------------------------------- FUNCTIONS

float2 GetCameraMotionVelocity(uint3 DispatchThreadId, float Depth, float4x4 ClipToPrevClip)
{
	// Compute velocity due to camera motion.
	float2 ViewportUV = ((float2)DispatchThreadId.xy + 0.5) / Velocity_ViewportSize;
	float2 ScreenPos = 2 * float2(ViewportUV.x, 1 - ViewportUV.y) - 1;
	float4 ThisClip = float4(ScreenPos, Depth, 1);
	float4 PrevClip = mul(ThisClip, ClipToPrevClip);
	float2 PrevScreen = PrevClip.xy / PrevClip.w;
	return ScreenPos - PrevScreen;
}


//------------------------------------------------------- ENTRY POINT

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex) 
{ 
	int2 PixelPos = min(DispatchThreadId.xy + Velocity_ViewportMin, Velocity_ViewportMax - 1);
	int2 DepthOffset = 0;

	{
		const int Cross = 1;
		// For motion vector, use camera/dynamic motion from min depth pixel in pattern around pixel.
		// This enables better quality outline on foreground against different motion background.
		
		half4 Depths;
		Depths.x = DepthTexture[ PixelPos + int2(-Cross, -Cross) ].x;
		Depths.y = DepthTexture[ PixelPos + int2( Cross, -Cross) ].x;
		Depths.z = DepthTexture[ PixelPos + int2(-Cross,  Cross) ].x;
		Depths.w = DepthTexture[ PixelPos + int2( Cross,  Cross) ].x;

		DepthOffset = Cross;
		int DepthOffsetXx = Cross;

		// Nearest depth is the largest depth (depth surface 0=far, 1=near).
		if(Depths.x > Depths.y) 
		{
			DepthOffsetXx = -Cross;
		}
		if(Depths.z > Depths.w) 
		{
			DepthOffset.x = -Cross;
		}
		half DepthsXY = max(Depths.x, Depths.y);
		half DepthsZW = max(Depths.z, Depths.w);
		if(DepthsXY > DepthsZW) 
		{
			DepthOffset.y = -Cross;
			DepthOffset.x = DepthOffsetXx; 
		}
	}

	float4 EncodedVelocity = VelocityTexture[ PixelPos + DepthOffset ];
	float Depth = DepthTexture[ PixelPos + DepthOffset ].x;

	float2 Velocity = 0.0f;
	if (EncodedVelocity.x > 0.0)
	{
		Velocity = DecodeVelocityFromTexture(EncodedVelocity).xy;
#if CAMERA_MOTION_BLUR_MODE != 1
		// Cancel motion blur caused by the current camera movements
		Velocity -= GetCameraMotionVelocity(DispatchThreadId, Depth, View.ClipToPrevClip);
#endif
#if CAMERA_MOTION_BLUR_MODE == 2
		// Apply motion blur caused by the custom camera movements
		Velocity += GetCameraMotionVelocity(DispatchThreadId, Depth, ClipToPrevClipOverride);
#endif
	}
#if CAMERA_MOTION_BLUR_MODE > 0
	else
	{
#if CAMERA_MOTION_BLUR_MODE == 2
		// Apply motion blur caused by the custom camera movements
		Velocity = GetCameraMotionVelocity(DispatchThreadId, Depth, ClipToPrevClipOverride);
#else
		// Apply motion blur caused by the current camera movements
		Velocity = GetCameraMotionVelocity(DispatchThreadId, Depth, View.ClipToPrevClip);
#endif
	}
#endif

	Velocity.y *= -MotionBlur_AspectRatio;

	float2 VelocityPolar = CartesianToPolar(Velocity);

	// If the velocity vector was zero length, VelocityPolar will contain NaNs.
	if (any(isnan(VelocityPolar)))
	{
		VelocityPolar = float2(0.0f, 0.0f);
	}

	bool bInsideViewport = all(PixelPos.xy < Velocity_ViewportMax);

	// 11:11:10  (VelocityLength, VelocityAngle, Depth)
	float2 EncodedPolarVelocity;
	EncodedPolarVelocity.x = VelocityPolar.x;
	EncodedPolarVelocity.y = VelocityPolar.y * (0.5 / PI) + 0.5;

	BRANCH
	if (bInsideViewport)
	{
		OutVelocityFlatTexture[PixelPos] = float3(EncodedPolarVelocity, ConvertFromDeviceZ(Depth)).xyzz;
	}

	// Limit velocity
	VelocityPolar.x = min(VelocityPolar.x, MotionBlur_VelocityMax / MotionBlur_VelocityScale);

	float4 VelocityMinMax = VelocityPolar.xyxy;
	VelocityMinMax.x = bInsideViewport ? VelocityMinMax.x : 2;
	VelocityMinMax.z = bInsideViewport ? VelocityMinMax.z : 0;

	Shared[GroupIndex] = VelocityMinMax;

	GroupMemoryBarrierWithGroupSync();

#if THREADGROUP_TOTALSIZE > 512
	if (GroupIndex < 512) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 512]);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 256
	if (GroupIndex < 256) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 256]);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 128
	if (GroupIndex < 128) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 128]);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 64
	if (GroupIndex <  64) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  64]);
	GroupMemoryBarrierWithGroupSync();
#endif

	// Safe for vector sizes 32 or larger, AMD and NV
	// TODO Intel variable size vector
	if (GroupIndex < 32) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 32]);
	if (GroupIndex < 16) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 16]);
	if (GroupIndex <  8) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  8]);
	if (GroupIndex <  4) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  4]);
	if (GroupIndex <  2) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  2]);
	if (GroupIndex <  1) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  1]);

	if (GroupIndex == 0)
	{
		OutVelocityTileTexture[GroupId.xy] = float4(PolarToCartesian(Shared[0].xy), PolarToCartesian(Shared[0].zw));
	}
}
