// Copyright Epic Games, Inc. All Rights Reserved.

#include "MotionBlurCommon.ush"
#include "../Random.ush"


//------------------------------------------------------- CONSTANTS

// from the paper: We use SOFT Z EXTENT = 1mm to 10cm for our results
#define SOFT_Z_EXTENT 1

#define MOTION_BLUR_QUALITY_LOW 0
#define MOTION_BLUR_QUALITY_MEDIUM 1
#define MOTION_BLUR_QUALITY_HIGH 2
#define MOTION_BLUR_QUALITY_VERY_HIGH 2


//------------------------------------------------------- PARAMETERS

float MotionBlur_AspectRatio;
float MotionBlur_VelocityScale;
float MotionBlur_VelocityScaleForTiles;
float MotionBlur_VelocityMax;

SCREEN_PASS_TEXTURE_VIEWPORT(Color)
SCREEN_PASS_TEXTURE_VIEWPORT(Velocity)
SCREEN_PASS_TEXTURE_VIEWPORT(VelocityTile)
FScreenTransform ColorToVelocity;

Texture2D ColorTexture;
Texture2D VelocityTexture;
Texture2D VelocityTileTexture;
Texture2D VelocityFlatTexture;
Texture2D DepthTexture;

SamplerState ColorSampler;
SamplerState VelocitySampler;
SamplerState VelocityTileSampler;
SamplerState VelocityFlatSampler;
SamplerState DepthSampler;

#if USE_POST_MOTION_BLUR_TRANSLUCENCY

Texture2D PostMotionBlurTranslucencyTexture;
SamplerState PostMotionBlurTranslucencySampler;

float2 ScreenPosToPostMotionBlurTranslucencyUV;
float2 PostMotionBlurTranslucencyUVMax;

#endif // USE_POST_MOTION_BLUR_TRANSLUCENCY

#if SUPPORTS_INDEPENDENT_SAMPLERS
	#define SharedVelocitySampler VelocitySampler
	#define SharedVelocityTileSampler VelocitySampler
	#define SharedVelocityFlatSampler VelocitySampler
	#define SharedDepthSampler VelocitySampler
#else
	#define SharedVelocitySampler VelocitySampler
	#define SharedVelocityTileSampler VelocityTileSampler
	#define SharedVelocityFlatSampler VelocityFlatSampler
	#define SharedDepthSampler DepthSampler
#endif

//------------------------------------------------------- LDS

#if COMPUTESHADER && !COMPILER_SUPPORTS_WAVE_VOTE

groupshared uint GroupSharedFastPath;

#endif


//------------------------------------------------------- FUNCTIONS

uint GetStepCountFromQuality()
{
#if MOTION_BLUR_QUALITY == MOTION_BLUR_QUALITY_LOW
	return 4;
#elif MOTION_BLUR_QUALITY == MOTION_BLUR_QUALITY_MEDIUM
	return 6;
#elif MOTION_BLUR_QUALITY == MOTION_BLUR_QUALITY_HIGH
	return 8;
#else // MOTION_BLUR_QUALITY == MOTION_BLUR_QUALITY_VERY_HIGH
	return 16;
#endif
}

float2 DepthCmp(float CenterDepth, float SampleDepth, float DepthScale)
{
	return saturate(0.5 + float2(DepthScale, -DepthScale) * (SampleDepth - CenterDepth));
}

float2 SpreadCmp(float OffsetLength, float2 SpreadLength, float PixelToSampleScale)
{
	return saturate(PixelToSampleScale * SpreadLength - max(OffsetLength - 1, 0));
}

float SampleWeight(float CenterDepth, float SampleDepth, float OffsetLength, float CenterSpreadLength, float SampleSpreadLength, float PixelToSampleScale, float DepthScale)
{
	float2 DepthWeights = DepthCmp(CenterDepth, SampleDepth, DepthScale);
	float2 SpreadWeights = SpreadCmp(OffsetLength, float2(CenterSpreadLength, SampleSpreadLength), PixelToSampleScale);
	return dot(DepthWeights, SpreadWeights);
}

float2 DecodeVelocity(float2 Velocity)
{
	// 11:11:10  (VelocityLength, VelocityAngle, Depth)
	float VelocityLength = Velocity.x;
	float VelocityAngle = Velocity.y * (2 * PI) - PI;
	sincos(VelocityAngle, Velocity.x, Velocity.y);
	Velocity *= VelocityLength;
	return Velocity;
}

float GetVelocityLengthPixels(float2 EncodedVelocity)
{
	// 11:11:10  (VelocityLength, VelocityAngle, Depth)
	float VelocityLength = EncodedVelocity.x;
	VelocityLength *= MotionBlur_VelocityScale;
	return min(VelocityLength, MotionBlur_VelocityMax);
}


//------------------------------------------------------- ENTRY POINT

float4 MainMotionBlurCommon(float2 ColorUV, float2 ColorPixelPos)
{
	const uint StepCount = GetStepCountFromQuality() / 2;

	const float PixelToTileScale = (1.0 / 16.0);

	float Random  = InterleavedGradientNoise(ColorPixelPos, 0);
	float Random2 = InterleavedGradientNoise(ColorPixelPos, 1);

	// [-0.25, 0.25]
	float2 TileJitter = (float2(Random, Random2) - 0.5) * 0.5;

	// Map color UV to velocity UV space.
	float2 VelocityUV = ApplyScreenTransform(ColorUV, ColorToVelocity);

	// Map velocity UV to velocity tile UV space with jitter.
	float2 NearestVelocitySvPosition = floor(VelocityUV * Velocity_Extent) + 0.5;
	float2 VelocityTileUV = ((NearestVelocitySvPosition - Velocity_ViewportMin) * PixelToTileScale + TileJitter) * VelocityTile_ExtentInverse;

	// Velocity tile UV originates at [0,0]; only need to clamp max.
	VelocityTileUV = min(VelocityTileUV, VelocityTile_UVViewportBilinearMax);

	float4 MinMaxVelocity = VelocityTileTexture.SampleLevel(SharedVelocityTileSampler, VelocityTileUV, 0);

	float2 MinVelocityPixels = MinMaxVelocity.xy * MotionBlur_VelocityScale;
	float2 MaxVelocityPixels = MinMaxVelocity.zw * MotionBlur_VelocityScale;

	float MinVelocityLengthSqrPixels = dot(MinVelocityPixels, MinVelocityPixels);
	float MaxVelocityLengthSqrPixels = dot(MaxVelocityPixels, MaxVelocityPixels);

	// Input buffer 0 as same viewport as output buffer.
	float4 CenterColor = ColorTexture.SampleLevel(ColorSampler, ColorUV, 0);

	float4 SearchVectorPixels = float4(MaxVelocityPixels, -MaxVelocityPixels);
	float4 SearchVector = SearchVectorPixels * Color_ExtentInverse.xyxy;

	// converts pixel length to sample steps
	float PixelToSampleScale = StepCount * rsqrt(dot(MaxVelocityPixels, MaxVelocityPixels));	
		
	#if USE_POST_MOTION_BLUR_TRANSLUCENCY
		const float2 PostMotionBlurTranslucencyUV = min((ColorPixelPos + (float2)0.5f) * ScreenPosToPostMotionBlurTranslucencyUV, PostMotionBlurTranslucencyUVMax);
		float4 PostMotionBlurTranslucency = PostMotionBlurTranslucencyTexture.SampleLevel(PostMotionBlurTranslucencySampler, PostMotionBlurTranslucencyUV, 0);
	#endif

	
	// TODO expose cvars
	bool bSkipPath = MaxVelocityLengthSqrPixels < 0.25;
	bool bFastPath = MinVelocityLengthSqrPixels > 0.4 * MaxVelocityLengthSqrPixels;

	// Only use fast path if all threads of the compute shader would.
	#if COMPILER_SUPPORTS_WAVE_VOTE
	{
		bFastPath = WaveActiveAllTrue(bFastPath);
	}
	#elif COMPUTESHADER
	{
		GroupSharedFastPath = 0;
		GroupMemoryBarrierWithGroupSync();

		uint IgnoredOut;
		InterlockedAdd(GroupSharedFastPath, bFastPath ? 1 : 0);
		
		GroupMemoryBarrierWithGroupSync();
		bFastPath = (GroupSharedFastPath == (THREADGROUP_SIZEX * THREADGROUP_SIZEY));
	}
	#endif
	
	BRANCH
	if (bSkipPath)
	{
		#if USE_POST_MOTION_BLUR_TRANSLUCENCY
			CenterColor.rgb = CenterColor.rgb * PostMotionBlurTranslucency.a + PostMotionBlurTranslucency.rgb;
		#endif
		#if !POST_PROCESS_ALPHA
			CenterColor.a = 0;
		#endif
		return CenterColor;
	}

	float4 OutColor = 0;

	BRANCH
	if (bFastPath)
	{
		float4 ColorAccum = 0;

		UNROLL
		for (uint i = 0; i < StepCount; i++)
		{
			float2 OffsetLength = (float)i + 0.5 + float2(Random - 0.5, 0.5 - Random);
			float2 OffsetFraction = OffsetLength / StepCount;

			float2 SampleUV[2];
			SampleUV[0] = ColorUV + OffsetFraction.x * SearchVector.xy;
			SampleUV[1] = ColorUV + OffsetFraction.y * SearchVector.zw;

			SampleUV[0] = clamp(SampleUV[0], Color_UVViewportBilinearMin, Color_UVViewportBilinearMax);
			SampleUV[1] = clamp(SampleUV[1], Color_UVViewportBilinearMin, Color_UVViewportBilinearMax);

			ColorAccum += ColorTexture.SampleLevel(ColorSampler, SampleUV[0], 0);
			ColorAccum += ColorTexture.SampleLevel(ColorSampler, SampleUV[1], 0);
		}
	
		ColorAccum *= 0.5 / StepCount;

		OutColor = ColorAccum;
	}
	else
	{
		float3 CenterVelocityDepth = VelocityFlatTexture.SampleLevel(SharedVelocityFlatSampler, VelocityUV, 0).xyz;
		float  CenterDepth = CenterVelocityDepth.z;
		float  CenterVelocityLength = GetVelocityLengthPixels(CenterVelocityDepth.xy);

		float4 ColorAccum = 0;
		float  ColorAccumWeight = 0;

		UNROLL
		for (uint i = 0; i < StepCount; i++)
		{
			float2 SampleUV[2];
			float4 SampleColor[2];
			float  SampleDepth[2];
			float  SampleVelocityLength[2];
			float  Weight[2];

			float2 OffsetLength = (float)i + 0.5 + float2(Random - 0.5, 0.5 - Random);
			float2 OffsetFraction = OffsetLength / StepCount;

			SampleUV[0] = ColorUV + OffsetFraction.x * SearchVector.xy;
			SampleUV[1] = ColorUV + OffsetFraction.y * SearchVector.zw;

			SampleUV[0] = clamp(SampleUV[0], Color_UVViewportBilinearMin, Color_UVViewportBilinearMax);
			SampleUV[1] = clamp(SampleUV[1], Color_UVViewportBilinearMin, Color_UVViewportBilinearMax);

			UNROLL
			for (uint j = 0; j < 2; j++)
			{
				float3 SampleVelocityDepth = VelocityFlatTexture.SampleLevel(
					SharedVelocityFlatSampler, ApplyScreenTransform(SampleUV[j], ColorToVelocity), 0).xyz;

				SampleColor[j] = ColorTexture.SampleLevel(ColorSampler, SampleUV[j], 0);
				SampleDepth[j] = SampleVelocityDepth.z;

				// in pixels
				SampleVelocityLength[j] = GetVelocityLengthPixels(SampleVelocityDepth.xy);

				Weight[j] = SampleWeight(CenterDepth, SampleDepth[j], OffsetLength.x, CenterVelocityLength, SampleVelocityLength[j], PixelToSampleScale, SOFT_Z_EXTENT);
			}
		
			bool2 Mirror = bool2(SampleDepth[0] > SampleDepth[1], SampleVelocityLength[1] > SampleVelocityLength[0]);
			Weight[0] = all(Mirror) ? Weight[1] : Weight[0];
			Weight[1] = any(Mirror) ? Weight[1] : Weight[0];
			
			ColorAccum += Weight[0] * SampleColor[0] + Weight[1] * SampleColor[1];
			ColorAccumWeight += Weight[0] + Weight[1];
		}
	
		ColorAccum			*= 0.5 / StepCount;
		ColorAccumWeight	*= 0.5 / StepCount;

		OutColor = ColorAccum + (1 - ColorAccumWeight) * CenterColor;
	}
	
#if USE_POST_MOTION_BLUR_TRANSLUCENCY
	OutColor.rgb = OutColor.rgb * PostMotionBlurTranslucency.a + PostMotionBlurTranslucency.rgb;
#endif

#if !POST_PROCESS_ALPHA
	OutColor.a = 0;
#endif

	return OutColor;
}

void MainPS(
	in noperspective float4 UVAndScreenPos : TEXCOORD0,
	in float4 SvPosition : SV_Position,
	out float4 OutColor : SV_Target0)
{
	float2 ColorUV = UVAndScreenPos.xy;
	OutColor = MainMotionBlurCommon(ColorUV, floor(SvPosition.xy));
}

#if COMPUTESHADER
RWTexture2D<float4> OutColorTexture;

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 iColorPixelPos = DispatchThreadId + Color_ViewportMin;
	float2 ColorPixelPos = float2(iColorPixelPos);
	float2 ColorUV = (ColorPixelPos + 0.5) * Color_ExtentInverse;

	float4 OutColor = MainMotionBlurCommon(ColorUV, ColorPixelPos);

	if (all(iColorPixelPos < Color_ViewportMax))
	{
		OutColorTexture[iColorPixelPos] = OutColor;
	}
}
#endif
