// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"

#define SUPPORT_CONTACT_SHADOWS 0

#include "/Engine/Generated/Material.ush"
#include "../PositionReconstructionCommon.ush"
#include "../MortonCode.ush"
#include "../ComputeShaderUtils.ush"
#include "../Hash.ush"
#include "../HashTable.ush"
#include "HeterogeneousVolumesLiveShadingUtils.ush"


#ifndef THREADGROUP_SIZE_3D
#define THREADGROUP_SIZE_3D 1
#endif // THREADGROUP_SIZE_3D

// Object data
float4x4 LocalToWorld;
float4x4 WorldToLocal;
float3 LocalBoundsOrigin;
float3 LocalBoundsExtent;
int PrimitiveId;

// Volume data
int3 VolumeResolution;

// Output
RWTexture3D<float3> RWExtinctionTexture;
RWTexture3D<float3> RWEmissionTexture;
RWTexture3D<float3> RWAlbedoTexture;

FPrimitiveSceneData GetPrimitiveData(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters, LocalToWorld, WorldToLocal, LocalBoundsOrigin, LocalBoundsExtent);
}

[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void HeterogeneousVolumesBakeMaterialCS(
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID
)
{
	uint3 VoxelIndex = DispatchThreadId;
	if (all(VoxelIndex < VolumeResolution))
	{
		float3 UVW = (VoxelIndex + 0.5) / float3(VolumeResolution);
		float3 LocalBoundsMin = LocalBoundsOrigin - LocalBoundsExtent;
		float3 LocalPosition = UVW * 2.0 * LocalBoundsExtent + LocalBoundsMin;
		float3 WorldPosition = mul(float4(LocalPosition, 1.0), LocalToWorld).xyz;

		// Setup evaluation context
		FMaterialPixelParameters MaterialParameters = MakeInitializedMaterialPixelParameters();
		MaterialParameters.PrimitiveId = PrimitiveId;
		MaterialParameters.AbsoluteWorldPosition = LWCPromote(WorldPosition);

		// Evaluate material graph
		FPixelMaterialInputs PixelMaterialInputs;
		CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);

		// Extract volume rendering coefficients
		RWExtinctionTexture[VoxelIndex] = SampleExtinctionCoefficients(PixelMaterialInputs);
		RWEmissionTexture[VoxelIndex] = SampleEmissive(PixelMaterialInputs);
		RWAlbedoTexture[VoxelIndex] = SampleAlbedo(PixelMaterialInputs);
	}
}

// Global transmittance volume

#include "HeterogeneousVolumesVoxelGridTypes.ush"
#include "HeterogeneousVolumesVoxelGridUtils.ush"

int3 TopLevelGridResolution;
float3 TopLevelGridWorldBoundsMin;
float3 TopLevelGridWorldBoundsMax;

float3 PrimitiveWorldBoundsMin;
float3 PrimitiveWorldBoundsMax;

int BottomLevelGridBufferSize;

void CalcVoxelBounds(float3 VoxelIndex, inout float3 VoxelBoundsMin, inout float3 VoxelBoundsMax)
{
	float3 TopLevelGridWorldBoundsExtent = TopLevelGridWorldBoundsMax - TopLevelGridWorldBoundsMin;
	VoxelBoundsMin = TopLevelGridWorldBoundsMin + TopLevelGridWorldBoundsExtent * (VoxelIndex / TopLevelGridResolution);
	VoxelBoundsMax = TopLevelGridWorldBoundsMin + TopLevelGridWorldBoundsExtent * ((VoxelIndex + 1) / TopLevelGridResolution);
}

float3 GetVoxelCenter(float3 VoxelIndex, inout float3 VoxelBoundsMin, inout float3 VoxelBoundsMax)
{
	float3 TopLevelGridWorldBoundsExtent = TopLevelGridWorldBoundsMax - TopLevelGridWorldBoundsMin;
	return TopLevelGridWorldBoundsMin + TopLevelGridWorldBoundsExtent * ((VoxelIndex + 0.5) / TopLevelGridResolution);
}

bool PrimitiveIntersectsVoxel(float3 VoxelBoundsMin, float3 VoxelBoundsMax)
{
	if (any(PrimitiveWorldBoundsMin > VoxelBoundsMax) || any(VoxelBoundsMin > PrimitiveWorldBoundsMax))
	{
		return false;
	}

	return true;
}

struct FRasterTileData
{
	uint TopLevelGridLinearIndex;
	uint BottomLevelGridLinearOffset;
};

Buffer<uint> RasterTileAllocatorBuffer;
StructuredBuffer<FRasterTileData> RasterTileBuffer;

RWStructuredBuffer<uint> RWTopLevelGridBuffer;
RWBuffer<uint> RWBottomLevelGridAllocatorBuffer;

RWStructuredBuffer<FScalarGridData> RWExtinctionGridBuffer;
RWStructuredBuffer<FVectorGridData> RWEmissionGridBuffer;
RWStructuredBuffer<FVectorGridData> RWScatteringGridBuffer;

// Indirection Grid
int FixedBottomLevelResolution;
RWStructuredBuffer<FTopLevelGridData> RWIndirectionGridBuffer;

// Hash index to voxel index
RWBuffer<uint> RWHashToVoxelBuffer;

// Sampling mode
int bSampleAtVertices;

float HomogeneousThreshold;

groupshared float3 Extinction[THREADGROUP_SIZE_1D];
groupshared float3 ExtinctionSum[THREADGROUP_SIZE_1D];
groupshared float ExtinctionVariance[THREADGROUP_SIZE_1D];
groupshared float ZeroCrossings[THREADGROUP_SIZE_1D];
groupshared FTopLevelGridData AllocatedGridData;
groupshared int3 AllocatedVoxelResolution;
groupshared int AllocatedVoxelCount;

float GetZeroThreshold()
{
	return 1.0e-6;
}

float CalcSampleVariance(float3 MeanValue, float3 SampleValue)
{
	float3 SampleVariance = MeanValue - SampleValue;
	return dot(SampleVariance, SampleVariance);
}

float CalcZeroCrossing(float3 SampleValue)
{
	float EmptyVoxelThreshold = 1.0e-5;
	return all(SampleValue < EmptyVoxelThreshold) ? 1.0 : 0.0;
}

uint2 CalcStencil(uint VoxelCount)
{
	//int x = i % 4;
	//int y = i / 4;
	//int z = i % 16;
	uint2 Stencil = 0;
	
	float ZeroThreshold = GetZeroThreshold();
	for (int i = 0; i < min(VoxelCount, 32); ++i)
	{
		int bit = i;
		Stencil[0] |= any(Extinction[i] > ZeroThreshold) ? 1 << bit : 0;
	}
	
	for (i = 32; i < min(VoxelCount, 64); ++i)
	{
		int bit = i - 32;
		Stencil[1] |= any(Extinction[i] > ZeroThreshold) ? 1 << bit : 0;
	}

	return Stencil;
}

float ExtinctionMax()
{
	return 0.01;
}

float ExtinctionFixedPointCeiling()
{
	//int QuantizeBits = 16;
	int QuantizeBits = 8;
	return 1 << QuantizeBits;
}

// TODO: Parallel
uint QuantizeOpticalThickness(uint VoxelCount)
{
	float ZeroThreshold = GetZeroThreshold();

	float3 ExtinctionMean = 0;
	uint NonZeroCount = 0;
	for (uint i = 0; i < VoxelCount; ++i)
	{
		if (any(Extinction[i] > ZeroThreshold))
		{
			ExtinctionMean += Extinction[i];
			NonZeroCount++;
		}
	}

	if (NonZeroCount > 0)
	{
		ExtinctionMean /= NonZeroCount;
	}

	return Luminance(ExtinctionMean) / ExtinctionMax() * ExtinctionFixedPointCeiling();
}

// TODO: Parallel
float3 QuantizeExtinction(uint VoxelCount)
{
	float ZeroThreshold = GetZeroThreshold();

	float3 ExtinctionMean = 0;
	uint NonZeroCount = 0;
	for (uint i = 0; i < VoxelCount; ++i)
	{
		if (any(Extinction[i] > ZeroThreshold))
		{
			ExtinctionMean += Extinction[i];
			NonZeroCount++;
		}
	}

	if (NonZeroCount > 0)
	{
		ExtinctionMean /= NonZeroCount;
	}

	uint3 QuantizedValue = ExtinctionMean / ExtinctionMax() * ExtinctionFixedPointCeiling();
	return QuantizedValue / ExtinctionFixedPointCeiling() * ExtinctionMax();
}

uint CalcBottomLevelHashKey(uint VoxelCount)
{
	uint HashKey = 0;

	// Hash Resolution
	HashKey = MurmurMix(VoxelCount);

	// Hash quantized average optical thickness
	//HashKey = MurmurAdd(HashKey, QuantizeOpticalThickness(VoxelCount));
	float3 QuantizedExtinction = QuantizeExtinction(VoxelCount);
	uint QuantizedValue = Luminance(QuantizedExtinction / ExtinctionMax()) * ExtinctionFixedPointCeiling();
	HashKey = MurmurAdd(HashKey, QuantizedValue);

	// Hash bottom-voxel stencil
	uint2 Stencil = CalcStencil(VoxelCount);
	HashKey = MurmurAdd(HashKey, Stencil[0]);
	HashKey = MurmurAdd(HashKey, Stencil[1]);

	return HashKey;
}

bool HashTableFind2(uint Key, out uint Index)
{
	// Zero is reserved as invalid
	Key++;

	uint NumLoops = 0;
	LOOP
		[allow_uav_condition]
	for (Index = MurmurMix(Key);; Index++)
	{
		//Belt and braces safety code to prevent inf loops if tables are malformed.
		if (++NumLoops > HashTableSize)
		{
			break;
		}

		//Index &= HashTableSize - 1;
		Index = Index % HashTableSize;

		uint StoredKey = RWHashTable[Index];
		if (StoredKey != Key)
		{
			if (StoredKey != 0)
				continue;
		}
		else
		{
			return true;
		}

		break;
	}

	return false;
}

[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void RasterizeBottomLevelGridCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID
)
{
	uint RasterTileIndex = GetUnWrappedDispatchGroupId(GroupId);
	if (RasterTileIndex >= RasterTileAllocatorBuffer[0])
	{
		return;
	}

	uint LinearThreadIndex = MortonEncode3(GroupThreadId);
	Extinction[LinearThreadIndex] = 0.0;

	uint TopLevelGridLinearIndex = RasterTileBuffer[RasterTileIndex].TopLevelGridLinearIndex;
	uint3 TopLevelGridVoxelIndex = GetVoxelIndex(TopLevelGridLinearIndex, TopLevelGridResolution);

	float3 TopLevelGridVoxelWorldBoundsMin;
	float3 TopLevelGridVoxelWorldBoundsMax;
	CalcVoxelBounds(TopLevelGridVoxelIndex, TopLevelGridVoxelWorldBoundsMin, TopLevelGridVoxelWorldBoundsMax);
	float3 TopLevelGridVoxelWorldBoundsExtent = TopLevelGridVoxelWorldBoundsMax - TopLevelGridVoxelWorldBoundsMin;

	// Note: Raster tiles map to non-empty voxels by definition
	if (PrimitiveIntersectsVoxel(TopLevelGridVoxelWorldBoundsMin, TopLevelGridVoxelWorldBoundsMax))
	{
		// Map thread id to voxel-space position
		uint BottomLevelGridLinearOffset = RasterTileBuffer[RasterTileIndex].BottomLevelGridLinearOffset;

		FTopLevelGridData TopLevelGridData = CreateTopLevelGridData(RWTopLevelGridBuffer[TopLevelGridLinearIndex]);
		int3 BottomLevelVoxelResolution = GetBottomLevelVoxelResolution(TopLevelGridData);

	#if DIM_ENABLE_INDIRECTION_GRID
		int3 BottomLevelVoxelIndex = MortonDecode3(BottomLevelGridLinearOffset) * THREADGROUP_SIZE_3D + GroupThreadId;
		BottomLevelVoxelResolution *= FixedBottomLevelResolution;
	#else
		int3 BottomLevelVoxelIndex = GetVoxelIndex(BottomLevelGridLinearOffset * THREADGROUP_SIZE_1D + MortonEncode3(GroupThreadId), BottomLevelVoxelResolution);
	#endif

		float3 Emission = 0;
		float3 Albedo = 0;
		if (all(BottomLevelVoxelIndex < BottomLevelVoxelResolution))
		{
#if 1
			float3 UVW;
			if (bSampleAtVertices)
			{
				UVW = BottomLevelVoxelIndex / float3(BottomLevelVoxelResolution - 1);
			}
			else
			{
				UVW = float3(BottomLevelVoxelIndex + 0.5) / float3(BottomLevelVoxelResolution);
			}
			float3 WorldPosition = UVW * TopLevelGridVoxelWorldBoundsExtent + TopLevelGridVoxelWorldBoundsMin;

			// Setup evaluation context
			FMaterialPixelParameters MaterialParameters = MakeInitializedMaterialPixelParameters();
			MaterialParameters.PrimitiveId = PrimitiveId;
			MaterialParameters.AbsoluteWorldPosition = LWCPromote(WorldPosition);

			// Evaluate material graph
			FPixelMaterialInputs PixelMaterialInputs;
			CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);

			// Extract volume rendering coefficients
			Extinction[LinearThreadIndex] = SampleExtinctionCoefficients(PixelMaterialInputs);
			Emission = SampleEmissive(PixelMaterialInputs);
			//Albedo = SampleAlbedo(PixelMaterialInputs);
			Albedo = SampleAlbedo(PixelMaterialInputs) * Extinction[LinearThreadIndex];
#else
			Extinction[LinearThreadIndex] = 0.01;
#endif
		}

	#if DIM_ENABLE_INDIRECTION_GRID
		AllocatedVoxelResolution = FixedBottomLevelResolution;
	#else
		AllocatedVoxelResolution = BottomLevelVoxelResolution;
	#endif
		if (all(GroupThreadId == 0))
		{
			AllocatedVoxelCount = AllocatedVoxelResolution.x * AllocatedVoxelResolution.y * AllocatedVoxelResolution.z;
		}

		GroupMemoryBarrier();

		// Sum contribution
#if 0
		ExtinctionSum[0] = 0;
		for (uint Index = 0; Index < THREADGROUP_SIZE_1D; ++Index)
		{
			ExtinctionSum[0] += Extinction[Index];
		}
#else
		ExtinctionSum[LinearThreadIndex] = Extinction[LinearThreadIndex];
		// Parallel Sum
		for (int NeighborOffset = 1; NeighborOffset < THREADGROUP_SIZE_1D; NeighborOffset = (NeighborOffset << 1))
		{
			int NeighborIndex = LinearThreadIndex + NeighborOffset;
			ExtinctionSum[LinearThreadIndex] += (NeighborIndex < THREADGROUP_SIZE_1D) ? ExtinctionSum[NeighborIndex] : 0.0;

			//GroupMemoryBarrierWithGroupSync();
			GroupMemoryBarrier();
		}
#endif

		GroupMemoryBarrierWithGroupSync();

#if DIM_ENABLE_HOMOGENEOUS_AGGREGATION
		// Calculate variance
		float3 ExtinctionMean = ExtinctionSum[0] * rcp(AllocatedVoxelCount);
		ExtinctionVariance[LinearThreadIndex] = CalcSampleVariance(ExtinctionMean, Extinction[LinearThreadIndex]);
		// Reuse ExtinctionSum..
		ZeroCrossings[LinearThreadIndex] = CalcZeroCrossing(Extinction[LinearThreadIndex]);

		// Parallel Sum
		for (NeighborOffset = 1; NeighborOffset < AllocatedVoxelCount; NeighborOffset = (NeighborOffset << 1))
		{
			int NeighborIndex = LinearThreadIndex + NeighborOffset;
			ExtinctionVariance[LinearThreadIndex] += (NeighborIndex < AllocatedVoxelCount) ? ExtinctionVariance[NeighborIndex] : 0.0;
			ZeroCrossings[LinearThreadIndex] += (NeighborIndex < AllocatedVoxelCount) ? ZeroCrossings[NeighborIndex] : 0.0;

			//GroupMemoryBarrierWithGroupSync();
			GroupMemoryBarrier();
		}
#if 0	
		// Linear Sum
		for (uint Index = 0; Index < AllocatedVoxelCount; ++Index)
		{
			ExtinctionVariance[0] += ExtinctionVariance[Index];
		}
#endif

		GroupMemoryBarrierWithGroupSync();
		ExtinctionVariance[0] *= rcp(AllocatedVoxelCount - 1);

		float StdRelError = sqrt(ExtinctionVariance[0] * rcp(AllocatedVoxelCount)) / ExtinctionMean;

		// Declare low-variance to constitute a region of homogeneity
		if (all(GroupThreadId == 0) && (StdRelError < HomogeneousThreshold) && (ZeroCrossings[0] < 4))
		{
			Extinction[0] = ExtinctionMean;
			AllocatedVoxelCount = AllocatedVoxelResolution = 1;
		}
#endif // #if DIM_ENABLE_HOMOGENEOUS_AGGREGATION

		bool bAllocate = true;
		uint BottomLevelIndex = EMPTY_VOXEL_INDEX;

	#if DIM_ENABLE_INDIRECTION_GRID
		uint IndirectionIndexOffset = GetBottomLevelIndex(TopLevelGridData);
		uint IndirectionGridLinearOffset = IndirectionIndexOffset + BottomLevelGridLinearOffset;

		FTopLevelGridData IndirectionData = RWIndirectionGridBuffer[IndirectionGridLinearOffset];
		bool bWasAlreadyAllocated = IsBottomLevelAllocated(IndirectionData);
		if (all(GroupThreadId == 0) && any(ExtinctionSum[0] > 1.0e-4) && !bWasAlreadyAllocated)
	#else
		bool bWasAlreadyAllocated = IsBottomLevelAllocated(TopLevelGridData);
		if (all(GroupThreadId == 0) && any(ExtinctionSum[0] > GetZeroThreshold()) && !bWasAlreadyAllocated)
	#endif
		{
			// Voxel Hashing
			uint HashIndex = 0;
	#if DIM_ENABLE_VOXEL_HASHING
			if (AllocatedVoxelCount == 1)
			{
				uint HashKey = CalcBottomLevelHashKey(AllocatedVoxelCount);
				bAllocate = !HashTableFind2(HashKey, HashIndex);
			}
	#endif // DIM_ENABLE_VOXEL_HASHING

#if 0
			// DEBUG: Only process aggregated voxels..
			if (AllocatedVoxelCount != 1)
			{
				BottomLevelIndex = EMPTY_VOXEL_INDEX;
				AllocatedVoxelCount = AllocatedVoxelResolution = 0;
				bAllocate = false;
			}
#endif

			// Otherwise allocate
			if (bAllocate)
			{
				InterlockedAdd(RWBottomLevelGridAllocatorBuffer[0], AllocatedVoxelCount, BottomLevelIndex);

				// Guard against over allocation
				if (BottomLevelIndex + AllocatedVoxelCount > BottomLevelGridBufferSize)
				{
					// Declare the buffer to be filled
					uint Dummy;
					InterlockedExchange(RWBottomLevelGridAllocatorBuffer[0], BottomLevelGridBufferSize, Dummy);

					BottomLevelIndex = EMPTY_VOXEL_INDEX;
					AllocatedVoxelCount = AllocatedVoxelResolution = 0;
				}
			}
	#if DIM_ENABLE_VOXEL_HASHING
			else
			{
				BottomLevelIndex = RWHashToVoxelBuffer[HashIndex];
			}
	#endif // DIM_ENABLE_VOXEL_HASHING

			// Update the index with the properly allocated index
			AllocatedGridData = TopLevelGridData;
			SetBottomLevelIndex(AllocatedGridData, BottomLevelIndex);
			SetBottomLevelVoxelResolution(AllocatedGridData, AllocatedVoxelResolution);

	#if DIM_ENABLE_INDIRECTION_GRID
			RWIndirectionGridBuffer[IndirectionGridLinearOffset] = AllocatedGridData;
	#else
			InterlockedCompareStore(RWTopLevelGridBuffer[TopLevelGridLinearIndex], TopLevelGridData.PackedData[0], AllocatedGridData.PackedData[0]);
	#endif
		}

		AllMemoryBarrierWithGroupSync();
		//AllMemoryBarrier();

#if DIM_ENABLE_VOXEL_HASHING
		// Compositing with hashed voxels should require copy-on-write, but it is not currently supported
		if (bAllocate && LinearThreadIndex < AllocatedVoxelCount)
#else
		if (LinearThreadIndex < AllocatedVoxelCount)
#endif
		{
	#if DIM_ENABLE_INDIRECTION_GRID
			FTopLevelGridData IndirectionData = RWIndirectionGridBuffer[IndirectionGridLinearOffset];

			if (IsBottomLevelAllocated(IndirectionData))
			{
				uint BottomLevelVoxelLinearIndex = GetBottomLevelIndex(IndirectionData) + LinearThreadIndex;

				if (bWasAlreadyAllocated)
				{
					Extinction[LinearThreadIndex] += GetExtinction(RWExtinctionGridBuffer[BottomLevelVoxelLinearIndex]);
					Emission += GetEmission(RWEmissionGridBuffer[BottomLevelVoxelLinearIndex]);
					Albedo += GetAlbedo(RWScatteringGridBuffer[BottomLevelVoxelLinearIndex]);
				}

				SetExtinction(RWExtinctionGridBuffer[BottomLevelVoxelLinearIndex], Extinction[LinearThreadIndex]);
				SetEmission(RWEmissionGridBuffer[BottomLevelVoxelLinearIndex], Emission);
				SetAlbedo(RWScatteringGridBuffer[BottomLevelVoxelLinearIndex], Albedo);
			}
	#else
			FTopLevelGridData TopLevelGridData = CreateTopLevelGridData(RWTopLevelGridBuffer[TopLevelGridLinearIndex]);

			if (IsBottomLevelAllocated(TopLevelGridData))
			{
				uint BottomLevelVoxelLinearIndex = GetBottomLevelIndex(TopLevelGridData) + MortonEncode3(BottomLevelVoxelIndex);

				if (bWasAlreadyAllocated)
				{
					Extinction[LinearThreadIndex] += GetExtinction(RWExtinctionGridBuffer[BottomLevelVoxelLinearIndex]);
					Emission += GetEmission(RWEmissionGridBuffer[BottomLevelVoxelLinearIndex]);
					Albedo += GetAlbedo(RWScatteringGridBuffer[BottomLevelVoxelLinearIndex]);
				}

				SetExtinction(RWExtinctionGridBuffer[BottomLevelVoxelLinearIndex], Extinction[LinearThreadIndex]);
				SetEmission(RWEmissionGridBuffer[BottomLevelVoxelLinearIndex], Emission);
				SetAlbedo(RWScatteringGridBuffer[BottomLevelVoxelLinearIndex], Albedo);
			}
	#endif
		}

	#if DIM_ENABLE_VOXEL_HASHING
		// Update deduplication structure
		if (all(GroupThreadId == 0) && AllocatedVoxelCount == 1)
		//if (all(GroupThreadId == 0) && any(ExtinctionSum[0] > GetZeroThreshold()) && bAllocate)
		{
			uint HashKey = CalcBottomLevelHashKey(AllocatedVoxelCount);
			uint HashIndex = 0;
			if (HashTableAdd(HashKey, HashIndex))
			{
				uint Dummy;
				InterlockedExchange(RWHashToVoxelBuffer[HashIndex], BottomLevelIndex, Dummy);
			}
		}
	#endif // DIM_ENABLE_VOXEL_HASHING
	}
}

int3 VoxelDimensions;
float4x4 ViewToWorld;

float HalfFOV;
float NearPlaneDepth;
float FarPlaneDepth;

#include "HeterogeneousVolumesFrustumVoxelGridUtils.ush"
#include "../BlueNoise.ush"

groupshared float GSExtinctionSum[THREADGROUP_SIZE_1D];

bool EvaluationPositionIntersectsPrimitive(float3 WorldPosition)
{
	return all(WorldPosition > PrimitiveWorldBoundsMin) && all(WorldPosition < PrimitiveWorldBoundsMax);
}

[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void RasterizeBottomLevelFroxelGridCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID
)
{
	uint RasterTileIndex = GetUnWrappedDispatchGroupId(GroupId);
	if (RasterTileIndex >= RasterTileAllocatorBuffer[0])
	{
		return;
	}

	uint TopLevelGridLinearIndex = RasterTileBuffer[RasterTileIndex].TopLevelGridLinearIndex;
	FTopLevelGridData TopLevelGridData = CreateTopLevelGridData(RWTopLevelGridBuffer[TopLevelGridLinearIndex]);
	int3 BottomLevelVoxelResolution = GetBottomLevelVoxelResolution(TopLevelGridData);

	// Setup evaluation context
	float3 TopLevelVoxelPos = GetVoxelIndex(TopLevelGridLinearIndex, TopLevelGridResolution);
	float3 BottomLevelVoxelPos = TopLevelVoxelPos * BottomLevelVoxelResolution + GroupThreadId;

	float2 JitterXY = 0.5;
	//float JitterZ = 0.5;
	float JitterZ = BlueNoiseScalar(BottomLevelVoxelPos.xy, View.StateFrameIndex);
	float3 Jitter = float3(JitterXY, JitterZ);

	float3 LocalVoxelPos = GroupThreadId + Jitter;
	float3 VoxelPosition = TopLevelVoxelPos + LocalVoxelPos / BottomLevelVoxelResolution;

	float3 ViewPos = VoxelToView(VoxelPosition, VoxelDimensions, NearPlaneDepth, FarPlaneDepth);
	float3 WorldPosition = mul(float4(ViewPos, 1), ViewToWorld).xyz;

	float3 Extinction = 0;
	float3 Emission = 0;
	float3 Albedo = 0;

	if (EvaluationPositionIntersectsPrimitive(WorldPosition))
	{
		FMaterialPixelParameters MaterialParameters = MakeInitializedMaterialPixelParameters();
		MaterialParameters.PrimitiveId = PrimitiveId;
		MaterialParameters.AbsoluteWorldPosition = LWCPromote(WorldPosition);

		// Evaluate material graph
		FPixelMaterialInputs PixelMaterialInputs;
		CalcPixelMaterialInputs(MaterialParameters, PixelMaterialInputs);

		// Rasterize coefficients
		Extinction = SampleExtinctionCoefficients(PixelMaterialInputs);
		Emission = SampleEmissive(PixelMaterialInputs);
		Albedo = SampleAlbedo(PixelMaterialInputs) * Extinction;
	}

	// Aggregate in group-shared memory
	uint LinearThreadIndex = MortonEncode3(GroupThreadId);
	GSExtinctionSum[LinearThreadIndex] = Luminance(Extinction);
	if (all(GroupThreadId == 0))
	{
		AllocatedVoxelCount = BottomLevelVoxelResolution.x * BottomLevelVoxelResolution.y * BottomLevelVoxelResolution.z;
	}
	GroupMemoryBarrierWithGroupSync();

	// Parallel Sum
	for (int NeighborOffset = 1; NeighborOffset < THREADGROUP_SIZE_1D; NeighborOffset = (NeighborOffset << 1))
	{
		int NeighborIndex = LinearThreadIndex + NeighborOffset;
		GSExtinctionSum[LinearThreadIndex] += (NeighborIndex < THREADGROUP_SIZE_1D) ? GSExtinctionSum[NeighborIndex] : 0.0;

		GroupMemoryBarrierWithGroupSync();
	}

	// Allocate if non-zero voxel data
	bool bWasAlreadyAllocated = IsBottomLevelAllocated(TopLevelGridData);
	float ZeroThreshold = 1.0e-6;
	if (all(GroupThreadId == 0) && any(GSExtinctionSum[0] > ZeroThreshold) && !bWasAlreadyAllocated)
	{
		uint3 AllocatedVoxelResolution = BottomLevelVoxelResolution;
		AllocatedVoxelCount = AllocatedVoxelResolution.x * AllocatedVoxelResolution.y * AllocatedVoxelResolution.z;

		uint BottomLevelIndex = 0;
		InterlockedAdd(RWBottomLevelGridAllocatorBuffer[0], AllocatedVoxelCount, BottomLevelIndex);

		// Guard against over allocation
		if (BottomLevelIndex + AllocatedVoxelCount > BottomLevelGridBufferSize)
		{
			// Declare the buffer to be filled
			uint Dummy;
			InterlockedExchange(RWBottomLevelGridAllocatorBuffer[0], BottomLevelGridBufferSize, Dummy);

			BottomLevelIndex = EMPTY_VOXEL_INDEX;
			AllocatedVoxelResolution = AllocatedVoxelCount = 0;
		}

		// Update the index with the properly allocated index
		FTopLevelGridData AllocatedGridData = TopLevelGridData;
		SetBottomLevelIndex(AllocatedGridData, BottomLevelIndex);
		SetBottomLevelVoxelResolution(AllocatedGridData, AllocatedVoxelResolution);

		InterlockedCompareStore(RWTopLevelGridBuffer[TopLevelGridLinearIndex], TopLevelGridData.PackedData[0], AllocatedGridData.PackedData[0]);
	}

	AllMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < AllocatedVoxelCount)
	{
		FTopLevelGridData TopLevelGridData = CreateTopLevelGridData(RWTopLevelGridBuffer[TopLevelGridLinearIndex]);
		if (IsBottomLevelAllocated(TopLevelGridData))
		{
			uint BottomLevelVoxelLinearIndex = GetBottomLevelIndex(TopLevelGridData) + LinearThreadIndex;

			if (bWasAlreadyAllocated)
			{
				Extinction += GetExtinction(RWExtinctionGridBuffer[BottomLevelVoxelLinearIndex]);
				Emission += GetEmission(RWEmissionGridBuffer[BottomLevelVoxelLinearIndex]);
				Albedo += GetAlbedo(RWScatteringGridBuffer[BottomLevelVoxelLinearIndex]);
			}

			SetExtinction(RWExtinctionGridBuffer[BottomLevelVoxelLinearIndex], Extinction);
			SetEmission(RWEmissionGridBuffer[BottomLevelVoxelLinearIndex], Emission);
			SetAlbedo(RWScatteringGridBuffer[BottomLevelVoxelLinearIndex], Albedo);
		}
	}
}