// Copyright Epic Games, Inc. All Rights Reserved.

#include "HeterogeneousVolumesTransmittanceVolumeUtils.ush"

#include "../ForwardShadowingCommon.ush"
#include "../VolumeLightingCommon.ush"

#ifndef HARDWARE_RAY_TRACING
#define HARDWARE_RAY_TRACING 0
#endif // HARDWARE_RAY_TRACING

#ifndef HARD_SURFACE_SHADOWING
#define HARD_SURFACE_SHADOWING 1
#endif // HARD_SURFACE_SHADOWING

struct FRayMarchingContext
{
	// Local-space
	float3 LocalRayOrigin;
	float3 LocalRayDirection;
	float LocalRayTMin;
	float LocalRayTMax;

	// World-space
	float3 WorldRayOrigin;
	float3 WorldRayDirection;

	// Ray-step attributes
	float Jitter;
	float StepSize;
	uint MaxStepCount;

	float MipLevel;

	// Lighting
	int bApplyEmissionAndTransmittance;
	int bApplyDirectLighting;
	int bApplyShadowTransmittance;
};

FRayMarchingContext CreateRayMarchingContext(
	// Local-space
	float3 LocalRayOrigin,
	float3 LocalRayDirection,
	float LocalRayTMin,
	float LocalRayTMax,
	// World-space
	float3 WorldRayOrigin,
	float3 WorldRayDirection,
	// Ray-step attributes
	float Jitter,
	float StepSize,
	uint MaxStepCount,
	// Lighting
	int bApplyEmissionAndTransmittance,
	int bApplyDirectLighting,
	int bApplyShadowTransmittance
)
{
	FRayMarchingContext Context = (FRayMarchingContext)0;

	// Local-space
	Context.LocalRayOrigin = LocalRayOrigin;
	Context.LocalRayDirection = LocalRayDirection;
	Context.LocalRayTMin = LocalRayTMin;
	Context.LocalRayTMax = LocalRayTMax;
	// World-space
	Context.WorldRayOrigin = WorldRayOrigin;
	Context.WorldRayDirection = WorldRayDirection;
	// Ray-step attributes
	Context.Jitter = Jitter;
	Context.StepSize = StepSize;
	Context.MaxStepCount = MaxStepCount;
	// Lighting
	Context.bApplyEmissionAndTransmittance = bApplyEmissionAndTransmittance;
	Context.bApplyDirectLighting = bApplyDirectLighting;
	Context.bApplyShadowTransmittance = bApplyShadowTransmittance;

	Context.MipLevel = 0.0f;

	return Context;
}

uint CalcStepCount(inout FRayMarchingContext Context)
{
	// Instead using the active ray-span, use the maximal ray-span so the stepsize is uniform among all rays
	//float HitSpan = length(Hit1 - Hit0)
	float HitSpan = length(GetLocalBoundsExtent());
	float StepSize = Context.StepSize;
	uint StepCount = max(ceil(HitSpan / StepSize), 1);
	if (StepCount > Context.MaxStepCount)
	{
		StepCount = Context.MaxStepCount;
		StepSize = HitSpan / StepCount;
	}

	Context.StepSize = StepSize;
	return StepCount;
}

void RayMarchTransmittance(
	inout FRayMarchingContext RayMarchingContext,
	uint StepCount,
	inout float3 Transmittance
)
{
	for (uint StepIndex = 0; StepIndex < StepCount; ++StepIndex)
	{
		float3 LocalPosition = RayMarchingContext.LocalRayOrigin + RayMarchingContext.LocalRayDirection * (RayMarchingContext.LocalRayTMin + RayMarchingContext.StepSize * StepIndex);
		float3 WorldPosition = RayMarchingContext.WorldRayOrigin + RayMarchingContext.WorldRayDirection * (RayMarchingContext.LocalRayTMin + RayMarchingContext.StepSize * StepIndex);

		FVolumeSampleContext SampleContext = CreateVolumeSampleContext(LocalPosition, WorldPosition, RayMarchingContext.MipLevel);
		float3 Extinction = SampleExtinction(SampleContext);
		Transmittance *= exp(-Extinction * RayMarchingContext.StepSize);

		float Epsilon = 1.0e-7;
		if (all(Transmittance < Epsilon))
		{
			Transmittance = 0.0;
			break;
		}
	}
}

float3 ComputeTransmittance(
	inout FRayMarchingContext RayMarchingContext
)
{
#if HARDWARE_RAY_TRACING
	return ComputeTransmittanceHardwareRayTracing(RayMarchingContext.WorldRayOrigin, RayMarchingContext.WorldRayDirection, RayMarchingContext.LocalRayTMin, RayMarchingContext.LocalRayTMax);
#else // HARDWARE_RAY_TRACING

	float3 Transmittance = 1.0;

	float3 LocalBoundsMin = GetLocalBoundsOrigin() - GetLocalBoundsExtent();
	float3 LocalBoundsMax = GetLocalBoundsOrigin() + GetLocalBoundsExtent();
	float2 HitT = IntersectAABB(RayMarchingContext.LocalRayOrigin, RayMarchingContext.LocalRayDirection, RayMarchingContext.LocalRayTMin, RayMarchingContext.LocalRayTMax,
		LocalBoundsMin, LocalBoundsMax);

	float HitSpan = HitT.y - HitT.x;
	if (HitSpan > 0.0)
	{
		RayMarchingContext.LocalRayTMin = HitT.x;
		RayMarchingContext.LocalRayTMax = HitT.y;
		uint StepCount = CalcStepCount(RayMarchingContext);

		RayMarchTransmittance(RayMarchingContext, StepCount, Transmittance);
	}

	return Transmittance;
#endif // HARDWARE_RAY_TRACING
}

void RayMarchEmissionAbsorption(
	inout FRayMarchingContext RayMarchingContext,
	uint StepCount,
	inout float3 Radiance,
	inout float3 Transmittance
)
{
	for (uint StepIndex = 0; StepIndex < StepCount; ++StepIndex)
	{
		float3 LocalPosition = RayMarchingContext.LocalRayOrigin + RayMarchingContext.LocalRayDirection * (RayMarchingContext.LocalRayTMin + RayMarchingContext.StepSize * StepIndex);
		float3 WorldPosition = RayMarchingContext.WorldRayOrigin + RayMarchingContext.WorldRayDirection * (RayMarchingContext.LocalRayTMin + RayMarchingContext.StepSize * StepIndex);

		FVolumeSampleContext SampleContext = CreateVolumeSampleContext(LocalPosition, WorldPosition, RayMarchingContext.MipLevel);
		float3 Extinction = SampleExtinction(SampleContext);

		float3 Emission = SampleEmission(SampleContext);
		Radiance += Emission * RayMarchingContext.StepSize * Transmittance;

		// Accumulate transmittance for the next evaluation
		Transmittance *= exp(-Extinction * RayMarchingContext.StepSize);
	}
}

void RayMarchSingleScattering(
	inout FRayMarchingContext RayMarchingContext,
	inout FDeferredLightData LightData,
	uint LightType,
	uint StepCount,
	inout float3 Radiance,
	inout float3 Transmittance
)
{
	for (uint StepIndex = 0; StepIndex < StepCount; ++StepIndex)
	{
		float3 LocalPosition = RayMarchingContext.LocalRayOrigin + RayMarchingContext.LocalRayDirection * (RayMarchingContext.LocalRayTMin + RayMarchingContext.StepSize * StepIndex);
		float3 WorldPosition = RayMarchingContext.WorldRayOrigin + RayMarchingContext.WorldRayDirection * (RayMarchingContext.LocalRayTMin + RayMarchingContext.StepSize * StepIndex);
		FVolumeSampleContext SampleContext = CreateVolumeSampleContext(LocalPosition, WorldPosition, RayMarchingContext.MipLevel);

		if (RayMarchingContext.bApplyEmissionAndTransmittance)
		{
			float3 Emission = SampleEmission(SampleContext);
			Radiance += Emission * RayMarchingContext.StepSize * Transmittance;
		}

		float3 Extinction = SampleExtinction(SampleContext);
		if (RayMarchingContext.bApplyDirectLighting && (any(Extinction > 0.0)))
		{
			float3 Albedo = SampleAlbedo(SampleContext);
			if (any(Albedo > 0.0))
			{
				float3 TranslatedWorldPosition = LWCHackToFloat(LWCAdd(WorldPosition, PrimaryView.PreViewTranslation));

				float3 L = LightData.Direction;
				//float3 ToLight = L * RayMarchingContext.MaxShadowTraceDistance;
				float3 ToLight = L * 10000;

				float LightAttenuation = 1.0;
				if (LightType != LIGHT_TYPE_DIRECTIONAL)
				{
					LightAttenuation = GetLocalLightAttenuation(TranslatedWorldPosition, LightData, ToLight, L);
					if (LightData.bRectLight)
					{
						FRect Rect = GetRect(ToLight, LightData);
						LightAttenuation *= IntegrateLight(Rect);
					}
					else
					{
						FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
						Capsule.DistBiasSqr = 0;
						LightAttenuation *= IntegrateLight(Capsule, LightData.bInverseSquared);
					}
				}

				float HardSurfaceShadowFactor = 1.0;
#if HARD_SURFACE_SHADOWING
				// Evaluate hard-surface shadow term
				if (LightType == LIGHT_TYPE_DIRECTIONAL)
				{
					float SceneDepth = dot(TranslatedWorldPosition - PrimaryView.TranslatedWorldCameraOrigin, View.ViewForward);
					bool bShadowingFromValidUVArea = false;
					float ShadowFactor = ComputeDirectionalLightDynamicShadowing(TranslatedWorldPosition, SceneDepth, bShadowingFromValidUVArea);

					if (bShadowingFromValidUVArea)
					{
						HardSurfaceShadowFactor *= ShadowFactor;
					}
				}
				else // Local lights
				{
					bool bShadowingFromValidUVArea = false;
					float ShadowFactor = ComputeVolumeShadowing(TranslatedWorldPosition, LightData.bRadialLight && !LightData.bSpotLight, LightData.bSpotLight, bShadowingFromValidUVArea);

					if (bShadowingFromValidUVArea)
					{
						HardSurfaceShadowFactor *= ShadowFactor;
					}
				}
#endif // HARD_SURFACE_SHADOWING

				float3 Inscattering = LightData.Color * LightAttenuation * HardSurfaceShadowFactor;
				if (any(Inscattering > 0.0))
				{
					float3 ShadowTransmittance = 1.0;

					if (RayMarchingContext.bApplyShadowTransmittance)
					{
						float3 LocalShadowRayOrigin = mul(float4(WorldPosition, 1.0), GetWorldToLocal()).xyz;

#if DIM_USE_TRANSMITTANCE_VOLUME
						float3 LocalBoundsMin = GetLocalBoundsOrigin() - GetLocalBoundsExtent();
						float3 TransmittanceUVW = saturate((LocalShadowRayOrigin - LocalBoundsMin) / (2.0 * GetLocalBoundsExtent()));
						float MipLevel = 0;
						ShadowTransmittance = SampleTransmittanceVolume(TransmittanceUVW, MipLevel);
#else
						// Build shadow ray and find intersection
						float3 LocalShadowRayEnd = mul(float4(WorldPosition + ToLight, 1.0), GetWorldToLocal()).xyz;
						float3 LocalShadowRayDirection = LocalShadowRayEnd - LocalShadowRayOrigin;
						float LocalShadowRayTMin = 0.0;
						float LocalShadowRayTMax = length(LocalShadowRayDirection);
						LocalShadowRayDirection /= LocalShadowRayTMax;

						//float ShadowJitter = InterleavedGradientNoise(PixelCoord, StepIndex);
						float ShadowJitter = 0.0;
						float ShadowStepSize = GetStepSize() * GetShadowStepFactor();
						int bApplyEmissionAndTransmittance = 0;
						int bApplyDirectLighting = 0;
						int bApplyShadowTransmittance = 0;

						FRayMarchingContext ShadowRayMarchingContext = CreateRayMarchingContext(
							LocalShadowRayOrigin,
							LocalShadowRayDirection,
							LocalShadowRayTMin,
							LocalShadowRayTMax,
							WorldPosition, // WorldShadowRayOrigin
							normalize(ToLight), // WorldShadowRayDirection
							ShadowJitter,
							ShadowStepSize,
							RayMarchingContext.MaxStepCount,
							bApplyEmissionAndTransmittance,
							bApplyDirectLighting,
							bApplyShadowTransmittance
							//RayMarchingContext.MaxShadowTraceDistance
						);

						ShadowTransmittance = ComputeTransmittance(ShadowRayMarchingContext);
#endif // DIM_USE_TRANSMITTANCE_VOLUME
					}

					// Convert in-scattering to exitant radiance
					float3 ScatteringCoefficient = Albedo * Extinction;
					float IsotropicPhase = 1.0 / (4.0 * PI);
					Radiance += Inscattering * ShadowTransmittance * ScatteringCoefficient * IsotropicPhase * Transmittance * RayMarchingContext.StepSize;
				}
			}
		}

		// Accumulate transmittance for the next evaluation
		Transmittance *= exp(-Extinction * RayMarchingContext.StepSize);

		float Epsilon = 1.0e-7;
		if (all(Transmittance < Epsilon))
		{
			Transmittance = 0.0;
			break;
		}
	}
}
