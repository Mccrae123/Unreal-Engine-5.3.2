/*=============================================================================
	ParticipatingMediaCommon.ush
=============================================================================*/

#pragma once

#include "Common.ush"

#define PARTICIPATING_MEDIA_MIN_MFP_METER		0.000001f
#define PARTICIPATING_MEDIA_MIN_EXTINCTION		0.000001f
#define PARTICIPATING_MEDIA_MIN_TRANSMITTANCE	0.000000000001f



//---------------------------------------------
// Participating media representation
//---------------------------------------------

struct FParticipatingMedia
{
	float3 ScatteringCoef;	// sigma_s (1/meter)
	float3 AbsorptionCoef;	// sigma_a (1/meter)
	float3 ExtinctionCoef;	// sigma_t (1/meter)
	float3 MeanFreePath;	// (meter)
	float3 Albedo;			// Represent sigma_s / sigma_t (unitless)
	float3 BaseColor;		// Represent the reflectance albedo resulting from single+multiple scattering assuming an isotropic phase function (unitless)
};

// GetBaseColorFromAlbedo: returns the color of the participating media resulting from the single+multiple subsurface scattering. 
// GetAlbedoFromBaseColor is the inverse transform.
// [Kulla and Conty 2017, "Revisiting Physically Based Shading at Imageworks"] https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf, slide 62 
// [d'Eon, "A Hitchhiker's guide to multiple scattering"] or http://www.eugenedeon.com/wp-content/uploads/2016/09/hitchhikers_v0.1.3.pdf
float3 GetBaseColorFromAlbedo(const float3 Albedo, const float g = 0.0f)
{
	const float3 s = sqrt((1 - Albedo) / (1.0f - Albedo * g));
	const float3 BaseColor = ((1.0f - s) * (1 - 0.139 * s)) / (1.0f + 1.17 * s);
	return BaseColor;
}
float3 GetAlbedoFromBaseColor(const float3 BaseColor, const float g = 0.0f)
{
	const float3 s = 4.09712 + 4.20863 * BaseColor - sqrt(9.59217 + 41.6808 * BaseColor + 17.7126 * BaseColor * BaseColor);
	const float3 Albedo = (1.0f - s * s) / (1.0f - g * s * s);
	return Albedo;
}

// The mean free path must be in meters
FParticipatingMedia CreateMediumFromAlbedoMFP(float3 Albedo, float3 MeanFreePathMeters)
{
	FParticipatingMedia PM = (FParticipatingMedia)0;
	PM.Albedo = Albedo;
	PM.BaseColor = GetBaseColorFromAlbedo(Albedo);
	PM.MeanFreePath = MeanFreePathMeters;
	PM.ExtinctionCoef = 1.0f / max(PARTICIPATING_MEDIA_MIN_MFP_METER, PM.MeanFreePath);
	PM.ScatteringCoef = PM.Albedo * PM.ExtinctionCoef;
	PM.AbsorptionCoef = max(0.0f, PM.ExtinctionCoef - PM.ScatteringCoef);
	return PM;
}

// The mean free path must be in meters
FParticipatingMedia CreateMediumFromBaseColorMFP(float3 BaseColor, float3 MeanFreePathMeters)
{
	FParticipatingMedia PM = (FParticipatingMedia)0;
	PM.Albedo = GetAlbedoFromBaseColor(BaseColor);
	PM.BaseColor = BaseColor;
	PM.MeanFreePath = MeanFreePathMeters;
	PM.ExtinctionCoef = 1.0f / max(PARTICIPATING_MEDIA_MIN_MFP_METER, PM.MeanFreePath);
	PM.ScatteringCoef = PM.Albedo * PM.ExtinctionCoef;
	PM.AbsorptionCoef = max(0.0f, PM.ExtinctionCoef - PM.ScatteringCoef);
	return PM;
}



//---------------------------------------------
// Phase functions
//---------------------------------------------

float IsotropicPhase()
{
	return 1.0f / (4.0f * PI);
}

// Follows PBRT convention http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html#PhaseHG
float HenyeyGreensteinPhase(float G, float CosTheta)
{
	return (1.0f - G * G) / (4.0f * PI * pow(1.0f + G * G + 2.0f * G * CosTheta, 1.5f));
}

float RaleighPhase(float CosTheta)
{
	return 3.0f * (1.0f + CosTheta * CosTheta) / (16.0f * PI);
}

// Schlick phase function approximating henyey-greenstein
float SchlickPhaseFromK(float K, float CosTheta)
{
	const float SchlickPhaseFactor = 1.0f + K * CosTheta;
	const float PhaseValue = (1.0f - K * K) / (4.0f * PI * SchlickPhaseFactor * SchlickPhaseFactor);
	return PhaseValue;
}
float SchlickPhase(float G, float CosTheta)
{
	const float K = 1.55f * G - 0.55f * G * G * G;
	return SchlickPhaseFromK(K, CosTheta);
}

// Follows PBRT convention http://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html#SamplingPhaseFunctions
float HenyeyGreensteinPhaseInvertCDF(float E, float G)
{
	float OnePlusG2  = 1.0f + G * G;
	float OneMinusG2 = 1.0f - G * G;
	float OneOver2G  = 0.5f / G;
	float t = OneMinusG2 / (1.0f + G - 2.0f * G * E);
	return -OneOver2G * (OnePlusG2 - t * t);	// Careful: OneOver2G undefined for g close to 0
}

// Follows PBRT convention http://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html#SamplingPhaseFunctions
float4 ImportanceSampleHenyeyGreensteinPhase(float2 E, float G)
{
	float Phi = 2.0f * PI * E.x;
	float CosTheta = 0;
	if (abs(G) < 0.001f)
	{
		CosTheta = 1.0f - 2.0f * E.y;
	}
	else
	{
		CosTheta = HenyeyGreensteinPhaseInvertCDF(E.y, G);
	}
	float SinTheta = sqrt(max(0.0f, 1.0f - CosTheta * CosTheta));

	float3 H = float3(SinTheta * sin(Phi), SinTheta * cos(Phi), CosTheta);

	return float4(H, HenyeyGreensteinPhase(G, CosTheta));
}



//---------------------------------------------
// Utilities
//---------------------------------------------

float3 TransmittanceToExtinction(in float3 TransmittanceColor, in float ThicknessMeters)
{
	// TransmittanceColor	= exp(-Extinction * Thickness)
	// Extinction			= -log(TransmittanceColor) / Thickness
	return -log(clamp(TransmittanceColor, PARTICIPATING_MEDIA_MIN_TRANSMITTANCE, 1.0f)) / max(PARTICIPATING_MEDIA_MIN_MFP_METER, ThicknessMeters);
}

float3 TransmittanceToMeanFreePath(in float3 TransmittanceColor, in float ThicknessMeters)
{
	return 1.0f / max(PARTICIPATING_MEDIA_MIN_EXTINCTION, TransmittanceToExtinction(TransmittanceColor, ThicknessMeters));
}

