// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"

#ifdef STRATA_RND_SHADERS

#include "/Engine/Private/MiniFontCommon.ush"
#include "/Engine/Private/ShaderPrint.ush"
#include "/Engine/Private/ColorMap.ush"
#include "/Engine/Private/BRDF.ush"
#include "/Engine/Private/MonteCarlo.ush"
#include "/Engine/Private/PathTracing/Material/PathTracingFresnel.ush"

// Updated from http://jcgt.org/published/0007/03/04/
bool Slabs(float3 P0, float3 P1, float3 RayOrigin, float3 InvRaydir, out float OutTMin, out float OutTMax)
{
	float3 T0 = (P0 - RayOrigin) * InvRaydir;
	float3 T1 = (P1 - RayOrigin) * InvRaydir;
	float3 TMin = min(T0, T1);
	float3 TMax = max(T0, T1);
	float MaxTMin = max(max(TMin.x, TMin.y), TMin.z);
	float MinTMax = min(min(TMax.x, TMax.y), TMax.z);
	OutTMin = MaxTMin;
	OutTMax = MinTMax;
	return MaxTMin <= MinTMax;
}

float3 GetScreenWorldDir(in float4 SVPos)
{
	float2 ScreenPosition = SvPositionToScreenPosition(SVPos).xy;
	const float Depth = 1000000.0f;
	float4 WorldPos = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToTranslatedWorld);
	return normalize(WorldPos.xyz - View.TranslatedWorldCameraOrigin);
}


bool GetRefractedDirection(float2 RandomUV, float a2, float3 V, inout float3 L )
{ 
	float4 H = ImportanceSampleVisibleGGX(UniformSampleDisk(RandomUV), a2, V);

	L = 0;
	float F = 0;
	const float AirIOR = 1.0f;
	const float WaterIOR = 1.33f;
	const float EtaIn = WaterIOR / AirIOR;	// We always consider entering from air to water
	const float RandSample = 1.0f;			// We only consider refracted rays
	return SampleRefraction(-V, H.xyz, EtaIn, RandSample, L, F);
}

#if defined(EVALUATE_ROUGH_REFRACTION_LOBE_CS) || defined(VISUALIZE_ROUGH_REFRACTION_PS)
struct FUI
{
	float IncidentAngle;
	float SlabThickness;
	float Roughness;

	// Derived
	float a2;
	float3 N;
	float3 V;
};


FShaderPrintContext GetUIContext(bool bActive)
{
	return InitShaderPrintContext(bActive, uint2(100, 100));
}

FUI GetUI(inout FShaderPrintContext Context)
{
	FUI UI;

	UI.IncidentAngle = AddSlider(Context, TEXT("IncidentAngle"), 0.0f, GetDefaultFontColor(), 0.0f, 0.5f * PI);
	Newline(Context);
	UI.SlabThickness = AddSlider(Context, TEXT("Slab Thickness"), 5.0f, GetDefaultFontColor(), 0.0f, 20.0f);
	Newline(Context);
	UI.Roughness = AddSlider(Context, TEXT("Roughness"), 0.5f, GetDefaultFontColor(), 0.0f, 1.0f);
	Newline(Context);

	UI.a2 = Pow4(UI.Roughness);
	UI.N = float3(0, 0, 1);
	UI.V = float3(sin(UI.IncidentAngle), 0, cos(UI.IncidentAngle));

	return UI;
}
#endif


#ifdef EVALUATE_ROUGH_REFRACTION_LOBE_CS

uint TraceSqrtSampleCount;

RWTexture2D<uint> SampleCountTextureUAV;

RWStructuredBuffer<FLobeMeanVariance> LobStatisticsBufferUAV;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void EvaluateRoughRefractionLobeCS(uint3 ThreadId : SV_DispatchThreadID)
{
	if (all(ThreadId == 0))
	{
		FShaderPrintContext Context = GetUIContext(true);
		FUI UI = GetUI(Context);


		FLobeMeanVariance Lobe = (FLobeMeanVariance)0;
		LobStatisticsBufferUAV[0] = Lobe;


		for (float u = 0.5f; u < float(TraceSqrtSampleCount); u++)
		{
			for (float v = 0.5f; v < float(TraceSqrtSampleCount); v++)
			{
				float2 RandomUV = float2(u, v) / float(TraceSqrtSampleCount);
				float3 L = 0;
				if (GetRefractedDirection(RandomUV, UI.a2, UI.V, L))
				{
					float2 SampleUV = L.xy * 0.5 + 0.5;
					SampleCountTextureUAV[uint2(SampleUV * 64.0f)] += 1;
				}
				else
				{
					// Discard refelctions
				}
			}
		}
	}
}

#endif // EVALUATE_ROUGH_REFRACTION_LOBE_CS



#ifdef VISUALIZE_ROUGH_REFRACTION_PS

float TraceDomainSize;
uint SlabInterfaceLineCount;

Texture2D<uint> SampleCountTexture;

StructuredBuffer<FLobeMeanVariance> LobStatisticsBuffer;

void VisualizeRoughRefractionPS(
	float4 SVPos : SV_POSITION,
	out float4 OutColor : SV_Target0)
{
	OutColor = float4(0.0, 0.0f, 0.0, 0.5f);

	float2 PixelPos = SVPos.xy;
	float2 UvBuffer = PixelPos * View.BufferSizeAndInvSize.zw;
	float3 WorldDir = GetScreenWorldDir(SVPos);
	float3 CamWorldPos = LWCToFloat(PrimaryView.WorldCameraOrigin);

	
	FShaderPrintContext Context = GetUIContext(all(uint2(PixelPos.xy) == uint2(10, 10)));
	FUI UI = GetUI(Context);

	float3 SlabEdgeX = float3(60.0f, 0.0f, 0.0f);
	float3 SlabEdgeY = float3(0.0f, 60.0f, 0.0f);
	float3 SlabEdgeZ = float3(0.0f, 0.0f, UI.SlabThickness);
	float3 SlabCenter = CamWorldPos + View.ViewForward * 60.0f;
	float3 RefractionP= SlabCenter + 0.5 * SlabEdgeZ;

	const float VizProjectedRays = 15.0f;

	AddLineWS(Context, RefractionP, RefractionP + UI.N * 25.0, float4(0, 0, 1, 1));
	AddLineWS(Context, RefractionP, RefractionP + UI.V * 25.0, float4(0, 1, 1, 1));

	float SlabTMin = -1.0f;
	float SlabTMax = -1.0f;
	float3 SlabP0 = SlabCenter - 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	float3 SlabP1 = SlabCenter + 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	if(Slabs(SlabP0, SlabP1, CamWorldPos, 1.0f / WorldDir, SlabTMin, SlabTMax))
	{
		float3 P = CamWorldPos + WorldDir * SlabTMin;
		if (P.z > -0.499 * UI.SlabThickness)
		{
			P = CamWorldPos + WorldDir * SlabTMax;
		}

		if (P.z < (SlabCenter -0.499 * SlabEdgeZ).z)
		{
			const float2 UV = 0.5 + 0.5 * ((P - RefractionP) / (VizProjectedRays)).xy;
			const int2 Coord = (UV * 64.0f + 0.5f);
			if (all(Coord >= 0) && all(Coord < 64))
			{
				const float SampleCount = float(SampleCountTexture[Coord].x);
				OutColor = float4(GetHSVDebugColor(SampleCount*0.01f), 0.0);
			}
		}
	}

#if 0
	const float SphereRadius = 10.0f;
	float2 Sol = RayIntersectSphere(CamWorldPos, WorldDir, float4(RefractionP, SphereRadius));
	if (Sol.x > 0.0f && Sol.y > 0.0f)
	{
		const float3 P = CamWorldPos + WorldDir * Sol.x;
		const float3 OmegaOut = P - RefractionP;
		const float OmegaOutLen = length(OmegaOut);
		const float3 OmegaOutNorm = OmegaOut / OmegaOutLen;

		const float NoH = dot(normalize(OmegaOutNorm + UI.V), UI.N);
		float D = D_GGX(UI.a2, NoH);
		OutColor = float4(D, D, 0.0, 0.0);
	}
#endif

	// Draw the top and bottom interfaces
	float3 SlabOrigin = SlabCenter - 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	for (uint i = 0; i <= SlabInterfaceLineCount; i++)
	{
		const float Offset = (float(i) / float(SlabInterfaceLineCount));

		AddLineWS(Context, SlabOrigin + SlabEdgeX * Offset, SlabOrigin + SlabEdgeX * Offset + SlabEdgeY, float4(0.2, 0.2, 0.2, 1.0));
		AddLineWS(Context, SlabOrigin + SlabEdgeY * Offset, SlabOrigin + SlabEdgeY * Offset + SlabEdgeX, float4(0.2, 0.2, 0.2, 1.0));

		AddLineWS(Context, SlabOrigin + SlabEdgeX * Offset + SlabEdgeZ, SlabOrigin + SlabEdgeX * Offset + SlabEdgeY + SlabEdgeZ, float4(0.2, 0.2, 0.2, 1.0));
		AddLineWS(Context, SlabOrigin + SlabEdgeY * Offset + SlabEdgeZ, SlabOrigin + SlabEdgeY * Offset + SlabEdgeX + SlabEdgeZ, float4(0.2, 0.2, 0.2, 1.0));
	}

	for (float u = 0.5f; u < TraceDomainSize; u++)
	{
		for (float v = 0.5f; v < TraceDomainSize; v++)
		{
			float2 RandomUV = float2(u, v) / TraceDomainSize;
			float3 L = 0;
			if (GetRefractedDirection(RandomUV, UI.a2, UI.V, L))
			{
				AddLineWS(Context, RefractionP, RefractionP + L * VizProjectedRays, float4(0, 1, 0, 0.3));
				//AddLineWS(Context, RefractionP + L * VizProjectedRays, float3((RefractionP + L * VizProjectedRays).xy, SlabCenter.z - 0.5* UI.SlabThickness), float4(0, 1, 0, 0.3));
			}
			else
			{
				AddLineWS(Context, RefractionP, RefractionP + L * VizProjectedRays, float4(1, 0, 0, 0.3));
			}
		}
	}

}

#endif // VISUALIZE_ROUGH_REFRACTION_PS



#endif // STRATA_RND_SHADERS


