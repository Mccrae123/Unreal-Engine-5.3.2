// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"

#ifdef STRATA_RND_SHADERS

#include "/Engine/Private/MiniFontCommon.ush"
#include "/Engine/Private/ShaderPrint.ush"
#include "/Engine/Private/ColorMap.ush"
#include "/Engine/Private/BRDF.ush"
#include "/Engine/Private/MonteCarlo.ush"
#include "/Engine/Private/PathTracing/Material/PathTracingFresnel.ush"

#include "/Engine/Private/Strata/StrataStatisticalOperators.ush"

// Updated from http://jcgt.org/published/0007/03/04/
bool Slabs(float3 P0, float3 P1, float3 RayOrigin, float3 InvRaydir, out float OutTMin, out float OutTMax)
{
	float3 T0 = (P0 - RayOrigin) * InvRaydir;
	float3 T1 = (P1 - RayOrigin) * InvRaydir;
	float3 TMin = min(T0, T1);
	float3 TMax = max(T0, T1);
	float MaxTMin = max(max(TMin.x, TMin.y), TMin.z);
	float MinTMax = min(min(TMax.x, TMax.y), TMax.z);
	OutTMin = MaxTMin;
	OutTMax = MinTMax;
	return MaxTMin <= MinTMax;
}

float3 GetScreenWorldDir(in float4 SVPos)
{
	float2 ScreenPosition = SvPositionToScreenPosition(SVPos).xy;
	const float Depth = 1000000.0f;
	float4 WorldPos = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToTranslatedWorld);
	return normalize(WorldPos.xyz - View.TranslatedWorldCameraOrigin);
}

float GetEta12()
{
	const float AirIOR = 1.0f;
	const float WaterIOR = 1.33f;
	const float EtaIn = WaterIOR / AirIOR;	// We always consider entering from air to water

	return EtaIn;
}

bool GetRefractedDirection(float2 RandomUV, float a2, float3 V, inout float3 L )
{ 
	float4 H = ImportanceSampleVisibleGGX(UniformSampleDisk(RandomUV), a2, V);

	L = 0;
	float F = 0;
	const float RandSample = 1.0f;			// We only consider refracted rays
	return SampleRefraction(-V, H.xyz, GetEta12(), RandSample, L, F);
}



#if defined(EVALUATE_ROUGH_REFRACTION_LOBE_CS) || defined(VISUALIZE_ROUGH_REFRACTION_PS)

struct FUI
{
	float IncidentAngle;
	float SlabThickness;
	float Roughness;

	// Derived
	float a2;
	float3 N;
	float3 V;
};

FShaderPrintContext GetUIContext(bool bActive)
{
	return InitShaderPrintContext(bActive, uint2(100, 100));
}

FUI GetUI(inout FShaderPrintContext Context)
{
	FUI UI;

	UI.IncidentAngle = AddSlider(Context, TEXT("IncidentAngle"), 0.0f, GetDefaultFontColor(), 0.0f, 0.5f * PI);
	Newline(Context);
	UI.SlabThickness = AddSlider(Context, TEXT("Slab Thickness"), 5.0f, GetDefaultFontColor(), 0.0f, 20.0f);
	Newline(Context);
	UI.Roughness = AddSlider(Context, TEXT("Roughness"), 0.5f, GetDefaultFontColor(), 0.0f, 1.0f);
	Newline(Context);

	UI.a2 = Pow4(UI.Roughness);
	UI.N = float3(0, 0, 1);
	UI.V = float3(sin(UI.IncidentAngle), 0, cos(UI.IncidentAngle));

	return UI;
}

void DrawCircleXY(inout FShaderPrintContext Context, float3 Center, float2 Radius, float4 ColorAlpha)
{
	const float TStep = 0.1f;
	for (float t = 0; t <= 1.0; t += TStep)
	{
		float S0, C0;
		float S1, C1;
		sincos(t * 2 * PI, S0, C0);
		sincos((t + TStep) * 2 * PI, S1, C1);
		float3 P0 = Center + float3(C0, S0, 0.0) * float3(Radius, 0.0);
		float3 P1 = Center + float3(C1, S1, 0.0) * float3(Radius, 0.0);

		AddLineWS(Context, P0, P1, ColorAlpha);
	}
}

struct FLobeStat
{
	float Count;
	float2 Mean;
	float2 M2;
	float2 Variance;
	float pad;
};

// See Welford's algorithm https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
void LobStatUpdate(inout FLobeStat LobeStat, in float2 InPos)
{
	LobeStat.Count += 1;
	float2 Delta = InPos - LobeStat.Mean;
	LobeStat.Mean += Delta / LobeStat.Count;
	float2 Delta2 = InPos - LobeStat.Mean;
	LobeStat.M2 += Delta * Delta2;
}

void LobStatFinalize(inout FLobeStat LobeStat)
{
	if (LobeStat.Count < 2)
	{
		// nan
	}
	else
	{
		// Mean is already valid
		LobeStat.Variance = LobeStat.M2 / LobeStat.Count;
		//LobeStat.SampleVariance = LobeStat.M2 / (LobeStat.Count - 1);
	}
}

#endif



#ifdef EVALUATE_ROUGH_REFRACTION_LOBE_CS

uint TraceSqrtSampleCount;

RWTexture2D<uint> SampleCountTextureUAV;

RWStructuredBuffer<FLobeStat> LobStatisticsBufferUAV;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void EvaluateRoughRefractionLobeCS(uint3 ThreadId : SV_DispatchThreadID)
{
	if (all(ThreadId == 0))
	{
		FShaderPrintContext Context = GetUIContext(true);
		FUI UI = GetUI(Context);

		FLobeStat LobeState = (FLobeStat)0;

		float Count = 0;
		float2 Mean = 0;
		float2 Variance = 0;

		for (float u = 0.5f; u < float(TraceSqrtSampleCount); u++)
		{
			for (float v = 0.5f; v < float(TraceSqrtSampleCount); v++)
			{
				float2 RandomUV = float2(u, v) / float(TraceSqrtSampleCount);
				float3 L = 0;
				if (GetRefractedDirection(RandomUV, UI.a2, UI.V, L))
				{
					float2 SampleUV = L.xy * 0.5 + 0.5;
					SampleCountTextureUAV[uint2(SampleUV * 64.0f)] += 1;

					LobStatUpdate(LobeState, L.xy);

					Count++;
					Mean += L.xy;
				}
				else
				{
					// Discard reflections
				}
			}
		}

/*		Mean = Mean / Count;
		Count = 0;
		for (float u = 0.5f; u < float(TraceSqrtSampleCount); u++)
		{
			for (float v = 0.5f; v < float(TraceSqrtSampleCount); v++)
			{
				float2 RandomUV = float2(u, v) / float(TraceSqrtSampleCount);
				float3 L = 0;
				if (GetRefractedDirection(RandomUV, UI.a2, UI.V, L))
				{
					float2 SampleUV = L.xy * 0.5 + 0.5;
					SampleCountTextureUAV[uint2(SampleUV * 64.0f)] += 1;

					LobStatUpdate(LobeState, L.xy);

					Count++;
					Variance += (L.xy - Mean) * (L.xy - Mean);
				}
				else
				{
					// Discard reflections
				}
			}
		}
		Variance = Variance / Count;
		LobeState.Mean = Mean;
		LobeState.Variance = Variance;*/

		LobStatFinalize(LobeState);
		LobStatisticsBufferUAV[0] = LobeState;
	}
}

#endif // EVALUATE_ROUGH_REFRACTION_LOBE_CS



#ifdef VISUALIZE_ROUGH_REFRACTION_PS

float TraceDomainSize;
uint SlabInterfaceLineCount;

Texture2D<uint> SampleCountTexture;

StructuredBuffer<FLobeStat> LobStatisticsBuffer;

FStrataLobeStatistic StrataGetRefractedLobe2(FStrataLobeStatistic WiLobe, float3 InterfaceFDG, float InterfaceRoughness, float InterfaceEta12)
{
	FStrataLobeStatistic WoLobe;

	WoLobe.E = WiLobe.E * (1.0f - InterfaceFDG);

	// The lobe is on the oposite side of the surface, and the direction account for change of medium IOR.
	WoLobe.Mu.xy = -WiLobe.Mu.xy * InterfaceEta12;
	WoLobe.Mu.z = -sign(WiLobe.Mu.z) * sqrt(1.0 - dot(WoLobe.Mu.xy, WoLobe.Mu.xy)); // derive z from vector projected xy

	// Equation 10, we have also noticed variance explosion at grazing angle so we make the inner product be 1 for now.
	const float OmegaIDotN = 1.0f; //WiLobe.Mu.z;
	const float OmegaTDotN = 1.0f; //WoLobe.Mu.z;
	//const float S = 0.5f * (1.0f + InterfaceEta12 * (abs(OmegaIDotN) / abs(OmegaTDotN)));						// equation 10 from paper
	const float S = 0.5f * (abs(OmegaTDotN * InterfaceEta12 - OmegaIDotN) / abs(OmegaTDotN * InterfaceEta12));	// equation from paper source code

	WoLobe.Sigma = (WiLobe.Sigma / InterfaceEta12) + StrataLobeRoughnessToVariance(InterfaceRoughness * S);

	return WoLobe;
}

void VisualizeRoughRefractionPS(
	float4 SVPos : SV_POSITION,
	out float4 OutColor : SV_Target0)
{
	OutColor = float4(0.0, 0.0f, 0.0, 0.5f);

	float2 PixelPos = SVPos.xy;
	float2 UvBuffer = PixelPos * View.BufferSizeAndInvSize.zw;
	float3 WorldDir = GetScreenWorldDir(SVPos);
	float3 CamWorldPos = LWCToFloat(PrimaryView.WorldCameraOrigin);

	
	FShaderPrintContext Context = GetUIContext(all(uint2(PixelPos.xy) == uint2(10, 10)));
	FUI UI = GetUI(Context);

	float3 SlabEdgeX = float3(60.0f, 0.0f, 0.0f);
	float3 SlabEdgeY = float3(0.0f, 60.0f, 0.0f);
	float3 SlabEdgeZ = float3(0.0f, 0.0f, UI.SlabThickness);
	float3 SlabCenter = CamWorldPos + View.ViewForward * 35.0f;
	float3 RefractionP= SlabCenter + 0.5 * SlabEdgeZ;
	const float SlabTopZ    = SlabCenter.z  + 0.5 * UI.SlabThickness;
	const float SlabBottomZ = SlabCenter.z - 0.5 * UI.SlabThickness;

	const float VisProjectedRayRadius = 15.0f;

	AddLineWS(Context, RefractionP, RefractionP + UI.N * 25.0, float4(0, 0, 1, 1));
	AddLineWS(Context, RefractionP, RefractionP + UI.V * 25.0, float4(0, 1, 1, 1));

	float SlabTMin = -1.0f;
	float SlabTMax = -1.0f;
	float3 SlabP0 = SlabCenter - 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	float3 SlabP1 = SlabCenter + 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	if(Slabs(SlabP0, SlabP1, CamWorldPos, 1.0f / WorldDir, SlabTMin, SlabTMax))
	{
		float3 P = CamWorldPos + WorldDir * SlabTMin;
		if (P.z > (SlabBottomZ + 0.01))
		{
			P = CamWorldPos + WorldDir * SlabTMax;
		}

		if (P.z < (SlabBottomZ+0.01))
		{
			const float2 UV = 0.5 + 0.5 * ((P - RefractionP) / (VisProjectedRayRadius)).xy;
			const int2 Coord = (UV * 64.0f + 0.5f);
			if (all(Coord >= 0) && all(Coord < 64))
			{
				const float SampleCount = float(SampleCountTexture[Coord].x);
				OutColor = float4(GetHSVDebugColor(SampleCount*0.01f), 0.0);
			}
		}
	}

#if 0
	const float SphereRadius = 10.0f;
	float2 Sol = RayIntersectSphere(CamWorldPos, WorldDir, float4(RefractionP, SphereRadius));
	if (Sol.x > 0.0f && Sol.y > 0.0f)
	{
		const float3 P = CamWorldPos + WorldDir * Sol.x;
		const float3 OmegaOut = P - RefractionP;
		const float OmegaOutLen = length(OmegaOut);
		const float3 OmegaOutNorm = OmegaOut / OmegaOutLen;

		const float NoH = dot(normalize(OmegaOutNorm + UI.V), UI.N);
		float D = D_GGX(UI.a2, NoH);
		OutColor = float4(D, D, 0.0, 0.0);
	}
#endif

	// Draw the top and bottom interfaces
	float3 SlabOrigin = SlabCenter - 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	for (uint i = 0; i <= SlabInterfaceLineCount; i++)
	{
		const float Offset = (float(i) / float(SlabInterfaceLineCount));

		AddLineWS(Context, SlabOrigin + SlabEdgeX * Offset, SlabOrigin + SlabEdgeX * Offset + SlabEdgeY, float4(0.2, 0.2, 0.2, 1.0));
		AddLineWS(Context, SlabOrigin + SlabEdgeY * Offset, SlabOrigin + SlabEdgeY * Offset + SlabEdgeX, float4(0.2, 0.2, 0.2, 1.0));

		AddLineWS(Context, SlabOrigin + SlabEdgeX * Offset + SlabEdgeZ, SlabOrigin + SlabEdgeX * Offset + SlabEdgeY + SlabEdgeZ, float4(0.2, 0.2, 0.2, 1.0));
		AddLineWS(Context, SlabOrigin + SlabEdgeY * Offset + SlabEdgeZ, SlabOrigin + SlabEdgeY * Offset + SlabEdgeX + SlabEdgeZ, float4(0.2, 0.2, 0.2, 1.0));
	}

	for (float u = 0.5f; u < TraceDomainSize; u++)
	{
		for (float v = 0.5f; v < TraceDomainSize; v++)
		{
			float2 RandomUV = float2(u, v) / TraceDomainSize;
			float3 L = 0;
			if (GetRefractedDirection(RandomUV, UI.a2, UI.V, L))
			{
				AddLineWS(Context, RefractionP, RefractionP + L * VisProjectedRayRadius, float4(0, 1, 0, 0.3));
				//AddLineWS(Context, RefractionP + L * VisProjectedRayRadius, float3((RefractionP + L * VisProjectedRayRadius).xy, SlabCenter.z - 0.5* UI.SlabThickness), float4(0, 1, 0, 0.3));
			}
			else
			{
				AddLineWS(Context, RefractionP, RefractionP + L * VisProjectedRayRadius, float4(1, 0, 0, 0.3));
			}
		}
	}

	// Draw the lobe estimated by Belcour
	FStrataLobeStatistic RefractedLobe = StrataGetRefractedLobe2(StrataGetDiracLobe(UI.V), 1.0, UI.Roughness, GetEta12());
	DrawCircleXY(Context, float3(SlabCenter.xy + RefractedLobe.Mu.xy * VisProjectedRayRadius, SlabBottomZ), RefractedLobe.Sigma * VisProjectedRayRadius, float4(1, 0, 1, 1));

	Newline(Context);
	Newline(Context);
	Print(Context, TEXT("Belcour variance = "));
	Print(Context, RefractedLobe.Sigma, FontWhite, 5, 5);

	// Our lobe
	FLobeStat LobeState = LobStatisticsBuffer[0];
	DrawCircleXY(Context, float3(SlabCenter.xy + LobeState.Mean * VisProjectedRayRadius, SlabBottomZ + 0.05), LobeState.Variance * VisProjectedRayRadius, float4(1, 1, 0, 1));

	Newline(Context);
	Newline(Context);
	Print(Context, TEXT("New variance X = "));
	Print(Context, LobeState.Variance.x, FontWhite, 5, 5);
	Newline(Context);
	Print(Context, TEXT("New variance Y = "));
	Print(Context, LobeState.Variance.y, FontWhite, 5, 5);

}

#endif // VISUALIZE_ROUGH_REFRACTION_PS



#endif // STRATA_RND_SHADERS


