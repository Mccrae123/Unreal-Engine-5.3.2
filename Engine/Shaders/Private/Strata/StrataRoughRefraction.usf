// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"

#ifdef STRATA_RND_SHADERS

#include "/Engine/Private/MiniFontCommon.ush"
#include "/Engine/Private/ShaderPrint.ush"
#include "/Engine/Private/BRDF.ush"
#include "/Engine/Private/MonteCarlo.ush"
#include "/Engine/Private/PathTracing/Material/PathTracingFresnel.ush"

// Updated from http://jcgt.org/published/0007/03/04/
bool slabs(float3 p0, float3 p1, float3 rayOrigin, float3 invRaydir, out float outTMin, out float outTMax)
{
	float3 t0 = (p0 - rayOrigin) * invRaydir;
	float3 t1 = (p1 - rayOrigin) * invRaydir;
	float3 tmin = min(t0, t1), tmax = max(t0, t1);
	float maxtmin = max(max(tmin.x, tmin.y), tmin.z);
	float mintmax = min(min(tmax.x, tmax.y), tmax.z);
	outTMin = maxtmin;
	outTMax = mintmax;
	return maxtmin <= mintmax;
}

// From https://en.wikipedia.org/wiki/MöllerTrumbore_intersection_algorithm
bool RayIntersectsTriangle(float3 rayOrigin, float3 rayVector, float3 v0, float3 v1, float3 v2, out float3 outIntersectionPoint, out float2 uv)
{
	outIntersectionPoint = 0.0f;
	uv = 0.0f;

	const float EPSILON = 0.0000001f;
	float3 edge1, edge2, tvec, pvec, qvec;
	float det, invDet, u, v;

	edge1 = v1 - v0;
	edge2 = v2 - v0;

	pvec = cross(rayVector, edge2);
	det = dot(edge1, pvec);
	if (det > -EPSILON && det < EPSILON)
		return false;
	invDet = 1.0f / det;

	tvec = rayOrigin - v0;
	u = dot(tvec, pvec) * invDet;
	if (u < 0.0f || u > 1.0f)
		return false;

	qvec = cross(tvec, edge1);

	v = dot(rayVector, qvec) * invDet;
	if (v < 0.0f || (u + v) > 1.0f)
		return false;

	float t = dot(edge2, qvec) * invDet;

	if (t > EPSILON)
	{
		uv = float2(u, v);
		outIntersectionPoint = rayOrigin + rayVector * t;
		return true;
	}
	else
		return false; // Intersection not in the ray direction
}

float3 GetAnyPerpendicularVector(float3 Dir)
{
	float3 Perp = 0;
	float3 Source = float3(1, 0, 0);
	if (dot(Dir, Source) < 0.99)
	{
		Perp = normalize(cross(Dir, Source));
	}
	else
	{
		Perp = normalize(cross(Dir.yzx, Source));
	}
	return Perp;
}

float3 GetScreenWorldDir(in float4 SVPos)
{
	float2 ScreenPosition = SvPositionToScreenPosition(SVPos).xy;
	const float Depth = 1000000.0f;
	float4 WorldPos = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToTranslatedWorld);
	return normalize(WorldPos.xyz - View.TranslatedWorldCameraOrigin);
}


bool GetRefractedDirection(float2 RandomUV, float a2, float3 V, inout float3 L )
{ 
	float4 H = ImportanceSampleVisibleGGX(UniformSampleDisk(RandomUV), a2, V);

	L = 0;
	float F = 0;
	const float AirIOR = 1.0f;
	const float WaterIOR = 1.33f;
	const float EtaIn = WaterIOR / AirIOR;	// We always consider entering from air to water
	const float RandSample = 1.0f;			// We only consider refracted rays
	return SampleRefraction(-V, H.xyz, EtaIn, RandSample, L, F);
}

float TraceDomainSize;
uint SlabInterfaceLineCount;

void VisualizeRoughRefractionPS(
	float4 SVPos : SV_POSITION,
	out float4 OutColor : SV_Target0)
{
	OutColor = float4(0.0, 0.0f, 0.0, 0.5f);

	float2 PixelPos = SVPos.xy;
	float2 UvBuffer = PixelPos * View.BufferSizeAndInvSize.zw;
	float3 WorldDir = GetScreenWorldDir(SVPos);
	float3 CamWorldPos = LWCToFloat(PrimaryView.WorldCameraOrigin);

	FShaderPrintContext Context = InitShaderPrintContext(all(uint2(PixelPos.xy) == uint2(100, 100)), uint2(100, 100));
	const float IncidentAngle = AddSlider(Context, TEXT("IncidentAngle"), 0.0f, GetDefaultFontColor(), 0.0f, 0.5f * PI);
	Newline(Context);
	const float SlabThickness = AddSlider(Context, TEXT("Slab Thickness"), 5.0f, GetDefaultFontColor(), 0.0f, 20.0f);
	Newline(Context);
	const float Roughness = AddSlider(Context, TEXT("Roughness"), 0.5f, GetDefaultFontColor(), 0.0f, 1.0f);
	Newline(Context);

	float a2 = Pow4(Roughness);
	const float3 N = float3(0, 0, 1);
	const float3 V = float3(sin(IncidentAngle), 0, cos(IncidentAngle));

	float3 SlabEdgeX = float3(60.0f, 0.0f, 0.0f);
	float3 SlabEdgeY = float3(0.0f, 60.0f, 0.0f);
	float3 SlabEdgeZ = float3(0.0f, 0.0f, SlabThickness);
	float3 SlabCenter = CamWorldPos + View.ViewForward * 100.0f;
	float3 RefractionP= SlabCenter + 0.5 * SlabEdgeZ;


	AddLineWS(Context, RefractionP, RefractionP + N * 25.0, float4(0, 0, 1, 1));
	AddLineWS(Context, RefractionP, RefractionP + V * 25.0, float4(0, 1, 1, 1));

#if 0
	float TMin = -1.0f;
	float TMax = -1.0f;
	float3 p0 = SlabCenter - 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	float3 p1 = SlabCenter + 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	slabs(p0, p1, WorldOrigin, 1.0f / WorldDir, TMin, TMax);
#endif

#if 0
	const float SphereRadius = 10.0f;
	float2 Sol = RayIntersectSphere(CamWorldPos, WorldDir, float4(RefractionP, SphereRadius));
	if (Sol.x > 0.0f && Sol.y > 0.0f)
	{
		const float3 P = CamWorldPos + WorldDir * Sol.x;
		const float3 OmegaOut = P - RefractionP;
		const float OmegaOutLen = length(OmegaOut);
		const float3 OmegaOutNorm = OmegaOut / OmegaOutLen;

		const float NoH = dot(normalize(OmegaOutNorm + V), N);
		float D = D_GGX(a2, NoH);
		OutColor = float4(D, D, 0.0, 0.0);
	}
#endif

	// Draw the top and bottom interfaces
	float3 SlabOrigin = SlabCenter - 0.5 * (SlabEdgeX + SlabEdgeY + SlabEdgeZ);
	for (uint i = 0; i <= SlabInterfaceLineCount; i++)
	{
		const float Offset = (float(i) / float(SlabInterfaceLineCount));

		AddLineWS(Context, SlabOrigin + SlabEdgeX * Offset, SlabOrigin + SlabEdgeX * Offset + SlabEdgeY, float4(0.2, 0.2, 0.2, 1.0));
		AddLineWS(Context, SlabOrigin + SlabEdgeY * Offset, SlabOrigin + SlabEdgeY * Offset + SlabEdgeX, float4(0.2, 0.2, 0.2, 1.0));

		AddLineWS(Context, SlabOrigin + SlabEdgeX * Offset + SlabEdgeZ, SlabOrigin + SlabEdgeX * Offset + SlabEdgeY + SlabEdgeZ, float4(0.2, 0.2, 0.2, 1.0));
		AddLineWS(Context, SlabOrigin + SlabEdgeY * Offset + SlabEdgeZ, SlabOrigin + SlabEdgeY * Offset + SlabEdgeX + SlabEdgeZ, float4(0.2, 0.2, 0.2, 1.0));
	}

	for (float u = 0.5f; u < TraceDomainSize; u++)
	{
		for (float v = 0.5f; v < TraceDomainSize; v++)
		{
			float2 RandomUV = float2(u, v) / TraceDomainSize;
			float3 L = 0;
			if (GetRefractedDirection(RandomUV, a2, V, L))
			{
				AddLineWS(Context, RefractionP, RefractionP + L * 15.0, float4(0, 1, 0, 0.3));
			}
			else
			{
				AddLineWS(Context, RefractionP, RefractionP + L * 15.0, float4(1, 0, 0, 0.3));
			}
		}
	}

}





#endif


