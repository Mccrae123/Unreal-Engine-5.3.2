// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"

#define STRATA_INLINE_SHADING 0
#define STRATA_SSS_MATERIAL_OVERRIDE 0
#include "/Engine/Private/Strata/Strata.ush"
#include "StrataTile.ush"

#define GROUP_THREAD_COUNT (STRATA_TILE_SIZE * STRATA_TILE_SIZE)

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_TILE_CATEGORIZATION
int bRectPrimitive;
int2 ViewResolution;
uint MaxBytesPerPixel;
Texture2D<uint> TopLayerTexture;
Texture2DArray<uint> MaterialTextureArray;

// Indirect draw data buffer for all tile types
RWBuffer<uint> TileIndirectDataBuffer;

RWBuffer<uint> SimpleTileListDataBuffer;
RWBuffer<uint> SingleTileListDataBuffer;
RWBuffer<uint> ComplexTileListDataBuffer;

#if STRATA_OPAQUE_ROUGH_REFRACTION_ENABLED
RWBuffer<uint> OpaqueRoughRefractionTileListDataBuffer;
RWBuffer<uint> SSSWithoutOpaqueRoughRefractionTileListDataBuffer;
Texture2D<float3> OpaqueRoughRefractionTexture;
#endif

#if !PERMUTATION_WAVE_OPS
groupshared uint s_TileFlags[GROUP_THREAD_COUNT];
#endif

#if PERMUTATION_STRATA_CLEAR_DURING_CATEGORIZATION
RWTexture2D<uint2> SSSTextureUAV;
#endif

[numthreads(STRATA_TILE_SIZE, STRATA_TILE_SIZE, 1)]
void TileMainCS(uint2 DispatchThreadId : SV_DispatchThreadID, uint LinearIndex : SV_GroupIndex, uint3 GroupId : SV_GroupID)
{
	if (all(DispatchThreadId == 0))
	{
		const uint IndexCountPerInstance = bRectPrimitive > 0 ? 4 : 6;
		TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_SIMPLE)					+ 0] = IndexCountPerInstance;
		TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_SINGLE)					+ 0] = IndexCountPerInstance;
		TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_COMPLEX)					+ 0] = IndexCountPerInstance;
		TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_ROUGH_REFRACT)				+ 0] = IndexCountPerInstance;
		TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_SSS_WITHOUT_ROUGH_REFRACT) + 0] = IndexCountPerInstance;
	}

	// TODO: add a SM6 permutation with ballot?
	const uint2 PixelCoord = DispatchThreadId;

	// Pixels outside of the view area are considered simple to enable screen borders to receive the simple permutation when not aligned to shader group size.
	bool bContainsComplexMaterial = false;
	bool bContainsSimpleMaterial  = false;
	bool bContainsSingleMaterial  = false;
	bool bContainsStrataMaterial  = false;
	bool bContainsOpaqueRoughRefraction = false;
	bool bContainsScreenSpaceSubsurfaceScattering = false;
	FStrataOpaqueRoughRefractionData OpaqueRoughRefractionData = (FStrataOpaqueRoughRefractionData)0;
	if (all(PixelCoord < uint2(ViewResolution)))
	{
		FStrataAddressing StrataAddressing = GetStrataPixelDataByteOffset(PixelCoord, uint2(View.BufferSizeAndInvSize.xy), MaxBytesPerPixel);
		FStrataPixelHeader StrataPixelHeader = UnpackStrataHeaderIn(MaterialTextureArray, StrataAddressing, TopLayerTexture);

		const bool bIsSimple =  IsSimpleMaterial(StrataPixelHeader) || StrataPixelHeader.BSDFCount == 0; // BSDFCount == 0 ensures that non-strata pixel, like sky pixels, won't make a simple tile flagged as complex
		const bool bIsSingle = !IsSimpleMaterial(StrataPixelHeader) && IsSingleMaterial(StrataPixelHeader);
		bContainsStrataMaterial  = StrataPixelHeader.BSDFCount > 0;
		bContainsSimpleMaterial  = bIsSimple;
		bContainsSingleMaterial  = bIsSingle;
		bContainsComplexMaterial = !bIsSingle & !bIsSimple;
		bContainsScreenSpaceSubsurfaceScattering = HasSubsurface(StrataPixelHeader);

#if STRATA_OPAQUE_ROUGH_REFRACTION_ENABLED
		OpaqueRoughRefractionData = StrataUnpackOpaqueRoughRefractionData(OpaqueRoughRefractionTexture[PixelCoord]);
		bContainsOpaqueRoughRefraction = OpaqueRoughRefractionData.OpaqueRoughRefractionEnabled > 0.0f;
#endif
	}

#if PERMUTATION_STRATA_CLEAR_DURING_CATEGORIZATION
	BRANCH
	if (!bContainsScreenSpaceSubsurfaceScattering)
	{
		// We must fill all the pixel which doe not hav subsurface scattering with default so that the SSS code is not executed where it should not.
		FStrataSubsurfaceData StrataSubsurfaceData = (FStrataSubsurfaceData)0;
		SSSTextureUAV[DispatchThreadId.xy] = StrataPackSSSData(StrataSubsurfaceData);
	}
#endif

#if PERMUTATION_WAVE_OPS
	const bool bTileContainsStrata							= WaveActiveAnyTrue(bContainsStrataMaterial);
//	const bool bTileContainsSimple							= WaveActiveAnyTrue(bContainsSimpleMaterial);
	const bool bTileContainsSingle							= WaveActiveAnyTrue(bContainsSingleMaterial);
	const bool bTileContainsComplex							= WaveActiveAnyTrue(bContainsComplexMaterial);
	const bool bTileContainsOpaqueRoughRefraction			= WaveActiveAnyTrue(bContainsOpaqueRoughRefraction);
	const bool bTileContainsScreenSpaceSubsurfaceScattering	= WaveActiveAnyTrue(bHasScreenSpaceSubsurfaceScattering);
#else // PERMUTATION_WAVE_OPS

	s_TileFlags[LinearIndex] = 
		(bContainsStrataMaterial					? 0x1u	: 0u) | 
//		(bContainsSimpleMaterial					? 0x2u	: 0u) | 
		(bContainsSingleMaterial					? 0x4u	: 0u) | 
		(bContainsComplexMaterial					? 0x8u	: 0u) | 
		(bContainsOpaqueRoughRefraction				? 0x10u : 0u) |
		(bContainsScreenSpaceSubsurfaceScattering	? 0x20u : 0u);

	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 32)
	{
		s_TileFlags[LinearIndex] = s_TileFlags[LinearIndex] | s_TileFlags[LinearIndex + 32];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 16)
	{
		s_TileFlags[LinearIndex] = s_TileFlags[LinearIndex] | s_TileFlags[LinearIndex + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	if (LinearIndex < 8)
	{
		s_TileFlags[LinearIndex] = s_TileFlags[LinearIndex] | s_TileFlags[LinearIndex + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 4)
	{
		s_TileFlags[LinearIndex] = s_TileFlags[LinearIndex] | s_TileFlags[LinearIndex + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 2)
	{
		s_TileFlags[LinearIndex] = s_TileFlags[LinearIndex] | s_TileFlags[LinearIndex + 2];
	}
	GroupMemoryBarrierWithGroupSync();

	const uint FinalTileFlags = s_TileFlags[LinearIndex] | s_TileFlags[LinearIndex + 1];

	const bool bTileContainsStrata							= (FinalTileFlags & 0x1u) > 0;
//	const bool bTileContainsSimple							= (FinalTileFlags & 0x2u) > 0;
	const bool bTileContainsSingle							= (FinalTileFlags & 0x4u) > 0;
	const bool bTileContainsComplex							= (FinalTileFlags & 0x8u) > 0;
	const bool bTileContainsOpaqueRoughRefraction			= (FinalTileFlags & 0x10u) > 0;
	const bool bTileContainsScreenSpaceSubsurfaceScattering	= (FinalTileFlags & 0x20u) > 0;
#endif // PERMUTATION_WAVE_OPS

	if (LinearIndex < 1 && bTileContainsStrata)
	{
		uint EncodedTile = StrataPackTile(GroupId.xy);

		if (bTileContainsComplex)
		{
			uint WriteToIndex;
			InterlockedAdd(TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_COMPLEX) + 1], 1, WriteToIndex);
			ComplexTileListDataBuffer[WriteToIndex] = EncodedTile;
		}
		else if (bTileContainsSingle)
		{
			uint WriteToIndex;
			InterlockedAdd(TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_SINGLE) + 1], 1, WriteToIndex);
			SingleTileListDataBuffer[WriteToIndex] = EncodedTile;
		}
		else // (bTileContainsSimple)
		{
			uint WriteToIndex;
			InterlockedAdd(TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_SIMPLE) + 1], 1, WriteToIndex);
			SimpleTileListDataBuffer[WriteToIndex] = EncodedTile;
		}

#if STRATA_OPAQUE_ROUGH_REFRACTION_ENABLED
		if (bTileContainsOpaqueRoughRefraction)
		{
			uint WriteToIndex;
			InterlockedAdd(TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_ROUGH_REFRACT) + 1], 1, WriteToIndex);
			OpaqueRoughRefractionTileListDataBuffer[WriteToIndex] = EncodedTile;
		}
		if(bTileContainsScreenSpaceSubsurfaceScattering && !bTileContainsOpaqueRoughRefraction)
		{
			uint WriteToIndex;
			InterlockedAdd(TileIndirectDataBuffer[GetStrataTileTypeDrawIndirectArgOffset_DWord(STRATA_TILE_TYPE_SSS_WITHOUT_ROUGH_REFRACT) + 1], 1, WriteToIndex);
			SSSWithoutOpaqueRoughRefractionTileListDataBuffer[WriteToIndex] = EncodedTile;
		}
#endif
	}
}
#endif // SHADER_TILE_CATEGORIZATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_CLEAR_MATERIAL_BUFFER

RWTexture2DArray<uint> MaterialTextureArrayUAV;
RWTexture2D<uint2> SSSTextureUAV;
uint MaxBytesPerPixel;
int2 TiledViewBufferResolution;

[numthreads(8, 8, 1)]
void ClearMaterialBufferMainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	if (any(int2(DispatchThreadId.xy) >= TiledViewBufferResolution))
	{
		return;
	}

	// Custom clear of the Strata material buffer.
	// The first layer of tiled uints contains the header that we need to clear so we only write a single uint per pixel instead of clearing the entire buffer which would be too slow.

	FStrataPixelHeader StrataHeader = InitialiseStrataPixelHeader();
	uint BSDFCount = 0;
	uint PackedStrataHeader = PackStrataHeader(BSDFCount, StrataHeader);

	const uint FirstSlice = 0;
	MaterialTextureArrayUAV[uint3(DispatchThreadId.xy, FirstSlice)] = PackedStrataHeader;

	FStrataSubsurfaceData StrataSubsurfaceData = (FStrataSubsurfaceData)0;
	SSSTextureUAV[DispatchThreadId.xy] = StrataPackSSSData(StrataSubsurfaceData);
}

#endif // SHADER_CLEAR_MATERIAL_BUFFER

////////////////////////////////////////////////////////////////////////////////////////////////////////////

