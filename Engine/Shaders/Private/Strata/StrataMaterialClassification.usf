// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

#define STRATA_INLINE_SHADING 0
#include "/Engine/Private/Strata/Strata.ush"

// Note: 
// This code is partial copy of PackStrataOut in Strata.ush. 
// The command part will progressively be removed as we remove data from the gbuffer.
void ComputePostProcessBSDFData(
	const FStrataPixelHeader Header,
	const FStrataBSDF BSDF,
	float3 V,
	inout FStrataClassification Classification,
	inout FStrataSubsurfaceData SSS,
	inout FStrataTopLayerData TopLayer)
{
	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;
	const float FullyRough = 1.0f;

	const float3 BSDFCoverage = BSDF.Weight;
	const float  BSDFCoverageAvg = dot(BSDF.Weight,1.0f/3.0f);

	// STRATA_TODO apply the same normal transform as for the material
	float3x3 TangentBasis = StrataGetBSDFSharedBasis(Header, BSDF);
	float3 N = TangentBasis[2];
	//N = normalize(N);

	TopLayer.Normal += N;

	BxDFContext ContextNoLight = (BxDFContext)0;
	const float3 FakeL = float3(0, 0, 1);
	Init(ContextNoLight, N, V, FakeL);

	const bool bTopLayer = BSDF_GETISTOPLAYER(BSDF);

	Classification.ShadingModels |= StrataShadingModelBit(BSDF_GETTYPE(BSDF));

	switch (BSDF_GETTYPE(BSDF))
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		const float3 F0 = ComputeF0(SLAB_SPECULAR(BSDF), SLAB_BASECOLOR(BSDF), SLAB_METALLIC(BSDF));

		if (bTopLayer)
		{
			// Setup SSR for the top layer
			TopLayer.Roughness += BSDFCoverageAvg * SLAB_ROUGHNESSX(BSDF);
			TopLayer.AccumRoughnessCount += BSDFCoverageAvg;

			const float SafeRoughness = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDF));
			TopLayer.BaseColor += BSDFCoverage * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
		}

		// Select the first/toppest layer with subsurface scattering
		if (BSDF_GETHASSCATTERING(BSDF) && BSDFCoverageAvg > 0 && SLAB_SSSPROFILERADIUS(BSDF) > 0 && !SSS.bHasSubsurface)
		{
			SSS.bHasSubsurface = true;
			SSS.bHasProfile	= BSDF_GETHASSSSPROFILE(BSDF);
			SSS.Profile		= SLAB_SSSPROFILEID(BSDF);
			SSS.RadiusScale	= SLAB_SSSPROFILERADIUS(BSDF);
			SSS.BaseColor	= SLAB_BASECOLOR(BSDF);
			SSS.DMFPAlbedo	= SLAB_SSSDMFPALBEDO(BSDF);
			SSS.DMFPRadius	= SLAB_SSSDMFPRADIUS(BSDF);
		}
		break;
	}

	case STRATA_BSDF_TYPE_SHEEN:
	{
		const float3 F0  = SHEEN_BASECOLOR(BSDF);
		const float3 F   = F_Schlick(F0, ContextNoLight.VoH);

		if (bTopLayer)
		{
			TopLayer.Roughness += SHEEN_ROUGHNESS(BSDF);
			TopLayer.AccumRoughnessCount += 1.0f;

			const float SafeRoughness = MakeRoughnessSafe(SHEEN_ROUGHNESS(BSDF));
			TopLayer.BaseColor += BSDFCoverage * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
		}
		break;
	}

	case STRATA_BSDF_TYPE_HAIR:
	{
		Classification.bHasTransmission = true;

		// No SSR
		if (bTopLayer)
		{
			TopLayer.Roughness += BSDFCoverageAvg * FullyRough; // Do not trigger SSR by using fully rough
			TopLayer.AccumRoughnessCount += BSDFCoverageAvg;
		}
		break;
	}

	case STRATA_BSDF_TYPE_SINGLELAYERWATER:
	{
		if (bTopLayer)
		{
			const float Roughness = SLW_ROUGHNESS(BSDF);

			TopLayer.Roughness += BSDFCoverageAvg * Roughness;
			TopLayer.AccumRoughnessCount += BSDFCoverageAvg;

			// The specular over the water in completely in the hand of the user. We do not fade out metallness for instance.
			const float3 F0 = ComputeF0(SLW_SPECULAR(BSDF), SLW_BASECOLOR(BSDF), SLW_METALLIC(BSDF));
			const float SafeRoughness = MakeRoughnessSafe(Roughness);
			TopLayer.BaseColor += BSDFCoverageAvg * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
		}
		break;
	}

	} // switch		
}

void MainPS(
	float4 SVPos : SV_POSITION, 
	out uint OutColor0 : SV_Target0,
	out uint2 OutColor1 : SV_Target1)
{
	const uint2 PixelPos = uint2(SVPos.xy);

	// Sample scene textures.
	float2 BufferUV		 = SvPositionToBufferUV(float4(PixelPos, SVPos.zw));
	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);
	
	FStrataClassification ClassificationData	= (FStrataClassification)0;
	FStrataSubsurfaceData SSSData				= (FStrataSubsurfaceData)0;
	FStrataTopLayerData TopLayerData			= (FStrataTopLayerData)0;

	ClassificationData.bIsStrataMaterial = GBuffer.ShadingModelID == SHADINGMODELID_STRATA;
	if (ClassificationData.bIsStrataMaterial)
	{
		float2 ScreenPosition = SvPositionToScreenPosition(SVPos).xy;
		const float Depth = 1000000.0f;
		float4 WorldPos = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToWorld);
		const float3 V = normalize(View.WorldCameraOrigin - WorldPos.xyz);

		uint PixelStrataDataByteOffset = GetStrataPixelDataByteOffset(PixelPos, View.BufferSizeAndInvSize.x, Strata.MaxBytesPerPixel);
		FStrataPixelHeader Header = UnpackStrataHeaderIn(Strata.MaterialLobesBuffer, PixelStrataDataByteOffset);
		for (uint BSDFIndex = 0; BSDFIndex < Header.BSDFCount; ++BSDFIndex)
		{
			const FStrataBSDF BSDF = UnpackStrataBSDFIn(Strata.MaterialLobesBuffer, PixelStrataDataByteOffset);
			ComputePostProcessBSDFData(Header, BSDF, V, ClassificationData, SSSData, TopLayerData);
		}

		FinalizeTopLayerData(TopLayerData);
	}

	OutColor0 = StrataPackClassificationData(ClassificationData);
	OutColor1 = StrataPackTopLayerData(TopLayerData);
}
