// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"

#define STRATA_INLINE_SHADING 0
#include "/Engine/Private/Strata/Strata.ush"

#define TILE_SIZE 8
#define GROUP_THREAD_COUNT (TILE_SIZE*TILE_SIZE)

#if SHADER_CATEGORIZATION 

// Note: 
// This code is partial copy of PackStrataOut in Strata.ush. 
// The command part will progressively be removed as we remove data from the gbuffer.
void ComputePostProcessBSDFData(
	const FStrataPixelHeader Header,
	const FStrataBSDF BSDF,
	const FStrataAddressing StrataAddressing,
	float3 V,
	inout FStrataClassification Classification,
	inout FStrataSubsurfaceData SSS,
	inout FStrataTopLayerData TopLayer,
	inout float TopLayerRoughness, 
	inout float TopLayerRoughnessAverageCount)
{
	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;
	const float FullyRough = 1.0f;

	const float3 BSDFWeight = BSDF.Weight;
	const float  BSDFWeightAvg = dot(BSDF.Weight,1.0f/3.0f);

	// STRATA_TODO apply the same normal transform as for the material
	float3x3 TangentBasis = StrataGetBSDFSharedBasis(Header, BSDF, StrataAddressing);
	float3 N = TangentBasis[2];
	//N = normalize(N);

	TopLayer.WorldNormal += N;

	BxDFContext ContextNoLight = (BxDFContext)0;
	const float3 FakeL = float3(0, 0, 1);
	Init(ContextNoLight, N, V, FakeL);

	const bool bTopLayer = BSDF_GETISTOPLAYER(BSDF);

	Classification.ShadingModels |= StrataShadingModelBit(BSDF_GETTYPE(BSDF));
	Classification.bIsSimple = Classification.bIsSimple && BSDF_GETTYPE(BSDF) == STRATA_BSDF_TYPE_SLAB;

	switch (BSDF_GETTYPE(BSDF))
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		const float3 F0  = ComputeF0(SLAB_SPECULAR(BSDF), SLAB_BASECOLOR(BSDF), SLAB_METALLIC(BSDF));
		const float3 F90 = ComputeF90(F0, SLAB_BASECOLOR(BSDF), SLAB_METALLIC(BSDF));

		if (bTopLayer)
		{
			// Setup SSR for the top layer
			TopLayerRoughness += BSDFWeightAvg * SLAB_ROUGHNESSX(BSDF);
			TopLayerRoughnessAverageCount += BSDFWeightAvg;
		}

		Classification.bIsSimple = Classification.bIsSimple && IsStrataFastPathCompatible(BSDF);

		// Select the latest encoutered SSS BSDF
		if (BSDF_GETHASSCATTERING(BSDF) && BSDFWeightAvg > 0)
		{
			Classification.bHasSubsurface = true;

			SSS.BaseColor = SLAB_BASECOLOR(BSDF);

			// STRATA_TODO when layered translucency is figured out once again, only bottom layer should run SSS

			// Profile ID: we only keep the latest ID, and profile will overtake any non-profile based SSS
			SSS.bIsProfile			= SSS.bIsProfile || BSDF_GETHASSSSPROFILE(BSDF);
			SSS.ProfilePackedId		= SLAB_SSSPROFILEID(BSDF);
			SSS.ProfileRadiusScale	= SLAB_SSSPROFILERADIUSSCALE(BSDF);

			// STRATA_TODO This should be accumulated according to the BSDF weight when we run this in the base pass.
			// We cannot do that now because BSDFWeight contains weight*coverage*trhougput all mixed together.
			SSS.DMFP				= SLAB_SSSDMFP(BSDF);
		}
		break;
	}

	case STRATA_BSDF_TYPE_SHEEN:
	{
		const float3 F0  = SHEEN_BASECOLOR(BSDF);
		const float3 F   = F_Schlick(F0, ContextNoLight.VoH);

		if (bTopLayer)
		{
			TopLayerRoughness += SHEEN_ROUGHNESS(BSDF);
			TopLayerRoughnessAverageCount += 1.0f;
		}
		break;
	}

	case STRATA_BSDF_TYPE_HAIR:
	{
		// No SSR
		if (bTopLayer)
		{
			TopLayerRoughness += BSDFWeightAvg * FullyRough; // Do not trigger SSR by using fully rough
			TopLayerRoughnessAverageCount += BSDFWeightAvg;
		}
		break;
	}

	case STRATA_BSDF_TYPE_SINGLELAYERWATER:
	{
		if (bTopLayer)
		{
			const float Roughness = SLW_ROUGHNESS(BSDF);

			TopLayerRoughness += BSDFWeightAvg * Roughness;
			TopLayerRoughnessAverageCount += BSDFWeightAvg;
		}
		break;
	}

	} // switch		
}

void MainPS(
	float4 SVPos : SV_POSITION, 
	out uint  OutColor0 : SV_Target0,
	out uint  OutColor1 : SV_Target1,
	out uint2 OutColor2 : SV_Target2)
{
	const uint2 PixelPos = uint2(SVPos.xy);
	
	FStrataClassification ClassificationData	= (FStrataClassification)0;
	FStrataSubsurfaceData SSSData				= (FStrataSubsurfaceData)0;
	FStrataTopLayerData TopLayerData			= (FStrataTopLayerData)0;

	FStrataAddressing StrataAddressing = GetStrataPixelDataByteOffset(PixelPos, uint2(View.BufferSizeAndInvSize.xy), Strata.MaxBytesPerPixel);
	FStrataPixelHeader Header = UnpackStrataHeaderIn(Strata.MaterialLobesBuffer, StrataAddressing);

	ClassificationData.bIsStrataMaterial = Header.BSDFCount > 0;
	ClassificationData.MaterialAO = 1.0;
	ClassificationData.bIsSimple = true; // non strata material or sky pixels are considered as simple.
	if (ClassificationData.bIsStrataMaterial)
	{
		float2 ScreenPosition = SvPositionToScreenPosition(SVPos).xy;
		const float Depth = 1000000.0f;
		float4 WorldPos = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToWorld);
		const float3 V = normalize(View.WorldCameraOrigin - WorldPos.xyz);

		ClassificationData.MaterialAO = Header.MaterialAO;
		ClassificationData.bIsSimple = Header.BSDFCount == 1;

		float TopLayerRoughness = 0.0f;
		float TopLayerRoughnessAverageCount = 0.0f;
		for (uint BSDFIndex = 0; BSDFIndex < Header.BSDFCount; ++BSDFIndex)
		{
			const FStrataBSDF BSDF = UnpackStrataBSDFIn(Strata.MaterialLobesBuffer, StrataAddressing);
			ComputePostProcessBSDFData(Header, BSDF, StrataAddressing, V, ClassificationData, SSSData, TopLayerData, TopLayerRoughness, TopLayerRoughnessAverageCount);
		}

		TopLayerData.WorldNormal = normalize(TopLayerData.WorldNormal);
		ClassificationData.TopLayerRoughness = TopLayerRoughnessAverageCount > 0.0f ? TopLayerRoughness / TopLayerRoughnessAverageCount : 0.0f;
	}
	else
	{
		TopLayerData.WorldNormal = normalize(float3(-1.0f, -1.0f, -1.0f));
	}

	OutColor0 = StrataPackClassificationData(ClassificationData);
	OutColor1 = StrataPackTopLayerData(TopLayerData);
	OutColor2 = StrataPackSSSData(SSSData);
}
#endif // SHADER_CATEGORIZATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint EncodeTile(uint2 TileCoord)
{
	return TileCoord.x | (TileCoord.y << 16); // assumes 16bit is enough to represent a tiled resolution up to 65,535 :)
}

uint2 DecodeTile(uint In)
{
	return uint2(In & 0xFFFF, In >> 16);
}

#if SHADER_TILE_CATEGORIZATION
int TileSize;
int bRectPrimitive;
int2 ViewResolution;
Texture2D<uint> ClassificationTexture;
RWBuffer<uint> TileIndirectData;
RWBuffer<uint> TileListData;

groupshared bool s_IsSimpleTile[GROUP_THREAD_COUNT];

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TileMainCS(uint2 DispatchThreadId : SV_DispatchThreadID, uint LinearIndex : SV_GroupIndex, uint3 GroupId : SV_GroupID)
{
	if (all(DispatchThreadId == 0))
	{
		TileIndirectData[0] = bRectPrimitive > 0 ? 4 : 6;
	}

	// TODO: add a SM6 permutation with ballot?
	const uint2 PixelCoord = DispatchThreadId;

	// Pixels outside of the view area are considered simple to enable screen borders to receive the simple permutation when not aligned to shader group size.
	bool bIsSimpleTile = true;
	if (all(PixelCoord < uint2(ViewResolution)))
	{
		const uint PackClassification = ClassificationTexture.Load(uint3(PixelCoord, 0));
		FStrataClassification Data = StrataUnpackClassificationData(PackClassification);
		bIsSimpleTile = Data.bIsSimple;
	}
	s_IsSimpleTile[LinearIndex] = bIsSimpleTile;

	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 32)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 32];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 16)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 16];
	}
	GroupMemoryBarrierWithGroupSync();

	if (LinearIndex < 8)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 8];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 4)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 4];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 2)
	{
		s_IsSimpleTile[LinearIndex] = s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 2];
	}
	GroupMemoryBarrierWithGroupSync();
	if (LinearIndex < 1 && (s_IsSimpleTile[LinearIndex] && s_IsSimpleTile[LinearIndex + 1]))
	{
		uint WriteToIndex;
		InterlockedAdd(TileIndirectData[1], 1, WriteToIndex);
		TileListData[WriteToIndex] = EncodeTile(GroupId.xy);
	}
}
#endif // SHADER_TILE_CATEGORIZATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_STENCIL_CATEGORIZATION

int  TileSize;
int2 TileCount;
int	 bRectPrimitive;
int2 OutputResolution;
Buffer<uint> TileListBuffer;

void StencilMainVS(
	in uint InVertexId : SV_VertexID,
	in uint InInstanceId : SV_InstanceID,
	out float4 OutPosition : SV_POSITION,
	out uint2 OutTileCoord : TILE_COORD)
{
	const uint2 TileCoord = DecodeTile(TileListBuffer[InInstanceId]);

	uint2 TileVertex = TileCoord * TILE_SIZE;
	TileVertex.x += InVertexId == 1 || InVertexId == 2 || InVertexId == 4 ? TILE_SIZE : 0;
	TileVertex.y += InVertexId == 2 || InVertexId == 4 || InVertexId == 5 ? TILE_SIZE : 0;
	OutPosition = float4(float2(TileVertex) / OutputResolution * float2(2.0f, -2.0f) + float2(-1.0, 1.0f), 0.5f, 1.0f);
	OutTileCoord = TileCoord;
}

void StencilMainPS(
	in float4 SVPos : SV_POSITION,
	in uint2 InTileCoord : TILE_COORD,
	out float4 OutColor0 : SV_Target0)
{
	const bool bTileX = (InTileCoord.x & 1) == 0;
	const bool bTileY = (InTileCoord.y & 1) == 0;
	const bool bChecker = (bTileX && bTileY) || (!bTileX && !bTileY);
	OutColor0 = bChecker ? float4(0.0f, 0.5f, 0.f, 1.0f) : float4(0.f, 1.0f, 0.f, 1.0f);
}

#endif //SHADER_STENCIL_CATEGORIZATION

////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if SHADER_CLEAR_MATERIAL_BUFFER

RWByteAddressBuffer MaterialLobesBufferUAV;
uint MaxBytesPerPixel;
int2 TiledViewBufferResolution;

[numthreads(8, 8, 1)]
void ClearMaterialBufferMainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	if (any(int2(DispatchThreadId.xy) > TiledViewBufferResolution))
	{
		return;
	}

	// Custom clear of the Strata material buffer.
	// The first layer of tiled uints contains the header that we need to clear so we only write a single uint per pixel instead of clearing the entire buffer which would be too slow.

	FStrataPixelHeader StrataHeader = InitialiseStrataPixelHeader();
	uint BSDFCount = 0;
	uint PackedStrataHeader = PackStrataHeaderIn(BSDFCount, StrataHeader);

	FStrataAddressing StrataAddressing = GetStrataPixelDataByteOffset(DispatchThreadId.xy, TiledViewBufferResolution, MaxBytesPerPixel);
	MaterialLobesBufferUAV.Store(StrataAddressing.CurrentAddr, PackedStrataHeader);
}

#endif // SHADER_CLEAR_MATERIAL_BUFFER
