// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../BRDF.ush"
#include "../ShadingCommon.ush"
#include "../ParticipatingMediaCommon.ush"
#include "../MonteCarlo.ush"
#include "../SHCommon.ush"
#include "../DeferredShadingCommon.ush"

#include "/Engine/Shared/StrataDefinitions.h"

// STRATA_TODO
//	- What model exactly
//	- Fat dielectric model? Or make it adaptative (for instance Medium_ could be optional to store/load)
//	- Have a Disney model that is convernient to be super packed and be able to represent current mateiral?
//	- Shared normal? Up to N normals? On CPU, inputs have a hash that could be use to decuplicate normals
//	- Transmittance lob modelisation (GGX statistics?) and blocking surface such as FStrataDiffuse?
//	- fp16 on gen5


///////////////////////////////////////////////////////////////////////////////
// BSDFs representation

//struct FStrataDiffuse
//{
//	float3	Albedo;
//	float   Roughness;
//
//	float3	Normal;
//};
//
//struct FStrataDielectric
//{
//	float	IOR;
//	float3	Tint;
//	float2	Roughness;
//
//	float3	Normal;
//};
//
//struct FStrataConductor
//{
//	float3	Reflectivity;
//	float3	EdgeColor;
//	float2	Roughness;
//
//	float3	Normal;
//};
//
//struct FStrataVolume
//{
//	float3	Albedo;
//	float3	Extinction;
//	float	Anisotropy;
//	float	Thickness;
//
//	float3  SmoothSurfaceNormal;	// Typically vertex normal
//};



// The largest Strata BSDF is FStrataConductor having as size of 24 bytes (FStrataConductor)
// So we will have 
//		STRATA_MAX_TOTAL_BSDF * sizeof(FStrataConductor) +				// 4 * 16
//		STRATA_MAX_TOTAL_BSDF * (sizeof(BSDFType) + sizeof(Weight))		// 4 * 8
//		sizeof(BSDFCount)												// UINT
//		= 4 * 16 + 4 * 8 + 1 = 96 + 32 + 1 = 97						// See Strata.cpp
struct FStrataBSDF
{
	int					BSDFType;
	float3				Weight;		// Weight is a float3 because, when loaded from the material buffer, it contains the BSDF throughput (coverage and transmittance combined)

	// We cannot have the structures above represented as a union in HLSL, so we enforce that using an array representing VGPRs and a bunch of preprocessor functions.
	//union BSDFsUnion
	//{
	//	FStrataDiffuse		Diffuse;
	//	FStrataDielectric	Dielectric;
	//	FStrataConductor	Conductor;
	//	FStrataVolume		Volume;
	//};
	//BSDFsUnion U;

	float4 VGPRs[3];
};

#define DIFFUSE_ALBEDO(X)				X.VGPRs[0].xyz
#define DIFFUSE_ROUGHNESS(X)			X.VGPRs[0].w
#define DIFFUSE_NORMAL(X)				X.VGPRs[1].xyz

#define DIELECTRIC_TINT(X)				X.VGPRs[0].xyz
#define DIELECTRIC_IOR(X)				X.VGPRs[0].w
#define DIELECTRIC_ROUGHNESS0(X)		X.VGPRs[1].w
#define DIELECTRIC_ROUGHNESS1(X)		X.VGPRs[2].w
#define DIELECTRIC_NORMAL(X)			X.VGPRs[1].xyz

#define CONDUCTOR_REFLECTIVITY(X)		X.VGPRs[0].xyz
#define CONDUCTOR_EDGECOLOR(X)			X.VGPRs[1].xyz
#define CONDUCTOR_ROUGHNESS0(X)			X.VGPRs[2].w
#define CONDUCTOR_ROUGHNESS1(X)			X.VGPRs[1].w
#define CONDUCTOR_NORMAL(X)				X.VGPRs[2].xyz

#define VOLUME_ALBEDO(X)				X.VGPRs[0].xyz
#define VOLUME_EXTINCTION(X)			X.VGPRs[1].xyz
#define VOLUME_ANISOTROPY(X)			X.VGPRs[0].w
#define VOLUME_THICKNESS(X)				X.VGPRs[1].w
#define VOLUME_SMOOTHSURFACENORMAL(X)	X.VGPRs[2].xyz


struct FStrataLayer
{
	int BSDFCount;

	FStrataBSDF BSDFs[STRATA_MAX_BSDF_COUNT_PER_LAYER];
};

struct FStrataData
{
	int LayerCount;

	FStrataLayer Layers[STRATA_MAX_LAYER_COUNT];	// Layer 0 is the top layer
};


FStrataData GetInitialisedStrataData()
{
	FStrataData StrataData = (FStrataData)0;
	return StrataData;
}

FStrataData GetStrataDiffuseOrenNayarBSDF(float3 Albedo, float Roughness, float3 Normal)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	StrataData.Layers[0].BSDFs[0].BSDFType						= STRATA_BSDF_TYPE_DIFFUSE_ON;
	DIFFUSE_ALBEDO(StrataData.Layers[0].BSDFs[0])				= Albedo;
	DIFFUSE_ROUGHNESS(StrataData.Layers[0].BSDFs[0])			= Roughness;
	DIFFUSE_NORMAL(StrataData.Layers[0].BSDFs[0])				= Normal;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataDiffuseChanBSDF(float3 Albedo, float Roughness, float3 Normal)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	StrataData.Layers[0].BSDFs[0].BSDFType						= STRATA_BSDF_TYPE_DIFFUSE_CHAN;
	DIFFUSE_ALBEDO		(StrataData.Layers[0].BSDFs[0])			= Albedo;
	DIFFUSE_ROUGHNESS	(StrataData.Layers[0].BSDFs[0])			= Roughness;
	DIFFUSE_NORMAL		(StrataData.Layers[0].BSDFs[0])			= Normal;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataDielectricBSDF(float2 Roughness, float IOR, float3 Tint, float3 Normal)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	StrataData.Layers[0].BSDFs[0].BSDFType						= STRATA_BSDF_TYPE_DIELECTRIC;
	DIELECTRIC_IOR			(StrataData.Layers[0].BSDFs[0])		= IOR;
	DIELECTRIC_TINT			(StrataData.Layers[0].BSDFs[0])		= Tint;
	DIELECTRIC_ROUGHNESS0	(StrataData.Layers[0].BSDFs[0])		= Roughness.x;
	DIELECTRIC_ROUGHNESS1	(StrataData.Layers[0].BSDFs[0])		= Roughness.y;
	DIELECTRIC_NORMAL		(StrataData.Layers[0].BSDFs[0])		= Normal;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataConductorBSDF(float3 Reflectivity, float3 EdgeColor, float2 Roughness, float3 Normal)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	StrataData.Layers[0].BSDFs[0].BSDFType						= STRATA_BSDF_TYPE_CONDUCTOR;
	CONDUCTOR_REFLECTIVITY	(StrataData.Layers[0].BSDFs[0])		= Reflectivity;
	CONDUCTOR_EDGECOLOR		(StrataData.Layers[0].BSDFs[0])		= EdgeColor;
	CONDUCTOR_ROUGHNESS0	(StrataData.Layers[0].BSDFs[0])		= Roughness.x;
	CONDUCTOR_ROUGHNESS1	(StrataData.Layers[0].BSDFs[0])		= Roughness.y;
	CONDUCTOR_NORMAL		(StrataData.Layers[0].BSDFs[0])		= Normal;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataVolumeBSDF(float3 Albedo, float3 Extinction, float Anisotropy, float Thickness, float3 SmoothSurfaceNormal)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	StrataData.Layers[0].BSDFs[0].BSDFType						= STRATA_BSDF_TYPE_VOLUME;
	VOLUME_ALBEDO				(StrataData.Layers[0].BSDFs[0])	= Albedo;
	VOLUME_EXTINCTION			(StrataData.Layers[0].BSDFs[0])	= Extinction;
	VOLUME_ANISOTROPY			(StrataData.Layers[0].BSDFs[0])	= Anisotropy;
	VOLUME_THICKNESS			(StrataData.Layers[0].BSDFs[0])	= Thickness;
	VOLUME_SMOOTHSURFACENORMAL	(StrataData.Layers[0].BSDFs[0])	= SmoothSurfaceNormal;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

// STRATA_TODO put in a common file
// Point lobe in off-specular peak direction
float3 StrataGetOffSpecularPeakReflectionDir(float3 Normal, float3 ReflectionVector, float Roughness)
{
	float a = Square(Roughness);
	return lerp(Normal, ReflectionVector, (1 - a) * (sqrt(1 - a) + a));
}

///////////////////////////////////////////////////////////////////////////////
// BSDF evaluate and sampling

struct FStrataBSDFContext
{
	FStrataBSDF BSDF;

	float3 N;
	float3 V;
	float3 R;
	float3 H;

	float3 L;	// There to initialise the BxDFContext. Only used by StrataEvaluateBSDF, not by StrataImportanceSampleBSDF or StrataEvaluateForEnvLight

	BxDFContext Context;
	float SatNoL;
	float SatNoV;

	float3x3 TangentBasis;
	float3 TangentV;
	float3 TangentH;

	// Preprocessed roughness override used for specular BSDF evaluation when integration area light (using MRP integrator)
	float a2Override;
};

void StrataGetBSDFNormal(in FStrataBSDF BSDF, inout float3 N)
{
	switch (BSDF.BSDFType)
	{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{ 
			N = DIFFUSE_NORMAL(BSDF);
			break; 
		}
		case STRATA_BSDF_TYPE_DIELECTRIC:
		{ 
			N = DIELECTRIC_NORMAL(BSDF);
			break; 
		}
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			N = CONDUCTOR_NORMAL(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_VOLUME:
		{
			N = VOLUME_SMOOTHSURFACENORMAL(BSDF);
			break;
		}
	}
}

void StrataGetBSDFRoughness(in FStrataBSDF BSDF, inout float R)
{
	R = 0;
	switch (BSDF.BSDFType)
	{
	case STRATA_BSDF_TYPE_DIFFUSE_ON:
	case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
	{
		R = DIFFUSE_ROUGHNESS(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_DIELECTRIC:
	{
		R = DIELECTRIC_ROUGHNESS0(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_CONDUCTOR:
	{
		R = CONDUCTOR_ROUGHNESS0(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_VOLUME:
	{
		R = 0;
		break;
	}
	}
}

// Return true if a BSDF has a custom area light integrator
bool StrataHasAreaLightIntegrator(in FStrataBSDF BSDF)
{
	return 
		BSDF.BSDFType == STRATA_BSDF_TYPE_CONDUCTOR ||
		BSDF.BSDFType == STRATA_BSDF_TYPE_DIELECTRIC;
}

FStrataBSDFContext StrataCreateBSDFContext(FStrataBSDF BSDF, float3 V, float3 L)
{
	FStrataBSDFContext BSDFContext = (FStrataBSDFContext)0;

	BSDFContext.BSDF = BSDF;

	BSDFContext.V = V;
	BSDFContext.L = L;

	BSDFContext.N = float3(0.0f, 0.0f, 1.0f);
	StrataGetBSDFNormal(BSDF, BSDFContext.N);
	BSDFContext.N = normalize(BSDFContext.N);

	BSDFContext.R = 2 * dot(BSDFContext.V, BSDFContext.N) * BSDFContext.N - BSDFContext.V;
	BSDFContext.H = normalize(BSDFContext.V + BSDFContext.L);

	BSDFContext.Context = (BxDFContext)0;
	Init(BSDFContext.Context, BSDFContext.N, BSDFContext.V, BSDFContext.L);
	BSDFContext.SatNoL = saturate(BSDFContext.Context.NoL);
	BSDFContext.SatNoV = saturate(BSDFContext.Context.NoV);

	BSDFContext.TangentBasis = GetTangentBasis(BSDFContext.N);
	BSDFContext.TangentV = mul(BSDFContext.TangentBasis, BSDFContext.V);
	BSDFContext.TangentH = mul(BSDFContext.TangentBasis, BSDFContext.H);

	return BSDFContext;
}

void StrataUpdateBSDFContext(inout FStrataBSDFContext BSDFContext, float3 NewL)
{
	// Update all the data related to L
	Init(BSDFContext.Context, BSDFContext.N, BSDFContext.V, NewL);
	BSDFContext.H = normalize(BSDFContext.V + BSDFContext.L);
	BSDFContext.TangentH = mul(BSDFContext.TangentBasis, BSDFContext.H);
}

struct FStrataEvaluateResult
{
	float3 Value;
	float  PDF;
	float3 Throughput;	// Throughput to the next layer
};

FStrataEvaluateResult StrataEvaluateBSDF(FStrataBSDFContext BSDFContext)
{
	FStrataEvaluateResult Sample = (FStrataEvaluateResult)0;

	const float OpaqueBSDFThroughput = 0.0f;

	switch (BSDFContext.BSDF.BSDFType)
	{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		{
			const float SafeRoughness = MakeRoughnessSafe(DIFFUSE_ROUGHNESS(BSDFContext.BSDF));

			Sample.Value		= Diffuse_OrenNayar(DIFFUSE_ALBEDO(BSDFContext.BSDF), SafeRoughness, BSDFContext.SatNoV, BSDFContext.SatNoL, BSDFContext.Context.VoH);
			Sample.PDF			= BSDFContext.SatNoV / PI;
			Sample.Throughput	= OpaqueBSDFThroughput;
			break;
		}
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{
			const float SafeRoughness = MakeRoughnessSafe(DIFFUSE_ROUGHNESS(BSDFContext.BSDF));
			float a2 = Pow4(SafeRoughness);

			Sample.Value		= Diffuse_Chan(DIFFUSE_ALBEDO(BSDFContext.BSDF), a2, BSDFContext.SatNoV, BSDFContext.SatNoL, BSDFContext.Context.VoH, BSDFContext.Context.NoH);
			Sample.PDF			= BSDFContext.SatNoV / PI;
			Sample.Throughput	= OpaqueBSDFThroughput;
			break;
		}
		case STRATA_BSDF_TYPE_DIELECTRIC:
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			const bool bIsDieletric = BSDFContext.BSDF.BSDFType == STRATA_BSDF_TYPE_DIELECTRIC;
			const float3 F0  = bIsDieletric ? DIELECTRIC_TINT(BSDFContext.BSDF) * DielectricIorToF0(DIELECTRIC_IOR(BSDFContext.BSDF)) : CONDUCTOR_REFLECTIVITY(BSDFContext.BSDF);
			const float3 F90 = bIsDieletric ? DIELECTRIC_TINT(BSDFContext.BSDF) : CONDUCTOR_EDGECOLOR(BSDFContext.BSDF);
			const float SafeRoughness = MakeRoughnessSafe(bIsDieletric ? DIELECTRIC_ROUGHNESS0(BSDFContext.BSDF) : CONDUCTOR_ROUGHNESS0(BSDFContext.BSDF));

			const float a2 = BSDFContext.a2Override>0 ? BSDFContext.a2Override : Pow4(SafeRoughness);

			// Generalized microfacet specular
			float D = D_GGX(a2, BSDFContext.Context.NoH);
			float Vis = Vis_SmithJointApprox(a2, BSDFContext.Context.NoV, BSDFContext.SatNoL);
			float3 F = F_Schlick(F0, F90, BSDFContext.Context.VoH);

			Sample.Value		= D * Vis * F;
			Sample.PDF			= VisibleGGXPDF(BSDFContext.TangentV, BSDFContext.TangentH, a2);
			Sample.Throughput	= bIsDieletric ? (1.0f - F) : OpaqueBSDFThroughput; // STRATA_TODO (Kulla's (1-FDG))
			break;
		}
		case STRATA_BSDF_TYPE_VOLUME:
		{
			const float3 Albedo = VOLUME_ALBEDO(BSDFContext.BSDF);
			const float3 ExtinctionCoefficients = VOLUME_EXTINCTION(BSDFContext.BSDF);
			const float3 ScatteringCoefficients = Albedo * ExtinctionCoefficients;
			const float3 AbsorptionCoefficients = ExtinctionCoefficients - ScatteringCoefficients;
			const float  Thickness = VOLUME_THICKNESS(BSDFContext.BSDF);
			const float  Phase = HenyeyGreensteinPhase(VOLUME_ANISOTROPY(BSDFContext.BSDF), BSDFContext.Context.VoL);

			const float3 SafeExtinctionThreshold = 0.000001f;
			const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, ExtinctionCoefficients);

			const float PathLength = Thickness / max(0.0001f, abs(BSDFContext.Context.NoV));
			const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);
			const float3 NormLuminanceTransfert = 1.0f * ScatteringCoefficients;
			float3 NormLuminanceSingleScattering = (NormLuminanceTransfert - NormLuminanceTransfert * SafePathSegmentTransmittance) / SafeExtinctionCoefficients;

#if 1
			const float3 SelfShadowTransmittance = 1.0;// BSDFContext.SatNoL;
#else
			const float LightPathLength = Thickness / max(0.0001f, BSDFContext.SatNoL);
			const float3 SelfShadowTransmittance = BSDFContext.SatNoL <= 0.0 ? 0.0 : exp(-ExtinctionCoefficients * LightPathLength);
#endif

			Sample.Value		= NormLuminanceSingleScattering * Phase * SelfShadowTransmittance;
			Sample.PDF			= Phase;
			Sample.Throughput	= SafePathSegmentTransmittance;
			break;
		}
	}

	return Sample;
}

struct FStrataImportanceSampleResult
{
	float3 Direction;
	float ConeAngle;		// Cone angle is 1/PDF as defined by Lumen

//	FStrataEvaluateResult Eval;
};

/**
 * Importance sample a Strata BSDF
 * BSDF: the strata BSDF to importance sample
 * E: two random numbers
 * CameraVector: vector from the camera to the considered direction (not V)
 */
FStrataImportanceSampleResult StrataImportanceSampleBSDF(FStrataBSDF BSDF, float2 E, float3 CameraVector)
{
	FStrataImportanceSampleResult Sample = (FStrataImportanceSampleResult)0;

	// Create a context from the information we have
	const float3 UnusedL = float3(0.0f, 0.0f, 1.0f);
	const float3 V = -CameraVector;
	FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(BSDF, V, UnusedL);

	float PDF = 0.0f;
	switch (BSDFContext.BSDF.BSDFType)
	{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{
			// STRATA_TODO take into account roughness
			float4 ImportanceSample = CosineSampleHemisphere(E);
			Sample.Direction = mul(ImportanceSample.xyz, BSDFContext.TangentBasis);
			PDF = ImportanceSample.w;
			Sample.ConeAngle = 1.0f / PDF;
			break;
		}
		case STRATA_BSDF_TYPE_DIELECTRIC:
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			const bool bIsDielectric = BSDFContext.BSDF.BSDFType == STRATA_BSDF_TYPE_DIELECTRIC;
			float Roughness = bIsDielectric ? DIELECTRIC_ROUGHNESS0(BSDFContext.BSDF) : CONDUCTOR_ROUGHNESS0(BSDFContext.BSDF);
			float4 GGXSample = ImportanceSampleVisibleGGX(UniformSampleDisk(E), Pow4(Roughness), BSDFContext.TangentV);
			float3 WorldH = mul(GGXSample.xyz, BSDFContext.TangentBasis);
			Sample.Direction = reflect(CameraVector, WorldH);
			PDF = GGXSample.w;
			Sample.ConeAngle = 1.0f / PDF;
			break;
		}
		case STRATA_BSDF_TYPE_VOLUME:
		{
			float4 PhaseSample = ImportanceSampleHenyeyGreensteinPhase(E, VOLUME_ANISOTROPY(BSDFContext.BSDF));
			Sample.Direction = mul(PhaseSample.xyz, BSDFContext.TangentBasis);
			PDF = PhaseSample.w;
			Sample.ConeAngle = 1.0f / PDF;
			break;
		}
	}

	//StrataUpdateBSDFContext(BSDFContext, Sample.Direction);
	//Sample.Eval = StrataEvaluateBSDF(BSDFContext);
	//Sample.Eval.PDF = PDF;	// We override the pdf to make sure the compiler skips all pdf code from StrataEvaluateBSDF because GGXSample.w si the pdf already for instance.

	return Sample;
}

struct FStrataEnvLightResult
{
	float3 DiffuseAlbedo;
	float3 DiffuseNormal;

	float3 SpecularDirection;
	float3 SpecularWeight;
	float  SpecularSafeRoughness;
};

FStrataEnvLightResult StrataEvaluateForEnvLight(FStrataBSDFContext BSDFContext, bool bEnableSpecular)
{
	FStrataEnvLightResult StrataEnvLightResult = (FStrataEnvLightResult)0;

	switch (BSDFContext.BSDF.BSDFType)
	{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{
			StrataEnvLightResult.DiffuseAlbedo = DIFFUSE_ALBEDO(BSDFContext.BSDF);
			StrataEnvLightResult.DiffuseNormal = BSDFContext.N;
			break;
		}
		case STRATA_BSDF_TYPE_DIELECTRIC:
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			BRANCH
			if (bEnableSpecular)
			{
				const bool bIsDielectric = STRATA_BSDF_TYPE_DIELECTRIC == BSDFContext.BSDF.BSDFType;
				const float3 F0  = bIsDielectric ? DIELECTRIC_TINT(BSDFContext.BSDF) * DielectricIorToF0(DIELECTRIC_IOR(BSDFContext.BSDF)) : CONDUCTOR_REFLECTIVITY(BSDFContext.BSDF);
				const float3 F90 = bIsDielectric ? DIELECTRIC_TINT(BSDFContext.BSDF) : CONDUCTOR_EDGECOLOR(BSDFContext.BSDF);
				const float SafeRoughness = MakeRoughnessSafe(bIsDielectric ? DIELECTRIC_ROUGHNESS0(BSDFContext.BSDF) : CONDUCTOR_ROUGHNESS0(BSDFContext.BSDF));

				float3 EvalEnvBRDF = EnvBRDFApprox(F0, F90, SafeRoughness, BSDFContext.SatNoV);

				StrataEnvLightResult.SpecularDirection = StrataGetOffSpecularPeakReflectionDir(BSDFContext.N, BSDFContext.R, SafeRoughness);
				StrataEnvLightResult.SpecularWeight = EvalEnvBRDF;
				StrataEnvLightResult.SpecularSafeRoughness = SafeRoughness;
			}
			break;
		}
		case STRATA_BSDF_TYPE_VOLUME:
		{
			const float3 VolumeAlbedo = VOLUME_ALBEDO(BSDFContext.BSDF);
			const float3 ExtinctionCoefficients = VOLUME_EXTINCTION(BSDFContext.BSDF);
			const float3 ScatteringCoefficients = VolumeAlbedo * ExtinctionCoefficients;
			const float3 AbsorptionCoefficients = ExtinctionCoefficients - ScatteringCoefficients;
			const float  Thickness = VOLUME_THICKNESS(BSDFContext.BSDF);

			const float3 SafeExtinctionThreshold = 0.000001f;
			const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, ExtinctionCoefficients);

			const float PathLength = Thickness / max(0.0001f, BSDFContext.SatNoV);
			const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);
			const float3 NormLuminanceTransfert = 1.0f * ScatteringCoefficients;
			float3 NormLuminanceSingleScattering = (NormLuminanceTransfert - NormLuminanceTransfert * SafePathSegmentTransmittance) / SafeExtinctionCoefficients;

			StrataEnvLightResult.DiffuseAlbedo = NormLuminanceSingleScattering;
			StrataEnvLightResult.DiffuseNormal = BSDFContext.N;
			break;
		}
	}

	return StrataEnvLightResult;
}

FThreeBandSHVector StrataBSDFToSH(FStrataBSDFContext BSDFContext)
{
	// STRATA_TODO adapt the SH to BSDFs
	return CalcDiffuseTransferSH3(BSDFContext.N, 1.0f);
}


///////////////////////////////////////////////////////////////////////////////
// Operators node


FStrataData StrataAdd(FStrataData A, FStrataData B)
{
	FStrataData StrataData = A;

	// Append each BSDF from B to A, with same layer position
	for (int Layer = 0; Layer < B.LayerCount; ++Layer)
	{
		FStrataLayer ALayer = A.Layers[Layer];
		FStrataLayer BLayer = B.Layers[Layer];
		for (int BSDF = 0; BSDF < BLayer.BSDFCount; BSDF++)
		{
			StrataData.Layers[Layer].BSDFs[ALayer.BSDFCount + BSDF] = BLayer.BSDFs[BSDF];
		}

		StrataData.Layers[Layer].BSDFCount = ALayer.BSDFCount + BLayer.BSDFCount;
	}

	StrataData.LayerCount = max(A.LayerCount, B.LayerCount);

	return StrataData;
}

FStrataData StrataMultiply(FStrataData A, float3 Weight)
{
	FStrataData StrataData = A;

	// Apply the weight to each BSDF
	for (int Layer = 0; Layer < StrataData.LayerCount; ++Layer)
	{
		for (int BSDF = 0; BSDF < StrataData.Layers[Layer].BSDFCount; ++BSDF)
		{
			StrataData.Layers[Layer].BSDFs[BSDF].Weight *= Weight;
		}
	}

	return StrataData;
}

FStrataData StrataHorizontalMixing(FStrataData Foreground, FStrataData Background, float Mix)
{
	const float ForgroundMixFactor = Mix;
	const float BackgroundMixFactor = 1.0 - Mix;

	FStrataData A = StrataMultiply(Foreground, ForgroundMixFactor);
	FStrataData B = StrataMultiply(Background, BackgroundMixFactor);
	return StrataAdd(A, B);
}

FStrataData StrataVerticalLayering(FStrataData Top, FStrataData Base)
{
	FStrataData StrataData = Top;

	// Add each layer from Base under Top
	int TopLayerCount = Top.LayerCount;
	for (int Layer = 0; Layer < Base.LayerCount; ++Layer)
	{
		StrataData.Layers[TopLayerCount + Layer] = Base.Layers[Layer];
	}

	StrataData.LayerCount += Base.LayerCount;

	return StrataData;
}



///////////////////////////////////////////////////////////////////////////////
// Functions used to sanitize BSDF before they are used for lighting (when forward) or stored to memory (base pass).
// We do not normalize normals, this is done before the lighting step.

void SanitizeStrataDiffuse(inout FStrataBSDF BSDF)
{
	DIFFUSE_ALBEDO(BSDF) = saturate(DIFFUSE_ALBEDO(BSDF));
	DIFFUSE_ROUGHNESS(BSDF) = saturate(DIFFUSE_ROUGHNESS(BSDF));
}

void SanitizeStrataDielectric(inout FStrataBSDF BSDF)
{
	DIELECTRIC_IOR(BSDF) = clamp(DIELECTRIC_IOR(BSDF), 1.0f, 5.0f);		// See https://en.wikipedia.org/wiki/List_of_refractive_indices
	DIELECTRIC_TINT(BSDF) = saturate(DIELECTRIC_TINT(BSDF));
	DIELECTRIC_ROUGHNESS0(BSDF) = saturate(DIELECTRIC_ROUGHNESS0(BSDF));
	DIELECTRIC_ROUGHNESS1(BSDF) = saturate(DIELECTRIC_ROUGHNESS1(BSDF));
}

void SanitizeStrataConductor(inout FStrataBSDF BSDF)
{
	CONDUCTOR_REFLECTIVITY(BSDF) = saturate(CONDUCTOR_REFLECTIVITY(BSDF));
	CONDUCTOR_EDGECOLOR(BSDF) = saturate(CONDUCTOR_EDGECOLOR(BSDF));
	CONDUCTOR_ROUGHNESS0(BSDF) = saturate(CONDUCTOR_ROUGHNESS0(BSDF));
	CONDUCTOR_ROUGHNESS1(BSDF) = saturate(CONDUCTOR_ROUGHNESS1(BSDF));
}

void SanitizeStrataVolume(inout FStrataBSDF BSDF)
{
	VOLUME_ALBEDO(BSDF) = saturate(VOLUME_ALBEDO(BSDF));
	VOLUME_EXTINCTION(BSDF) = max(0.0f, VOLUME_EXTINCTION(BSDF));
	VOLUME_ANISOTROPY(BSDF) = max(0.0f, VOLUME_ANISOTROPY(BSDF));
	VOLUME_THICKNESS(BSDF) = max(0.0f, VOLUME_THICKNESS(BSDF));
}

void StrataSanitizeBSDF(inout FStrataBSDF BSDF)
{
	switch (BSDF.BSDFType)
	{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{
			SanitizeStrataDiffuse(BSDF);
			break; 
		}
		case STRATA_BSDF_TYPE_DIELECTRIC:
		{
			SanitizeStrataDielectric(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			SanitizeStrataConductor(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_VOLUME:
		{
			SanitizeStrataVolume(BSDF);
			break;
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// BSDFs packing/unpacking

uint PackR11G11B10F(float3 rgb)
{
	uint r = (f32tof16(rgb.r) << 17) & 0xFFE00000;
	uint g = (f32tof16(rgb.g) << 6)  & 0x001FFC00;
	uint b = (f32tof16(rgb.b) >> 5)  & 0x000003FF;
	return r | g | b;
}

float3 UnpackR11G11B10F(uint rgb)
{
	float r = f16tof32((rgb >> 17) & 0x7FF0);
	float g = f16tof32((rgb >> 6)  & 0x7FF0);
	float b = f16tof32((rgb << 5)  & 0x7FE0);
	return float3(r, g, b);
}

uint2 PackR16G16B16A16F(float4 rgba)
{
	uint A = (f32tof16(rgba.r) << 16) | f32tof16(rgba.g);
	uint B = (f32tof16(rgba.b) << 16) | f32tof16(rgba.a);
	return uint2 (A, B);
}

float4 UnpackR16G16B16A16F(uint2 AB)
{
	float r = f16tof32(AB.x >> 16);
	float g = f16tof32(AB.x);
	float b = f16tof32(AB.y >> 16);
	float a = f16tof32(AB.y);
	return float4(r, g, b, a);
}

uint PackAlbedoLinearToGamma2(float3 rgb)
{
	uint r = (uint(sqrt(saturate(rgb.r)) * 255.0f) << 16);
	uint g = (uint(sqrt(saturate(rgb.g)) * 255.0f) << 8);
	uint b = (uint(sqrt(saturate(rgb.b)) * 255.0f) << 0);
	return r | g | b;
}

float3 UnpackAlbedoGamma2ToLinear(uint rgb)
{
	float r = float((rgb >> 16) & 0x000000FF);
	float g = float((rgb >> 8)  & 0x000000FF);
	float b = float((rgb >> 0)  & 0x000000FF);
	float3 Gamma2 = float3(r, g, b) * (1.0f / 255.0f);
	return Gamma2 * Gamma2;	// Simple gamma 2.0
}

uint PackAlbedoLinearToGamma2AlphaLinear(float4 rgba)
{
	uint r = (uint(sqrt(saturate(rgba.r)) * 255.0f) << 24);
	uint g = (uint(sqrt(saturate(rgba.g)) * 255.0f) << 16);
	uint b = (uint(sqrt(saturate(rgba.b)) * 255.0f) << 8);
	uint a = (uint(     saturate(rgba.a)  * 255.0f) << 0);
	return r | g | b | a;
}

float4 UnpackAlbedoGamma2ToLinearAlphaLinear(uint rgba)
{
	float r = float((rgba >> 24) & 0x000000FF);
	float g = float((rgba >> 16) & 0x000000FF);
	float b = float((rgba >> 8)  & 0x000000FF);
	float a = float((rgba >> 0)  & 0x000000FF);
	float3 Gamma2 = float3(r, g, b) * (1.0f / 255.0f);
	return float4(Gamma2 * Gamma2, a * (1.0f / 255.0f));	// Simple gamma 2.0
}

#if COMPILER_SWITCH // These platforms are complaining so simply disabling Strata there for now.

#define STRATA_STORE_UINT1(x) 
#define STRATA_STORE_UINT2(x) 
#define STRATA_STORE_UINT3(x) 
#define STRATA_STORE_UINT4(x) 

#define STRATA_LOAD_UINT1(x) x = 0;
#define STRATA_LOAD_UINT2(x) x = 0;
#define STRATA_LOAD_UINT3(x) x = 0;
#define STRATA_LOAD_UINT4(x) x = 0;

#define STRATA_LOAD_FLOAT1(x) x = 0;
#define STRATA_LOAD_FLOAT2(x) x = 0;
#define STRATA_LOAD_FLOAT3(x) x = 0;
#define STRATA_LOAD_FLOAT4(x) x = 0;

uint  StrataLoadUint1(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }
uint2 StrataLoadUint2(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }
uint3 StrataLoadUint3(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }
uint4 StrataLoadUint4(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { return 0; }

#else

#define STRATA_STORE_UINT1(x) StrataBuffer.Store (ByteOffset, asuint(x)); ByteOffset += 4;
#define STRATA_STORE_UINT2(x) StrataBuffer.Store2(ByteOffset, asuint(x)); ByteOffset += 8;
#define STRATA_STORE_UINT3(x) StrataBuffer.Store3(ByteOffset, asuint(x)); ByteOffset += 12;
#define STRATA_STORE_UINT4(x) StrataBuffer.Store4(ByteOffset, asuint(x)); ByteOffset += 16;

#define STRATA_LOAD_UINT1(x) x = StrataBuffer.Load (ByteOffset); ByteOffset += 4;
#define STRATA_LOAD_UINT2(x) x = StrataBuffer.Load2(ByteOffset); ByteOffset += 8;
#define STRATA_LOAD_UINT3(x) x = StrataBuffer.Load3(ByteOffset); ByteOffset += 12;
#define STRATA_LOAD_UINT4(x) x = StrataBuffer.Load4(ByteOffset); ByteOffset += 16;

#define STRATA_LOAD_FLOAT1(x) x = asfloat(StrataBuffer.Load (ByteOffset)); ByteOffset += 4;
#define STRATA_LOAD_FLOAT2(x) x = asfloat(StrataBuffer.Load2(ByteOffset)); ByteOffset += 8;
#define STRATA_LOAD_FLOAT3(x) x = asfloat(StrataBuffer.Load3(ByteOffset)); ByteOffset += 12;
#define STRATA_LOAD_FLOAT4(x) x = asfloat(StrataBuffer.Load4(ByteOffset)); ByteOffset += 16;

uint  StrataLoadUint1(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint  x = StrataBuffer.Load (ByteOffset); ByteOffset += 4; return x; }
uint2 StrataLoadUint2(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint2 x = StrataBuffer.Load2(ByteOffset); ByteOffset += 8; return x; }
uint3 StrataLoadUint3(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint3 x = StrataBuffer.Load3(ByteOffset); ByteOffset +=12; return x; }
uint4 StrataLoadUint4(ByteAddressBuffer StrataBuffer, inout uint ByteOffset) { uint4 x = StrataBuffer.Load4(ByteOffset); ByteOffset +=16; return x; }

#endif

void StrataLoad_R16G16B16F_A16F(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 A, inout float B)
{
	float4 temp = UnpackR16G16B16A16F(StrataLoadUint2(StrataBuffer, ByteOffset));
	A = temp.xyz;
	B = temp.a;
}

void StrataLoad_R11G11B10F(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 A)
{
	A = UnpackR11G11B10F(StrataLoadUint1(StrataBuffer, ByteOffset));
}

void StrataLoad_R11_G11_B10F(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float A, inout float B, inout float C)
{
	float3 temp = UnpackR11G11B10F(StrataLoadUint1(StrataBuffer, ByteOffset));
	A = temp.x;
	B = temp.y;
	C = temp.z;
}

void StrataLoad_AlbedoGamma2ToLinear(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 A)
{
	A = UnpackAlbedoGamma2ToLinear(StrataLoadUint1(StrataBuffer, ByteOffset));
}

void StrataLoad_AlbedoGamma2ToLinearAlphaLinear(ByteAddressBuffer StrataBuffer, inout uint ByteOffset, inout float3 RGB, inout float A)
{
	float4 Data = UnpackAlbedoGamma2ToLinearAlphaLinear(StrataLoadUint1(StrataBuffer, ByteOffset));
	RGB = Data.rgb;
	A = Data.a;
}



uint GetStrataPixelDataByteOffset(uint2 PixelPos, uint ViewBufferSizeX, uint StrataMaxBytesPerPixel)
{
	return (PixelPos.y * ViewBufferSizeX + PixelPos.x) * StrataMaxBytesPerPixel;
}



void PackStrataOut(
	RWByteAddressBuffer StrataBuffer, 
	uint ByteOffset, 
	FStrataData Strata, 
	float3 VertexNormal,
	float3 V,
	inout FGBufferData GBuffer)
{
	// We cannot output (layers x bsdf) information because if we try to load them later, the reserved amount of VGPRS would be crazy high.
	// So instead we simply store a list of BSDF and we allow only up to STRATA_MAX_TOTAL_BSDF of them.
	// For each of the BSDF, we evaluated their final waight according to the material operation performed (layering, mixing, etc.).

	// STRATA_TODO:
	//	- We could clean up irrelevant BSDFs 
	//	- We could generate transmittance BSDFs 

	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;
	const float FullyRough = 1.0f;

	uint BSDFCount = 0;
	float3 Throughput = 1.0f;

	int l;
	for (l = 0; l < Strata.LayerCount; ++l)
	{
		float3 LayerThroughput = 0.0f;
		float3 LayerCoverage = 0.0f;

		float3 AccumTopNormal = 0.0f;
		float3 AccumRoughness = 0.0f;
		float  AccumRoughnessCount = 0.0f;
		float3 AccumBaseColor = 0.0f;
		const bool bTopLayer = l == 0;

		for (int i = 0; i < Strata.Layers[l].BSDFCount; ++i)
		{
			// Sanitize BSDF in place before it is used and packed out to memory
			StrataSanitizeBSDF(Strata.Layers[l].BSDFs[i]);

			FStrataBSDF BSDF = Strata.Layers[l].BSDFs[i];
			const float3 BSDFCoverage = BSDF.Weight;
			BSDFCount++;

			// STRATA_TODO apply the same normal transform as for the material
			float3 N = VertexNormal;
			StrataGetBSDFNormal(BSDF, N);
			N = normalize(N);

			AccumTopNormal += N;

			BxDFContext ContextNoLight = (BxDFContext)0;
			const float3 FakeL = float3(0, 0, 1);
			Init(ContextNoLight, N, V, FakeL);

			switch (BSDF.BSDFType)
			{
			case STRATA_BSDF_TYPE_DIFFUSE_ON:
			{
				if (bTopLayer)
				{
					AccumRoughness		+= BSDFCoverage * FullyRough;
					AccumRoughnessCount += BSDFCoverage;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
			{
				if (bTopLayer)
				{
					AccumRoughness		+= BSDFCoverage * FullyRough;
					AccumRoughnessCount += BSDFCoverage;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_DIELECTRIC:
			{
				float F0 = DielectricIorToF0(DIELECTRIC_IOR(BSDF));
				float3 F = F_Schlick(F0, ContextNoLight.VoH);

				if (bTopLayer)
				{
					AccumRoughness		+= DIELECTRIC_ROUGHNESS0(BSDF);
					AccumRoughnessCount += 1.0f;

					const float SafeRoughness = MakeRoughnessSafe(DIELECTRIC_ROUGHNESS0(BSDF));
					AccumBaseColor		+= BSDFCoverage * EnvBRDFApprox(F0, SafeRoughness, saturate(ContextNoLight.NoV));
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * (1.0f - F); // STRATA_TODO use 1-FGD instead of simple 1-F, event if we ignore ray scattering/spreading
				break;
			}

			case STRATA_BSDF_TYPE_CONDUCTOR:
			{
				float3 F = F_Schlick(CONDUCTOR_REFLECTIVITY(BSDF), CONDUCTOR_EDGECOLOR(BSDF), ContextNoLight.VoH);

				if (bTopLayer)
				{
					AccumRoughness		+= CONDUCTOR_ROUGHNESS0(BSDF);
					AccumRoughnessCount += 1.0f;

					const float SafeRoughness = MakeRoughnessSafe(CONDUCTOR_ROUGHNESS0(BSDF));
					AccumBaseColor		+= BSDFCoverage * EnvBRDFApprox(CONDUCTOR_REFLECTIVITY(BSDF), CONDUCTOR_EDGECOLOR(BSDF), SafeRoughness, saturate(ContextNoLight.NoV));;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_VOLUME:
			{
				const float3 Albedo					= VOLUME_ALBEDO(BSDF);
				const float3 ExtinctionCoefficients = VOLUME_EXTINCTION(BSDF);
				const float3 ScatteringCoefficients = Albedo * ExtinctionCoefficients;
				const float3 AbsorptionCoefficients = ExtinctionCoefficients - ScatteringCoefficients;
				const float  Thickness				= VOLUME_THICKNESS(BSDF);

				const float3 SafeExtinctionThreshold = 0.000001f;
				const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, ExtinctionCoefficients);

				const float PathLength = Thickness / max(0.0001f, abs(ContextNoLight.NoV));
				const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);
				
				if (bTopLayer)
				{
					AccumRoughness		+= BSDFCoverage * FullyRough;
					AccumRoughnessCount += BSDFCoverage;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * SafePathSegmentTransmittance;
				break;
			}
			} // switch

			// Update the weights to take into account throughput towards the view from layers above
			Strata.Layers[l].BSDFs[i].Weight *= Throughput;
		}

		// Now modify the gbuffer according to the top layer information
		if (bTopLayer)
		{
			// Normal is needed for some AO techniques
			GBuffer.WorldNormal = normalize(AccumTopNormal);

			// Roughness is needed for SSR, base color represents EnvBRDF
			GBuffer.Roughness = AccumRoughnessCount > 0.0f ? saturate(AccumRoughness / AccumRoughnessCount) : FullyRough;
			GBuffer.BaseColor = saturate(AccumBaseColor);
			
			// Approximative way to be able to have SSR produce colored specular reflections
			GBuffer.Specular = 1;
			GBuffer.Metallic = 1;
		}

		// Take into account the non covered part for this layer and update throughput accordingly
		LayerThroughput += (1.0 - saturate(LayerCoverage)) * FullThroughput;

		// And combine this layer throughtput with he material throughput
		Throughput *= LayerThroughput;
	}


	// Now write out the BSDFs

	BSDFCount = min(BSDFCount, uint(STRATA_MAX_TOTAL_BSDF));
	STRATA_STORE_UINT1(BSDFCount);

	BSDFCount = 0;
	for (l = 0; l < Strata.LayerCount; ++l)
	{
		FStrataLayer Layer = Strata.Layers[l];

		for (int i = 0; i < Layer.BSDFCount; ++i)
		{
			FStrataBSDF BSDF = Layer.BSDFs[i];

			STRATA_STORE_UINT2(PackR16G16B16A16F(float4(BSDF.Weight, BSDF.BSDFType)));

			switch (BSDF.BSDFType)
			{
			case STRATA_BSDF_TYPE_DIFFUSE_ON:
			case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
			{
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2(DIFFUSE_ALBEDO(BSDF)));
				STRATA_STORE_UINT2(PackR16G16B16A16F(float4(DIFFUSE_NORMAL(BSDF), DIFFUSE_ROUGHNESS(BSDF))));
				// 12 bytes
			}
			break;
			case STRATA_BSDF_TYPE_DIELECTRIC: //
			{
				STRATA_STORE_UINT1(PackR11G11B10F(DIELECTRIC_TINT(BSDF)));
				STRATA_STORE_UINT1(PackR11G11B10F(float3(DIELECTRIC_ROUGHNESS0(BSDF), DIELECTRIC_ROUGHNESS1(BSDF), DIELECTRIC_IOR(BSDF))));
				STRATA_STORE_UINT2(PackR16G16B16A16F(float4(DIELECTRIC_NORMAL(BSDF), 0.0f)));
				// 16 bytes
			}
			break;
			case STRATA_BSDF_TYPE_CONDUCTOR:
			{
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(CONDUCTOR_REFLECTIVITY(BSDF), CONDUCTOR_ROUGHNESS0(BSDF))));
				STRATA_STORE_UINT1(PackAlbedoLinearToGamma2AlphaLinear(float4(CONDUCTOR_EDGECOLOR(BSDF),    CONDUCTOR_ROUGHNESS1(BSDF))));
				STRATA_STORE_UINT2(PackR16G16B16A16F(float4(CONDUCTOR_NORMAL(BSDF), 0.0f)));
				// 16 bytes
			}
			break;
			case STRATA_BSDF_TYPE_VOLUME:
			{
				// We simply multiply the absorption and scattering coefficient by the thickness to simplify the material to be a normalise medium of thickness 1 meter.
				// This gives the same result and reduces memory usage.
				const float Thickness = VOLUME_THICKNESS(BSDF);
				STRATA_STORE_UINT1(PackR11G11B10F(VOLUME_EXTINCTION(BSDF) * Thickness));
				STRATA_STORE_UINT1(PackR11G11B10F(VOLUME_ALBEDO(BSDF)));
				STRATA_STORE_UINT2(PackR16G16B16A16F(float4(VOLUME_SMOOTHSURFACENORMAL(BSDF), VOLUME_ANISOTROPY(BSDF))));
				// 16 bytes
			}
			break;
			}

			// Stop writing if above budget.
			BSDFCount++;
			if (BSDFCount >= STRATA_MAX_TOTAL_BSDF)
			{
				return;
			}
		}
	}
}

struct FStrataPixelHeader
{
	uint BSDFCount;
};

// Unpack only strata header
FStrataPixelHeader UnpackStrataHeaderIn(ByteAddressBuffer StrataBuffer, inout uint ByteOffset)
{
	FStrataPixelHeader Out = (FStrataPixelHeader)0;

	STRATA_LOAD_UINT1(Out.BSDFCount);
	Out.BSDFCount = min(Out.BSDFCount, STRATA_MAX_TOTAL_BSDF);	// To make the compiler happy
	return Out;
}

// Unpack a single BSDF
// Note: All BSDF lobes needs to be unpack in a sequential manner since each BSDF has a variable footprint.
FStrataBSDF UnpackStrataBSDFIn(ByteAddressBuffer StrataBuffer, inout uint ByteOffset)
{
	FStrataBSDF OutBSDF = (FStrataBSDF)0;

	float DummyFloat = 0.0f;

	{
		float4 temp4  = UnpackR16G16B16A16F(StrataLoadUint2(StrataBuffer, ByteOffset));
		OutBSDF.Weight   = temp4.xyz;
		OutBSDF.BSDFType = int(temp4.a);
	}

	switch (OutBSDF.BSDFType)
	{
	case STRATA_BSDF_TYPE_DIFFUSE_ON:
	case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
	{
		StrataLoad_AlbedoGamma2ToLinear	(StrataBuffer, ByteOffset, DIFFUSE_ALBEDO(OutBSDF));
		StrataLoad_R16G16B16F_A16F		(StrataBuffer, ByteOffset, DIFFUSE_NORMAL(OutBSDF),			DIFFUSE_ROUGHNESS(OutBSDF));
	}
	break;
	case STRATA_BSDF_TYPE_DIELECTRIC:
	{
		StrataLoad_R11G11B10F			(StrataBuffer, ByteOffset, DIELECTRIC_TINT(OutBSDF));
		StrataLoad_R11_G11_B10F			(StrataBuffer, ByteOffset, DIELECTRIC_ROUGHNESS0(OutBSDF), DIELECTRIC_ROUGHNESS1(OutBSDF), DIELECTRIC_IOR(OutBSDF));
		StrataLoad_R16G16B16F_A16F		(StrataBuffer, ByteOffset, DIELECTRIC_NORMAL(OutBSDF),		DummyFloat);
	}
	break;
	case STRATA_BSDF_TYPE_CONDUCTOR:
	{
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, CONDUCTOR_REFLECTIVITY(OutBSDF),	CONDUCTOR_ROUGHNESS0(OutBSDF));
		StrataLoad_AlbedoGamma2ToLinearAlphaLinear(StrataBuffer, ByteOffset, CONDUCTOR_EDGECOLOR(OutBSDF),		CONDUCTOR_ROUGHNESS1(OutBSDF));
		StrataLoad_R16G16B16F_A16F		(StrataBuffer, ByteOffset,			 CONDUCTOR_NORMAL(OutBSDF),			DummyFloat);
	}
	break;
	case STRATA_BSDF_TYPE_VOLUME:
	{
		StrataLoad_R11G11B10F			(StrataBuffer, ByteOffset, VOLUME_EXTINCTION(OutBSDF));
		StrataLoad_R11G11B10F			(StrataBuffer, ByteOffset, VOLUME_ALBEDO(OutBSDF));
		StrataLoad_R16G16B16F_A16F		(StrataBuffer, ByteOffset, VOLUME_SMOOTHSURFACENORMAL(OutBSDF), VOLUME_ANISOTROPY(OutBSDF));
		VOLUME_THICKNESS(OutBSDF) = 1.0f;
	}
	break;
	}

	return OutBSDF;
}