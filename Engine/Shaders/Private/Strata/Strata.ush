// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../BRDF.ush"
#include "../DeferredShadingCommon.ush"
#include "../ParticipatingMediaCommon.ush"
#include "../ThinFilmBSDF.ush"

#include "/Engine/Shared/StrataDefinitions.h"


// During the base pass or forward rendering, shared normals are simply available from registers.
// If a BSDF is loaded for processing from the strata buffer, normals are unpacked on demand to reduce VGPR pressure and increase occupancy.
#ifndef STRATA_INLINE_SHADING
#define STRATA_INLINE_SHADING 1
#endif

// During the unpacking of the Strata material data, if a slab has some sub-surface scattering, its BaseColor/Specular value will be 
// patched/overriden with white albedo (and optionally no specular) for computing the incoming irradiance without any albedo information. 
// This is required by the post-process/screen-space sub-surface methods. This overriden can be opt-out. This is used during the classification 
// pass for writing out the correct base color value into the FStrataSubsurfaceData
#ifndef STRATA_SSS_MATERIAL_OVERRIDE
#define STRATA_SSS_MATERIAL_OVERRIDE 1
#endif

#ifndef STRATA_CLAMPED_LAYER_COUNT
#define STRATA_CLAMPED_LAYER_COUNT 1
#endif

#ifndef MATERIAL_SHADINGMODEL_SINGLELAYERWATER
#define MATERIAL_SHADINGMODEL_SINGLELAYERWATER 0 
#endif

#define STRATA_INLINE_SINGLELAYERWATER (PROJECT_STRATA && MATERIAL_IS_STRATA && STRATA_INLINE_SHADING && MATERIAL_SHADINGMODEL_SINGLELAYERWATER)

// Behind the scene, we do all the simple volumetric lighting & transmitance computations considering a slab of 100 centimeters = 1 meter.
// If the user specifies a different thickness to simulate varying appearance, we rescale the mean free path in order to not have to store thickness as part of the BSDF description.
#define STRATA_SIMPLEVOLUME_THICKNESS_CM	100.0f
#define STRATA_CENTIMETER_TO_METER			0.01f
#define STRATA_METER_TO_CENTIMETER			100.0f
#define STRATA_SIMPLEVOLUME_THICKNESS_M		(STRATA_SIMPLEVOLUME_THICKNESS_CM * STRATA_CENTIMETER_TO_METER)

///////////////////////////////////////////////////////////////////////////////
// BSDFs representation
struct FStrataBSDF
{
	float3				Weight;		// Weight is a float3 because, when loaded from the material buffer, it contains the BSDF throughput (coverage and transmittance combined)
	uint				State;		// (27 unused bits) (1bit as HasAnisotropy) (2bits as SharedNormalIndex) (3bits as BSDFType)

#if STRATA_INLINE_SHADING
	float3				Emissive;	// All bsdf can potientially have emissive. This is never written out to the strata gbuffer but instead accumulated in the emissive buffer during the base pass.
	float				ThicknessCm;// This must be kept in order to be able to normalize the mean free path to comply with our volumetric material math all done in a normalised slab of medium.
	float3				TmpDMFP;
#endif

	// Water has too many parameters to be stores in the extra VGPRs below. So we extend this structure for the case where it is evaluated inline only.
	// This is fine because when water is used, it is the only BSDF that can be used and it is only used to do in line shading.
#if STRATA_INLINE_SINGLELAYERWATER
	float4 InlineVGPRs[3];
#endif

	float4 VGPRs[4];
};



#define TO_BITMASK(BitCount)							((1u<<BitCount)-1)
#define READ_BITS(X, BitCount, BitOffset)				uint((X>>BitOffset) & TO_BITMASK(BitCount))
#define WRITE_BITS(X, BitCount, BitOffset, NewValue)	X = (X & (~(TO_BITMASK(BitCount)<<BitOffset))) | ((NewValue & TO_BITMASK(BitCount)) << BitOffset)

// Bit count for each component stored in a Strata header
// For HEADER_BIT_BSDF_COUNT and  HEADER_BIT_SHAREDNORMAL_X, please refer to values in StrataDefinitions.h
#define HEADER_BIT_COUNT_BSDF_COUNT				4
#define HEADER_BIT_COUNT_SHAREDNORMAL_COUNT		3
#define HEADER_BIT_COUNT_SHAREDNORMAL_TYPE		4
#define HEADER_BIT_COUNT_AO						8
#define HEADER_BIT_COUNT_SKIP_PRECSHADOW_MASK	1
#define HEADER_BIT_COUNT_ZERO_PRECSHADOW_MASK	1
#define HEADER_BIT_COUNT_ISSINGLELAYERWATER		1
#define HEADER_BIT_COUNT___UNUSED___			10

#define HEADER_BIT_OFFSET_BSDF_COUNT			0
#define HEADER_BIT_OFFSET_SHAREDNORMAL_COUNT	(HEADER_BIT_OFFSET_BSDF_COUNT				+ HEADER_BIT_COUNT_BSDF_COUNT)
#define HEADER_BIT_OFFSET_SHAREDNORMAL_TYPE		(HEADER_BIT_OFFSET_SHAREDNORMAL_COUNT		+ HEADER_BIT_COUNT_SHAREDNORMAL_COUNT)
#define HEADER_BIT_OFFSET_AO					(HEADER_BIT_OFFSET_SHAREDNORMAL_TYPE		+ HEADER_BIT_COUNT_SHAREDNORMAL_TYPE)
#define HEADER_BIT_OFFSET_SKIP_PRECSHADOW_MASK	(HEADER_BIT_OFFSET_AO						+ HEADER_BIT_COUNT_AO)
#define HEADER_BIT_OFFSET_ZERO_PRECSHADOW_MASK	(HEADER_BIT_OFFSET_SKIP_PRECSHADOW_MASK		+ HEADER_BIT_COUNT_SKIP_PRECSHADOW_MASK)
#define HEADER_BIT_OFFSET_ISSINGLELAYERWATER	(HEADER_BIT_OFFSET_ZERO_PRECSHADOW_MASK		+ HEADER_BIT_COUNT_ZERO_PRECSHADOW_MASK)

#define HEADER_GETBSDFCOUNT(X)					READ_BITS( X, HEADER_BIT_COUNT_BSDF_COUNT, HEADER_BIT_OFFSET_BSDF_COUNT)
#define HEADER_SETBSDFCOUNT(X, NewValue)		WRITE_BITS(X, HEADER_BIT_COUNT_BSDF_COUNT, HEADER_BIT_OFFSET_BSDF_COUNT, NewValue)

#define HEADER_GETSHAREDNORMALCOUNT(X)			READ_BITS( X, HEADER_BIT_COUNT_SHAREDNORMAL_COUNT, HEADER_BIT_OFFSET_SHAREDNORMAL_COUNT)
#define HEADER_SETSHAREDNORMALCOUNT(X, NewValue)WRITE_BITS(X, HEADER_BIT_COUNT_SHAREDNORMAL_COUNT, HEADER_BIT_OFFSET_SHAREDNORMAL_COUNT, NewValue)

#define HEADER_GETSHAREDNORMALTYPE(X)			READ_BITS( X, HEADER_BIT_COUNT_SHAREDNORMAL_TYPE, HEADER_BIT_OFFSET_SHAREDNORMAL_TYPE)
#define HEADER_SETSHAREDNORMALTYPE(X, NewValue)	WRITE_BITS(X, HEADER_BIT_COUNT_SHAREDNORMAL_TYPE, HEADER_BIT_OFFSET_SHAREDNORMAL_TYPE, NewValue)

#define HEADER_GETAO(X)							READ_BITS( X, HEADER_BIT_COUNT_AO, HEADER_BIT_OFFSET_AO)
#define HEADER_SETAO(X, NewValue)				WRITE_BITS(X, HEADER_BIT_COUNT_AO, HEADER_BIT_OFFSET_AO, NewValue)

#define HEADER_GETSKIPPRECSHADOWMASK(X)			READ_BITS(  X, HEADER_BIT_COUNT_SKIP_PRECSHADOW_MASK, HEADER_BIT_OFFSET_SKIP_PRECSHADOW_MASK)
#define HEADER_SETSKIPPRECSHADOWMASK(X, NewValue)WRITE_BITS(X, HEADER_BIT_COUNT_SKIP_PRECSHADOW_MASK, HEADER_BIT_OFFSET_SKIP_PRECSHADOW_MASK, NewValue)

#define HEADER_GETZEROPRECSHADOWMASK(X)			READ_BITS(  X, HEADER_BIT_COUNT_ZERO_PRECSHADOW_MASK, HEADER_BIT_OFFSET_ZERO_PRECSHADOW_MASK)
#define HEADER_SETZEROPRECSHADOWMASK(X, NewValue)WRITE_BITS(X, HEADER_BIT_COUNT_ZERO_PRECSHADOW_MASK, HEADER_BIT_OFFSET_ZERO_PRECSHADOW_MASK, NewValue)

#define HEADER_GETISSINGLELAYERWATER(X)			READ_BITS(  X, HEADER_BIT_COUNT_ISSINGLELAYERWATER, HEADER_BIT_OFFSET_ISSINGLELAYERWATER)
#define HEADER_SETISSINGLELAYERWATER(X, NewValue)WRITE_BITS(X, HEADER_BIT_COUNT_ISSINGLELAYERWATER, HEADER_BIT_OFFSET_ISSINGLELAYERWATER, NewValue)

// Bit count for each component stored in a Strata BSDF state
#define STATE_BIT_COUNT_BSDF					3
#define STATE_BIT_COUNT_SHAREDNORMALID			2
#define STATE_BIT_COUNT_ANISOTROPY				1
#define STATE_BIT_COUNT_TOPLAYER				1
#define STATE_BIT_COUNT_HASSSS					1
#define STATE_BIT_COUNT_HASSSSPROFILE			1
#define STATE_BIT_COUNT_GREYWEIGHT				1
#define STATE_BIT_COUNT_HAZINESS				1
#define STATE_BIT_COUNT_EDGECOLOR				1
#define STATE_BIT_COUNT_THINFILM				1
#define STATE_BIT_COUNT_SIMPLEVOLUME			1
#define STATE_BIT_COUNT_DMFPPLUGGED				1
#define STATE_BIT_COUNT___UNUSED___				7
#define STATE_BIT_COUNT_WEIGHT10F				10

// Bit offset of each component store in BSDF state 
#define STATE_BIT_OFFSET_BSDF			0
#define STATE_BIT_OFFSET_SHAREDNORMALID	(STATE_BIT_OFFSET_BSDF				+ STATE_BIT_COUNT_BSDF)
#define STATE_BIT_OFFSET_ANISOTROPY		(STATE_BIT_OFFSET_SHAREDNORMALID	+ STATE_BIT_COUNT_SHAREDNORMALID)
#define STATE_BIT_OFFSET_TOPLAYER		(STATE_BIT_OFFSET_ANISOTROPY		+ STATE_BIT_COUNT_ANISOTROPY)
#define STATE_BIT_OFFSET_HASSSS			(STATE_BIT_OFFSET_TOPLAYER			+ STATE_BIT_COUNT_TOPLAYER)
#define STATE_BIT_OFFSET_HASSSSPROFILE	(STATE_BIT_OFFSET_HASSSS			+ STATE_BIT_COUNT_HASSSS)
#define STATE_BIT_OFFSET_GREYWEIGHT		(STATE_BIT_OFFSET_HASSSSPROFILE		+ STATE_BIT_COUNT_HASSSSPROFILE)
#define STATE_BIT_OFFSET_HAZINESS		(STATE_BIT_OFFSET_GREYWEIGHT		+ STATE_BIT_COUNT_GREYWEIGHT)
#define STATE_BIT_OFFSET_EDGECOLOR		(STATE_BIT_OFFSET_HAZINESS			+ STATE_BIT_COUNT_HAZINESS)
#define STATE_BIT_OFFSET_THINFILM		(STATE_BIT_OFFSET_EDGECOLOR			+ STATE_BIT_COUNT_EDGECOLOR)
#define STATE_BIT_OFFSET_SIMPLEVOLUME	(STATE_BIT_OFFSET_THINFILM			+ STATE_BIT_COUNT_THINFILM)
#define STATE_BIT_OFFSET_DMFPPLUGGED	(STATE_BIT_OFFSET_SIMPLEVOLUME		+ STATE_BIT_COUNT_SIMPLEVOLUME)
#define STATE_BIT_OFFSET_WEIGHT10F		22

// Accessors for the BSDF type
#define BSDF_GETTYPE(X)					READ_BITS(X.State,  STATE_BIT_COUNT_BSDF, STATE_BIT_OFFSET_BSDF)
#define BSDF_SETTYPE(X, NewType)		WRITE_BITS(X.State, STATE_BIT_COUNT_BSDF, STATE_BIT_OFFSET_BSDF, NewType)

// Accessors for Shared Normal
// This assumes Normals[STRATA_MAX_SHARED_NORMAL_REGISTERS]
#define BSDF_GETNORMALID(X)				READ_BITS(X.State,  STATE_BIT_COUNT_SHAREDNORMALID, STATE_BIT_OFFSET_SHAREDNORMALID)
#define BSDF_SETNORMALID(X, NrmlIdx)	WRITE_BITS(X.State, STATE_BIT_COUNT_SHAREDNORMALID, STATE_BIT_OFFSET_SHAREDNORMALID, NrmlIdx)

// Accessors for HasAnisotropy
// Indicates if the BSDF has anisotropic feature
#define BSDF_GETANISOTROPY(X)			READ_BITS(X.State,  STATE_BIT_COUNT_ANISOTROPY, STATE_BIT_OFFSET_ANISOTROPY)
#define BSDF_SETANISOTROPY(X, Aniso)	WRITE_BITS(X.State, STATE_BIT_COUNT_ANISOTROPY, STATE_BIT_OFFSET_ANISOTROPY, Aniso)

// Indicates if the BSDF is part of the top layer
#define BSDF_GETISTOPLAYER(X)			READ_BITS(X.State,  STATE_BIT_COUNT_TOPLAYER, STATE_BIT_OFFSET_TOPLAYER)
#define BSDF_SETISTOPLAYER(X, IsTop)	WRITE_BITS(X.State, STATE_BIT_COUNT_TOPLAYER, STATE_BIT_OFFSET_TOPLAYER, IsTop)

// Indicates if the BSDF has scattering component
#define BSDF_GETHASSSS(X)			READ_BITS(X.State,  STATE_BIT_COUNT_HASSSS, STATE_BIT_OFFSET_HASSSS)
#define BSDF_SETHASSSS(X, Scatt)	WRITE_BITS(X.State, STATE_BIT_COUNT_HASSSS, STATE_BIT_OFFSET_HASSSS, Scatt)

// Indicates if the BSDF has a SSS profile
#define BSDF_GETHASSSSPROFILE(X)		READ_BITS(X.State,  STATE_BIT_COUNT_HASSSSPROFILE, STATE_BIT_OFFSET_HASSSSPROFILE)
#define BSDF_SETHASSSSPROFILE(X, Profi)	WRITE_BITS(X.State, STATE_BIT_COUNT_HASSSSPROFILE, STATE_BIT_OFFSET_HASSSSPROFILE, Profi)

// Indicates if the BSDF weight is grey scale so that it can be stored in a single float (e.g. top layer BSDFs)
#define BSDF_GETGREYWEIGHT(X)			READ_BITS(X.State,  STATE_BIT_COUNT_GREYWEIGHT, STATE_BIT_OFFSET_GREYWEIGHT)
#define BSDF_SETGREYWEIGHT(X, Grey)		WRITE_BITS(X.State, STATE_BIT_COUNT_GREYWEIGHT, STATE_BIT_OFFSET_GREYWEIGHT, Grey)

// Indicates if the BSDF has haziness data
#define BSDF_GETHASHAZINESS(X)			READ_BITS(X.State,  STATE_BIT_COUNT_HAZINESS, STATE_BIT_OFFSET_HAZINESS)
#define BSDF_SETHASHAZINESS(X, Haze)	WRITE_BITS(X.State, STATE_BIT_COUNT_HAZINESS, STATE_BIT_OFFSET_HAZINESS, Haze)

// Indicates if the BSDF has edge color data
#define BSDF_GETHASEDGECOLOR(X)			READ_BITS(X.State,  STATE_BIT_COUNT_EDGECOLOR, STATE_BIT_OFFSET_EDGECOLOR)
#define BSDF_SETHASEDGECOLOR(X, Col)	WRITE_BITS(X.State, STATE_BIT_COUNT_EDGECOLOR, STATE_BIT_OFFSET_EDGECOLOR, Col)

// Indicates if the BSDF has thin film
#define BSDF_GETHASTHINFILM(X)			READ_BITS(X.State,  STATE_BIT_COUNT_THINFILM, STATE_BIT_OFFSET_THINFILM)
#define BSDF_SETHASTHINFILM(X, Thin)	WRITE_BITS(X.State, STATE_BIT_COUNT_THINFILM, STATE_BIT_OFFSET_THINFILM, Thin)

// Accessors for the 10bits float weight used if is it detected being a grey scale
#define BSDF_GETWEIGHT10F(X)			READ_BITS(X.State,  STATE_BIT_COUNT_WEIGHT10F, STATE_BIT_OFFSET_WEIGHT10F)
#define BSDF_SETWEIGHT10F(X, Weight)	WRITE_BITS(X.State, STATE_BIT_COUNT_WEIGHT10F, STATE_BIT_OFFSET_WEIGHT10F, Weight)

// Indicates if the BSDF is part of the top layer
#define BSDF_GETISSIMPLEVOLUME(X)		READ_BITS(X.State,  STATE_BIT_COUNT_SIMPLEVOLUME, STATE_BIT_OFFSET_SIMPLEVOLUME)
#define BSDF_SETISSIMPLEVOLUME(X, Value)WRITE_BITS(X.State, STATE_BIT_COUNT_SIMPLEVOLUME, STATE_BIT_OFFSET_SIMPLEVOLUME, Value)

// Indicates if the BSDF is part of the top layer
#define BSDF_GETHASDMFP(X)				READ_BITS(X.State,  STATE_BIT_COUNT_DMFPPLUGGED, STATE_BIT_OFFSET_DMFPPLUGGED)
#define BSDF_SETHASDMFP(X, Value)		WRITE_BITS(X.State, STATE_BIT_COUNT_DMFPPLUGGED, STATE_BIT_OFFSET_DMFPPLUGGED, Value)

#if STRATA_INLINE_SHADING
#define BSDF_SETEMISSIVE(X, V)			X.Emissive = V
#define BSDF_GETEMISSIVE(X)				X.Emissive
#else
#define BSDF_SETEMISSIVE(X, V)			X
#define BSDF_GETEMISSIVE(X)				0.0f
#endif

#if STRATA_INLINE_SHADING
#define BSDF_SETTHICKNESSCM(X, V)		X.ThicknessCm = V
#define BSDF_GETTHICKNESSCM(X)			X.ThicknessCm
#else
#define BSDF_SETTHICKNESSCM(X, V)		X
#define BSDF_GETTHICKNESSCM(X)			STRATA_SIMPLEVOLUME_THICKNESS_CM
#endif

#define SLAB_BASECOLOR(X)				X.VGPRs[0].xyz
#define SLAB_SPECULAR(X)				X.VGPRs[0].w
#define SLAB_METALLIC(X)				X.VGPRs[1].x
#define SLAB_ROUGHNESSX(X)				X.VGPRs[1].y
#define SLAB_ROUGHNESSY(X)				X.VGPRs[1].z
#define SLAB_HAZINESS(X)				X.VGPRs[1].w
#define SLAB_EDGECOLOR(X)				X.VGPRs[3].xyz
// Either with SSS profile
#define SLAB_SSSPROFILEID(X)			X.VGPRs[2].x
#define SLAB_SSSPROFILERADIUSSCALE(X)	X.VGPRs[2].y
// Or explicit DMFP in centimeter
#define SLAB_SSSDMFP(X)					X.VGPRs[2].xyz
// Thin film. IOR is harcoded to oil IOR in order to save VGPR
#define SLAB_THINFILM_THICKNESS(X)		X.VGPRs[2].w
#define SLAB_THINFILM_IOR(X)			1.44f

#define SHEEN_BASECOLOR(X)				X.VGPRs[0].xyz
#define SHEEN_ROUGHNESS(X)				X.VGPRs[0].w

#define VOLUMETRICFOGCLOUD_ALBEDO(X)	X.VGPRs[0].xyz
#define VOLUMETRICFOGCLOUD_EXTINCTION(X)X.VGPRs[1].xyz
#define VOLUMETRICFOGCLOUD_AO(X)		X.VGPRs[0].w

#define UNLIT_TRANSMITTANCE(X)			X.VGPRs[0].xyz

#define HAIR_BASECOLOR(X)				X.VGPRs[0].xyz
#define HAIR_SCATTER(X)					X.VGPRs[0].w
#define HAIR_ROUGHNESS(X)				X.VGPRs[1].x
#define HAIR_SPECULAR(X)				X.VGPRs[1].y
#define HAIR_BACKLIT(X)					X.VGPRs[1].z

#define SLW_BASECOLOR(X)				X.VGPRs[0].xyz
#define SLW_METALLIC(X)					X.VGPRs[1].x
#define SLW_SPECULAR(X)					X.VGPRs[1].y
#define SLW_ROUGHNESS(X)				X.VGPRs[1].z
#define SLW_TOPMATERIALOPACITY(X)		X.VGPRs[1].w
#if STRATA_INLINE_SINGLELAYERWATER
#define SLW_WATERALBEDO(X)				X.InlineVGPRs[0].xyz
#define SLW_WATEREXTINCTION(X)			X.InlineVGPRs[1].xyz
#define SLW_WATERPHASEG(X)				X.InlineVGPRs[0].w
#define SLW_COLORSCALEBEHINDWATER(X)	X.InlineVGPRs[2].xyz
#endif

void StrataRequestSharedNormalTangentBasis(inout uint NormalTypes, uint Index);

uint   PackRGBA8(float4 rgba);
float4 UnpackRGBA8(uint rgba);
uint   PackR11G11B10F(float3 rgb);
float3 UnpackR11G11B10F(uint rgb);
uint   PackColorLinearToGamma2AlphaLinear(float4 rgba);
float4 UnpackColorGamma2ToLinearAlphaLinear(uint rgba);
uint   StrataPackNormal(in float3 Normal);
float3 StrataUnpackNormal(uint PackedNormal);

struct FStrataClassification
{
	uint ShadingModels;
	float MaterialAO;
	float TopLayerRoughness;
	bool bIsStrataMaterial;
	bool bHasSubsurface;
	bool bHasSubsurfaceProfile;
	bool bIsSimple;
};

uint StrataPackClassificationData(FStrataClassification In)
{
	const uint MaterialAO8Bits = sqrt(saturate(In.MaterialAO)) * 255.0f;	// Give more accuracy to the blacks to reduce banding
	const uint TopLayerRoughness8Bits = In.TopLayerRoughness * 255.0f;
	return 
		(In.ShadingModels & 0xFF) | 
		((MaterialAO8Bits & 0xFF)			 << 8  ) |
		((TopLayerRoughness8Bits & 0xFF)	 << 16 ) |
		((In.bIsStrataMaterial		? 1 : 0) << 24 ) |
		((In.bHasSubsurface			? 1 : 0) << 25 ) | 
		((In.bHasSubsurfaceProfile	? 1 : 0) << 26 ) |
		((In.bIsSimple				? 1 : 0) << 27 );
}

FStrataClassification StrataUnpackClassificationData(uint In)
{
	uint MaterialAO8Bits = 0;
	uint TopLayerRoughness8Bits = 0;
	FStrataClassification Out;
	Out.ShadingModels			= (In >> 0 ) & 0xFF;
	MaterialAO8Bits				= (In >> 8 ) & 0xFF;
	TopLayerRoughness8Bits		= (In >> 16) & 0xFF;
	Out.bIsStrataMaterial		= (In >> 24) & 0x1;
	Out.bHasSubsurface			= (In >> 25) & 0x1;
	Out.bHasSubsurfaceProfile	= (In >> 26) & 0x1;
	Out.bIsSimple				= (In >> 27) & 0x1;

	Out.MaterialAO = Square(float(MaterialAO8Bits) * (1.0f / 255.0f));
	Out.TopLayerRoughness = float(TopLayerRoughness8Bits) * (1.0f / 255.0f);
	return Out;
}

struct FStrataTopLayerData
{
	float3 WorldNormal;
};

uint StrataPackTopLayerData(FStrataTopLayerData In)
{
	uint Out = StrataPackNormal(In.WorldNormal);
	return Out;
}

FStrataTopLayerData StrataUnpackTopLayerData(uint In)
{
	FStrataTopLayerData Out = (FStrataTopLayerData)0;
	Out.WorldNormal = StrataUnpackNormal(In);
	return Out;
}

struct FStrataSubsurfaceData
{
	float3 BaseColor;
	float  Specular;

	bool   bIsValid;
	bool   bIsProfile;
	uint   ProfileId;
	float  ProfileRadiusScale;

	float3 DMFP;				// When the profile is not used, a per pixel DMFP is used
};

uint2 StrataPackSSSData(FStrataSubsurfaceData In)
{
	uint2 Out;
	Out.x = PackColorLinearToGamma2AlphaLinear(float4(In.BaseColor, In.bIsValid ? (In.bIsProfile ? 1.0f : 0.5f) : 0.0f));
	Out.y = In.bIsProfile ? ((In.ProfileId & 0xFF) | PackRGBA8(float4(0.f, In.ProfileRadiusScale, In.Specular, 0.0f))) : PackR11G11B10F(In.DMFP);
	return Out;
}

uint StrataSubsurfaceProfileIdTo8bits(float In)
{
	// Similar encoding than ExtractSubsurfaceProfileInt. Valid profile ID start at 1.
	return In * 255.0f + 0.5f;
}

FStrataSubsurfaceData StrataUnpackSSSData(uint2 In)
{
	FStrataSubsurfaceData Out = (FStrataSubsurfaceData)0;

	float4 Data0 = UnpackColorGamma2ToLinearAlphaLinear(In.x);
	Out.BaseColor = Data0.rgb;
	Out.bIsValid  = Data0.a > 0.0f;
	Out.bIsProfile= Data0.a > 0.75f;
	Out.ProfileId = SSS_PROFILE_ID_INVALID;

	if (Out.bIsProfile)
	{
		float4 Data1 = UnpackRGBA8(In.y);
		Out.ProfileId = In.y & 0xFF;
		Out.ProfileRadiusScale = Data1.y;
		Out.Specular = Data1.z;
	}
	else if (Out.bIsValid)
	{
		Out.ProfileId = SSS_PROFILE_ID_PERPIXEL;
		Out.DMFP = UnpackR11G11B10F(In.y);
	}
	return Out;
}

uint StrataShadingModelBit(uint ShadingModel)
{
	return 1u << ShadingModel;
}

bool StrataHasShadingModel(uint ShadingModels, uint ShadingModel)
{
	return (ShadingModels & (1u << ShadingModel)) > 0;
}

bool StrataHasAnisotropy(in float RoughnessX, float RoughnessY)
{
	return RoughnessX != RoughnessY;
}

// Return true if a BSDF has a custom area light integrator
bool StrataHasAreaLightIntegrator(in FStrataBSDF BSDF)
{
	const uint BSDFType = BSDF_GETTYPE(BSDF);
	return BSDFType == STRATA_BSDF_TYPE_SLAB;
}

bool StrataHasGreyScaleWeight(in float3 Weight)
{
	return Weight.x == Weight.y && Weight.y == Weight.z;
}


struct FStrataLayer
{
	int BSDFCount;

	FStrataBSDF BSDFs[STRATA_MAX_BSDF_COUNT_PER_LAYER];
};

struct FStrataData
{
	int LayerCount;

	FStrataLayer Layers[STRATA_MAX_LAYER_COUNT];	// Layer 0 is the top layer
};

uint GetStrataSubsurfaceProfile(float NormalizedId)
{
	// can be optimized
	return uint(NormalizedId * 255.0f + 0.5f);

}
FStrataData GetInitialisedStrataData()
{
	FStrataData StrataData = (FStrataData)0;
	return StrataData;
}

FStrataData GetStrataSlabBSDF(
	float3 BaseColor, float3 EdgeColor, float Specular, float Metallic, float Roughness, float Anisotropy,
	float SSSProfileID, float3 SSSDMFP, float SSSDMFPScale,
	float3 Emissive, float Haziness, float ThinFilmThickness,  float Thickness, 
	uint SharedNormalIndex, inout uint SharedNormalTypes)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	const uint bHasEdgeColor = any(EdgeColor < 1);
	const uint bHasHaziness = Haziness > 0.0f ? 1 : 0;
	const uint bHasThinFilm = ThinFilmThickness > 0.0f ? 1 : 0;
	const uint bHasAnisotropy = Anisotropy != 0;
	if (bHasAnisotropy)
	{
		StrataRequestSharedNormalTangentBasis(SharedNormalTypes, SharedNormalIndex);
	}

	const float2 RoughnessXY = GetAnisotropicRoughness(Roughness, Anisotropy);

	// STRATA_TODO apply SSS as a function of pixel footprint w.r.t. MFP
	const bool bDMFPPlugged = any(SSSDMFP > 0);
	const bool bHasSSSProfile = SSSProfileID  > 0.0f;	// When no profile is provide, we use Burley. STRATA_TODO we should clarify as burley is also an option of the profile.
	const bool bHasSSS = bDMFPPlugged || bHasSSSProfile;

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE			(StrataData.Layers[0].BSDFs[0],		STRATA_BSDF_TYPE_SLAB);
	BSDF_SETNORMALID		(StrataData.Layers[0].BSDFs[0],		SharedNormalIndex);
	BSDF_SETEMISSIVE		(StrataData.Layers[0].BSDFs[0],		Emissive);
	BSDF_SETANISOTROPY		(StrataData.Layers[0].BSDFs[0],		bHasAnisotropy);
	BSDF_SETISTOPLAYER		(StrataData.Layers[0].BSDFs[0],		0);
	BSDF_SETHASSSS			(StrataData.Layers[0].BSDFs[0],		bHasSSS ? 1 : 0);
	BSDF_SETHASSSSPROFILE	(StrataData.Layers[0].BSDFs[0],		bHasSSSProfile ? 1 : 0);
	BSDF_SETHASDMFP			(StrataData.Layers[0].BSDFs[0],		bDMFPPlugged ? 1 : 0);
	BSDF_SETHASHAZINESS		(StrataData.Layers[0].BSDFs[0],		bHasHaziness);
	BSDF_SETHASEDGECOLOR	(StrataData.Layers[0].BSDFs[0],		bHasEdgeColor);
	BSDF_SETHASTHINFILM		(StrataData.Layers[0].BSDFs[0],		bHasThinFilm);
	BSDF_SETTHICKNESSCM		(StrataData.Layers[0].BSDFs[0],		Thickness);

	SLAB_BASECOLOR			(StrataData.Layers[0].BSDFs[0])		= BaseColor;
	SLAB_EDGECOLOR			(StrataData.Layers[0].BSDFs[0])		= EdgeColor;
	SLAB_SPECULAR			(StrataData.Layers[0].BSDFs[0])		= Specular;
	SLAB_METALLIC			(StrataData.Layers[0].BSDFs[0])		= Metallic;
	SLAB_ROUGHNESSX			(StrataData.Layers[0].BSDFs[0])		= RoughnessXY.x;
	SLAB_ROUGHNESSY			(StrataData.Layers[0].BSDFs[0])		= RoughnessXY.y;
	SLAB_HAZINESS			(StrataData.Layers[0].BSDFs[0])		= Haziness;
	SLAB_THINFILM_THICKNESS	(StrataData.Layers[0].BSDFs[0])		= ThinFilmThickness;
	if (bHasSSSProfile)
	{
		SLAB_SSSPROFILEID	(StrataData.Layers[0].BSDFs[0])		= SSSProfileID;
		SLAB_SSSPROFILERADIUSSCALE(StrataData.Layers[0].BSDFs[0])= saturate(SSSDMFPScale);
	}
	else
	{
		SLAB_SSSDMFP	(StrataData.Layers[0].BSDFs[0])			= SSSDMFP * saturate(SSSDMFPScale);
	}

#if STRATA_INLINE_SHADING
	// At this stage we do not know if this strata BSDF is going to be using simple volume lighting so always store the DMFP on the side to not override SSSPROFILE data.
	StrataData.Layers[0].BSDFs[0].TmpDMFP = SSSDMFP * saturate(SSSDMFPScale);
#endif

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;
	return StrataData;
}

FStrataData GetStrataSheenBSDF(float3 BaseColor, float Roughness, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;

	StrataData.Layers[0].BSDFCount++;
	BSDF_SETTYPE			(StrataData.Layers[0].BSDFs[0],		STRATA_BSDF_TYPE_SHEEN);
	BSDF_SETNORMALID		(StrataData.Layers[0].BSDFs[0],		SharedNormalIndex);
	BSDF_SETISTOPLAYER		(StrataData.Layers[0].BSDFs[0],		0);
	SHEEN_BASECOLOR			(StrataData.Layers[0].BSDFs[0])		= BaseColor;
	SHEEN_ROUGHNESS			(StrataData.Layers[0].BSDFs[0])		= Roughness;

	StrataData.Layers[0].BSDFs[0].Weight						= 1.0f;

	return StrataData;
}

FStrataData GetStrataVolumeFogCloudBSDF(float3 Albedo, float3 Extinction, float3 Emissive, float AmbientOcclusion)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD);
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], Emissive);
	VOLUMETRICFOGCLOUD_ALBEDO		(StrataData.Layers[0].BSDFs[0]) = Albedo;
	VOLUMETRICFOGCLOUD_EXTINCTION	(StrataData.Layers[0].BSDFs[0]) = Extinction;
	VOLUMETRICFOGCLOUD_AO			(StrataData.Layers[0].BSDFs[0]) = AmbientOcclusion;

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}

FStrataData GetStrataUnlitBSDF(float3 Emissive, float3 TransmittanceColor)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_UNLIT);
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], Emissive);
	UNLIT_TRANSMITTANCE				(StrataData.Layers[0].BSDFs[0]) = TransmittanceColor;

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}

FStrataData GetStrataHairBSDF(float3 BaseColor, float Scatter, float Specular, float Roughness, float Backlit, float3 Emissive, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_HAIR);
	BSDF_SETNORMALID				(StrataData.Layers[0].BSDFs[0], SharedNormalIndex);
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], Emissive);
	HAIR_BASECOLOR					(StrataData.Layers[0].BSDFs[0]) = BaseColor;
	HAIR_SCATTER					(StrataData.Layers[0].BSDFs[0]) = Scatter;
	HAIR_ROUGHNESS					(StrataData.Layers[0].BSDFs[0]) = Roughness;
	HAIR_SPECULAR					(StrataData.Layers[0].BSDFs[0]) = Specular;
	HAIR_BACKLIT					(StrataData.Layers[0].BSDFs[0]) = Backlit;

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}

FStrataData GetStrataSingleLayerWaterBSDF(
	float3 BaseColor, float Metallic, float Specular, float Roughness, float3 Emissive, float TopMaterialOpacity,
	float3 WaterAlbedo, float3 WaterExtinction, float WaterPhaseG, float3 ColorScaleBehindWater, uint SharedNormalIndex)
{
	FStrataData StrataData = GetInitialisedStrataData();
	StrataData.LayerCount++;
	StrataData.Layers[0].BSDFCount++;

	BSDF_SETTYPE					(StrataData.Layers[0].BSDFs[0], STRATA_BSDF_TYPE_SINGLELAYERWATER);
	BSDF_SETNORMALID				(StrataData.Layers[0].BSDFs[0], SharedNormalIndex);
	BSDF_SETEMISSIVE				(StrataData.Layers[0].BSDFs[0], Emissive);
	SLW_BASECOLOR					(StrataData.Layers[0].BSDFs[0]) = BaseColor;
	SLW_METALLIC					(StrataData.Layers[0].BSDFs[0]) = Metallic;
	SLW_SPECULAR					(StrataData.Layers[0].BSDFs[0]) = Specular;
	SLW_ROUGHNESS					(StrataData.Layers[0].BSDFs[0]) = Roughness;
	SLW_TOPMATERIALOPACITY			(StrataData.Layers[0].BSDFs[0]) = TopMaterialOpacity;
#if STRATA_INLINE_SINGLELAYERWATER
	SLW_WATERALBEDO					(StrataData.Layers[0].BSDFs[0]) = WaterAlbedo;
	SLW_WATEREXTINCTION				(StrataData.Layers[0].BSDFs[0]) = WaterExtinction;
	SLW_WATERPHASEG					(StrataData.Layers[0].BSDFs[0]) = WaterPhaseG;
	SLW_COLORSCALEBEHINDWATER		(StrataData.Layers[0].BSDFs[0]) = ColorScaleBehindWater;
#endif

	StrataData.Layers[0].BSDFs[0].Weight = 1.0f;

	return StrataData;
}

// Optimised for power of two because it relies on a division done using bit shift
uint DivideAndRoundUp(uint Dividend, uint Divisor, uint DivisorAsBitShift)
{
	return (Dividend + Divisor - 1) >> DivisorAsBitShift;
}

struct FStrataAddressing
{
	uint  CurrentAddr;
	uint  ByteOffsetToNextUint;
	uint  ReadBytes;
	uint2 PixelCoords;
};
FStrataAddressing GetStrataPixelDataByteOffset(uint2 PixelPos, uint2 ViewBufferSize, uint StrataMaxBytesPerPixel)
{
	FStrataAddressing StrataAddressing = (FStrataAddressing)0;

#if 0
	// Linear storage, pixel0 bytes, pixel1 bytes, etc.
	StrataAddressing.CurrentAddr = (PixelPos.y * ViewBufferSize.x + PixelPos.x) * StrataMaxBytesPerPixel;
	StrataAddressing.ByteOffsetToNextUint = 4;
#else

	// A tile of pixels has each uint that can be read packed in contiguous memory to be cache efficient. Then, the next set of uint to be read is in another "plane", after all uint from all the pixel/tile.
	// Without that, L2 is rarely hit and GCN TA FIFO command buffer is getting full in no time because memory fetches are not served in time (GPU cost then increase by at least x2)

	uint TilePixelSizeBytes			= 4;	// sizeof(uint)
	uint TileSizeBytes				= STRATA_DATA_TILE_SIZE * STRATA_DATA_TILE_SIZE * TilePixelSizeBytes;
	uint2 TileCount					= uint2(DivideAndRoundUp(ViewBufferSize.x, STRATA_DATA_TILE_SIZE, STRATA_DATA_TILE_SIZE_DIV_AS_SHIFT), DivideAndRoundUp(ViewBufferSize.y, STRATA_DATA_TILE_SIZE, STRATA_DATA_TILE_SIZE_DIV_AS_SHIFT));
	uint2 TileCoord					= uint2(PixelPos.x >> STRATA_DATA_TILE_SIZE_DIV_AS_SHIFT, PixelPos.y >> STRATA_DATA_TILE_SIZE_DIV_AS_SHIFT);
	uint2 PixelCoordInTile			= PixelPos - TileCoord * STRATA_DATA_TILE_SIZE;

	uint PreviousTilesBytes			= (TileCoord.y * TileCount.x + TileCoord.x) * TileSizeBytes;
	uint PreviousPixelsInTileBytes	= (PixelCoordInTile.y * STRATA_DATA_TILE_SIZE + PixelCoordInTile.x) * TilePixelSizeBytes;
	StrataAddressing.CurrentAddr	= PreviousTilesBytes + PreviousPixelsInTileBytes;

	// All
	StrataAddressing.ByteOffsetToNextUint = TileCount.x * TileCount.y * TileSizeBytes;

#endif

	StrataAddressing.PixelCoords = PixelPos;
	StrataAddressing.ReadBytes = 0;
	return StrataAddressing;
}

#if COMPILER_SWITCH // These platforms are complaining so simply disabling Strata there for now.

#define STRATA_STORE_UINT1(x) 

#define STRATA_LOAD_UINT1(x) x = 0;

#define STRATA_LOAD_FLOAT1(x) x = 0;

uint  StrataLoadUint1(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing) { return 0; }

#else

#define STRATA_STORE_UINT1(x)	StrataBuffer.Store (StrataAddressing.CurrentAddr, asuint(x)); \
								StrataAddressing.CurrentAddr += StrataAddressing.ByteOffsetToNextUint; \
								StrataAddressing.ReadBytes += 4;

#define STRATA_LOAD_UINT1(x)	x = StrataBuffer.Load (StrataAddressing.CurrentAddr); \
								StrataAddressing.CurrentAddr += StrataAddressing.ByteOffsetToNextUint; \
								StrataAddressing.ReadBytes += 4;

#define STRATA_LOAD_FLOAT1(x)	x = asfloat(StrataBuffer.Load (StrataAddressing.CurrentAddr)); \
								StrataAddressing.CurrentAddr += StrataAddressing.ByteOffsetToNextUint; \
								StrataAddressing.ReadBytes += 4;

uint  StrataLoadUint1(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing) 
{ 
	uint  x = StrataBuffer.Load(StrataAddressing.CurrentAddr); 
	StrataAddressing.CurrentAddr += StrataAddressing.ByteOffsetToNextUint;	
	StrataAddressing.ReadBytes += 4;
	return x; 
}

#endif


///////////////////////////////////////////////////////////////////////////////
// Shared normals

float3 StrataUnpackNormal(uint PackedNormal);
void StrataUnpackNormalAndTangent(inout float3 Normal, inout float3 Tangent, in uint InPacked);

#define STRATA_BASIS_TYPE_NORMAL 0u
#define STRATA_BASIS_TYPE_TANGENT 1u
struct FSharedNormals
{
	uint NormalCount;
	uint NormalTypes;
	float3 Normals[STRATA_MAX_SHARED_NORMAL_REGISTERS];	// once registered, normals are always world space
	float3 Tangents[STRATA_MAX_SHARED_NORMAL_REGISTERS];// idem for tangents
};

FSharedNormals StrataInitialiseSharedNormals()
{
	FSharedNormals SharedNormals = (FSharedNormals)0;
	return SharedNormals;
}

void StrataRequestSharedNormalTangentBasis(inout uint NormalTypes, uint Index)
{
	NormalTypes = NormalTypes | (STRATA_BASIS_TYPE_TANGENT << Index);
}

uint StrataGetSharedNormalType(in uint NormalTypes, uint Index)
{
	return (NormalTypes >> Index) & 0x1 ? STRATA_BASIS_TYPE_TANGENT : STRATA_BASIS_TYPE_NORMAL;
}

struct FStrataPixelHeader
{
	uint BSDFCount;

#if STRATA_INLINE_SHADING
	// All the shared normal in VGPRS. This is only used in basepass and during forward rendering.
	FSharedNormals SharedNormals;
#else
	ByteAddressBuffer StrataBuffer;
	uint SharedNormalByteOffset;
	uint SharedNormalTypes;
#endif

	float MaterialAO;
	bool SkipPrecShadowMask;
	bool ZeroPrecShadowMask;
	bool IsSingleLayerWater;	// Used to avoid loading BSDF or Categorisation data when generating tiles containing SLW material. Avoid running another categorisation.
};

FStrataPixelHeader InitialiseStrataPixelHeader()
{
	FStrataPixelHeader Out;
	Out.BSDFCount = 0;
#if STRATA_INLINE_SHADING
	Out.SharedNormals = (FSharedNormals)0;
#else
	Out.SharedNormalByteOffset = 0;
	Out.SharedNormalTypes = 0;
#endif
	Out.MaterialAO = 1.0f;
	Out.SkipPrecShadowMask = false;
	Out.ZeroPrecShadowMask = false;
	Out.IsSingleLayerWater = false;
	return Out;
}

float3x3 StrataGetBSDFSharedBasis(in FStrataPixelHeader StrataPixelHeader, in FStrataBSDF BSDF, in FStrataAddressing StrataAddressing)
{
#if STRATA_INLINE_SHADING
	// Assume Normal & Tangent are already been normalized
	float3 Normal  = StrataPixelHeader.SharedNormals.Normals[BSDF_GETNORMALID(BSDF)];
	float3 Tangent = StrataPixelHeader.SharedNormals.Tangents[BSDF_GETNORMALID(BSDF)];
	float3 Bitangent = cross(Normal, Tangent);
	return float3x3(Tangent, Bitangent, Normal);
#else
	const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDF) != 0;
	uint PackedBasis = StrataPixelHeader.StrataBuffer.Load(StrataPixelHeader.SharedNormalByteOffset + BSDF_GETNORMALID(BSDF) * StrataAddressing.ByteOffsetToNextUint);
	uint BasisType   = StrataGetSharedNormalType(StrataPixelHeader.SharedNormalTypes, BSDF_GETNORMALID(BSDF));
	float3x3 OutTangentBasis;
	if (BasisType == STRATA_BASIS_TYPE_NORMAL)
	{
		float3 Normal = StrataUnpackNormal(PackedBasis);
		OutTangentBasis = GetTangentBasis(Normal);
	}
	else // if (BasisType == STRATA_BASIS_TYPE_TANGENT)
	{
		float3 Normal;
		float3 Tangent;
		StrataUnpackNormalAndTangent(Normal, Tangent, PackedBasis);

		OutTangentBasis[0] = Tangent;
		OutTangentBasis[1] = cross(Normal, Tangent);
		OutTangentBasis[2] = Normal;
	}
	return OutTangentBasis;
#endif
}



///////////////////////////////////////////////////////////////////////////////
// Operator nodes

FStrataData StrataAdd(FStrataData A, FStrataData B)
{
	FStrataData StrataData = A;

	// Append each BSDF from B to A, with same layer position
	UNROLL
	for (int Layer = 0; Layer < B.LayerCount; ++Layer)
	{
		FStrataLayer ALayer = A.Layers[Layer];
		FStrataLayer BLayer = B.Layers[Layer];
		UNROLL
		for (int BSDF = 0; BSDF < BLayer.BSDFCount; BSDF++)
		{
			StrataData.Layers[Layer].BSDFs[ALayer.BSDFCount + BSDF] = BLayer.BSDFs[BSDF];
		}

		StrataData.Layers[Layer].BSDFCount = ALayer.BSDFCount + BLayer.BSDFCount;
	}

	StrataData.LayerCount = max(A.LayerCount, B.LayerCount);

	return StrataData;
}

FStrataData StrataMultiply(FStrataData A, float Weight)
{
	FStrataData StrataData = A;

	// Apply the weight to each BSDF
	UNROLL
	for (int Layer = 0; Layer < StrataData.LayerCount; ++Layer)
	{
		UNROLL
		for (int BSDF = 0; BSDF < StrataData.Layers[Layer].BSDFCount; ++BSDF)
		{
			StrataData.Layers[Layer].BSDFs[BSDF].Weight *= Weight;
		}
	}

	return StrataData;
}

FStrataData StrataHorizontalMixing(FStrataData Foreground, FStrataData Background, float Mix)
{
	const float ForegroundMixFactor = saturate(Mix);
	const float BackgroundMixFactor = 1.0 - ForegroundMixFactor;

	FStrataData A = StrataMultiply(Foreground, ForegroundMixFactor);
	FStrataData B = StrataMultiply(Background, BackgroundMixFactor);
	return StrataAdd(A, B);
}

FStrataData StrataVerticalLayering(FStrataData Top, FStrataData Base)
{
	FStrataData StrataData = Top;

	// Add each layer from Base under Top
	int TopLayerCount = Top.LayerCount;
	UNROLL
	for (int Layer = 0; Layer < Base.LayerCount; ++Layer)
	{
		StrataData.Layers[TopLayerCount + Layer] = Base.Layers[Layer];
	}

	StrataData.LayerCount += Base.LayerCount;

	return StrataData;
}



///////////////////////////////////////////////////////////////////////////////
// Functions used to sanitize BSDF before they are used for lighting (when forward) or stored to memory (base pass).
// We do not normalize normals, this is done before the lighting step.

void SanitizeStrataSlab(inout FStrataBSDF BSDF)
{
	BSDF_SETEMISSIVE(BSDF, clamp(BSDF_GETEMISSIVE(BSDF), 0.0, Max10BitsFloat));
	SLAB_BASECOLOR(BSDF) = saturate(SLAB_BASECOLOR(BSDF));
	SLAB_EDGECOLOR(BSDF) = saturate(SLAB_EDGECOLOR(BSDF));
	SLAB_SPECULAR(BSDF) = saturate(SLAB_SPECULAR(BSDF));
	SLAB_METALLIC(BSDF) = saturate(SLAB_METALLIC(BSDF));
	SLAB_ROUGHNESSX(BSDF) = saturate(SLAB_ROUGHNESSX(BSDF));
	SLAB_ROUGHNESSY(BSDF) = saturate(SLAB_ROUGHNESSY(BSDF));
	SLAB_HAZINESS(BSDF) = saturate(SLAB_HAZINESS(BSDF));
	SLAB_THINFILM_THICKNESS(BSDF) = saturate(SLAB_THINFILM_THICKNESS(BSDF));
#if STRATA_INLINE_SHADING
	BSDF.TmpDMFP = clamp(BSDF.TmpDMFP, 0.0f, Max111110BitsFloat3);
#endif

	// BSDF feature tests must be executed for profile path to not interact with DMFP, especially for forward rendered simple volumetrics.
	if (BSDF_GETHASSSS(BSDF))
	{
		if (BSDF_GETHASSSSPROFILE(BSDF))
		{
			SLAB_SSSPROFILERADIUSSCALE(BSDF) = saturate(SLAB_SSSPROFILERADIUSSCALE(BSDF));
		}
		else
		{
			SLAB_SSSDMFP(BSDF) = clamp(SLAB_SSSDMFP(BSDF), 0.0f, Max111110BitsFloat3);
		}
	}
}

void SanitizeStrataSheen(inout FStrataBSDF BSDF)
{
	SHEEN_BASECOLOR(BSDF) = saturate(SHEEN_BASECOLOR(BSDF));
	SHEEN_ROUGHNESS(BSDF) = saturate(SHEEN_ROUGHNESS(BSDF));
}

void SanitizeStrataHair(inout FStrataBSDF BSDF)
{
	BSDF_SETEMISSIVE(BSDF, clamp(BSDF_GETEMISSIVE(BSDF), 0.0, Max10BitsFloat));
	HAIR_BASECOLOR(BSDF) = saturate(HAIR_BASECOLOR(BSDF));
	HAIR_SCATTER(BSDF) = saturate(HAIR_SCATTER(BSDF));
	HAIR_ROUGHNESS(BSDF) = saturate(HAIR_ROUGHNESS(BSDF));
	HAIR_SPECULAR(BSDF) = saturate(HAIR_SPECULAR(BSDF));
	HAIR_BACKLIT(BSDF) = saturate(HAIR_BACKLIT(BSDF));
}

void SanitizeStrataSingleLayerWater(inout FStrataBSDF BSDF)
{
	BSDF_SETEMISSIVE(BSDF, clamp(BSDF_GETEMISSIVE(BSDF), 0.0, Max10BitsFloat));
	SLW_BASECOLOR(BSDF) = saturate(SLW_BASECOLOR(BSDF));
	SLW_METALLIC(BSDF) = saturate(SLW_METALLIC(BSDF));
	SLW_SPECULAR(BSDF) = saturate(SLW_SPECULAR(BSDF));
	SLW_ROUGHNESS(BSDF) = saturate(SLW_ROUGHNESS(BSDF));
	SLW_TOPMATERIALOPACITY(BSDF) = saturate(SLW_TOPMATERIALOPACITY(BSDF));
#if STRATA_INLINE_SINGLELAYERWATER
	SLW_WATERALBEDO(BSDF) = saturate(SLW_WATERALBEDO(BSDF));
	SLW_WATEREXTINCTION(BSDF) = clamp(SLW_WATEREXTINCTION(BSDF), 0.0f, Max10BitsFloat);
	SLW_WATERPHASEG(BSDF) = clamp(SLW_WATERPHASEG(BSDF), -1.0f, 1.0f);
	SLW_COLORSCALEBEHINDWATER(BSDF) = clamp(SLW_COLORSCALEBEHINDWATER(BSDF), 0.0f, Max10BitsFloat);
#endif
}



void StrataSanitizeBSDF(inout FStrataBSDF BSDF)
{
	switch (BSDF_GETTYPE(BSDF))
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			SanitizeStrataSlab(BSDF);
			break; 
		}
		case STRATA_BSDF_TYPE_SHEEN:
		{
			SanitizeStrataSheen(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_HAIR:
		{
			SanitizeStrataHair(BSDF);
			break;
		}
		case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		{
			SanitizeStrataSingleLayerWater(BSDF);
			break;
		}
		
	}
}



///////////////////////////////////////////////////////////////////////////////
// Other tools

// Those participating media funtion are use by the Slab node. In this case, the DMFP is considered as a simple MFP because DMFP is not directly inversible to medium properties.

FParticipatingMedia StrataSlabCreateParticipatingMedia(float3 DiffuseColor, float3 MeanFreePathCentimeters)
{
	const float3 MeanFreePathMeters = MeanFreePathCentimeters * STRATA_CENTIMETER_TO_METER;
	return CreateMediumFromBaseColorMFP(DiffuseColor, MeanFreePathMeters);
}

float StrataSlabDiffuseToVolumeBlend(FParticipatingMedia PM)
{
	// Remember, computation are made for a slab of 1 metter, according to STRATA_SIMPLEVOLUME_THICKNESS_M.
	// We start blending from diffuse toward a slab of participating media when the mean free path reaches 4 centimeters.
	const float MaxMeanFreePathMeters = max(PM.MeanFreePath.x, max(PM.MeanFreePath.y, PM.MeanFreePath.z));
	// Start blending volumetric after mean free path of 4 centimeters (also needed because threshold when recovering extinction from transmittance cause a small minimum value)
	const float StartVolumeBlendMFP = 0.04f;
	// And when the mean free path reaches 1/3.0f = 0.33 meter. That is extinction=1/0.33=3, transmittance at 1m (bottom of the slab) = exp(-3) = 0.05) we fully use the volumetric model.
	const float Blend = saturate(max(0.0, MaxMeanFreePathMeters - StartVolumeBlendMFP) * 3.0f);
	//const float Blend = max(0.0, MaxMeanFreePathMeters - StartVolumeBlendMFP) > 0.0 ? 1.0 : 0.0;

	// Using a non linear blend helps smoothing out transitions visually.
	return Blend * Blend;
}

struct FStrataSlabSingleScattering
{
	float3 Transmittance;
	float3 SingleScattering;
};
FStrataSlabSingleScattering StrataSlabSingleScattering(FParticipatingMedia PM, float NoV)
{
	const float3 SafeExtinctionThreshold = 0.000001f;
	const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, PM.ExtinctionCoef);

	const float PathLength = STRATA_SIMPLEVOLUME_THICKNESS_M / max(0.0001f, abs(NoV));
	const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);

	// Single scattering analytical integration from "Physically Based Unified Volumetric Rendering in Frostbite", slide 27/28.
	FStrataSlabSingleScattering Result;
	Result.SingleScattering = (PM.ScatteringCoef - PM.ScatteringCoef * SafePathSegmentTransmittance) / SafeExtinctionCoefficients;
	Result.Transmittance = SafePathSegmentTransmittance;
	return Result;
}

void EnableSlabBSDFSimpleVolumetric(inout FStrataBSDF BSDF)
{
#if STRATA_INLINE_SHADING
	// Now we know that this is a simple volume so we can freely set the mean free path
	SLAB_SSSDMFP(BSDF) = BSDF.TmpDMFP;
#endif

	// Rescale the BSDF mean free path so that we can drop the thickness parameter and run volumetric material math on a unit slab of medium
	// For instance, if thickness is larger => we need to reduce the MFP for the medium to appear visually thicker.
	SLAB_SSSDMFP(BSDF) = clamp(SLAB_SSSDMFP(BSDF) * (STRATA_SIMPLEVOLUME_THICKNESS_CM / BSDF_GETTHICKNESSCM(BSDF)), 0.0f, Max111110BitsFloat3);

	// Mark the BSDF has not having any SSS through post process.
	BSDF_SETHASSSS(BSDF, 0);
	BSDF_SETHASSSSPROFILE(BSDF, 0);

	// Notify that the Slab can use SSS post-process only if at the bottom (layered considered optically thick, e.g. cannot see-through)
	// When forward rendering is used or if a layer is not a bottom layer, SSS post cannot be used and simple scattering is used.
	BSDF_SETISSIMPLEVOLUME(BSDF, 1);
}


///////////////////////////////////////////////////////////////////////////////
// BSDFs packing/unpacking
// 11G11B10F and 10F are unsigned float format

uint Pack10F(float Value)
{
	return (f32tof16(Value) >> 5) & 0x000003FF;
}

float Unpack10F(uint Value)
{
	return f16tof32((Value << 5) & 0x7FE0);
}

uint PackR11G11B10F(float3 rgb)
{
	uint r = (f32tof16(rgb.r) << 17) & 0xFFE00000;
	uint g = (f32tof16(rgb.g) << 6)  & 0x001FFC00;
	uint b = (f32tof16(rgb.b) >> 5)  & 0x000003FF;
	return r | g | b;
}

float3 UnpackR11G11B10F(uint rgb)
{
	float r = f16tof32((rgb >> 17) & 0x7FF0);
	float g = f16tof32((rgb >> 6)  & 0x7FF0);
	float b = f16tof32((rgb << 5)  & 0x7FE0);
	return float3(r, g, b);
}

uint2 PackR16G16B16A16F(float4 rgba)
{
	uint A = (f32tof16(rgba.r) << 16) | f32tof16(rgba.g);
	uint B = (f32tof16(rgba.b) << 16) | f32tof16(rgba.a);
	return uint2 (A, B);
}

float4 UnpackR16G16B16A16F(uint2 AB)
{
	float r = f16tof32(AB.x >> 16);
	float g = f16tof32(AB.x);
	float b = f16tof32(AB.y >> 16);
	float a = f16tof32(AB.y);
	return float4(r, g, b, a);
}

uint PackColorLinearToGamma2(float3 rgb)
{
	uint r = (uint(sqrt(saturate(rgb.r)) * 255.0f) << 16);
	uint g = (uint(sqrt(saturate(rgb.g)) * 255.0f) << 8);
	uint b = (uint(sqrt(saturate(rgb.b)) * 255.0f) << 0);
	return r | g | b;
}

float3 UnpackColorGamma2ToLinear(uint rgb)
{
	float r = float((rgb >> 16) & 0x000000FF);
	float g = float((rgb >> 8)  & 0x000000FF);
	float b = float((rgb >> 0)  & 0x000000FF);
	float3 Gamma2 = float3(r, g, b) * (1.0f / 255.0f);
	return Gamma2 * Gamma2;	// Simple gamma 2.0
}

uint PackColorLinearToGamma2AlphaLinear(float4 rgba)
{
	uint r = (uint(sqrt(saturate(rgba.r)) * 255.0f) << 24);
	uint g = (uint(sqrt(saturate(rgba.g)) * 255.0f) << 16);
	uint b = (uint(sqrt(saturate(rgba.b)) * 255.0f) << 8);
	uint a = (uint(     saturate(rgba.a)  * 255.0f) << 0);
	return r | g | b | a;
}

float4 UnpackColorGamma2ToLinearAlphaLinear(uint rgba)
{
	float r = float((rgba >> 24) & 0x000000FF);
	float g = float((rgba >> 16) & 0x000000FF);
	float b = float((rgba >> 8)  & 0x000000FF);
	float a = float((rgba >> 0)  & 0x000000FF);
	float3 Gamma2 = float3(r, g, b) * (1.0f / 255.0f);
	return float4(Gamma2 * Gamma2, a * (1.0f / 255.0f));	// Simple gamma 2.0
}

uint PackRGBA8(float4 rgba)
{
	uint r = (uint(saturate(rgba.r) * 255.0f) << 0);
	uint g = (uint(saturate(rgba.g) * 255.0f) << 8);
	uint b = (uint(saturate(rgba.b) * 255.0f) << 16);
	uint a = (uint(saturate(rgba.a) * 255.0f) << 24);
	return r | g | b | a;
}

float4 UnpackRGBA8(uint rgba)
{
	float4 Out;
	Out.r = float((rgba >> 0)  & 0xFF) * (1.0f/255.0f);
	Out.g = float((rgba >> 8)  & 0xFF) * (1.0f/255.0f);
	Out.b = float((rgba >> 16) & 0xFF) * (1.0f/255.0f);
	Out.a = float((rgba >> 24) & 0xFF) * (1.0f/255.0f);
	return Out;
}

// Simple Octahedral from "A Survey of Efficient Representations for Independent Unit Vectors" http://jcgt.org/published/0003/02/01/
float SignNotZero(in float k)
{
	return k >= 0.0 ? 1.0 : -1.0;
}
float2 SignNotZero(in float2 v)
{
	return float2(SignNotZero(v.x), SignNotZero(v.y));
}

uint StrataPackNormal(in float3 Normal)
{
	float l1norm = abs(Normal.x) + abs(Normal.y) + abs(Normal.z);
	float2 result = Normal.xy * (1.0 / l1norm);
	if (Normal.z < 0.0)
	{
		result = (1.0 - abs(result.yx)) * SignNotZero(result.xy);
	}
	uint PackedX = f32tof16(result.x);
	uint PackedY = f32tof16(result.y);
	return PackedX | (PackedY << 16);
}

float3 StrataUnpackNormal(uint PackedNormal)
{
	float x = f16tof32(0xFFFFFFFF &  PackedNormal);
	float y = f16tof32(0xFFFFFFFF & (PackedNormal>>16));

	float3 Normal = float3(x, y, 1.0f - abs(x) - abs(y));
	if (Normal.z < 0.0f)
	{
		Normal.xy = (1.0f - abs(Normal.yx)) * SignNotZero(Normal.xy);
	}
	return normalize(Normal);
}

#define STRATA_TANGENT_SYMMETRY 1
uint StrataPackNormalAndTangent(in float3 Normal, in float3 Tangent)
{
	uint X10Bits;
	uint Y10Bits;
	uint Z11Bits;
	uint W1Bit;

	// Oct. encoding for the normal
	{
		float l1norm = abs(Normal.x) + abs(Normal.y) + abs(Normal.z);
		float2 result = Normal.xy * (1.0 / l1norm);
		if (Normal.z < 0.0)
		{
			result = (1.0 - abs(result.yx)) * SignNotZero(result.xy);
		}
		X10Bits = uint(clamp(result.x * 511.0f + 512.0f, 0.0f, 1023.0f));
		Y10Bits = uint(clamp(result.y * 511.0f + 512.0f, 0.0f, 1023.0f));
	}

	// Oct. encoding for the projected tangent, relative to an generated ortho frame based on normal
	{
		// Use the quantize normal to regenerate tje ortho. frame. This removes discontinuities
		float x = float(int(X10Bits) - 512) / 511.0f;
		float y = float(int(Y10Bits) - 512) / 511.0f;
		Normal = float3(x, y, 1.0f - abs(x) - abs(y));
		if (Normal.z < 0.0f)
		{
			Normal.xy = (1.0f - abs(Normal.yx)) * SignNotZero(Normal.xy);
		}
		//Normal = normalize(Normal);

		float3x3 LocalRef = GetTangentBasis(Normal);
		float2 ProjXY = float2(dot(LocalRef[0], Tangent), dot(LocalRef[1], Tangent));
	#if STRATA_TANGENT_SYMMETRY
		// Use symmetry to improve precision
		ProjXY = ProjXY.x >= 0 ? ProjXY : -ProjXY.xy;
	#endif
		float l1norm = abs(ProjXY.x) + abs(ProjXY.y);
		float2 result = ProjXY.xy * (1.0 / l1norm);

	#if STRATA_TANGENT_SYMMETRY
		Z11Bits = uint(clamp(result.x * 2047.0f, 0.0f, 2047.0f));
	#else
		Z11Bits = uint(clamp(result.x * 1023.0f + 1024.0f, 0.0f, 2047.0f));
	#endif
		W1Bit   = ProjXY.y >= 0 ? 1u : 0u;
	}

	return
		 (0x3FF & X10Bits)        | 
		((0x3FF & Y10Bits) << 10) | 
		((0x7FF & Z11Bits) << 20) |
		((0x1   & W1Bit  ) << 31);
}

void StrataUnpackNormalAndTangent(inout float3 Normal, inout float3 Tangent, in uint InPacked)
{
	uint X10Bits = 0x3FF &  InPacked;
	uint Y10Bits = 0x3FF & (InPacked>>10);
	uint Z11bits = 0x7FF & (InPacked>>20);
	uint W1Bit   = 0x1   & (InPacked>>31);

	// Oct. decoding for the normal
	{
		float x = float(int(X10Bits) - 512) / 511.0f;
		float y = float(int(Y10Bits) - 512) / 511.0f;

		Normal = float3(x, y, 1.0f - abs(x) - abs(y));
		if (Normal.z < 0.0f)
		{
			Normal.xy = (1.0f - abs(Normal.yx)) * SignNotZero(Normal.xy);
		}
		Normal = normalize(Normal);
	}

	// Oct. decoding for the projected tangent, relative to an generated ortho frame based on normal
	{
		// Create intermediate basis
		float3x3 LocalRef = GetTangentBasis(Normal);
	#if STRATA_TANGENT_SYMMETRY
		float x = float(Z11bits) / 2047.0f;
	#else
		float x = float(int(Z11bits) - 1024) / 1023.0f;
	#endif
		float Sign = (W1Bit > 0 ? 1 : -1);
		float2 ProjX = float2(x, 1.0f - abs(x));
		Tangent = LocalRef[0] * ProjX.x + LocalRef[1] * ProjX.y * Sign;
		Tangent = normalize(Tangent);
	}
}

void StrataLoad_R11G11B10F(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing, inout float3 A)
{
	A = UnpackR11G11B10F(StrataLoadUint1(StrataBuffer, StrataAddressing));
}

void StrataLoad_R11_G11_B10F(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing, inout float A, inout float B, inout float C)
{
	float3 temp = UnpackR11G11B10F(StrataLoadUint1(StrataBuffer, StrataAddressing));
	A = temp.x;
	B = temp.y;
	C = temp.z;
}

void StrataLoad_ColorGamma2ToLinear(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing, inout float3 A)
{
	A = UnpackColorGamma2ToLinear(StrataLoadUint1(StrataBuffer, StrataAddressing));
}

void StrataLoad_ColorGamma2ToLinearAlphaLinear(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing, inout float3 RGB, inout float A)
{
	float4 Data = UnpackColorGamma2ToLinearAlphaLinear(StrataLoadUint1(StrataBuffer, StrataAddressing));
	RGB = Data.rgb;
	A = Data.a;
}

// DXC has issue with unrolling certain part of the code. To address temporarly the warning-as-error issues, 
// we redefine the unroll function and fall back to loop on DXC
#if COMPILER_DXC == 1
#define STRATA_UNROLL LOOP
#define STRATA_UNROLL_N(X) LOOP
#else
#define STRATA_UNROLL UNROLL
#define STRATA_UNROLL_N(X) UNROLL_N(X)
#endif

uint PackStrataHeaderIn(uint BSDFCount, FStrataPixelHeader In);

// If this is changed, please update the compiler side material size evaluation in StrataMaterial.cpp
void PackStrataOut(
	RWByteAddressBuffer StrataBuffer, 
	FStrataAddressing StrataAddressing,
	FStrataPixelHeader StrataPixelHeader,
	FStrataData Strata,
	float3 V,
	inout bool bStrataSubsurfaceEnable,
	inout float3 EmissiveColor)
{
	bStrataSubsurfaceEnable = false;
	EmissiveColor = 0.0f;

	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;
	const float FullyRough = 1.0f;

	uint BSDFCount = 0;
	float3 Throughput = 1.0f;

	// We clamp the layer count to the maximum one according to our byte per pixel budget (removing the bottom layer first)
	Strata.LayerCount = STRATA_CLAMPED_LAYER_COUNT;

	// For each of the BSDF, we evaluated their combined weight/throughput according to the material operation performed (layering, mixing, etc.).
	int l;
	STRATA_UNROLL_N(STRATA_CLAMPED_LAYER_COUNT)
	for (l = 0; l < Strata.LayerCount; ++l)
	{
		float3 LayerThroughput = 0.0f;
		float3 LayerCoverage = 0.0f;

		const bool bTopLayer = l == 0;
		const bool bBottomLayer = l == (Strata.LayerCount - 1);

		STRATA_UNROLL
		for (int i = 0; i < Strata.Layers[l].BSDFCount; ++i)
		{
			// Sanitize BSDF in place before it is used and packed out to memory
			StrataSanitizeBSDF(Strata.Layers[l].BSDFs[i]);

			FStrataBSDF BSDF = Strata.Layers[l].BSDFs[i];
			const float3 BSDFCoverage = BSDF.Weight;
			const float  BSDFCoverageAvg = dot(BSDF.Weight,1.0f/3.0f);
			BSDFCount++;

			// STRATA_TODO apply the same normal transform as for the material
			float3x3 TangentBasis = StrataGetBSDFSharedBasis(StrataPixelHeader, BSDF, StrataAddressing);
			float3 N = TangentBasis[2];
			//N = normalize(N);

			BxDFContext ContextNoLight = (BxDFContext)0;
			const float3 FakeL = float3(0, 0, 1);
			Init(ContextNoLight, N, V, FakeL);

			switch (BSDF_GETTYPE(BSDF))
			{
			case STRATA_BSDF_TYPE_SLAB:
			{
				EmissiveColor += BSDF_GETEMISSIVE(BSDF) * Throughput;

				// We want simple volumetric only if the DMFP input is pluged in, otherwise we avoid storing the DFMP
				const bool bIsSimpleVolume = !bBottomLayer && BSDF_GETHASDMFP(Strata.Layers[l].BSDFs[i]);

				bStrataSubsurfaceEnable = bStrataSubsurfaceEnable || (BSDF_GETHASSSS(BSDF) && BSDFCoverageAvg > 0 && !bIsSimpleVolume);

				// By default, without coverage, the diffuse BSDF is completely opaque
				float3 BSDFThroughput = OpaqueBSDFThroughput;

				if (bIsSimpleVolume)
				{
					float3 ApproxFresnelForTransmittance = 0;
					// STRATA_TODO Fresnel throughput, Use a LUT, this is currently in progress and will be coming soon.
					// In the meantime, we use a simple approach to feed Fresnel function and compute an approximation of the general transmition/througput.
					const float SatNoV = saturate(ContextNoLight.NoV);
					const float VoH = SatNoV;
					const float NoL = SatNoV;
					const float3 BaseColor = SLAB_BASECOLOR(BSDF);
					const float  Metallic = SLAB_METALLIC(BSDF);
					const float3 F0 = ComputeF0(SLAB_SPECULAR(BSDF), BaseColor, Metallic);
					const float3 F90 = ComputeF90(F0, SLAB_EDGECOLOR(BSDF), Metallic);
					const bool bHasThinFilm = BSDF_GETHASTHINFILM(BSDF);
					BRANCH
					if (bHasThinFilm)
					{
						float ThinFilmIOR = SLAB_THINFILM_IOR(BSDF);
						float ThinFilmThickness = SLAB_THINFILM_THICKNESS(BSDF);
						ApproxFresnelForTransmittance = F_ThinFilm(SatNoV, NoL, VoH, F0, F90, ThinFilmIOR, ThinFilmThickness);
					}
					else
					{
						ApproxFresnelForTransmittance = F_Schlick(F0, F90, VoH);
					}

					EnableSlabBSDFSimpleVolumetric(Strata.Layers[l].BSDFs[i]);

					const float3 UnusedDiffuseColor = 0; // Unused when only trasmittance is needed
					FParticipatingMedia PM = StrataSlabCreateParticipatingMedia(UnusedDiffuseColor, SLAB_SSSDMFP(Strata.Layers[l].BSDFs[i]));
					const float DiffuseToVolumeBlend = StrataSlabDiffuseToVolumeBlend(PM);
					const FStrataSlabSingleScattering Result = StrataSlabSingleScattering(PM, dot(N,V));

					// Update the see-through throughput accoding to the medium transmittance
					BSDFThroughput = lerp(OpaqueBSDFThroughput, (1- ApproxFresnelForTransmittance) * Result.Transmittance, DiffuseToVolumeBlend);

					// Mark the BSDF has not having any SSS through post process.
					bStrataSubsurfaceEnable = false;
				}

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * BSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_SHEEN:
			{
				// STRATA_TODO Fresnel throughput, Use a LUT, this is currently in progress and will be coming soon.
				// In the meantime, we use a simple approach to feed Fresnel function and compute an approximation of the general transmition/througput.
				const float NoL = saturate(ContextNoLight.NoV);
				const float3 F0  = SHEEN_BASECOLOR(BSDF);
				const float3 ApproxFresnelForTransmittance = F_Schlick(F0, NoL);

				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * (1.0f - ApproxFresnelForTransmittance);
				break;
			}

			case STRATA_BSDF_TYPE_HAIR:
			{
				// Hair are considered opaque
				LayerCoverage	+= BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			case STRATA_BSDF_TYPE_SINGLELAYERWATER:
			{
				EmissiveColor += BSDF_GETEMISSIVE(BSDF) * Throughput;

				// Water is considered opaque, it has a custom process to simulate translucency
				LayerCoverage += BSDFCoverage;
				LayerThroughput += BSDFCoverage * OpaqueBSDFThroughput;
				break;
			}

			} // switch

			// Update the weights to take into account throughput towards the view from layers above
			Strata.Layers[l].BSDFs[i].Weight *= Throughput;
			
			// Notify that the BSDF is at the top for SSR to only affect reflection there and not on the lower layers
			BSDF_SETISTOPLAYER(Strata.Layers[l].BSDFs[i], bTopLayer ? 1 : 0);
		}

		// Take into account the non covered part for this layer and update throughput accordingly
		LayerThroughput += (1.0 - saturate(LayerCoverage)) * FullThroughput;

		// And combine this layer throughtput with he material throughput
		Throughput *= LayerThroughput;
	}

	// Now write out Strata data

	// 1. the header
	STRATA_STORE_UINT1(PackStrataHeaderIn(BSDFCount, StrataPixelHeader));
#if STRATA_INLINE_SHADING
	UNROLL
	for (uint i = 0; i < StrataPixelHeader.SharedNormals.NormalCount; ++i)
	{
		const uint BasisType = StrataGetSharedNormalType(StrataPixelHeader.SharedNormals.NormalTypes, i);
		if (BasisType == STRATA_BASIS_TYPE_NORMAL)
		{
			STRATA_STORE_UINT1(StrataPackNormal(StrataPixelHeader.SharedNormals.Normals[i]));
		}
		else // if (BasisType == STRATA_BASIS_TYPE_TANGENT)
		{
			STRATA_STORE_UINT1(StrataPackNormalAndTangent(StrataPixelHeader.SharedNormals.Normals[i], StrataPixelHeader.SharedNormals.Tangents[i]));
		}
	}
#endif

	// 2. the list of BSDFs
	BSDFCount = 0;
	STRATA_UNROLL_N(STRATA_CLAMPED_LAYER_COUNT)
	for (l = 0; l < Strata.LayerCount; ++l)
	{
		FStrataLayer Layer = Strata.Layers[l];

		STRATA_UNROLL
		for (int i = 0; i < Layer.BSDFCount; ++i)
		{
			FStrataBSDF BSDF = Layer.BSDFs[i];

			const uint GreyScaleWeight = StrataHasGreyScaleWeight(BSDF.Weight) ? 1 : 0;
			BSDF_SETGREYWEIGHT(BSDF, GreyScaleWeight);
			if (GreyScaleWeight > 0)
			{
				BSDF_SETWEIGHT10F(BSDF, Pack10F(BSDF.Weight.x));
				STRATA_STORE_UINT1(BSDF.State);
			}
			else
			{
				STRATA_STORE_UINT1(BSDF.State);
				STRATA_STORE_UINT1(PackR11G11B10F(BSDF.Weight));
			}

			const uint BSDFType = BSDF_GETTYPE(BSDF);
			switch (BSDF_GETTYPE(BSDF))
			{
			case STRATA_BSDF_TYPE_SLAB:
			{
				STRATA_STORE_UINT1(PackColorLinearToGamma2AlphaLinear(float4(SLAB_BASECOLOR(BSDF), SLAB_ROUGHNESSX(BSDF))));
				STRATA_STORE_UINT1(PackRGBA8(float4(SLAB_SPECULAR(BSDF), SLAB_METALLIC(BSDF), SLAB_ROUGHNESSY(BSDF), SLAB_HAZINESS(BSDF))));

				if (BSDF_GETHASEDGECOLOR(BSDF) || BSDF_GETHASTHINFILM(BSDF))
				{
					STRATA_STORE_UINT1(PackColorLinearToGamma2AlphaLinear(float4(SLAB_EDGECOLOR(BSDF), SLAB_THINFILM_THICKNESS(BSDF))));
				}

				const bool bIsSimpleVolume = BSDF_GETISSIMPLEVOLUME(BSDF);
				if (BSDF_GETHASSSS(BSDF) || bIsSimpleVolume)
				{
					if (BSDF_GETHASSSSPROFILE(BSDF) && !bIsSimpleVolume)
					{
						STRATA_STORE_UINT1(PackRGBA8(float4(SLAB_SSSPROFILEID(BSDF), SLAB_SSSPROFILERADIUSSCALE(BSDF), 0, 0)));
					}
					else
					{
						STRATA_STORE_UINT1(PackR11G11B10F(SLAB_SSSDMFP(BSDF)));
					}
				}

				// 8-16 bytes
			}
			break;
			case STRATA_BSDF_TYPE_SHEEN:
			{
				STRATA_STORE_UINT1(PackColorLinearToGamma2AlphaLinear(float4(SHEEN_BASECOLOR(BSDF), SHEEN_ROUGHNESS(BSDF))));
				// 4 bytes
			}
			break;
			case STRATA_BSDF_TYPE_HAIR:
			{
				STRATA_STORE_UINT1(PackColorLinearToGamma2AlphaLinear(float4(HAIR_BASECOLOR(BSDF), HAIR_ROUGHNESS(BSDF))));
				STRATA_STORE_UINT1(PackR11G11B10F(float3(HAIR_SCATTER(BSDF), HAIR_SPECULAR(BSDF), HAIR_BACKLIT(BSDF))));
				// 8 bytes
			}
			break;
			case STRATA_BSDF_TYPE_SINGLELAYERWATER:
			{
				STRATA_STORE_UINT1(PackColorLinearToGamma2AlphaLinear(float4(SLW_BASECOLOR(BSDF), 0.0f)));
				STRATA_STORE_UINT1(PackRGBA8(float4(SLW_METALLIC(BSDF), SLW_SPECULAR(BSDF), SLW_ROUGHNESS(BSDF), SLW_TOPMATERIALOPACITY(BSDF))));
			}
			break;
			}

			// Stop writing if above budget.
			BSDFCount++;
		}
	}
}

// Pack only strata header
uint PackStrataHeaderIn(uint InBSDFCount, FStrataPixelHeader InHeader)
{
	uint Out = 0;
	HEADER_SETBSDFCOUNT(Out, InBSDFCount);

#if STRATA_INLINE_SHADING
	HEADER_SETSHAREDNORMALCOUNT(Out, InHeader.SharedNormals.NormalCount);
	HEADER_SETSHAREDNORMALTYPE(Out, InHeader.SharedNormals.NormalTypes);
#endif

	HEADER_SETAO(Out, uint(InHeader.MaterialAO * 255.0f));

	HEADER_SETSKIPPRECSHADOWMASK(Out, InHeader.SkipPrecShadowMask ? 1u : 0u);
	HEADER_SETZEROPRECSHADOWMASK(Out, InHeader.ZeroPrecShadowMask ? 1u : 0u);
	HEADER_SETISSINGLELAYERWATER(Out, InHeader.IsSingleLayerWater ? 1u : 0u);
	return Out;
}

// Unpack only strata header
// If this is changed, please update the compiler side material size evaluation in StrataMaterial.cpp
FStrataPixelHeader UnpackStrataHeaderIn(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing)
{
	FStrataPixelHeader Out = InitialiseStrataPixelHeader();

	uint PackedHeader = 0;
	STRATA_LOAD_UINT1(PackedHeader);
	Out.BSDFCount    = HEADER_GETBSDFCOUNT(PackedHeader);
	uint NormalCount = HEADER_GETSHAREDNORMALCOUNT(PackedHeader);
	uint NormalTypes = HEADER_GETSHAREDNORMALTYPE(PackedHeader);

#if STRATA_INLINE_SHADING==0
	// Only keep the offset to the shared normal memory. We are going to load them on demand.
	Out.SharedNormalByteOffset = StrataAddressing.CurrentAddr;
	Out.StrataBuffer = StrataBuffer;
	Out.SharedNormalTypes = NormalTypes;

	// Now skip over the shared normal memory to be able to load the BSDF content
	StrataAddressing.CurrentAddr += NormalCount * StrataAddressing.ByteOffsetToNextUint;

	// And account for the space used by normal for the debug information
	StrataAddressing.ReadBytes += NormalCount * STRATA_PACKED_NORMAL_STRIDE_BYTES;
#endif

	Out.MaterialAO = float(HEADER_GETAO(PackedHeader)) * (1.0f / 255.0f);

	Out.SkipPrecShadowMask = HEADER_GETSKIPPRECSHADOWMASK(PackedHeader);
	Out.ZeroPrecShadowMask = HEADER_GETSKIPPRECSHADOWMASK(PackedHeader);
	Out.IsSingleLayerWater = HEADER_GETISSINGLELAYERWATER(PackedHeader);

	return Out;
}

bool IsStrataFastPathCompatible(in FStrataBSDF BSDF)
{
	return
		!BSDF_GETANISOTROPY(BSDF) &&
		!BSDF_GETHASSSS(BSDF) &&
		!BSDF_GETHASSSSPROFILE(BSDF) &&
		!BSDF_GETHASHAZINESS(BSDF) &&
		!BSDF_GETHASTHINFILM(BSDF) &&
		!BSDF_GETHASEDGECOLOR(BSDF) &&
		!BSDF_GETISSIMPLEVOLUME(BSDF);
}

void UnpackFastPathSlabBSDF(inout FStrataBSDF OutBSDF, uint2 PackedData01)
{
	float4 Data0 = UnpackColorGamma2ToLinearAlphaLinear(PackedData01.x);
	SLAB_BASECOLOR(OutBSDF)		= Data0.rgb;
	SLAB_EDGECOLOR(OutBSDF)		= 1.0f;
	SLAB_ROUGHNESSX(OutBSDF)	= Data0.a;

	float4 Data1 = UnpackRGBA8(PackedData01.y);
	SLAB_SPECULAR(OutBSDF)		= Data1.x;
	SLAB_METALLIC(OutBSDF)		= Data1.y;
	SLAB_ROUGHNESSY(OutBSDF)	= Data1.z;
	SLAB_HAZINESS(OutBSDF)		= Data1.w;
}

FStrataBSDF UnpackFastPathStrataBSDFIn(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing)
{
	FStrataBSDF OutBSDF = (FStrataBSDF)0;

	OutBSDF.State = StrataLoadUint1(StrataBuffer, StrataAddressing);

	// In the fast path the single slab BSDF is always on top so the weight must be grey scale.
	OutBSDF.Weight = Unpack10F(BSDF_GETWEIGHT10F(OutBSDF));

	// Now unpack the simple Slab BSDF
	uint DataX = StrataLoadUint1(StrataBuffer, StrataAddressing);
	uint DataY = StrataLoadUint1(StrataBuffer, StrataAddressing);
	UnpackFastPathSlabBSDF(OutBSDF, uint2(DataX, DataY));

	// Force a BSDF state to a single slab with isotropic specular, no subsurface scattering or any other options.
	// This is to help the compiler understand disabled path.
	BSDF_SETTYPE(OutBSDF, STRATA_BSDF_TYPE_SLAB);
	BSDF_SETHASEDGECOLOR(OutBSDF, 0);
	BSDF_SETANISOTROPY(OutBSDF, 0);
	BSDF_SETISTOPLAYER(OutBSDF, 1);
	BSDF_SETHASSSS(OutBSDF, 0);
	BSDF_SETHASSSSPROFILE(OutBSDF, 0);
	BSDF_SETHASHAZINESS(OutBSDF, 0);
	BSDF_SETHASTHINFILM(OutBSDF, 0);
	BSDF_SETISSIMPLEVOLUME(OutBSDF, 0);

	return OutBSDF;
}

// Unpack a single BSDF
// Note: All BSDF lobes needs to be unpack in a sequential manner since each BSDF has a variable footprint.
// If this is changed, please update the compiler side material size evaluation in StrataMaterial.cpp
FStrataBSDF UnpackStrataBSDFIn(ByteAddressBuffer StrataBuffer, inout FStrataAddressing StrataAddressing)
{
	FStrataBSDF OutBSDF = (FStrataBSDF)0;

	float DummyFloat = 0.0f;

	STRATA_LOAD_UINT1(OutBSDF.State);
	if (BSDF_GETGREYWEIGHT(OutBSDF))
	{
		OutBSDF.Weight = Unpack10F(BSDF_GETWEIGHT10F(OutBSDF));
	}
	else
	{
		StrataLoad_R11G11B10F(StrataBuffer, StrataAddressing, OutBSDF.Weight);
	}


	const uint BSDFType = BSDF_GETTYPE(OutBSDF);
	BSDF_SETTYPE(OutBSDF, BSDFType);
	switch (BSDFType)
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		uint DataX = StrataLoadUint1(StrataBuffer, StrataAddressing);
		uint DataY = StrataLoadUint1(StrataBuffer, StrataAddressing);
		UnpackFastPathSlabBSDF(OutBSDF, uint2(DataX, DataY));

		SLAB_EDGECOLOR(OutBSDF) = 1.0f;
		SLAB_THINFILM_THICKNESS(OutBSDF) = 0.0f;
		if (BSDF_GETHASEDGECOLOR(OutBSDF) || BSDF_GETHASTHINFILM(OutBSDF))
		{
			StrataLoad_ColorGamma2ToLinearAlphaLinear(StrataBuffer, StrataAddressing, SLAB_EDGECOLOR(OutBSDF), SLAB_THINFILM_THICKNESS(OutBSDF));
		}

		const bool bIsSimpleVolume = BSDF_GETISSIMPLEVOLUME(OutBSDF);
		if (BSDF_GETHASSSS(OutBSDF) || bIsSimpleVolume)
		{
			if (BSDF_GETHASSSSPROFILE(OutBSDF) && !bIsSimpleVolume)
			{
				float4 Data = UnpackRGBA8(StrataLoadUint1(StrataBuffer, StrataAddressing));
				SLAB_SSSPROFILEID(OutBSDF) = Data.r;
				SLAB_SSSPROFILERADIUSSCALE(OutBSDF) = Data.g;
			}
			else
			{
				StrataLoad_R11G11B10F(StrataBuffer, StrataAddressing, SLAB_SSSDMFP(OutBSDF));
			}

			// When loading Strata BSDF which have SSS enable, BaseColor and (optionally) Specular value can be overriden 
			// based on the SSS method used (screen space SSS / checherboarded screen space SSS / ...)
			#if STRATA_SSS_MATERIAL_OVERRIDE
			if (!bIsSimpleVolume)
			{
				const bool bChecker = CheckerFromPixelPos(StrataAddressing.PixelCoords);
				AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(SLAB_BASECOLOR(OutBSDF), SLAB_SPECULAR(OutBSDF), bChecker);
			}
			#endif
		}
	}
	break;
	case STRATA_BSDF_TYPE_SHEEN:
	{
		StrataLoad_ColorGamma2ToLinearAlphaLinear(StrataBuffer, StrataAddressing, SHEEN_BASECOLOR(OutBSDF), SHEEN_ROUGHNESS(OutBSDF));
	}
	break;
	case STRATA_BSDF_TYPE_HAIR:
	{
		StrataLoad_ColorGamma2ToLinearAlphaLinear(StrataBuffer, StrataAddressing, HAIR_BASECOLOR(OutBSDF), HAIR_ROUGHNESS(OutBSDF));
		StrataLoad_R11_G11_B10F(StrataBuffer, StrataAddressing, HAIR_SCATTER(OutBSDF), HAIR_SPECULAR(OutBSDF), HAIR_BACKLIT(OutBSDF));
		// 8 bytes
	}
	break;
	case STRATA_BSDF_TYPE_SINGLELAYERWATER:
	{
		StrataLoad_ColorGamma2ToLinearAlphaLinear(StrataBuffer, StrataAddressing, SLW_BASECOLOR(OutBSDF), DummyFloat);
		float4 Data = UnpackRGBA8(StrataLoadUint1(StrataBuffer, StrataAddressing));
		SLW_METALLIC(OutBSDF) = Data.x;
		SLW_SPECULAR(OutBSDF) = Data.y;
		SLW_ROUGHNESS(OutBSDF) = Data.z;
		SLW_TOPMATERIALOPACITY(OutBSDF) = Data.w;
		// 8 bytes
	}
	break;
	}

	return OutBSDF;
}
