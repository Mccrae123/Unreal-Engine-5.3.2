// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once



float3 StrataEnvironmentLighting(
	float2 BufferUV,
	FGBufferData GBuffer,
	float3 WorldPosition,
	float3 CameraToPixel,
	float3 V,
	float AmbientOcclusion,
	FStrataPixelBSDFs PixelBSDFs
	)
{
	float3 SkyLighting = 0;
	for (int i = 0; i < PixelBSDFs.BSDFCount; ++i)
	{
		FStrataBSDF BSDF = PixelBSDFs.BSDFs[i];
		const float3 BSDFThroughput = BSDF.Weight;

		float3 DiffuseAlbedo = 0.0f;
		float3 DiffuseNormal = 0.0f;

		float3 SpecularDirection = 0.0f;
		float3 SpecularWeight = 0.0f;
		float  SpecularSafeRoughness = 0.0f;

		switch (BSDF.BSDFType)
		{
		case STRATA_BSDF_TYPE_DIFFUSE_ON:
		case STRATA_BSDF_TYPE_DIFFUSE_CHAN:
		{
			DiffuseAlbedo = BSDF.Diffuse.Albedo;
			DiffuseNormal = BSDF.Diffuse.Normal;
		}
		break;
		case STRATA_BSDF_TYPE_DIELECTRIC:
		{
			BRANCH
			if (ReflectionStruct.SkyLightParameters.y > 0)
			{
				float F0 = DielectricIorToF0(BSDF.Dielectric.IOR);
				const float SafeRoughness = MakeRoughnessSafe(BSDF.Dielectric.Roughness.x);
				float a2 = Pow4(SafeRoughness);
				float Energy = 1.0f; // See EnergyNormalization

				const float3 N = BSDF.Dielectric.Normal;
				const float SatNoV = saturate(dot(N, V));
				float3 R = 2 * dot(V, N) * N - V;
				float3 EvalEnvBRDF = EnvBRDFApprox(F0, SafeRoughness, SatNoV);

				SpecularDirection = R;
				SpecularWeight = EvalEnvBRDF * BSDF.Dielectric.Tint;
				SpecularSafeRoughness = a2;
			}
		}
		break;
		case STRATA_BSDF_TYPE_CONDUCTOR:
		{
			BRANCH
			if (ReflectionStruct.SkyLightParameters.y > 0)
			{
				// See SpecularGGX, isotropic verion

				const float SafeRoughness = MakeRoughnessSafe(BSDF.Conductor.Roughness.x);
				float a2 = Pow4(SafeRoughness);
				float Energy = 1.0f; // See EnergyNormalization

				const float3 N = BSDF.Conductor.Normal;
				const float SatNoV = saturate(dot(N, V));
				float3 R = 2 * dot(V, N) * N - V;
				float3 EvalEnvBRDF = EnvBRDFApprox(BSDF.Conductor.Reflectivity, BSDF.Conductor.EdgeColor, SafeRoughness, SatNoV);

				SpecularDirection = R;
				SpecularWeight = EvalEnvBRDF;
				SpecularSafeRoughness = a2;
			}
		}
		break;
		case STRATA_BSDF_TYPE_VOLUME:
		{
			const float3 VolumeAlbedo = BSDF.Volume.Albedo;
			const float3 ExtinctionCoefficients = BSDF.Volume.Extinction;
			const float3 ScatteringCoefficients = VolumeAlbedo * ExtinctionCoefficients;
			const float3 AbsorptionCoefficients = ExtinctionCoefficients - ScatteringCoefficients;
			const float  Thickness = BSDF.Volume.Thickness;

			const float3 SafeExtinctionThreshold = 0.000001f;
			const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, ExtinctionCoefficients);

			const float SatNoV = saturate(dot(BSDF.Volume.SmoothSurfaceNormal, V));
			const float PathLength = Thickness / max(0.0001f, SatNoV);
			const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);
			const float3 NormLuminanceTransfert = 1.0f * ScatteringCoefficients;
			float3 NormLuminanceSingleScattering = (NormLuminanceTransfert - NormLuminanceTransfert * SafePathSegmentTransmittance) / SafeExtinctionCoefficients;

			// No phase function because the SH already contains integration of BSDF with respect to hemisphere. Incorrect but needed.
			DiffuseAlbedo = NormLuminanceSingleScattering;

			// STRATA_TODO: This is to fake some directionality. Have normal specified on the material as for MaterialX?
			DiffuseNormal = BSDF.Volume.SmoothSurfaceNormal;
		}
		break;
		}

		// Diffuse component
		if (any(DiffuseAlbedo > 0.0f))
		{
			// Apply bent normal if needed
			#if APPLY_SKY_SHADOWING
			{
				DiffuseNormal = UpsampleDFAO(BufferUV, GBuffer.Depth, DiffuseNormal); // Bent normal
			}
			#endif

			// Compute the common sky visibility factors
			FSkyLightVisibilityData SkyVisData = GetSkyLightVisibilityData(GBuffer, AmbientOcclusion, DiffuseNormal);

			// Finally sample the sky diffuse contribution (spherical harmonic, Lambert BRDF)
			float3 DiffuseLookup = GetSkySHDiffuse(DiffuseNormal) * View.SkyLightColor.rgb;			// STRATA_TODO compute SH coefficients for ON or Chan
			// And accumulate
			SkyLighting += BSDFThroughput * (SkyVisData.SkyDiffuseLookUpMul * DiffuseLookup + SkyVisData.SkyDiffuseLookUpAdd) * DiffuseAlbedo;
		}

		// Specular component
		if (any(SpecularWeight > 0.0f))
		{
			float SkyAverageBrightness = 1.0f;
			const float3 SpecularLuminance = GetSkyLightReflection(SpecularDirection, SpecularSafeRoughness, SkyAverageBrightness);

			SkyLighting += BSDFThroughput * SpecularLuminance * SpecularWeight * View.SkyLightColor.rgb * AmbientOcclusion;
		}

	}
#if USE_PREEXPOSURE
	SkyLighting *= View.PreExposure;
#endif
	return SkyLighting;
}


