// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

// Analytical lighting evaluation for strata material.
// Unpack BSDF on-the-fly
float4 StrataDeferredLighting(
	FDeferredLightData LightData,
	FGBufferData GBuffer,
	float3 V,
	float3 L,
	float3 ToLight,
	float LightMask,
	float SurfaceShadow,
	FRectTexture RectTexture,
	ByteAddressBuffer StrataDataBuffer,
	uint PixelStrataDataByteOffset)
{
	float4 Radiance = 0;


	float3 UglyIntegrationFactor = 0; // This is bad we need to make sure it is done the right way
	if (LightData.bRectLight)
	{
		FRect Rect = GetRect(ToLight, LightData);
		UglyIntegrationFactor = IntegrateLight(Rect, RectTexture);
	}
	else
	{
		FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
		UglyIntegrationFactor = IntegrateLight(Capsule, LightData.bInverseSquared);
	}

	FStrataPixelHeader Header = UnpackStrataHeaderIn(StrataDataBuffer, PixelStrataDataByteOffset);
	
	LOOP
	for (uint BSDFIndex = 0; BSDFIndex < Header.BSDFCount; ++BSDFIndex)
	{
		const FStrataBSDF BSDF = UnpackStrataBSDFIn(StrataDataBuffer, PixelStrataDataByteOffset);
		const float3 BSDFThroughput = BSDF.Weight;

		// Create the BSDF context
		FStrataBSDFContext StrataBSDFContext = StrataCreateBSDFContext(BSDF, V, L);

		// Compute some common factors
		const float3 DirLightBaseFactor = BSDFThroughput * LightData.Color * LightMask * SurfaceShadow * UglyIntegrationFactor;
		const float3 DirLightGeometryFactor = DirLightBaseFactor * StrataBSDFContext.SatNoL;

		// Evalaute the lighting coming from L
		FStrataEvaluateResult StrataEvaluate = StrataEvaluateBSDF(StrataBSDFContext);
		Radiance.rgb += StrataEvaluate.Value * DirLightGeometryFactor;
	}

	return Radiance;
}
