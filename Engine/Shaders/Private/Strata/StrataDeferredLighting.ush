// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../AreaLightCommon.ush"

struct FStrataLightIntegrationContext
{
	float3 IncidentRadianceNoShadow;
	float3 IncidentIrradianceNoShadow;	// Modified incident irradiance, based on custom are light integrator
	float3 OutgoingRadianceNoShadow;	// Continue the outgoing radiance if the BSDF evaluation/integration has been done with the custom area light integrator
	bool bEvaluateBSDF;					// True if the BSDF need to be evalued, false, if the integration has already been done
};

FStrataLightIntegrationContext StrataIniLightIntegrationContext()
{
	FStrataLightIntegrationContext Out;
	Out.bEvaluateBSDF = true;
	Out.OutgoingRadianceNoShadow = 0;
	Out.IncidentIrradianceNoShadow = 0;
	Out.IncidentRadianceNoShadow = 0;
	return Out;
}

// Preprocess area lights and handle custom BSDF integrator
// This computes the full area light x BSDF or precompute incident lighting & reweigth the BSDF parameters depending on the custom integrator type (LTC/MRP)
void StrataPreprocessAreaLightIntegration(
	in float3 ToLight,
	in FDeferredLightData LightData, 
	in FRectTexture RectTexture,
	inout FStrataBSDFContext BSDFContext,
	inout FStrataLightIntegrationContext Out)
{
	Out.bEvaluateBSDF = true;
	Out.OutgoingRadianceNoShadow = 0;

	// Special area lighting integration
	bool bIsValid = true;
	float Roughness = 0;
	StrataGetBSDFRoughness(BSDFContext.BSDF, Roughness);
	FAreaLightIntegrateContext LightContext;
	if (LightData.bRectLight)
	{
		FRect Rect = GetRect(ToLight, LightData);
		bIsValid = IsRectVisible(Rect);
		Out.bEvaluateBSDF = false;
		// No-visible rect light due to barn door occlusion
		LightContext = CreateRectIntegrateContext(Roughness, BSDFContext.N, BSDFContext.V, Rect, RectTexture);
	}
	else
	{
		FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
		LightContext = CreateCapsuleIntegrateContext(Roughness, BSDFContext.N, BSDFContext.V, Capsule, LightData.bInverseSquared);
	}

	// Special area light integrator for BSDF (opt-in)
	// bEvaluateBSDF: Indicates if the BSDF need to be evaluate at the end, or if the custom area light integration handles the BSDF evaluation
	if (bIsValid && IsAreaLight(LightContext.AreaLight) && StrataHasAreaLightIntegrator(BSDFContext.BSDF))
	{
		// Evaluate roughness / specular color
		float SafeRoughness0 = 0;
		float SafeRoughness1 = 0;
		float3 SpecularColor = 0;
		switch (BSDF_GETTYPE(BSDFContext.BSDF))
		{
			case STRATA_BSDF_TYPE_SLAB:
			{
				SafeRoughness0 = MakeRoughnessSafe(SLAB_ROUGHNESS0(BSDFContext.BSDF), View.MinRoughness);
				SafeRoughness1 = MakeRoughnessSafe(SLAB_ROUGHNESS1(BSDFContext.BSDF), View.MinRoughness);
				SpecularColor = ComputeF0(SLAB_REFLECTIVITY(BSDFContext.BSDF), SLAB_ALBEDO(BSDFContext.BSDF), SLAB_METALLIC(BSDFContext.BSDF));
			}
			break;
		}

		// Currently anistropic material don't support area lighting and will fallback on punctual lighting (that is a2Override == 0)
		const bool bAnistropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
		if (!bAnistropy)
		{
			// Evaluate area-light preintegration
			if (LightContext.AreaLight.bIsRect)
			{
				// Rect light uses LTC integrator, which computes the full BDSD x Area light integration. 
				// This is why there is no need to evaluate the BSDF. The result is stored into a local 
				// OutgoingRadianceNoShadow, which will be accumulated outside of this function
				Out.OutgoingRadianceNoShadow.rgb +=
					Out.IncidentRadianceNoShadow *
					RectGGXApproxLTC(SafeRoughness0, SpecularColor, BSDFContext.N, BSDFContext.V, LightContext.AreaLight.Rect, LightContext.AreaLight.Texture);
				Out.bEvaluateBSDF = false;
			}
			else
			{
				// Sphere/Tube/Disk light use MRP integrator, which:
				// 1. compute an energy rescaling factor (this is fold into the incident radiance)
				// 2. change the BSDF roughness
				// 3. compute a derived L 
				// Update the BSDF context with the new L (and derived data) with value coming from MRP integrator
				StrataUpdateBSDFContext(BSDFContext, LightContext.L);
				SphereMaxNoH(BSDFContext.Context, LightContext.AreaLight.SphereSinAlpha, true);
				BSDFContext.Context.NoV = saturate(abs(BSDFContext.Context.NoV) + 1e-5);

				// Update incident irradiance to add the energy rescaling to due MRP integration
				// The a2 override stored the overriden roughness, which will be used during the BSDF evaluation
				BSDFContext.a2Override = Pow4(SafeRoughness0);
				Out.IncidentIrradianceNoShadow =
					Out.IncidentRadianceNoShadow *
					EnergyNormalization(BSDFContext.a2Override, BSDFContext.Context.VoH, LightContext.AreaLight) *
					LightContext.AreaLight.FalloffColor * (LightContext.Falloff * LightContext.NoL);
				Out.bEvaluateBSDF = true;
			}
		}
	}
}

// Analytical lighting evaluation for strata material.
// Unpack BSDF on-the-fly
float4 StrataDeferredLighting(
	FDeferredLightData LightData,
	FGBufferData GBuffer,
	float3 V,
	float3 L,
	float3 ToLight,
	float LightMask,
	FShadowTerms ShadowTerms,
	FRectTexture RectTexture,
	ByteAddressBuffer StrataDataBuffer,
	uint PixelStrataDataByteOffset)
{
	FStrataPixelHeader StrataPixelHeader = UnpackStrataHeaderIn(StrataDataBuffer, PixelStrataDataByteOffset);
	
	float3 PreintegratedIndicentIrradiance = 0;
	if (LightData.bRectLight)
	{
		FRect Rect = GetRect(ToLight, LightData);
		PreintegratedIndicentIrradiance = IntegrateLight(Rect, RectTexture);
	}
	else
	{
		FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
		PreintegratedIndicentIrradiance = IntegrateLight(Capsule, LightData.bInverseSquared);
	}

	FLightAccumulator Out = (FLightAccumulator)0;

	LOOP
	for (uint BSDFIndex = 0; BSDFIndex < StrataPixelHeader.BSDFCount; ++BSDFIndex)
	{
		// Unpack BSDF data
		const FStrataBSDF BSDF = UnpackStrataBSDFIn(StrataDataBuffer, PixelStrataDataByteOffset);
		FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(StrataPixelHeader, BSDF, V, L);

		// Evaluate incident lighting & (optionally) precompute area light integration
		FStrataLightIntegrationContext IntegrationContext = StrataIniLightIntegrationContext();
		IntegrationContext.IncidentRadianceNoShadow   = LightData.Color * LightMask;
		IntegrationContext.IncidentIrradianceNoShadow = PreintegratedIndicentIrradiance * IntegrationContext.IncidentRadianceNoShadow * StrataBSDFProjectedSolidAngleFactor(BSDFContext);
		StrataPreprocessAreaLightIntegration(ToLight, LightData, RectTexture, BSDFContext, IntegrationContext);

		// Evaluate BSDF
		if (IntegrationContext.bEvaluateBSDF)
		{
			FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(BSDFContext, ShadowTerms);

			const float3 DiffusePathWeight		= BSDF.Weight * BSDFEvaluate.DiffusePathValue;
			const float3 SpecularPathWeight		= BSDF.Weight * BSDFEvaluate.SpecularPathValue;
			const float3 TransmissionPathWeight	= BSDF.Weight * BSDFEvaluate.TransmissionPathValue;

			const bool bNeedsSeparateSubsurfaceLightAccumulation = BSDFEvaluate.bSubsurface;

			LightAccumulator_AddSplit(Out, DiffusePathWeight,		SpecularPathWeight, DiffusePathWeight,		IntegrationContext.IncidentIrradianceNoShadow * ShadowTerms.SurfaceShadow,		bNeedsSeparateSubsurfaceLightAccumulation);
			LightAccumulator_AddSplit(Out, TransmissionPathWeight,	0.0f,				TransmissionPathWeight,	IntegrationContext.IncidentIrradianceNoShadow * ShadowTerms.TransmissionShadow,	bNeedsSeparateSubsurfaceLightAccumulation);
		}
		else
		{
			// STRATA_TODO Find a better solution for special of are lighting which handles specular path only, so we can hardcode weight.
			const float3 DiffuseRadiance  = 0;
			const float3 SpecularRadiance = 1;
			const bool bNeedsSeparateSubsurfaceLightAccumulation = false;

			LightAccumulator_AddSplit(Out, DiffuseRadiance,			SpecularRadiance,	DiffuseRadiance,		IntegrationContext.OutgoingRadianceNoShadow * ShadowTerms.SurfaceShadow,		bNeedsSeparateSubsurfaceLightAccumulation);
		}
	}

	const FDeferredLightingSplit SplitLighting = LightAccumulator_GetResultSplit(Out);
	const float4 OutRadiance = SplitLighting.SpecularLighting + SplitLighting.DiffuseLighting;
	return OutRadiance;
}