// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../AreaLightCommon.ush"

struct FStrataLightIntegrationContext
{
	float3 IncidentRadiance;
	float3 IncidentIrradiance;	// Modified incident irradiance, based on custom are light integrator
	float3 OutgoingRadiance;	// Continue the outgoing radiance if the BSDF evaluation/integration has been done with the custom area light integrator
	bool bEvaluateBSDF;			// True if the BSDF need to be evalued, false, if the integration has already been done
};

FStrataLightIntegrationContext StrataIniLightIntegrationContext()
{
	FStrataLightIntegrationContext Out;
	Out.bEvaluateBSDF = true;
	Out.OutgoingRadiance = 0;
	Out.IncidentIrradiance = 0;
	Out.IncidentRadiance = 0;
	return Out;
}

// Preprocess area lights and handle custom BSDF integrator
// This computes the full area light x BSDF or precompute incident lighting & reweigth the BSDF parameters depending on the custom integrator type (LTC/MRP)
void StrataPreprocessAreaLightIntegration(
	in float3 ToLight,
	in FDeferredLightData LightData, 
	in FRectTexture RectTexture,
	inout FStrataBSDFContext BSDFContext,
	inout FStrataLightIntegrationContext Out)
{
	Out.bEvaluateBSDF = true;
	Out.OutgoingRadiance = 0;

	// Special area lighting integration
	bool bIsValid = true;
	float Roughness = 0;
	StrataGetBSDFRoughness(BSDFContext.BSDF, Roughness);
	FAreaLightIntegrateContext LightContext;
	if (LightData.bRectLight)
	{
		FRect Rect = GetRect(ToLight, LightData);
		bIsValid = IsRectVisible(Rect);
		Out.bEvaluateBSDF = false;
		// No-visible rect light due to barn door occlusion
		LightContext = CreateRectIntegrateContext(Roughness, BSDFContext.N, BSDFContext.V, Rect, RectTexture);
	}
	else
	{
		FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
		LightContext = CreateCapsuleIntegrateContext(Roughness, BSDFContext.N, BSDFContext.V, Capsule, LightData.bInverseSquared);
	}

	// Special area light integrator for BSDF (opt-in)
	// bEvaluateBSDF: Indicates if the BSDF need to be evaluate at the end, or if the custom area light integration handles the BSDF evaluation
	if (bIsValid && IsAreaLight(LightContext.AreaLight) && StrataHasAreaLightIntegrator(BSDFContext.BSDF))
	{
		// Evaluate roughness / specular color
		float SafeRoughness0 = 0;
		float SafeRoughness1 = 0;
		float3 SpecularColor = 0;
		switch (BSDF_GETTYPE(BSDFContext.BSDF))
		{
			case STRATA_BSDF_TYPE_DIELECTRIC:
			{
				SafeRoughness0 = MakeRoughnessSafe(DIELECTRIC_ROUGHNESS0(BSDFContext.BSDF), View.MinRoughness);
				SafeRoughness1 = MakeRoughnessSafe(DIELECTRIC_ROUGHNESS1(BSDFContext.BSDF), View.MinRoughness);
				SpecularColor = DielectricIorToF0(DIELECTRIC_IOR(BSDFContext.BSDF)) * DIELECTRIC_TINT(BSDFContext.BSDF);
			}
			break;
			case STRATA_BSDF_TYPE_CONDUCTOR:
			{
				SafeRoughness0 = MakeRoughnessSafe(CONDUCTOR_ROUGHNESS0(BSDFContext.BSDF), View.MinRoughness);
				SafeRoughness1 = MakeRoughnessSafe(CONDUCTOR_ROUGHNESS1(BSDFContext.BSDF), View.MinRoughness);
				SpecularColor = CONDUCTOR_REFLECTIVITY(BSDFContext.BSDF);
			}
			break;
		}

		// Currently anistropic material don't support area lighting and will fallback on punctual lighting (that is a2Override == 0)
		const bool bAnistropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
		if (!bAnistropy)
		{
			// Evaluate area-light preintegration
			if (LightContext.AreaLight.bIsRect)
			{
				// Rect light uses LTC integrator, which computes the full BDSD x Area light integration. 
				// This is why there is no need to evaluate the BSDF. The result is stored into a local 
				// OutgoingRadiance, which will be accumulated outside of this function
				Out.OutgoingRadiance.rgb += 
					Out.IncidentRadiance * 
					RectGGXApproxLTC(SafeRoughness0, SpecularColor, BSDFContext.N, BSDFContext.V, LightContext.AreaLight.Rect, LightContext.AreaLight.Texture);
				Out.bEvaluateBSDF = false;
			}
			else
			{
				// Sphere/Tube/Disk light use MRP integrator, which:
				// 1. compute an energy rescaling factor (this is fold into the incident radiance)
				// 2. change the BSDF roughness
				// 3. compute a derived L 
				// Update the BSDF context with the new L (and derived data) with value coming from MRP integrator
				StrataUpdateBSDFContext(BSDFContext, LightContext.L);
				SphereMaxNoH(BSDFContext.Context, LightContext.AreaLight.SphereSinAlpha, true);
				BSDFContext.Context.NoV = saturate(abs(BSDFContext.Context.NoV) + 1e-5);

				// Update incident irradiance to add the energy rescaling to due MRP integration
				// The a2 override stored the overriden roughness, which will be used during the BSDF evaluation
				BSDFContext.a2Override = Pow4(SafeRoughness0);
				Out.IncidentIrradiance =
					Out.IncidentRadiance *
					EnergyNormalization(BSDFContext.a2Override, BSDFContext.Context.VoH, LightContext.AreaLight) *
					LightContext.AreaLight.FalloffColor * (LightContext.Falloff * LightContext.NoL);
				Out.bEvaluateBSDF = true;
			}
		}
	}
}

// Analytical lighting evaluation for strata material.
// Unpack BSDF on-the-fly
float4 StrataDeferredLighting(
	FDeferredLightData LightData,
	FGBufferData GBuffer,
	float3 V,
	float3 L,
	float3 ToLight,
	float LightMask,
	float SurfaceShadow,
	FRectTexture RectTexture,
	ByteAddressBuffer StrataDataBuffer,
	uint PixelStrataDataByteOffset)
{
	FStrataPixelHeader StrataPixelHeader = UnpackStrataHeaderIn(StrataDataBuffer, PixelStrataDataByteOffset);
	
	float3 PreintegratedIndicentIrradiance = 0;
	if (LightData.bRectLight)
	{
		FRect Rect = GetRect(ToLight, LightData);
		PreintegratedIndicentIrradiance = IntegrateLight(Rect, RectTexture);
	}
	else
	{
		FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
		PreintegratedIndicentIrradiance = IntegrateLight(Capsule, LightData.bInverseSquared);
	}

	FLightAccumulator Out = (FLightAccumulator)0;

	LOOP
	for (uint BSDFIndex = 0; BSDFIndex < StrataPixelHeader.BSDFCount; ++BSDFIndex)
	{
		// Unpack BSDF data
		const FStrataBSDF BSDF = UnpackStrataBSDFIn(StrataDataBuffer, PixelStrataDataByteOffset);
		FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(StrataPixelHeader, BSDF, V, L);

		// Evaluate incident lighting & (optionally) precompute area light integration
		FStrataLightIntegrationContext IntegrationContext = StrataIniLightIntegrationContext();
		IntegrationContext.IncidentRadiance = LightData.Color * LightMask * SurfaceShadow;
		IntegrationContext.IncidentIrradiance = PreintegratedIndicentIrradiance * BSDFContext.SatNoL * IntegrationContext.IncidentRadiance;
		StrataPreprocessAreaLightIntegration(ToLight, LightData, RectTexture, BSDFContext, IntegrationContext);

		// Evaluate BSDF
		if (IntegrationContext.bEvaluateBSDF)
		{
			FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(BSDFContext);

			const float3 DiffuseRadiance  = (BSDFEvaluate.PathType & STRATA_PATH_TYPE_DIFFUSE)  != 0 ? BSDF.Weight * BSDFEvaluate.Value : 0;
			const float3 SpecularRadiance = (BSDFEvaluate.PathType & STRATA_PATH_TYPE_SPECULAR) != 0 ? BSDF.Weight * BSDFEvaluate.Value : 0;

			float3 CommonFactor = IntegrationContext.IncidentIrradiance;
			const bool bNeedsSeparateSubsurfaceLightAccumulation = (BSDFEvaluate.PathType & STRATA_PATH_TYPE_SCATTER) != 0;
			LightAccumulator_AddSplit(Out, DiffuseRadiance, SpecularRadiance, DiffuseRadiance, CommonFactor, bNeedsSeparateSubsurfaceLightAccumulation);
		}
		else
		{
			
			// STRATA_TODO Find a better solution for special of are lighting which handles specular path only, so we can hardcode weight.
			const float3 DiffuseRadiance  = 0;
			const float3 SpecularRadiance = 1;

			float3 CommonFactor = IntegrationContext.OutgoingRadiance;
			const bool bNeedsSeparateSubsurfaceLightAccumulation = false;
			LightAccumulator_AddSplit(Out, DiffuseRadiance, SpecularRadiance, DiffuseRadiance, CommonFactor, bNeedsSeparateSubsurfaceLightAccumulation);
		}
	}

	const FDeferredLightingSplit SplitLighting = LightAccumulator_GetResultSplit(Out);
	const float4 OutRadiance = SplitLighting.SpecularLighting + SplitLighting.DiffuseLighting;
	return OutRadiance;
}