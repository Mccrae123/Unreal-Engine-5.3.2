// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once


#define FORWARD_PER_PIXEL_SHADING (FORWARD_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING || MATERIAL_SHADINGMODEL_SINGLELAYERWATER)


// Forward declarations
void GetVolumeLightingNonDirectional(float4 AmbientLightingVector, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting);
void GetVolumeLightingDirectional(float4 AmbientLightingVector, float3 DirectionalLightingVector, float3 WorldNormal, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting);


// Common function for forward lighting per pixel using light data
float3 StrataForwardLightingCommon(
	float Dither,
	FDeferredLightData LightData,
	float3 ToLight,
	float LightMask,
	float4 LightAttenuation,
	FRectTexture RectTexture,
	uint LightChannelMask,
	uint PrimitiveLightingChannelMask,
	float3 AbsoluteWorldPosition,
	float3 TranslatedWorldPosition,
	float SceneDepth,
	float3 BSDFColoredVisibility,
	float AmbientOcclusion,
	float3 IndirectOcclusion,
	FStrataPixelHeader StrataPixelHeader,
	FStrataBSDFContext StrataBSDFContext,
	inout bool bEvaluateHasBeenExecuted,
	inout FStrataEvaluateResult BSDFEvaluate)
{
	bEvaluateHasBeenExecuted = false;
	float3 Color = 0.0;

	if (LightMask > 0.0)
	{
		// Evaluate the ShadowTerm that can then be used when integrating the lighting
		FShadowTerms ShadowTerms = { AmbientOcclusion, 1.0, 1.0, InitHairTransmittanceData() };

		float4 PrecomputedShadowFactors = StrataPixelHeader.ZeroPrecShadowMask ? 0.0f : 1.0f;
	#if TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING
		PrecomputedShadowFactors.x = ComputeDirectionalLightStaticShadowing(AbsoluteWorldPosition).x;
	#else
		PrecomputedShadowFactors.x = 1;
	#endif

		const uint FakeShadingModelID = 0;
		const float FakeContactShadowOpacity = 1.0f;
		GetShadowTerms(SceneDepth, PrecomputedShadowFactors, FakeShadingModelID, FakeContactShadowOpacity,
			LightData, TranslatedWorldPosition, LightData.Direction, LightAttenuation, Dither, ShadowTerms);

		float Roughness = 0;
		StrataGetBSDFRoughness(StrataBSDFContext.BSDF, Roughness);
		FAreaLightIntegrateContext AreaLightContext = InitAreaLightIntegrateContext();
		BRANCH
		if (ShadowTerms.SurfaceShadow + ShadowTerms.TransmissionShadow > 0)
		{
			BSDFEvaluate = (FStrataEvaluateResult)0;

		#if NON_DIRECTIONAL_DIRECT_LIGHTING
			// See comment above about NON_DIRECTIONAL_DIRECT_LIGHTING
			//#error NON_DIRECTIONAL_DIRECT_LIGHTING encoutered in Strata (sanity check)
			// STRATA_TODO
		#else
			if (LightData.bRectLight)
			{
				FRect Rect = GetRect(ToLight, LightData);
				if (!IsRectVisible(Rect))
				{
					LightMask = 0.0f; // Rect light can be non visible due to barn door occlusion
				}
				AreaLightContext = CreateRectIntegrateContext(Roughness, StrataBSDFContext.N, StrataBSDFContext.V, Rect, RectTexture);

				// We must have the evaluate inside the if due to the rectlight texture: it must be now be ambiguous which texture is going ot be used.
				// After te compilation, a local resource must map to a unique global resource (the default or the actual rect light texture).
				BSDFEvaluate = StrataIntegrateBSDF(StrataBSDFContext, ShadowTerms, AreaLightContext);
				bEvaluateHasBeenExecuted = true;
			}
			else
			{
				FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
				AreaLightContext = CreateCapsuleIntegrateContext(Roughness, StrataBSDFContext.N, StrataBSDFContext.V, Capsule, LightData.bInverseSquared);

				BSDFEvaluate = StrataIntegrateBSDF(StrataBSDFContext, ShadowTerms, AreaLightContext);
				bEvaluateHasBeenExecuted = true;
			}

			FLATTEN
			if (LightChannelMask & PrimitiveLightingChannelMask)
			{
				float3 DiffuseLuminance = BSDFEvaluate.IntegratedDiffuseValue;
				float3 SpecularLuminance = BSDFEvaluate.IntegratedSpecularValue * LightData.SpecularScale;
				const float3 LightCommonMultiplier = LightData.Color * LightMask;
				Color += ((DiffuseLuminance + SpecularLuminance) * LightCommonMultiplier + BSDFEvaluate.EmissivePathValue) * BSDFColoredVisibility;
			}
		#endif
		}
	}

	return Color;
}

// This code should map to GetForwardDirectLightingSplit
float3 StrataForwardLighting(
	uint EyeIndex,
	float4 SvPosition,
	uint PrimitiveId,
	FBasePassInterpolantsVSToPS BasePassInterpolants,
	float3 AbsoluteWorldPosition,
	float3 TranslatedWorldPosition,
	float3 LightingPositionOffset,
	float SceneDepth,
	float2 ScreenUV,
	float3 V,
	float3 L,
	float3 IndirectOcclusion,
	FStrataPixelHeader StrataPixelHeader,
	FStrataData StrataData,
	inout float3 OutThroughput
	)
{
	uint2 PixelPos = uint2(SvPosition.xy);
	float Dither = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8);
	FStrataAddressing NullStrataAddressing = (FStrataAddressing)0;	// Fake unused in StrataCreateBSDFContext when using Forward inline shading

	const float OpaqueBSDFThroughput = 0.0f;
	const float FullThroughput = 1.0f;

	float3 Color = 0;
	OutThroughput = 1.0f;

	float4 DynamicShadowFactors = 1;
#if MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
	DynamicShadowFactors = GetForwardDynamicShadowFactors(ScreenUV);
#endif

	float SpecularScale = 1;
#if TRANSLUCENCY_ANY_VOLUMETRIC
	// No specular on volumetric translucency lighting modes
	SpecularScale = 0;
#endif

	uint PrimitiveLightingChannelMask = GetPrimitive_LightingChannelMask(PrimitiveId);

#if FORWARD_PER_PIXEL_SHADING
	// Create the common directional light data use for all layers
	const FDirectionalLightData DirectionalLightData = GetDirectionalLightData(EyeIndex);
	FRectTexture RectTexture = InitRectTexture(ForwardLightData.DummyRectLightSourceTexture);
	
	FDeferredLightData DirLightData = (FDeferredLightData)0;
	DirLightData.Color = DirectionalLightData.DirectionalLightColor;
	DirLightData.FalloffExponent = 0;
	DirLightData.Direction = DirectionalLightData.DirectionalLightDirection;
	DirLightData.DistanceFadeMAD = DirectionalLightData.DirectionalLightDistanceFadeMAD;
	DirLightData.bRadialLight = false;
	DirLightData.SpecularScale = SpecularScale;

	DirLightData.ShadowedBits = (DirectionalLightData.DirectionalLightShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
	// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
	DirLightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(DirectionalLightData.DirectionalLightShadowMapChannelMask);
	DirLightData.HairTransmittance = InitHairTransmittanceData();
	#if USE_HAIR_COMPLEX_TRANSMITTANCE
	//if (GBufferData.ShadingModelID == SHADINGMODELID_HAIR)
	//{
	DirLightData.HairTransmittance = 0.0;////  EvaluateDualScattering(GBufferData, -CameraVector, DirLightData.Direction);	// STRATA_TODO
	//}
	#endif

	// We want to force the directional light shadow when using water material to see shadow on the water. This could be an option later.
#if DISABLE_FORWARD_DIRECTIONAL_LIGHT_SHADOW
	float4 DirLightAttenuation = float4(1, 1, 1, 1);
#elif ((MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED) && !MATERIAL_SHADINGMODEL_SINGLELAYERWATER)
	float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(DirectionalLightData.DirectionalLightShadowMapChannelMask >> 4);
	float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);

	// In the forward shading path we can't separate per-object shadows from CSM, since we only spend one light attenuation channel per light
	// If CSM is enabled (distance fading to precomputed shadowing is active), treat all of our dynamic shadowing as whole scene shadows that will be faded out at the max CSM distance
	// If CSM is not enabled, allow our dynamic shadowing to coexist with precomputed shadowing
	float PerObjectShadowing = DirLightData.DistanceFadeMAD.y < 0.0f ? 1.0f : DynamicShadowing;
	float WholeSceneShadowing = DirLightData.DistanceFadeMAD.y < 0.0f ? DynamicShadowing : 1.0f;
		
	float4 DirLightAttenuation = float4(WholeSceneShadowing.xx, PerObjectShadowing.xx);
#else
	DirLightData.ShadowedBits = 1;
	DirLightData.ShadowMapChannelMask.x = 1;
	bool bUnused = false;
	float DirLightDynamicShadowFactor = ComputeDirectionalLightDynamicShadowing(AbsoluteWorldPosition, SceneDepth, bUnused);
			
#if VIRTUAL_SHADOW_MAP
	BRANCH
	if ( ForwardLightData.DirectionalLightVSM != INDEX_NONE )
	{
		FVirtualShadowMapSampleResult VirtualShadowMapSample = SampleVirtualShadowMap( ForwardLightData.DirectionalLightVSM, AbsoluteWorldPosition);
		DirLightDynamicShadowFactor *= VirtualShadowMapSample.ShadowFactor;
	}
#endif

	float4 DirLightAttenuation = float4(DirLightDynamicShadowFactor.x, DirLightDynamicShadowFactor.x, 1, 1);
#endif
#endif // FORWARD_PER_PIXEL_SHADING

	UNROLL
	for (int l = 0; l < StrataData.LayerCount; ++l)
	{
		float3 LayerThroughput = 0.0f;
		float3 LayerCoverage = 0.0f;

		const bool bTopLayer = l == 0;
		const bool bBottomLayer = l == (StrataData.LayerCount - 1);

		UNROLL
		for (int i = 0; i < StrataData.Layers[l].BSDFCount; ++i)
		{
			FStrataBSDF BSDF = StrataData.Layers[l].BSDFs[i];

			// Sanitize BSDF before it is used for forward shading
			StrataSanitizeBSDF(BSDF);

			BRANCH
			if(BSDF_GETTYPE(BSDF) == STRATA_BSDF_TYPE_SLAB)
			{
				// We want simple volumetric only if the DMFP input is pluged in, otherwise we avoid dealing with simple volumetric
				const bool bIsSimpleVolume = BSDF_GETHASDMFP(BSDF);
				if (bIsSimpleVolume)
				{
					EnableSlabBSDFSimpleVolumetric(BSDF);
				}
			}

			const float3 BSDFCoverage = BSDF.Coverage;
			const float3 BSDFColoredVisibility = OutThroughput * BSDFCoverage;

			// Create the BSDF context
			FStrataBSDFContext StrataBSDFContext = StrataCreateBSDFContext(StrataPixelHeader, BSDF, NullStrataAddressing, V, L);

			////
			//// Evaluate environment lighting
			////

			const float3 SkyLightCommonFactor = BSDFColoredVisibility * ResolvedView.SkyLightColor.rgb * IndirectOcclusion;
			if (UseBasePassSkylight > 0)
			{
				const bool bEnableSpecular = ReflectionStruct.SkyLightParameters.y > 0.0f;
				FStrataEnvLightResult StrataEnvLight = StrataEvaluateForEnvLight(StrataBSDFContext, bEnableSpecular);
				if (any(StrataEnvLight.DiffuseWeight > 0.0f))
				{
					Color += GetEffectiveSkySHDiffuse(StrataEnvLight.DiffuseNormal) * StrataEnvLight.DiffuseWeight * SkyLightCommonFactor;
				}
			#if FORWARD_PER_PIXEL_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME
				if (any(StrataEnvLight.SpecularWeight > 0.0f))
				{
					float SkyAverageBrightness = 1.0f;
					Color += GetSkyLightReflection(StrataEnvLight.SpecularDirection, StrataEnvLight.SpecularSafeRoughness, SkyAverageBrightness) * StrataEnvLight.SpecularWeight * SkyLightCommonFactor;
				}
			#endif
			}
			// STRATA_TODO  indirect lighting from GetPrecomputedIndirectLightingAndSkyLight

			////
			//// Evaluate environment lighting
			////

		#if TRANSLUCENCY_PERVERTEX_FORWARD_SHADING || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL || TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME
			float4 VolumeLighting;
			float3 InterpolatedLighting = 0;
			float3 InnerVolumeUVs;
			float3 OuterVolumeUVs;
			float FinalLerpFactor;
			ComputeVolumeUVs(AbsoluteWorldPosition, LightingPositionOffset, InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);

			FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(StrataBSDFContext);
			LayerThroughput += BSDFCoverage * BSDFEvaluate.Throughput;
		#endif

		#if TRANSLUCENCY_PERVERTEX_FORWARD_SHADING

			Color += (BasePassInterpolants.VertexDiffuseLighting * BSDFEvaluate.DiffuseColor + BSDFEvaluate.EmissivePathValue)* BSDFColoredVisibility;

		#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL

			GetVolumeLightingNonDirectional(float4(BasePassInterpolants.AmbientLightingVector, 1), BSDFEvaluate.DiffuseColor, InterpolatedLighting, VolumeLighting);
			Color += (InterpolatedLighting + BSDFEvaluate.EmissivePathValue) * BSDFColoredVisibility;

		#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL

			GetVolumeLightingDirectional(float4(BasePassInterpolants.AmbientLightingVector, 1), BasePassInterpolants.DirectionalLightingVector, StrataBSDFContext.N, BSDFEvaluate.DiffuseColor, InterpolatedLighting, VolumeLighting);
			Color += (InterpolatedLighting + BSDFEvaluate.EmissivePathValue) * BSDFColoredVisibility;

		#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL

			float4 AmbientLightingVector = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
			GetVolumeLightingNonDirectional(AmbientLightingVector, BSDFEvaluate.DiffuseColor, InterpolatedLighting, VolumeLighting);
			Color += (InterpolatedLighting + BSDFEvaluate.EmissivePathValue) * BSDFColoredVisibility;

		#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL || TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME

			float4 AmbientLightingVector = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
			float3 DirectionalLightingVector = GetDirectionalLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
			GetVolumeLightingDirectional(AmbientLightingVector, DirectionalLightingVector, StrataBSDFContext.N, BSDFEvaluate.DiffuseColor, InterpolatedLighting, VolumeLighting);
			Color += (InterpolatedLighting + BSDFEvaluate.EmissivePathValue) * BSDFColoredVisibility;

		#elif FORWARD_PER_PIXEL_SHADING

			////
			//// Evaluate Directional light
			////

			float3 DirLightL = DirLightData.Direction;	// Already normalized
			float3 ToDirLight = DirLightL;
			float DirLightMask = 1;
			if (DirLightData.bRadialLight)
			{
				DirLightMask = GetLocalLightAttenuation(AbsoluteWorldPosition, DirLightData, ToDirLight, DirLightL);
			}

			bool bEvaluateHasBeenExecuted = false;
			BRANCH
			if (DirectionalLightData.HasDirectionalLight)
			{
				uint LightChannelMask = DirectionalLightData.DirectionalLightShadowMapChannelMask >> 8;

				float DirectionalLightCloudShadow = 1.0f;
			#if NEEDS_BASEPASS_CLOUD_SHADOW_INTERPOLATOR
				DirectionalLightCloudShadow = BasePassInterpolants.VertexCloudShadow;
			#endif

				FStrataEvaluateResult BSDFEvaluate = (FStrataEvaluateResult)0;
				Color += StrataForwardLightingCommon(
					Dither,
					DirLightData,
					ToDirLight,
					DirLightMask,
					DirLightAttenuation,
					RectTexture,
					LightChannelMask,
					PrimitiveLightingChannelMask,
					AbsoluteWorldPosition,
					TranslatedWorldPosition,
					SceneDepth,
					BSDFColoredVisibility,
					1.0,
					IndirectOcclusion,
					StrataPixelHeader,
					StrataBSDFContext,
					bEvaluateHasBeenExecuted,
					BSDFEvaluate) * DirectionalLightCloudShadow;

				LayerThroughput += BSDFCoverage * BSDFEvaluate.Throughput;
			}

			BRANCH
			if(!bEvaluateHasBeenExecuted)
			{
				// Only update the throughput
				FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(StrataBSDFContext);
				LayerThroughput += BSDFCoverage * BSDFEvaluate.Throughput;
			}

			////
			//// Evaluate local lights
			////

		#if !DISABLE_FORWARD_LOCAL_LIGHTS && (FORWARD_SHADING || TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING) // Forbidden for Single Layer Water
			// Basic implementation for FORWARD_LOCAL_LIGHTS where local lights are reloaded per BSDF layer. It is fast by default when layer==1.

			uint GridIndex = ComputeLightGridCellIndex((uint2)((SvPosition.xy - ResolvedView.ViewRectMin.xy) * View.LightProbeSizeRatioAndInvSizeRatio.zw), SvPosition.w, EyeIndex);
			const FCulledLightsGridData CulledLightsGrid = GetCulledLightsGrid(GridIndex, EyeIndex);

			// Limit max to ForwardLightData.NumLocalLights.
			// This prevents GPU hangs when the PS tries to read from uninitialized NumCulledLightsGrid buffer
			const uint NumLocalLights = min(CulledLightsGrid.NumLocalLights, GetNumLocalLights(EyeIndex));

			LOOP
			for (uint LocalLightListIndex = 0; LocalLightListIndex < NumLocalLights; LocalLightListIndex++)
			{
				const FLocalLightData LocalLight = GetLocalLightData(CulledLightsGrid.DataStartIndex + LocalLightListIndex, EyeIndex);

				FDeferredLightData LightData = (FDeferredLightData)0;
				LightData.Position = LocalLight.LightPositionAndInvRadius.xyz;
				LightData.InvRadius = LocalLight.LightPositionAndInvRadius.w;
				LightData.Color = LocalLight.LightColorAndFalloffExponent.xyz;
				LightData.FalloffExponent = LocalLight.LightColorAndFalloffExponent.w;
				LightData.Direction = LocalLight.LightDirectionAndShadowMask.xyz;
				LightData.SpotAngles = LocalLight.SpotAnglesAndSourceRadiusPacked.xy;
				LightData.SourceRadius = LocalLight.SpotAnglesAndSourceRadiusPacked.z;
				LightData.SourceLength = f16tof32(asuint(LocalLight.SpotAnglesAndSourceRadiusPacked.w));
				LightData.Tangent = LocalLight.LightTangentAndSoftSourceRadius.xyz;
				LightData.SoftSourceRadius = LocalLight.LightTangentAndSoftSourceRadius.w;
				LightData.bInverseSquared = LightData.FalloffExponent == 0;
				LightData.bRadialLight = true;
				LightData.bSpotLight = LightData.SpotAngles.x > -2.0f;
				LightData.SpecularScale = SpecularScale;
				LightData.HairTransmittance = InitHairTransmittanceData();
			#if USE_HAIR_COMPLEX_TRANSMITTANCE
				//if (GBufferData.ShadingModelID == SHADINGMODELID_HAIR)
				//{
					LightData.HairTransmittance = 0.0;////  EvaluateDualScattering(GBufferData, -CameraVector, LightData.Direction);	// STRATA_TODO
				//}
			#endif

				// LightType=bits[17:16], LightingChannelMask=[15:8], DynShadowMask=[7:4] ShadowMapChannelMask=[3:0]
				uint LightTypeAndPackedShadowMapChannelMask = asuint(LocalLight.LightDirectionAndShadowMask.w);

				// TODO: currently LightType is ignored and the code always sets 'LightData.bRectLight' to false (initialization)
				//       but the light grid adds rect lights as well so this probably leads to artifacts.
				uint LightType = LightTypeAndPackedShadowMapChannelMask >> 16;

				LightData.ShadowedBits = (LightTypeAndPackedShadowMapChannelMask & 0xFF) != 0 ? 1 : 0;
				// Static shadowing uses ShadowMapChannel, dynamic shadows are packed into light attenuation using PreviewShadowMapChannel
				LightData.ShadowMapChannelMask = UnpackShadowMapChannelMask(LightTypeAndPackedShadowMapChannelMask);
				float4 PreviewShadowMapChannelMask = UnpackShadowMapChannelMask(LightTypeAndPackedShadowMapChannelMask >> 4);
				float DynamicShadowing = dot(PreviewShadowMapChannelMask, DynamicShadowFactors);
				float4 LightAttenuation = float4(1, 1, DynamicShadowing.x, DynamicShadowing.x);

				float3 L = LightData.Direction;	// Already normalized
				float3 ToLight = L;
				float LightMask = 1;
				if (LightData.bRadialLight)
				{
					LightMask = GetLocalLightAttenuation(AbsoluteWorldPosition, LightData, ToLight, L);
				}

				uint LightChannelMask = LightTypeAndPackedShadowMapChannelMask >> 8;

				bool bEvaluateHasBeenExecuted = false;
				FStrataEvaluateResult BSDFEvaluate = (FStrataEvaluateResult)0;
				Color += StrataForwardLightingCommon(
					Dither,
					LightData,
					ToLight,
					LightMask,
					LightAttenuation,
					RectTexture,
					LightChannelMask,
					PrimitiveLightingChannelMask,
					AbsoluteWorldPosition,
					TranslatedWorldPosition,
					SceneDepth,
					BSDFColoredVisibility,
					1.0,
					IndirectOcclusion,
					StrataPixelHeader,
					StrataBSDFContext,
					bEvaluateHasBeenExecuted,
					BSDFEvaluate);
			}

		#endif // !DISABLE_FORWARD_LOCAL_LIGHTS

		#endif // Lighting technique

			LayerCoverage	+= BSDFCoverage;
		}

		// Take into account the non covered part for this layer and update throughput accordingly
		LayerThroughput += (1.0 - saturate(LayerCoverage)) * FullThroughput;

		// And combine this layer throughtput with the full material throughput
		OutThroughput *= LayerThroughput;
	}
	return Color;
}


