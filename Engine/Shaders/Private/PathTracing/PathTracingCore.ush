// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#define RANDSEQ_UNROLL_SOBOL PATH_TRACER_USE_COMPACTION // unrolling sobol sampler is best when we can guarantee high occupancy

#define USE_PATH_TRACING_LIGHT_GRID	1

#include "../Common.ush"
#include "../PostProcessCommon.ush"
#include "../RectLight.ush"
#include "../RayTracing/RayTracingCommon.ush"

#include "PathTracingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"

#include "../ShadingModels.ush"
#include "./Utilities/PathTracingRandomSequence.ush"
#include "./Light/PathTracingLightSampling.ush"
#include "./Light/PathTracingLightGrid.ush"
#include "./Material/PathTracingMaterialSampling.ush"
#include "PathTracingCamera.ush"

float BlendFactor;
uint Iteration;
uint TemporalSeed;
uint MaxSamples;
uint MaxBounces;
uint MaxSSSBounces;

// 0: only Material sampling
// 1: only Light sampling
// 2: both Material and Light
uint MISMode;

uint ApproximateCaustics;
uint EnableCameraBackfaceCulling;
uint EnableDirectLighting;
uint EnableEmissive;
uint SamplerType;
uint VisualizeLightGrid;
float MaxPathIntensity;
float MaxNormalBias;
float FilterWidth;

RWTexture2D<float4> RadianceTexture;
RWTexture2D<float4> AlbedoTexture;
RWTexture2D<float4> NormalTexture;
RaytracingAccelerationStructure TLAS;
int3 TileOffset;
uint SceneVisibleLightCount;


void AccumulateRadiance(inout float3 TotalRadiance, float3 PathRadiance, bool bIsCameraRay)
{
	// User asked for path contributions to be clamped to reduce fireflies.
	// This puts an upper bound on variance within the pixel at the expense of bias
	float MaxPathRadiance = max3(PathRadiance.x, PathRadiance.y, PathRadiance.z);
	if (!bIsCameraRay && MaxPathRadiance > MaxPathIntensity)
	{
		// adjust sample while keeping color
		PathRadiance *= MaxPathIntensity / MaxPathRadiance;
	}

	// accumulate into the total
	TotalRadiance += PathRadiance;
}

FPathTracingPayload TraceTransparentRay(RayDesc Ray, FRayCone RayCone, bool bIsCameraRay, bool bLastBounce, bool bIncludeEmission, uint2 LaunchIndex, uint NumLights, float PathRoughness, inout RandomSequence RandSequence, inout float3 PathThroughput, inout float3 Radiance, inout float3 Albedo, inout float3 Normal)
{
	const uint RayFlags = bIsCameraRay && EnableCameraBackfaceCulling ? RAY_FLAG_CULL_BACK_FACING_TRIANGLES : 0;
	const uint MissShaderIndex = 0;
	float SelectionWeightSum = 0;
	float3 PayloadThroughput = PathThroughput;
	FPathTracingPayload Payload;
	if (!bIncludeEmission && bLastBounce)
	{
		Payload.SetMiss();
		PathThroughput = 0;
		return Payload;
	}
	for (;;)
	{
		// avoid double counting what was captured by the skylight
		// also avoid noise from hot spots (they can be properly
		// importance sampled if a capturing skylight is added)
		const bool bIgnoreSky = !bIsCameraRay;
		FPackedPathTracingPayload PackedPayload = InitPathTracingPayload(RayCone, LaunchIndex, bIgnoreSky);
		// Trace the ray
		TraceRay(
			TLAS,
			RayFlags,
			RAY_TRACING_MASK_ALL,
			RAY_TRACING_SHADER_SLOT_MATERIAL,
			RAY_TRACING_NUM_SHADER_SLOTS,
			MissShaderIndex,
			Ray,
			PackedPayload);

		// Loop over lights to capture their contribution
		// #dxr_todo: if we have lots of lights, having some hierarchical structure would be better ....
		for (uint LightId = 0; LightId < NumLights; ++LightId)
		{
			RayDesc LightRay = Ray;
			LightRay.TMax = PackedPayload.IsMiss() ? Ray.TMax : PackedPayload.HitT;
			float3 LightRadiance = TraceLight(LightRay, LightId).Radiance;
			AccumulateRadiance(Radiance, PathThroughput * LightRadiance, bIsCameraRay);
		}

		if (PackedPayload.IsMiss())
		{
			// Ray didn't hit any real geometry, so nothing left to do
			break;
		}

		// Unpack the payload
		FPathTracingPayload HitPayload = UnpackPathTracingPayloadMaterial(PackedPayload, Ray);

		if (HitPayload.BlendingMode == RAY_TRACING_BLEND_MODE_ADDITIVE ||
			HitPayload.BlendingMode == RAY_TRACING_BLEND_MODE_TRANSLUCENT)
		{
			// emission needs to be pre-multiplied by the opacity
			HitPayload.Radiance *= HitPayload.Opacity;
		}

		// add in surface emission (except for modulate blend mode which uses Radiance as the transparency multiplier)
		if (bIncludeEmission && HitPayload.BlendingMode != RAY_TRACING_BLEND_MODE_MODULATE)
		{
			AccumulateRadiance(Radiance, PathThroughput * HitPayload.Radiance, bIsCameraRay);
		}

		float3 Transparency = GetMaterialTransparency(HitPayload, Ray.Direction);

		if (!bLastBounce)
		{
			float3 Contrib = PathThroughput * EstimateMaterialAlbedo(HitPayload);

			// accumulate what the denoiser wants into albedo/normal (as long as the current path is rough enough)
			AccumulateAlbedoNormal(HitPayload, PathThroughput, PathRoughness, Albedo, Normal);

			float SelectionWeight = max3(Contrib.x, Contrib.y, Contrib.z);
			SelectionWeightSum += SelectionWeight;
			bool AcceptHit = false;

			// weighted reservoir sampling
			if (SelectionWeight > 0)
			{
				if (SelectionWeight < SelectionWeightSum)
				{
					// the acceptance probability is not 1.0
					// generate a random number to see if we should accept this hit
					float RandValue = RandomSequence_GenerateSample1D(RandSequence);
					AcceptHit = RandValue * SelectionWeightSum < SelectionWeight;
				}
				else
				{
					// accept automatically on the first hit
					AcceptHit = true;
				}
			}

			if (AcceptHit)
			{
				// stash this hit for next time
				Payload = HitPayload;
				PayloadThroughput = PathThroughput / SelectionWeight;
			}
		}

		// prepare next step around the loop
		// retrace the exact same ray with TMin one ulp past the hit we just found
		PathThroughput *= Transparency;
		Ray.TMin = asfloat(asuint(HitPayload.HitT) + 1);

		if (all(PathThroughput == 0))
		{
			break;
		}
	}

	if (SelectionWeightSum > 0)
	{
		// if we stored a valid hit in the payload, reset the path throughput to this point
		PathThroughput = PayloadThroughput * SelectionWeightSum;
	}
	else
	{
		PathThroughput = 0;
		Payload.SetMiss();
	}
	return Payload;
}

float3 TraceTransparentVisibilityRay(RayDesc Ray, uint2 PixelCoord, float PathRoughness)
{
	const uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
	const uint InstanceInclusionMask = RAY_TRACING_MASK_SHADOW;
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_SHADOW;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	FPackedPathTracingPayload PackedPayload = InitPathTracingVisibilityPayload(PixelCoord, PathRoughness);

	// Trace the ray
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray,
		PackedPayload);

	if (PackedPayload.IsMiss())
	{
		// we didn't hit any geo - just return whatever throughput is left
		return PackedPayload.GetRayThroughput();
	}

	// we registered a hit -- assumed to be fully opaque
	return 0;
}

struct FProbeResult
{
	float HitT;
	float3 WorldNormal;
	float3 WorldGeoNormal;
	int FrontFace;

	bool IsMiss() { return HitT <= 0; }
};

FProbeResult TraceProbeRay(RayDesc Ray, uint2 PixelCoord)
{
	// Trace a short ray to see if we escaped the surface
	FPackedPathTracingPayload PackedPayload = InitPathTracingPayload((FRayCone)0, PixelCoord, true);
	// TODO: use smaller payload + flag to skip shading work? (only want smooth+geo normals)
	//       however supporting blockers would require some shading ...
	const uint RayFlags = 0;
	const uint MissShaderIndex = 0;
	TraceRay(
		TLAS,
		RayFlags,
		RAY_TRACING_MASK_ALL,
		RAY_TRACING_SHADER_SLOT_MATERIAL,
		RAY_TRACING_NUM_SHADER_SLOTS,
		MissShaderIndex,
		Ray,
		PackedPayload);

	if (PackedPayload.IsMiss())
	{
		return (FProbeResult)0;
	}
	FPathTracingPayload Payload = UnpackPathTracingPayload(PackedPayload, Ray);
	FProbeResult Result;
	Result.HitT = PackedPayload.HitT;
	Result.WorldNormal = Payload.WorldNormal;
	Result.WorldGeoNormal = Payload.WorldGeoNormal;
	Result.FrontFace = Payload.IsFrontFace();
	return Result;
}

void ApplyRayBias(inout RayDesc Ray, float HitT, float3 Normal, bool ShadowTerminatorFix = false)
{
#if 1
	// Take maximum of position or hit distance to determine "radius" of hit avoidance
	const float RefValue = max(max(abs(Ray.Origin.x), abs(Ray.Origin.y)), max(abs(Ray.Origin.z), HitT));
	const uint UlpRadius = 16; // number of floating point ulps to skip around an intersection
	const float RelativeOffset = asfloat(asuint(RefValue) + UlpRadius) - RefValue;
	const float ShadowOffset = 0.1; // 1mm
	const float BaseOffset = 0.001; // 0.01mm (avoid precision issues very close to the origin where ulps become tiny)
	// for shadow rays, push out the point a bit more so we can reduce shadow terminator issues from poor tesselations
	// other rays are less likely to arrive at grazing angles, so don't need the extra offset
	Ray.Origin += max(ShadowTerminatorFix ? ShadowOffset : BaseOffset, RelativeOffset) * Normal;
#else
	ApplyPositionBias(Ray.Origin, Ray.Direction, Normal, MaxNormalBias);
#endif
}

bool ProcessSubsurfaceRandomWalk(inout FPathTracingPayload Payload, inout float3 PathThroughput, inout RandomSequence RandSequence, uint2 PixelCoord, bool SimplifySSS)
{
	if (!Payload.IsSubsurfaceMaterial())
	{
		// material doesn't have SSS
		// just return so we can process the rest of the payload's shading
		return true;
	}

	float3 SSSColor = Payload.GetSubsurfaceColor();
	float3 SSSRadius = Payload.GetSubsurfaceRadius();

	if (SimplifySSS || all(SSSRadius == 0) || all(SSSColor == 0) || MaxSSSBounces == 0)
	{
		// if we are running in a context that won't see the SSS directly -- just turn it into diffuse and skip the random walk
		// we can also skip random walk if the radius or color is 0
		// or if the user decided not to perform any SSS bounces
		Payload.DiffuseColor += SSSColor;
		Payload.DiffuseColor = saturate(Payload.DiffuseColor);
		Payload.SetSubsurfaceColor(0.0);
		return true;
	}
	SSSRadius = max(SSSRadius, 0.1); // 1mm minimum to make sure random walk can move forward and to keep SigmaT finite

	// decide randomly to evaluate the SSS part of the material, or keep shading the current part
	float SSSProb = LobeSelectionProb(SSSColor, Payload.DiffuseColor + Payload.SpecularColor);
	float3 RandSample = RandomSequence_GenerateSample3D(RandSequence);
	if (RandSample.x < SSSProb)
	{
		// do random walk
		PathThroughput *= 1 / SSSProb;
		RandSample.x /= SSSProb;
	}
	else
	{
		// skip random walk and shade current point instead
		PathThroughput *= 1 / (1 - SSSProb);
		return true;
	}

	// create ray to enter the surface (using a diffuse scattering event)
	RayDesc Ray;
	Ray.Origin = Payload.WorldPos;
	Ray.Direction = TangentToWorld(-CosineSampleHemisphere(RandSample.xy).xyz, Payload.WorldNormal);
	Ray.TMin = 0;
	ApplyRayBias(Ray, Payload.HitT, -Payload.WorldGeoNormal);

    // Use the technique mentioned in "A Hero Beneath the Surface" (Section 6.3.2)
	// https://jo.dreggn.org/home/2021_spectral_imaging.pdf
	// This allows multiple overlapping meshes to be treated as a single "volume" by discarding internal hits until we have
	// crossed the appropriate number of interfaces
#define SSS_USE_INTERFACE_COUNTING 1

	int InterfaceCounter = Payload.IsFrontFace() ? +1 : -1;

	// Use the technique detailed in the Hyperion paper (Section 4.4.2)
	// https://media.disneyanimation.com/uploads/production/publication_asset/177/asset/a.pdf
	// This avoids overly bright thin regions by applying a bit of internal reflection when the boundary is hit
#define SSS_USE_TIR 1


#if SSS_USE_TIR
	const float3 Albedo = 1 - exp(SSSColor * (-11.43 + SSSColor * (15.38 - 13.91 * SSSColor)));
#else
	// Van de-Hulst inverse mapping
	// https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf (Slide 44)
	// http://www.eugenedeon.com/project/a-hitchhikers-guide-to-multiple-scattering/ (Section 7.5.3 of v0.1.3)
	const float3 Albedo = 1 - Pow2(4.09712 + 4.20863 * SSSColor - sqrt(9.59217 + SSSColor * (41.6808 + 17.7126 * SSSColor)));
	SSSRadius *= 2.0; // roughly match parameterization above
#endif
	const int MAX_SSS_BOUNCES = MaxSSSBounces;
	const float3 SigmaT = 1.0 / SSSRadius;
	const float3 SigmaS = Albedo * SigmaT;
	for (int i = 0; i < MAX_SSS_BOUNCES; i++)
	{
		// TODO: add Dwivedi sampling for faster escape in low albedo media ...

		// Pick a color channel for transmittance sampling:
		float3 ColorChannelWeight = PathThroughput * Albedo;
		float3 ColorChannelCdf = float3(ColorChannelWeight.x,
			ColorChannelWeight.x + ColorChannelWeight.y,
			ColorChannelWeight.x + ColorChannelWeight.y + ColorChannelWeight.z);
		if (ColorChannelCdf.z == 0)
		{
			// no more energy left in the path
			break;
		}
		ColorChannelCdf.xy /= ColorChannelCdf.z;
		float3 ColorChannelPdf = float3(ColorChannelCdf.x, ColorChannelCdf.y - ColorChannelCdf.x, 1 - ColorChannelCdf.y);
		// pick a maximum distance to scatter
		const float OneMinusEpsilon = 0.99999994; // 32-bit float just before 1.0
		if (RandSample.z < ColorChannelCdf.x)
		{
			float RescaleRand = min(RandSample.z / ColorChannelPdf.x, OneMinusEpsilon);
			Ray.TMax = -log(1 - RescaleRand) * SSSRadius.x;
		}
		else if (RandSample.z < ColorChannelCdf.y)
		{
			float RescaleRand = min((RandSample.z - ColorChannelCdf.x) / ColorChannelPdf.y, OneMinusEpsilon);
			Ray.TMax = -log(1 - RescaleRand) * SSSRadius.y;
		}
		else
		{
			float RescaleRand = min((RandSample.z - ColorChannelCdf.y) / ColorChannelPdf.z, OneMinusEpsilon);
			Ray.TMax = -log(1 - RescaleRand) * SSSRadius.z;
		}
		for (;;)
		{
			FProbeResult ProbeResult = TraceProbeRay(Ray, PixelCoord);
			if (ProbeResult.IsMiss())
			{
				// we didn't hit anything, so scatter randomly in the volume and keep tracing
				RandSample = RandomSequence_GenerateSample3D(RandSequence);
				Ray.Origin += Ray.TMax * Ray.Direction;
				Ray.Direction = UniformSampleSphere(RandSample.xy).xyz;
				Ray.TMin = 0;
				// account for transmittance and scattering up to this point
				float3 Transmittance = exp(-Ray.TMax * SigmaT);
				PathThroughput *= SigmaS * Transmittance;
				// account for transmittance pdf (which is the balance heuristic combination of transmittance sampling in each color channel)
				float3 TransmittancePdf = SigmaT * Transmittance;
				PathThroughput /= dot(TransmittancePdf, ColorChannelPdf);

				// NOTE: phase function cancels out since it is being perfectly importance sampled

				// exit the Interface counting loop and keep scattering
				break;
			}
#if SSS_USE_INTERFACE_COUNTING
			// update counter
			InterfaceCounter += ProbeResult.FrontFace ? +1 : -1;
			if (InterfaceCounter != 0)
			{
				// we have not yet crossed the right number of interfaces, so ignore the current hit and try the segment again
				Ray.TMin = asfloat(asuint(ProbeResult.HitT) + 1);
			}
			else
#endif
			{
				// account for transmittance and scattering up to this point
				float3 Transmittance = exp(-ProbeResult.HitT * SigmaT);
				PathThroughput *= Transmittance;
				// account for transmittance pdf (which is the balance heuristic combination of transmittance sampling in each color channel)
				float3 TransmittancePdf = Transmittance; // integral of pdf from HitT to infinity
				PathThroughput /= dot(Transmittance, ColorChannelPdf);

				// our short ray hit the geomtry - decide if we should exit or not
#if SSS_USE_TIR
				RandSample = RandomSequence_GenerateSample2D(RandSequence).xxy;
				float3 WorldNormal = ProbeResult.WorldNormal;
				float CosTheta = abs(dot(Ray.Direction, WorldNormal));
				float Fresnel = FresnelReflectance(CosTheta, 1.0 / 1.4);
				if (RandSample.x < Fresnel)
				{
					// internal reflection occured -- reflect and keep tracing
					// NOTE: weight and probability cancel out, so no throughput adjustment is needed
					Ray.Origin += ProbeResult.HitT * Ray.Direction;
					Ray.Direction = reflect(Ray.Direction, WorldNormal);
					Ray.TMin = 0;
					ApplyRayBias(Ray, ProbeResult.HitT, ProbeResult.WorldGeoNormal);
					// Reset interface counter as if we had just entered the model (taking into account that we are seeing it from the opposite side now)
					InterfaceCounter = ProbeResult.FrontFace ? -1 : +1;
					// exit from the interface counting loop and keep scattering
					break;
				}
#endif
				// we hit the boundary! overwrite the current payload and exit the walk with a diffuse scattering event
				Payload.WorldPos = Ray.Origin + ProbeResult.HitT * Ray.Direction;
				Payload.WorldNormal = ProbeResult.WorldNormal;
				Payload.WorldGeoNormal = ProbeResult.WorldGeoNormal;
				// make sure normal is pointed outward from the object so we capture illumination from the exterior
				if (ProbeResult.FrontFace != Payload.IsFrontFace())
				{
					Payload.WorldNormal *= -1.0;
					Payload.WorldGeoNormal *= -1.0;
				}
				Payload.ShadingModelID = SHADINGMODELID_NUM; // invalid value so that we get diffuse shading
				Payload.BlendingMode = RAY_TRACING_BLEND_MODE_OPAQUE;
				Payload.BaseColor = 1;
				return true;
			}
		}
	}
	// we scattered a bunch of times and never hit anything -- give up
	return false;
}

uint2 Shuffle(uint2 Value, uint2 Seed)
{
	const uint M = PATHTRACER_COHERENT_TILE_SIZE;
#if 1
	// Scramble the MxM tile of pixels with an error-diffusion pattern
	// visualizing the seeds shows the distribution of seeds is slightly better
	const uint X = Value.x;
	const uint Y = Value.y;
	uint TileID = 0, HilbertState = 0;
	for (int i = PATHTRACER_COHERENT_TILE_SHIFT - 1; i >= 0; i--) {
		uint xi = (X >> i) & 1;
		uint yi = (Y >> i) & 1;
		uint Row = 8 * HilbertState + 4 * xi + 2 * yi;
		TileID = TileID * 4 + ((0x361E9CB4u >> Row) & 3);
		HilbertState = (0x8FE65831u >> Row) & 3;
	}
	uint SeedTile = StrongIntegerHash(Seed.x + StrongIntegerHash(Seed.y));
	uint SobolIndex = FastOwenScrambling(reversebits(TileID), SeedTile);
	uint SobolX = SobolIndex;
	uint SobolY = 0;
	for (uint v = 1; SobolIndex; SobolIndex >>= 1, v ^= v << 1)
	{
		SobolY ^= (SobolIndex & 1) * v;
	}
	return reversebits(uint2(SobolX, SobolY)) >> (32 - PATHTRACER_COHERENT_TILE_SHIFT);
#elif 1
	// randomly shuffle coordinate (x,y) within an RxR tile of pixels according to the given seed
	// this has a slight directional preference when visualizing seeds
	uint SeedTile = StrongIntegerHash(Seed.x + StrongIntegerHash(Seed.y));
	uint Index = Value.x + Value.y * M;
	uint ShuffledIndex = FastOwenScrambling(reversebits(Index), SeedTile) % (M * M);
	return uint2(ShuffledIndex % M, ShuffledIndex / M);
#else
	// no shuffling (just to show repeating artifacts)
	return Value;
#endif
}

uint2 Reorder(uint2 I, uint2 N)
{
	const uint M = PATHTRACER_COHERENT_TILE_SIZE;
	uint2 GroupId = I * M / N;				// [0, M)  - which group we landed in?
	uint2 GroupCoord = ((I * M) % N) / M;	// [0, N/M) - which pixel within the group?

	// reconstruct pixel coordinate, shuffling the assignment of pixels within a group to hide repeating structure
	return GroupCoord * M + Shuffle(GroupId, GroupCoord);
}

struct FPathState
{                                   // packed size
	uint2 PixelIndex;               //  4 bytes
	RandomSequence RandSequence;    //  8 bytes
	float3 Radiance;                // 12 bytes
	float3 Albedo;                  //  6 bytes // half precision
	float3 Normal;                  //  6 bytes // half precision
	RayDesc Ray;                    // 12+12 = 24 bytes (TMin/TMax do not need to be stored)
	FRayCone RayCone;               //  4 bytes // half precision
	float3 PathThroughput;          // 12 bytes
	float PathRoughness;            //  4 bytes
	                                // 80 bytes total

	void WritePixel(float BlendFactor)
	{
		// Avoid reading the old pixel on the first sample on the off-chance there is a NaN/Inf pixel ...
		float4 OldPixel = Iteration > 0 ? RadianceTexture[PixelIndex] : 0;
		float4 OldAlbedo = Iteration > 0 ? AlbedoTexture[PixelIndex] : 0;
		float4 OldNormal = Iteration > 0 ? NormalTexture[PixelIndex] : 0;
		float3 OldRadiance = OldPixel.rgb;
		float OldVariance = OldPixel.a;

		float3 NewRadiance = lerp(OldRadiance, Radiance, BlendFactor);

		float RadianceY = Luminance(Radiance);

		// https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm
		float DeviationSquared = (RadianceY - Luminance(NewRadiance)) * (RadianceY - Luminance(OldRadiance));
		float NewVariance = lerp(OldVariance, DeviationSquared, BlendFactor);

		RadianceTexture[PixelIndex] = float4(NewRadiance, NewVariance);
		AlbedoTexture[PixelIndex] = lerp(OldAlbedo, float4(Albedo, 0), BlendFactor);
		NormalTexture[PixelIndex] = lerp(OldNormal, float4(Normal, 0), BlendFactor);
	}
};

FPathState CreatePathState(uint2 DispatchIdx, uint2 DispatchDim)
{
	FPathState Output = (FPathState)0;

	Output.PixelIndex = DispatchIdx;
	if (SamplerType == PATHTRACER_SAMPLER_COHERENT)
	{
		// shuffle the pixels around so the ones that share a seed land in the same warp
		Output.PixelIndex = Reorder(Output.PixelIndex, DispatchDim);
	}
	Output.PixelIndex = Output.PixelIndex + TileOffset.xy;
	uint2 LaunchIndex = Output.PixelIndex + View.ViewRectMin.xy;

	// Initialize random sequence 

	uint2 RandPixel = SamplerType == PATHTRACER_SAMPLER_COHERENT
		? (DispatchIdx / PATHTRACER_COHERENT_TILE_SIZE)	// unique seed within small squares of the shuffled sub-images
		//? (DispatchIdx * PATHTRACER_COHERENT_TILE_SIZE) / DispatchDim // unique seed per sub-image
		: LaunchIndex; // unique seed per pixel
	if (SamplerType == PATHTRACER_SAMPLER_ERROR_DIFFUSION)
	{
		// z-sampler init
		RandomSequence_Initialize(Output.RandSequence, RandPixel, Iteration, TemporalSeed - Iteration, MaxSamples);
	}
	else
	{
		// random sobol init
		RandomSequence_Initialize(Output.RandSequence, RandPixel.x + RandPixel.y * 65536, TemporalSeed);
	}


	// Initialize ray and payload
	{
		uint2 Pixel;
		float EmitterPdf;
		SampleEmitter(LaunchIndex, Output.RandSequence, 0, 0, Output.Ray, Pixel, EmitterPdf);
	}

	Output.Ray.Direction = normalize(Output.Ray.Direction);

	Output.RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;

	// path state variables (these cary information between bounces)
	Output.PathThroughput = 1.0;
	Output.PathRoughness = 0;

	return Output;
}

float3 AdjustShadingNormal(float3 ShadingNormal, float3 GeoNormal, float3 RayDirection)
{
	// Clip shading normal in a view dependent way such that the reflection stays above the geometric normal
	// This introduces a bit of view-dependency to the shading normal but fixes dark artifacts around grazing angles

	float3 D = RayDirection;
	float3 R = reflect(D, ShadingNormal);

	// https://iquilezles.org/www/articles/dontflip/dontflip.htm
	float k = dot(R, GeoNormal);
	if (k < 0.0)
	{
		return normalize(normalize(R - k * GeoNormal) - D);
	}
	return ShadingNormal;
}


bool PathTracingKernel(inout FPathState PathState, int Bounce)
{
	// This array will hold a CDF for light picking
	float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM];

#if 0
	// visualize pixel seeds
	Radiance = HashToColor(StrongIntegerHash(RandPixel.x + StrongIntegerHash(RandPixel.y)));
	return false;
#endif
	const bool bIsCameraRay = Bounce == 0;
	const bool bIsLastBounce = Bounce == MaxBounces;
	const bool bIncludeEmissive = (EnableDirectLighting != 0 || Bounce > 1) &&
		(EnableEmissive != 0 || bIsCameraRay);

	// number of directly visible lights for the first bounce
	// after the first bounce, we don't need to include lights in the trace call
	// because NEE handled it for us
	uint NumVisibleLights = bIsCameraRay ? SceneVisibleLightCount : 0;

	FPathTracingPayload Payload = TraceTransparentRay(
		PathState.Ray,
		PathState.RayCone,
		bIsCameraRay,
		bIsLastBounce,
		bIncludeEmissive,
		PathState.PixelIndex,
		NumVisibleLights,
		PathState.PathRoughness,
		PathState.RandSequence,
		PathState.PathThroughput,
		PathState.Radiance,
		PathState.Albedo,
		PathState.Normal);

	if (Payload.IsMiss())
	{
		// we didn't hit anything selectable for further shading, we are done
		return false;
	}

	// fix dark edges in reflections from shading normals
	Payload.WorldNormal = AdjustShadingNormal(Payload.WorldNormal, Payload.WorldGeoNormal, PathState.Ray.Direction);

	// As soon as the path is blurry enough, we can get away with diffuse sampling only
	const bool bSimplifySSS = PathState.PathRoughness >= 0.15;

	if (ApproximateCaustics)
	{
		// modify the payload roughness to minimize difficult caustics
		// This is inspired by a trick used in the Arnold renderer:
		//   https://cgg.mff.cuni.cz/~jaroslav/gicourse2010/giai2010-02-marcos_fajardo-slides.pdf (slide 39)
		//   https://www.arnoldrenderer.com/research/Arnold_TOG2018.pdf (section 4.2)
		AdjustMaterialRoughness(Payload, PathState.PathRoughness);
	}

	// Processing the random walk will (stochastically) move the shading point elsewhere on the surface of the object
	if (!ProcessSubsurfaceRandomWalk(Payload, PathState.PathThroughput, PathState.RandSequence, PathState.PixelIndex, bSimplifySSS))
	{
		// random walk did not terminate at a valid point
		return false;
	}

	FLightLoopCount LightLoopCount = LightGridLookup(Payload.WorldPos);

	// visualize the # of lights
	if (VisualizeLightGrid)
	{
		PathState.Radiance = LightGridVisualize(LightLoopCount, VisualizeLightGrid);
		PathState.Radiance *= abs(dot(Payload.WorldNormal, PathState.Ray.Direction));
		PathState.Radiance /= View.PreExposure; // cancel out exposure
		return false;
	}

	// Choose a random number for both Light sampling and BxDF sampling
	float4 RandSample = RandomSequence_GenerateSample4D(PathState.RandSequence);

	// Does this material require NEE? (will be false if MaterialPdf is always +inf)
	const bool bIsNeeValid = IsNeeValidMaterial(Payload);

	const bool bDoLightLoop = EnableDirectLighting != 0 || Bounce > 0;

	float LightPickingCdfSum = 0;

	// If we are using Light sampling and the material can use it ...
	if (MISMode != 0 && bIsNeeValid && SceneLightCount > 0 && bDoLightLoop)
	{
		// Choose a light and sample it
		float3 WorldPos = Payload.WorldPos;
		float3 WorldNormal = Payload.WorldNormal;
		uint PrimitiveLightingChannelMask = Payload.PrimitiveLightingChannelMask;

		bool IsTransmissiveMaterial = ENABLE_TRANSMISSION && Payload.IsMaterialTransmissive();

		for (uint Index = 0, Num = LightLoopCount.NumLights; Index < Num; ++Index)
		{
			uint LightIndex = GetLightId(Index, LightLoopCount);
			LightPickingCdfSum += EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial);
			LightPickingCdf[Index] = LightPickingCdfSum;
		}

		if (LightPickingCdfSum > 0)
		{
			// init worked
			int LightId;
			float LightPickPdf = 0;

			SelectLight(RandSample.x * LightPickingCdfSum, LightLoopCount.NumLights, LightPickingCdf, LightId, LightPickPdf);
			LightPickPdf /= LightPickingCdfSum;

			LightId = GetLightId(LightId, LightLoopCount);
			FLightSample LightSample = SampleLight(LightId, RandSample.yz, WorldPos, WorldNormal);

			LightSample.RadianceOverPdf /= LightPickPdf;
			LightSample.Pdf *= LightPickPdf;
			if (LightSample.Pdf > 0)
			{
				if (CastsShadow(LightId))
				{
					// for transmissive materials, bias the position to the other side of the surface if the light is coming from behind
					const float SignedPositionBias = IsTransmissiveMaterial ? sign(dot(Payload.WorldGeoNormal, LightSample.Direction)) : 1.0;

					RayDesc LightRay;
					LightRay.Origin = WorldPos;
					LightRay.TMin = 0;
					LightRay.Direction = LightSample.Direction;
					LightRay.TMax = LightSample.Distance;
					ApplyRayBias(LightRay, Payload.HitT, SignedPositionBias * Payload.WorldGeoNormal, true);

					float AvgRoughness = ApproximateCaustics ? GetAverageRoughness(Payload) : 0.0;

					LightSample.RadianceOverPdf *= TraceTransparentVisibilityRay(LightRay, PathState.PixelIndex, AvgRoughness);
				}

				// #dxr_todo: Is it cheaper to fire the ray first? Or eval the material first?
				if (any(LightSample.RadianceOverPdf > 0))
				{
					// Evaluate material
					FMaterialEval MaterialEval = EvalMaterial(PathState.Ray.Direction, LightSample.Direction, Payload, false);

					// Record the contribution
					float3 LightContrib = PathState.PathThroughput * LightSample.RadianceOverPdf * MaterialEval.Weight * MaterialEval.Pdf;
					if (MISMode == 2)
					{
						LightContrib *= MISWeightRobust(LightSample.Pdf, MaterialEval.Pdf);
					}
					AccumulateRadiance(PathState.Radiance, LightContrib, bIsCameraRay);
				}
			}
		}
	}

	// Sample material
	FMaterialSample MaterialSample = SampleMaterial(PathState.Ray.Direction, Payload, RandSample, false);

	if (MaterialSample.Pdf < 0 || asuint(MaterialSample.Pdf) > 0x7F800000)
	{
		// Pdf became invalid (either negative or NaN)
		PathState.Radiance = float3(1, 0, 1);
		return false;
	}

	if (!(MaterialSample.Pdf > 0))
	{
		// No valid direction -- we are done
		return false;
	}

	float3 NextPathThroughput = PathState.PathThroughput * MaterialSample.Weight;
	if (!any(NextPathThroughput > 0))
	{
		// no energy left in this path
		return false;
	}

	// Russian roulette:
	//   The probability of keeping the path should be roughly proportional to the weight at the current shade point,
	//  but just using MaterialWeight would miss out on cases where the path throughput changes color (like in a cornell
	//  box when bouncing between walls of different colors). So use the ratio of the brightest color channel in the
	//  previous and next throughput.
	//   The second tweak is to add a sqrt() around the probability to soften the termination probability (paths will last
	//  a little longer). This allows paths to go a bit deeper than the naive heuristic while still allowing them to terminate
	//  early. This makes RR effective from the very first bounce without needing to delay it.
	float ContinuationProb = sqrt(saturate(max(NextPathThroughput.x, max(NextPathThroughput.y, NextPathThroughput.z)) / max(PathState.PathThroughput.x, max(PathState.PathThroughput.y, PathState.PathThroughput.z))));
	if (ContinuationProb < 1)
	{
		// If there is some chance we should terminate the ray, draw an extra random value
		float RussianRouletteRand = RandSample.w; // SampleMaterial does not use this value at the moment
		//RussianRouletteRand = RandomSequence_GenerateSample1D(RandSequence);
		if (RussianRouletteRand >= ContinuationProb)
		{
			// stochastically terminate the path
			return false;
		}
		PathState.PathThroughput = NextPathThroughput / ContinuationProb;
	}
	else
	{
		PathState.PathThroughput = NextPathThroughput;
	}

	// Update ray according to material sample
	PathState.Ray.Origin = Payload.WorldPos;
	PathState.Ray.Direction = MaterialSample.Direction;
	PathState.Ray.TMin = 0;
	PathState.Ray.TMax = POSITIVE_INFINITY;
	ApplyRayBias(PathState.Ray, Payload.HitT, MaterialSample.PositionBiasSign * Payload.WorldGeoNormal);

	// enlarge roughness based on the chosen lobe roughness
	PathState.PathRoughness = max(PathState.PathRoughness, MaterialSample.Roughness);

	// If we are using Material sampling for lights
	if (MISMode != 1 && bDoLightLoop)
	{
		// Check which lights can be seen by the material ray and trace a dedicated shadow ray
		// While it would be possible to just loop around and use the indirect ray to do this, it would prevent the application
		// of shadow ray specific logic for transparent shadows or various per light tricks like shadow casting
		const bool bUseMIS = MISMode == 2 && LightPickingCdfSum > 0;
		const float ShadowRayRoughness = ApproximateCaustics ? PathState.PathRoughness : 0.0;
		for (uint Index = 0, Num = LightLoopCount.NumMISLights; Index < Num; ++Index)
		{
			uint LightId = GetLightId(Index, LightLoopCount);
			if ((Payload.PrimitiveLightingChannelMask & GetLightingChannelMask(LightId)) == 0)
			{
				// light does not affect the current ray
				continue;
			}

			FLightHit LightResult = TraceLight(PathState.Ray, LightId);

			if (LightResult.IsMiss())
			{
				continue;
			}

			float3 LightContrib = PathState.PathThroughput * LightResult.Radiance;
			if (bUseMIS)
			{
				float PreviousCdfValue = Index > 0 ? LightPickingCdf[Index - 1] : 0.0;
				float LightPickPdf = (LightPickingCdf[Index] - PreviousCdfValue) / LightPickingCdfSum;

				LightContrib *= MISWeightRobust(MaterialSample.Pdf, LightResult.Pdf * LightPickPdf);
			}

			if (any(LightContrib > 0))
			{
				if (CastsShadow(LightId))
				{
					RayDesc LightRay = PathState.Ray;
					LightRay.TMax = LightResult.HitT;
					LightContrib *= TraceTransparentVisibilityRay(LightRay, PathState.PixelIndex, ShadowRayRoughness);
				}
				// the light made some contribution, and there was nothing along the shadow ray
				AccumulateRadiance(PathState.Radiance, LightContrib, bIsCameraRay);
			}
		}

	}

	// update ray cone for the next bounce
	PathState.RayCone = Payload.RayCone;

	// this path should continue bouncing
	return true;
}
