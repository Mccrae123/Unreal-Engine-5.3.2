// Copyright Epic Games, Inc. All Rights Reserved.

#define PATH_TRACING 1
#define ENABLE_SKY_LIGHT 1      
#define NEEDS_LIGHTMAP_COORDINATE 0
#ifdef NEEDS_VERTEX_FACTORY_INTERPOLATION
#undef NEEDS_VERTEX_FACTORY_INTERPOLATION
#endif
// Needed for VertexFactoryInterpolate to interpolate attributes from vertices to hit point
#define NEEDS_VERTEX_FACTORY_INTERPOLATION 1

// This should be good enough for path tracing and avoids having to bind an extra buffer
#define EYE_ADAPTATION_PREV_FRAME_EXPOSURE 1

// Ensure that SSS albedo comes through in the material
#define STRATA_SSS_MATERIAL_OVERRIDE 0

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/RayTracing/RayTracingHitGroupCommon.ush"
#include "/Engine/Private/PathTracing/PathTracingShaderUtils.ush"
#include "/Engine/Generated/Material.ush"   
#include "/Engine/Generated/VertexFactory.ush"

#include "/Engine/Private/RayTracing/RayTracingCalcInterpolants.ush"
#include "/Engine/Private/ShadingCommon.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "/Engine/Private/SubsurfaceProfileCommon.ush"
#include "/Engine/Private/BurleyNormalizedSSSCommon.ush"
#include "/Engine/Private/PathTracing/PathTracingCommon.ush"
#include "/Engine/Private/PathTracing/Material/PathTracingFresnel.ush"
#if STRATA_ENABLED
#define MATERIAL_STRATA_OPAQUE_PRECOMPUTED_LIGHTING 0
#include "/Engine/Private/Strata/StrataExport.ush"
#else
#include "/Engine/Private/PathTracing/Material/PathTracingThinGlass.ush"
#endif

float AdjustMaterialRoughness(float Roughness, float PathRoughness)
{
	// Modify the payload roughness to minimize difficult caustics
	// This is inspired by a trick used in the Arnold renderer:
	//   https://cgg.mff.cuni.cz/~jaroslav/gicourse2010/giai2010-02-marcos_fajardo-slides.pdf (slide 39)
	//   https://www.arnoldrenderer.com/research/Arnold_TOG2018.pdf (section 4.2)
	// NOTE: If approximate caustics are disabled, the path roughness passed in here will be 0.0 which effectively turns off this optimization
	return max(Roughness, PathRoughness);
}

float GetRefractionIor(FPixelMaterialInputs PixelMaterialInputs)
{
#if REFRACTION_ROOT_NODE_OVERRIDES_DEFAULT || STRATA_OPTIMIZED_UNLIT
	float Ior = GetMaterialRefractionIOR(GetMaterialRefraction(PixelMaterialInputs));
#else
	float3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
	float  Metallic = GetMaterialMetallic(PixelMaterialInputs);
	float  Specular = GetMaterialSpecular(PixelMaterialInputs);
	float3 F0 = ComputeF0(Specular, BaseColor, Metallic);
	float Ior = DielectricF0RGBToIor(F0);
#endif
	return Ior;
}

float3 DecodeSSSProfileRadius(uint ProfileId, float3 DiffuseColor, float Opacity)
{
	// Burley parameterization
	float3 SurfaceAlbedo = View.SSProfilesTexture.Load(int3(BSSS_SURFACEALBEDO_OFFSET, ProfileId, 0)).xyz;
	float3 DiffuseMeanFreePath = DecodeDiffuseMeanFreePath(View.SSProfilesTexture.Load(int3(BSSS_DMFP_OFFSET, ProfileId, 0))).xyz;
	float WorldUnitScale = DecodeWorldUnitScale(View.SSProfilesTexture.Load(int3(SSSS_TINT_SCALE_OFFSET, ProfileId, 0)).a) * BURLEY_CM_2_MM;

	// Opacity acts as a per-pixel radius multiplier
	// NOTE: this seems backwards? Opacity=0 acts like default-lit while Opacity=1 acts like SSS?
	// NOTE2: Confirm if this interpretation of opacity is correct ...
	float3 SSSRadius = GetMFPFromDMFPApprox(SurfaceAlbedo, DiffuseColor, Opacity * WorldUnitScale * DiffuseMeanFreePath);

	return SSSRadius * BURLEY_MM_2_CM;
}

float DecodeSSSProfileScatteringDistribution(uint ProfileId)
{
	float EncodedScatteringDistribution = View.SSProfilesTexture.Load(int3(SSSS_TRANSMISSION_OFFSET, ProfileId, 0)).z;
	return DecodeScatteringDistribution(EncodedScatteringDistribution);
}

RAY_TRACING_ENTRY_CLOSEST_HIT(PathTracingMaterialCHS,
	FPackedPathTracingPayload, PackedPayload,
	FRayTracingIntersectionAttributes, Attributes)
{
	PackedPayload.HitT = RayTCurrent();
#if MATERIALBLENDING_SOLID || MATERIALBLENDING_ALPHAHOLDOUT || (MATERIALBLENDING_MASKED && !MATERIAL_DITHER_OPACITY_MASK)
	if (PackedPayload.IsVisibilityRay())
	{
		// Shadow ray case -- all these blend modes get treated as fully opaque, so exit early.
		// In the case of Masked materials without dithered opacity, the masking logic was already handled by AHS.
		PackedPayload.SetRayThroughput(0.0);
		return;
	}
#endif
#if MATERIALBLENDING_ADDITIVE
	if (PackedPayload.IsVisibilityRay())
	{
		// should be fully invisible to shadow rays
		// this case should be caught by making the mesh invisible to shadows, but it doesn't cost too much to have this extra check here just in case that fails
		return;
	}
#endif
	ResolvedView = ResolveView();

	const float3 TranslatedWorldPosition = TranslatedWorldRayOrigin() + RayTCurrent() * WorldRayDirection();
	const float4 SvPosition = mul(float4(TranslatedWorldPosition, 1.0f), ResolvedView.TranslatedWorldToClip);

	CurrentPayloadInputFlags = PackedPayload.GetFlags();

#if USE_DBUFFER && MATERIAL_USES_DECAL_LOOKUP
	CurrentPayloadDBufferA = PackedPayload.GetDBufferA();
	CurrentPayloadDBufferB = PackedPayload.GetDBufferB();
	CurrentPayloadDBufferC = PackedPayload.GetDBufferC();
#endif

#if VF_SUPPORTS_RAYTRACING_PREPARE_MATERIAL_PIXEL_PARAMETERS
	// this is a newer codepath that is both more flexible and allows for more direct calculation compared to the other codepath
	// TODO: implement such a method for all vertex factories
	float3 GeoNormal = 0;
	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(TranslatedWorldRayOrigin(), WorldRayDirection(), RayTCurrent(), PrimitiveIndex(), Attributes, HitKind(), GeoNormal);
#else
	FVertexFactoryInterpolantsVSToPS Interpolants;
	float3 GeoNormal = 0;
	CalcInterpolants((FRayCone)0, Attributes, Interpolants, GeoNormal);

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Interpolants, SvPosition);
#endif

	FPixelMaterialInputs PixelMaterialInputs;

	const bool bIsFrontFace = HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE;
	{
		const float4 ScreenPosition = SvPositionToResolvedScreenPosition(SvPosition);
		MaterialParameters.CameraVector = -WorldRayDirection();
		CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
	}

	// the following blend modes need to process shadows after having executed the material
#if MATERIALBLENDING_MODULATE || (MATERIALBLENDING_MASKED && MATERIAL_DITHER_OPACITY_MASK) || MATERIALBLENDING_ALPHACOMPOSITE || MATERIALBLENDING_TRANSLUCENT
	if (PackedPayload.IsVisibilityRay())
	{
		// STRATA_TODO: Handle transparent shadows here ...
#if MATERIALBLENDING_MODULATE
		const float3 Transparency = GetMaterialEmissive(PixelMaterialInputs);
#elif MATERIALBLENDING_ALPHACOMPOSITE
		const float Opacity = GetMaterialOpacity(PixelMaterialInputs);
		const float Transparency = 1 - Opacity;
#elif MATERIALBLENDING_MASKED && MATERIAL_DITHER_OPACITY_MASK
		// See MATERIAL_DITHER_OPACITY_MASK comment below
		const float Opacity = saturate(GetMaterialMaskInputRaw(PixelMaterialInputs));
		const float Transparency = 1 - Opacity;
#elif MATERIALBLENDING_TRANSLUCENT
		const float Opacity = GetMaterialOpacity(PixelMaterialInputs);
#if MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT
		// We can only get colored shadows for thin translucent (solid translucent case happens via absorption only)
		float3 Transparency = 1 - Opacity;
#else
		float Transparency = 1 - Opacity;
#endif
		uint ShadingModelID = GetMaterialShadingModel(PixelMaterialInputs);

#if MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT
		if (ShadingModelID == SHADINGMODELID_THIN_TRANSLUCENT)
		{
			float3 Transmission = GetThinTranslucentMaterialOutput0(MaterialParameters);
#if REFRACTION_USE_INDEX_OF_REFRACTION
			float Ior = GetRefractionIor(PixelMaterialInputs);
#else
			float Ior = 0.0;
#endif
			float3 V = WorldRayDirection();
			float3 N = normalize(MaterialParameters.WorldNormal);
			float VoN = abs(dot(V, N));
			if (Opacity < 1.0)
			{
				float PathRoughness = PackedPayload.GetPathRoughness();
				float Roughness = GetMaterialRoughness(PixelMaterialInputs);
				if (Ior > 0.0 && PathRoughness <= Roughness)
				{
					// not using fast caustic approximation - treat as opaque
					PackedPayload.SetRayThroughput(0.0);
					return;
				}
				// compute transmission through the slab (fresnel + absorption)
				float3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
				float  Metallic = GetMaterialMetallic(PixelMaterialInputs);
				float  Specular = GetMaterialSpecular(PixelMaterialInputs);
				float  F0 = F0RGBToF0(ComputeF0(Specular, BaseColor, Metallic));
				Transparency *= ComputeThinSlabWeights(Transmission, VoN, Ior, F0).Transmitted;

				// fake caustic approximation (see comments below)
				if (Ior > 0.0)
				{
					Transparency *= (1 - Roughness * Roughness) * saturate(PathRoughness - Roughness);
				}
			}
		}
		else
#endif // MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT
#if MATERIAL_SHADINGMODEL_DEFAULT_LIT && REFRACTION_USE_INDEX_OF_REFRACTION
		if (ShadingModelID == SHADINGMODELID_DEFAULT_LIT)
		{
			// Is refraction enabled?
			float Ior = GetRefractionIor(PixelMaterialInputs);
			if (Transparency > 0 && Ior > 0.0)
			{
				// current hit has some refraction
				float PathRoughness = PackedPayload.GetPathRoughness();
				float Roughness = GetMaterialRoughness(PixelMaterialInputs);
				if (PathRoughness <= Roughness)
				{
					// not using fast caustic approximation - treat as opaque
					PackedPayload.SetRayThroughput(0.0);
					return;
				}
				// The heuristic used here is inspired by the following presentations:
				//   - Kulla & Conty: Revisiting Physically Based Shading at Imageworks
				//       https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf
				//   - Colin BarrÃ©-Brisebois - Pica Pica & Nvidia Turing
				//       https://www.ea.com/seed/news/siggraph-2018-picapica-nv-turing

				// fake caustics
				float3 N = normalize(MaterialParameters.WorldNormal);
				float Eta = Ior;
				float VoN = abs(dot(WorldRayDirection(), N));
				float3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
				float  Metallic = GetMaterialMetallic(PixelMaterialInputs);
				float  Specular = GetMaterialSpecular(PixelMaterialInputs);
				float  F0 = F0RGBToF0(ComputeF0(Specular, BaseColor, Metallic));
				float Fr = FresnelReflectance(VoN, Eta, F0);
				Transparency *= pow(1 - Fr, 2) * (1 - Roughness * Roughness) * saturate(PathRoughness - Roughness);

#if HAVE_GetAbsorptionMediumMaterialOutput0
				// Does the material have any kind of volumetric absorption to apply?
				// Now track the optical thickness so that we can account for Beer's law along the shadow ray
				// TODO: to support lights inside glass we would need to track an extra offset, but this is hopefully an uncommon scenario
				// TODO2: SingleLayerWater needs something similar, but it generally is setup with opaque or masked blend mode and water geometry does not cast shadows ...
				float Distance = RayTCurrent();
				float3 TransmittanceColor = GetAbsorptionMediumMaterialOutput0(MaterialParameters);
				float3 LocalSigmaT = PathTracingGlassTransmittanceToExtinction(TransmittanceColor);
				
				// Front Face: remove contribution from the ray origin to the current hit (assuming the backside will be hit)
				// Back Face:  add contribution from ray origin to current hit (backside) - excess portion not covered by the ray will be removed by the front face hit
				Distance *= bIsFrontFace ? -1.0 : +1.0;
				PackedPayload.SetTau(PackedPayload.GetTau() + LocalSigmaT * Distance);
#endif // HAVE_GetAbsorptionMediumMaterialOutput0
			}
		}
		else
#endif // MATERIAL_SHADINGMODEL_DEFAULT_LIT
		{
			// base case for shadingmodel if/else
		}
#else // MATERIALBLEINDG_*
#error Unhandled blending mode!
#endif

		// Update the ray throughput (it is packed simply into the payload since we don't need to carry any other information across hits)
		float3 RayThroughput = PackedPayload.GetRayThroughput();
		RayThroughput *= Transparency;
		PackedPayload.SetRayThroughput(RayThroughput);
		return;
	}
#endif

	FPathTracingPayload Payload = (FPathTracingPayload)0;

	/**
	 * Set common material attributes for both full and simplified materials
	 **/
	Payload.ShadingModelID = GetMaterialShadingModel(PixelMaterialInputs);

#if MATERIALBLENDING_ALPHACOMPOSITE
	Payload.BSDFOpacity = 1.0;
	Payload.TransparencyColor = 1.0 - GetMaterialOpacity(PixelMaterialInputs);
#elif MATERIALBLENDING_ALPHAHOLDOUT
	Payload.BSDFOpacity = GetMaterialOpacity(PixelMaterialInputs);
	Payload.TransparencyColor = 1.0 - GetMaterialOpacity(PixelMaterialInputs);
	Payload.SetHoldout();
	HLSL_STATIC_ASSERT(MATERIAL_SHADINGMODEL_UNLIT == 1, "Alpha holdout blend mode requires unlit shading model");
	Payload.ShadingModelID = SHADINGMODELID_UNLIT;
#elif MATERIALBLENDING_TRANSLUCENT
	Payload.BSDFOpacity = GetMaterialOpacity(PixelMaterialInputs);
	Payload.TransparencyColor = 1.0 - Payload.BSDFOpacity;
#elif MATERIALBLENDING_ADDITIVE
	Payload.BSDFOpacity = GetMaterialOpacity(PixelMaterialInputs);
	Payload.TransparencyColor = 1.0;
#elif MATERIALBLENDING_MODULATE
	Payload.BSDFOpacity = 0.0;
	Payload.TransparencyColor = GetMaterialEmissive(PixelMaterialInputs);
	HLSL_STATIC_ASSERT(MATERIAL_SHADINGMODEL_UNLIT == 1, "Modulate blend mode requires unlit shading model");
	Payload.ShadingModelID = SHADINGMODELID_UNLIT;
#elif MATERIALBLENDING_MASKED && MATERIAL_DITHER_OPACITY_MASK
	// dithering emulates real transparency, so switch to translucent
	// NOTE: the raster path technically takes into account the opacity mask clip value, so the effective transparency should be:
	//        saturate(MaskRaw - ClipValue + 0.5)
	// (See derivation in DitheredOpacityMaskToOpacity)
	// However this behavior is surprising to most users and does not exactly match the rasterizer anyway due to how the realtime AA
	// code performs blending.
	// Since the goal of dithered opacity is to emulate ordinary transparency, just use the mask input as opacity directly and
	// ignore the configured clip value.
	Payload.BSDFOpacity = saturate(GetMaterialMaskInputRaw(PixelMaterialInputs));
	Payload.TransparencyColor = 1.0 - Payload.BSDFOpacity;
#elif MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
	Payload.BSDFOpacity = 1.0;
	Payload.TransparencyColor = 0.0;
#else
#error Unknown material blending mode
#endif

	// fetch primitive flags only once
	// TODO: would be nice to keep this inside MaterialParameters as it is also needed there as well
	const uint PrimitiveFlags = GetPrimitiveData(MaterialParameters.PrimitiveId).Flags;

	Payload.PrimitiveLightingChannelMask = GetPrimitive_LightingChannelMask_FromFlags(PrimitiveFlags);

	Payload.HitT = RayTCurrent();
	if (HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE)
	{
		Payload.SetFrontFace();
	}

#if MATERIAL_IS_SKY
	if (!PackedPayload.IsCameraRay())
	{
		// avoid double counting what was captured by the skylight
		// also avoid noise from hot spots (they can be properly
		// importance sampled if a capturing skylight is added)
		PackedPayload = PackPathTracingPayload(Payload);
		return;
	}
#endif

	float GeoNormalSign = MaterialParameters.TwoSidedSign;
#if !VF_SUPPORTS_RAYTRACING_PREPARE_MATERIAL_PIXEL_PARAMETERS
	// Because the geometric normal is computed directly in world space
	// it doesn't reflect the sign flip from the object transform, so apply it here
	GeoNormalSign *= GetPrimitive_DeterminantSign_FromFlags(PrimitiveFlags);
#endif
	Payload.WorldGeoNormal = GeoNormalSign * GeoNormal;
	Payload.WorldSmoothNormal = MaterialParameters.TwoSidedSign * TransformTangentNormalToWorld(MaterialParameters.TangentToWorld, float3(0, 0, 1));
	Payload.WorldSmoothNormal = AdjustShadingNormal(Payload.WorldSmoothNormal, Payload.WorldGeoNormal, WorldRayDirection());


#if STRATA_ENABLED
	// unless proven otherwise, we are a basic unlit material
	Payload.ShadingModelID = SHADINGMODELID_UNLIT;

#if STRATA_OPTIMIZED_UNLIT
	FStrataBSDF UnlitBSDF = PixelMaterialInputs.GetFrontStrataData().InlinedBSDF;
	Payload.Radiance = BSDF_GETEMISSIVE(UnlitBSDF);
#if STRATA_OPAQUE_MATERIAL
	Payload.BSDFOpacity = 1;
	Payload.TransparencyColor = 0;
#else
	Payload.BSDFOpacity = UnlitBSDF.Coverage;
	Payload.TransparencyColor = 1 - Payload.BSDFOpacity; // STRATA_TODO: is this right?
#endif

#else // STRATA_OPTIMIZED_UNLIT

	// STRATA_TODO: Handle transparency blend modes ...
	Payload.BSDFOpacity = 1;
	Payload.TransparencyColor = 0;

	const float3 V_World = MaterialParameters.CameraVector;
	FStrataPixelHeader StrataPixelHeader = MaterialParameters.GetFrontStrataHeader();
	FStrataIntegrationSettings IntegrationSettings = InitStrataIntegrationSettings();
	FStrataAddressing NullStrataAddressing = (FStrataAddressing)0;	// Fake unused in StrataCreateBSDFContext when using Forward inline shading
	FStrataTree StrataTree = StrataPixelHeader.StrataTree;
	if (StrataTree.BSDFCount > 0)
	{
		StrataUpdateTree(NullStrataAddressing, StrataPixelHeader, StrataTree, V_World, IntegrationSettings);

	
		{
#if HAIR_STRAND_MESH_FACTORY
			Payload.WorldSmoothNormal = Payload.WorldGeoNormal;
#else
			// Nudge normal to avoid dark edges in bump
			// Not that we must recompute tangent vector to keep the basis frame orthogonal
			for (uint i = 0; i < StrataPixelHeader.SharedLocalBases.Count; ++i)
			{
				float3 N = normalize(StrataPixelHeader.SharedLocalBases.Normals[i]);
				float3 T = StrataPixelHeader.SharedLocalBases.Tangents[i];
				N = AdjustShadingNormal(N, Payload.WorldGeoNormal, WorldRayDirection());
				float3 B = normalize(cross(N, T)); // N and T are no longer orthogonal to each other, need to normalize
				StrataPixelHeader.SharedLocalBases.Normals[i]  = N;
				StrataPixelHeader.SharedLocalBases.Tangents[i] = cross(B, N); // no normalize needed here, will be orthogonal
				
			}
#endif
		}

#define BSDF StrataTree.BSDFs[BSDFIdx]

		// Accumulate radiance across all BSDFs
		Payload.Radiance = 0.0;
		for (int BSDFIdx = 0; BSDFIdx < StrataTree.BSDFCount; ++BSDFIdx)
		{
			Payload.Radiance += BSDF.LuminanceWeightV * BSDF_GETEMISSIVE(BSDF);
		}


#if STRATA_CLAMPED_BSDF_COUNT > 1
		// The material might be using more than one slab -- insert code to stochastically pick one 
		int BSDFIdx = 0;
		float SlabPdf = 1.0;
		if (StrataTree.BSDFCount > 1)
		{
			float SlabCDF[STRATA_CLAMPED_BSDF_COUNT];
			float SlabCDFSum = 0.0;
			for (BSDFIdx = 0; BSDFIdx < StrataTree.BSDFCount; ++BSDFIdx)
			{
				float Pdf = 0.0; // The goal is to predict the weight of each BSDF
				switch (BSDF_GETTYPE(BSDF))
				{
					case STRATA_BSDF_TYPE_SLAB:
					{
						const float3 WeightV = BSDF.LuminanceWeightV;
						const float3 TransmittanceN = BSDF.TransmittanceAboveAlongN;
						const float CoverageAboveAlongN = BSDF.CoverageAboveAlongN;
						const float3 MaxLobeWeight = WeightV * lerp(1.0f, TransmittanceN, CoverageAboveAlongN); // largest value LobeWeight() could return

						// accumulate visibility
						Payload.Radiance += WeightV * BSDF_GETEMISSIVE(BSDF);

						// Is the slab even visible at all?
						if (any(MaxLobeWeight > 0.0))
						{
							const float3 N = StrataPixelHeader.SharedLocalBases.Normals[BSDF_GETSHAREDLOCALBASISID(BSDF)];
							const float NoV = saturate(dot(N, V_World));

							float3 DiffuseColor = SLAB_DIFFUSEALBEDO(BSDF);
							float3 F0 = SLAB_F0(BSDF);
							float3 F90 = SLAB_F90(BSDF);
							{
								// make sure F0=0.0 fades off the specular lobe completely
								const float SpecularMicroOcclusion = F0RGBToMicroOcclusion(F0);
								F0 *= SpecularMicroOcclusion;
								F90 *= SpecularMicroOcclusion;
							}

							float Roughness0 = MakeRoughnessSafe(SLAB_ROUGHNESS(BSDF), PackedPayload.GetPathRoughness());
							float Roughness1 = Roughness0;
							float SpecBlend = 0.0;
							if (BSDF_GETHASHAZINESS(BSDF))
							{
								const FHaziness Haziness = UnpackHaziness(SLAB_HAZINESS(BSDF));
								// STRATA_TODO: Ideally clearcoat in the path tracer would be handled via actual layering rather than this backwards compatibility trick
								if (!Haziness.bSimpleClearCoat)
								{
									SpecBlend = Haziness.Weight;
									Roughness1 = MakeRoughnessSafe(Haziness.Roughness, PackedPayload.GetPathRoughness());
								}
							}
							float FuzzAmount = 0.0;
							float FuzzRoughness = 1.0;
							float3 FuzzColor = 0.0;
							if (BSDF_GETHASFUZZ(BSDF))
							{
								FuzzAmount = SLAB_FUZZ_AMOUNT(BSDF);
								FuzzColor = SLAB_FUZZ_COLOR(BSDF);
								FuzzRoughness = SLAB_FUZZ_ROUGHNESS(BSDF);
								FuzzRoughness = MakeRoughnessSafe(FuzzRoughness, STRATA_MIN_FUZZ_ROUGHNESS);
							}

							// STRATA_TODO: Support Fresnel82?
							const FBxDFEnergyTermsRGB Spec0 = ComputeGGXSpecEnergyTermsRGB(Roughness0, NoV, F0, F90);
							const FBxDFEnergyTermsRGB Spec1 = ComputeGGXSpecEnergyTermsRGB(Roughness1, NoV, F0, F90);
							const FBxDFEnergyTermsA   Fuzz  = ComputeClothEnergyTermsA(FuzzRoughness, NoV);
							const float3 SpecE = lerp(Spec0.E, Spec1.E, SpecBlend);
							const float FuzzAttenuation = 1.0 - FuzzAmount * Fuzz.E;
							const float DiffuseWeight = FuzzAttenuation * (1.0 - Luminance(SpecE));
							const float3 Spec0Albedo  = FuzzAttenuation * (1.0 - SpecBlend) * Spec0.E;
							const float3 Spec1Albedo  = FuzzAttenuation * (      SpecBlend) * Spec1.E;
							const float  FuzzAlbedo   = FuzzAmount * Fuzz.E;
							const float3 SlabAlbedo = MaxLobeWeight * (DiffuseWeight * DiffuseColor + Spec0Albedo + Spec1Albedo + FuzzAlbedo);
							Pdf = LobeColorToWeight(SlabAlbedo);
						}
						break;
					}
					default:
					{
						// In theory none of the other slab types can be layered
						break;
					}
				}
				SlabCDFSum += Pdf;
				SlabCDF[BSDFIdx] = SlabCDFSum;
			}
			if (SlabCDFSum > 0.0)
			{
				// linear search
				float PreviousCdfValue = 0;
				float RandSample = SlabCDFSum * PackedPayload.GetStochasticSlabRand();
				for (BSDFIdx = 0; BSDFIdx < StrataTree.BSDFCount - 1; ++BSDFIdx)
				{
					if (RandSample < SlabCDF[BSDFIdx])
					{
						break;
					}
					PreviousCdfValue = SlabCDF[BSDFIdx];
				}
				SlabPdf = (SlabCDF[BSDFIdx] - PreviousCdfValue) / SlabCDFSum;
			}
			else
			{
				BSDFIdx = 0;
				SlabPdf = 0.0;
			}
		}
		if (SlabPdf > 0)
		{
#elif STRATA_CLAMPED_BSDF_COUNT == 1
		if (StrataTree.BSDFCount > 0)
		{
			// there is only one slab active
			const int BSDFIdx = 0;
#else
// shouldn't be possible to reach this point
#error Unexpected BSDF Count
#endif // STRATA_CLAMPED_BSDF_COUNT 


			Payload.WorldNormal = StrataPixelHeader.SharedLocalBases.Normals[BSDF_GETSHAREDLOCALBASISID(BSDF)];
			Payload.WorldTangent = StrataPixelHeader.SharedLocalBases.Tangents[BSDF_GETSHAREDLOCALBASISID(BSDF)];

			switch (BSDF_GETTYPE(BSDF))
			{
				case STRATA_BSDF_TYPE_SLAB:
				{
					Payload.DiffuseColor      = SLAB_DIFFUSEALBEDO(BSDF);
					Payload.SpecularColor     = SLAB_F0(BSDF);
					Payload.SpecularEdgeColor = SLAB_F90(BSDF);
					Payload.RoughnessData.x   = MakeRoughnessSafe(SLAB_ROUGHNESS(BSDF), PackedPayload.GetPathRoughness());
					Payload.RoughnessData.y = Payload.RoughnessData.x;
					Payload.RoughnessData.z = 0;
					if (BSDF_GETHASHAZINESS(BSDF))
					{
						const FHaziness Haziness = UnpackHaziness(SLAB_HAZINESS(BSDF));
						// STRATA_TODO: detect this and use the old SHADINGMODELID_CLEARCOAT?
						if (!Haziness.bSimpleClearCoat)
						{
							Payload.RoughnessData.y = MakeRoughnessSafe(Haziness.Roughness, PackedPayload.GetPathRoughness());
							Payload.RoughnessData.z = Haziness.Weight;
						}
					}
					Payload.Anisotropy = BSDF_GETHASANISOTROPY(BSDF) ? SLAB_ANISOTROPY(BSDF) : 0.0;
					if (BSDF_GETHASFUZZ(BSDF))
					{
						Payload.FuzzAmount    = SLAB_FUZZ_AMOUNT(BSDF);
						Payload.FuzzColor     = SLAB_FUZZ_COLOR(BSDF);
						Payload.FuzzRoughness = MakeRoughnessSafe(SLAB_FUZZ_ROUGHNESS(BSDF), STRATA_MIN_FUZZ_ROUGHNESS);
					}
					else
					{
						Payload.FuzzAmount    = 0.0;
						Payload.FuzzColor     = 0.0;
						Payload.FuzzRoughness = 0.0;
					}
					if (BSDF_GETSSSTYPE(BSDF) == SSS_TYPE_DIFFUSION)
					{
						Payload.MeanFreePath = SLAB_SSSMFP(BSDF);
						Payload.PhaseG       = SLAB_SSSPHASEANISOTROPY(BSDF); // STRATA_TODO: evaluate if we always want this or not ...
					}
					else if (BSDF_GETSSSTYPE(BSDF) == SSS_TYPE_DIFFUSION_PROFILE)
					{
						const uint ProfileId = StrataSubsurfaceProfileIdTo8bits(SLAB_SSSPROFILEID(BSDF));
						const float Scale = SLAB_SSSPROFILERADIUSSCALE(BSDF);
						Payload.MeanFreePath = DecodeSSSProfileRadius(ProfileId, Payload.DiffuseColor, Scale);
						Payload.PhaseG = 0.0;
					}
					else
					{
						// STRATA_TODO: Do something meaningful for the other SSS types ...
						Payload.MeanFreePath = 0;
						Payload.PhaseG       = 0;
					}
					Payload.WeightV             = BSDF.LuminanceWeightV;
					Payload.TransmittanceN      = BSDF.TransmittanceAboveAlongN;
					Payload.CoverageAboveAlongN = BSDF.CoverageAboveAlongN;
					Payload.Ior                 = 0.0; // STRATA_TODO: figure out when to use refraction ...
					Payload.ShadingModelID      = SHADINGMODELID_STRATA;
					break;
				}
				case STRATA_BSDF_TYPE_HAIR:
				{
					// clamp the roughness to whatever came along the path
					Payload.SetBaseColor(HAIR_BASECOLOR(BSDF));
					Payload.SetHairLongitudinalRoughness(max(HAIR_ROUGHNESS(BSDF), PackedPayload.GetPathRoughness()));
					Payload.SetHairAzimuthalRoughness(HAIR_SCATTER(BSDF)); // STRATA_TODO: Map from scatter param to azimuthal roughness here instead of in the raygen
					Payload.SetHairSpecular(HAIR_SPECULAR(BSDF));

	#if HAIR_STRAND_MESH_FACTORY
					Payload.WorldSmoothNormal = Payload.WorldNormal = Payload.WorldGeoNormal;
					Payload.WorldTangent      = MaterialParameters.TangentToWorld[2];
					Payload.SetHairPrimitiveUV(MaterialParameters.HairPrimitiveUV);
	#else
					Payload.SetHairPrimitiveUV(0.5);
	#endif
					Payload.ShadingModelID = SHADINGMODELID_HAIR;
					break;
				}
				case STRATA_BSDF_TYPE_EYE:
				{
					Payload.DiffuseColor = EYE_DIFFUSEALBEDO(BSDF);
					Payload.SpecularColor = EYE_F0(BSDF);
					// NOTE: EYE_F90 is always 1.0 (does not exist in legacy model), so don't bother with it
					Payload.SetEyeRoughness(max(EYE_ROUGHNESS(BSDF), PackedPayload.GetPathRoughness()));

					if (BSDF_GETSSSTYPE(BSDF) == SSS_TYPE_DIFFUSION_PROFILE)
					{
						const uint ProfileId = StrataSubsurfaceProfileIdTo8bits(EYE_SSSPROFILEID(BSDF));
						Payload.MeanFreePath = DecodeSSSProfileRadius(ProfileId, Payload.DiffuseColor, 1.0);
						Payload.PhaseG = 0.0;
					}


					float IrisMask = EYE_IRISMASK(BSDF);
					float IrisDistance = EYE_IRISDISTANCE(BSDF);

					// see logic in non-substrate code below
					const float3 PlaneNormal = normalize(EYE_IRISPLANENORMAL(BSDF));
					const float3 CausticNormal = normalize(lerp(PlaneNormal, -Payload.WorldNormal, IrisMask * IrisDistance));

					Payload.SetEyeCausticNormal(CausticNormal);
					Payload.SetEyeIrisMask(IrisMask);
					Payload.SetEyeIrisNormal(normalize(EYE_IRISNORMAL(BSDF)));
					Payload.ShadingModelID = SHADINGMODELID_EYE;
					break;
				}
				default:
				{
					// STRATA_TODO: handle all other cases
					break;
				}
			}
#if STRATA_CLAMPED_BSDF_COUNT > 1
			// account for the probability of having chosen this slab
			Payload.BSDFOpacity /= SlabPdf;
#endif
		} // close brace opened by STRATA_CLAMPED_BSDF_COUNT > 1 or STRATA_CLAMPED_BSDF_COUNT == 1 ifdefs above
#undef  BSDF
	} // if BSDFCount > 0

#endif // STRATA_OPTIMIZED_UNLIT


#if MATERIAL_TWOSIDED == 0
	if (MaterialParameters.TwoSidedSign < 0)
	{
		// when viewing the surface from "inside", don't include emission
		Payload.Radiance = 0;
	}
#endif

#else // STRATA_ENABLED
	Payload.Radiance = GetMaterialEmissive(PixelMaterialInputs);

	Payload.WorldNormal = MaterialParameters.WorldNormal;
	Payload.WorldNormal = AdjustShadingNormal(Payload.WorldNormal, Payload.WorldGeoNormal, WorldRayDirection());

	// Store the results in local variables and reuse instead of calling the functions multiple times.
	half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
	half  Metallic = GetMaterialMetallic(PixelMaterialInputs);
	half  Specular = GetMaterialSpecular(PixelMaterialInputs);
	half Roughness = GetMaterialRoughness(PixelMaterialInputs);
	float Ior = 0.0;
#if MATERIALBLENDING_TRANSLUCENT && REFRACTION_USE_INDEX_OF_REFRACTION && (MATERIAL_SHADINGMODEL_DEFAULT_LIT || MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT)
	// NOTE: only default-lit and thin-translucent use ior, the other material models only support plain transparency
	// This is an attempt to limit the complexity of the material eval/sample API which must take into account an extra lobe if supporting refraction
	Ior = GetRefractionIor(PixelMaterialInputs);
#endif


	Payload.Radiance *= Payload.BSDFOpacity; // pre-multiply


#if MATERIAL_TWOSIDED == 0
	if (MaterialParameters.TwoSidedSign < 0)
	{
		// when viewing the surface from "inside", don't include emission
		Payload.Radiance = 0;
	}
#endif
	Payload.BaseColor = BaseColor;
	Payload.Specular = Specular;
	Payload.Metallic = Metallic;
	Payload.Roughness = Roughness;

#if MATERIAL_USES_ANISOTROPY
	Payload.WorldTangent = CalculateAnisotropyTangent(MaterialParameters, PixelMaterialInputs);
	Payload.Anisotropy = GetMaterialAnisotropy(PixelMaterialInputs);
#endif	

#if HAIR_STRAND_MESH_FACTORY
	Payload.WorldSmoothNormal = Payload.WorldNormal = Payload.WorldGeoNormal;
	Payload.WorldTangent = MaterialParameters.TangentToWorld[2];
#endif

#if MATERIAL_SHADINGMODEL_CLEAR_COAT
	if (Payload.ShadingModelID == SHADINGMODELID_CLEAR_COAT)
	{
		const float ClearCoat = GetMaterialCustomData0(MaterialParameters);
		const float ClearCoatRoughness = GetMaterialCustomData1(MaterialParameters);
		Payload.SetClearCoat(ClearCoat);
		Payload.SetClearCoatRoughness(AdjustMaterialRoughness(ClearCoatRoughness, PackedPayload.GetPathRoughness()));
#if CLEAR_COAT_BOTTOM_NORMAL
#if NUM_MATERIAL_OUTPUTS_CLEARCOATBOTTOMNORMAL > 0
#if MATERIAL_TANGENTSPACENORMAL
		float3 BottomNormal = normalize(TransformTangentVectorToWorld(MaterialParameters.TangentToWorld, ClearCoatBottomNormal0(MaterialParameters)));
#else
		float3 BottomNormal = ClearCoatBottomNormal0(MaterialParameters);
#endif
		
		// if we got a custom normal for the clearcoat, adjust it now
		BottomNormal = AdjustShadingNormal(BottomNormal, Payload.WorldGeoNormal, WorldRayDirection());
		Payload.SetClearCoatBottomNormal(BottomNormal);
#else
		Payload.SetClearCoatBottomNormal(Payload.WorldNormal);
#endif
#else
		Payload.SetClearCoatBottomNormal(Payload.WorldNormal);
#endif
		
	}
	else
#endif

#if MATERIAL_SHADINGMODEL_CLOTH
	if (Payload.ShadingModelID == SHADINGMODELID_CLOTH)
	{
		const float3 ClothColor = GetMaterialSubsurfaceData(PixelMaterialInputs).rgb;
		const float Fuzz = saturate(GetMaterialCustomData0(MaterialParameters));
		Payload.SetClothColor(ClothColor);
		Payload.SetClothAmount(Fuzz);
	}
	else
#endif

#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
	if (Payload.ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE)
	{
		const float3 SubsurfaceColor = GetMaterialSubsurfaceData(PixelMaterialInputs).rgb;
		Payload.SetSubsurfaceColor(SubsurfaceColor);
	}
	else
#endif

#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN
	if (Payload.ShadingModelID == SHADINGMODELID_SUBSURFACE ||
		Payload.ShadingModelID == SHADINGMODELID_PREINTEGRATED_SKIN)
	{
		const float3 SubsurfaceColor = GetMaterialSubsurfaceData(PixelMaterialInputs).rgb;
		Payload.SetSubsurfaceColor(SubsurfaceColor);

#if HAVE_GetSubsurfaceMediumMaterialOutput0
		Payload.SetSubsurfaceRadius(GetSubsurfaceMediumMaterialOutput0(MaterialParameters));
#else
		// TODO: is this accurate enough? hard to measure exactly since the raster path uses a very different approach
		const float Opacity = GetMaterialOpacity(PixelMaterialInputs);
		const float SSSRadius = (1 - Opacity) * 10.0; // simple formula, up to 10cm radius
		Payload.SetSubsurfaceRadius(SSSRadius);
#endif

#if HAVE_GetSubsurfaceMediumMaterialOutput1
		float ScatteringDistribution = clamp(GetSubsurfaceMediumMaterialOutput1(MaterialParameters), -0.99f, 0.99f);
		Payload.SetSubsurfacePhaseFunction(ScatteringDistribution);
#else
		Payload.SetSubsurfacePhaseFunction(0.0);
#endif
	}
	else
#endif
#if MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE
	if (Payload.ShadingModelID == SHADINGMODELID_SUBSURFACE_PROFILE)
	{
		const uint ProfileId = ExtractSubsurfaceProfileInt(GetMaterialSubsurfaceDataRaw(PixelMaterialInputs).a);

		// Decode dual roughness info
		float Lobe0Roughness = 0;
		float Lobe1Roughness = 0;
		float LobeMix = 0;

		// NOTE: we pass 1.0 for opacity because we don't really want to fade-out the dual roughness as opacity is lowered
		GetSubsurfaceProfileDualSpecular(ProfileId, Payload.Roughness, 1.0, Lobe0Roughness, Lobe1Roughness, LobeMix);

		Lobe0Roughness = AdjustMaterialRoughness(Lobe0Roughness, PackedPayload.GetPathRoughness());
		Lobe1Roughness = AdjustMaterialRoughness(Lobe1Roughness, PackedPayload.GetPathRoughness());
		Payload.SetDualRoughnessSpecular(Lobe0Roughness, Lobe1Roughness, LobeMix);

#if HAVE_GetSubsurfaceMediumMaterialOutput0
		Payload.SetSubsurfaceRadius(GetSubsurfaceMediumMaterialOutput0(MaterialParameters));
#else
		if (GetSubsurfaceProfileUseBurley(ProfileId))
		{
			// Decode SSS radius
			const float Opacity = GetMaterialOpacity(PixelMaterialInputs);
			const float3 DiffuseColor = Payload.BaseColor * (1.0 - Payload.Metallic);
			Payload.SetSubsurfaceRadius(DecodeSSSProfileRadius(ProfileId, DiffuseColor, Opacity));
		}
		else
		{
			Payload.SetSubsurfaceRadius(0.0);
		}
#endif

#if HAVE_GetSubsurfaceMediumMaterialOutput1
		float ScatteringDistribution = clamp(GetSubsurfaceMediumMaterialOutput1(MaterialParameters), -0.99f, 0.99f);
		Payload.SetSubsurfacePhaseFunction(ScatteringDistribution);
#else
		Payload.SetSubsurfacePhaseFunction(0.0);
#endif
	}
	else
#endif
#if MATERIAL_SHADINGMODEL_SINGLELAYERWATER
	if (Payload.ShadingModelID == SHADINGMODELID_SINGLELAYERWATER)
	{
#if STRATA_INLINE_SINGLELAYERWATER
		SanitizeStrataSingleLayerWater(MaterialParameters.StrataTree.BSDFs[0]);
		FStrataBSDF SLWBSDF = MaterialParameters.StrataTree.BSDFs[0];
		const float3 Albedo = SLW_WATERALBEDO(SLWBSDF);
		const float3 ExtinctionCoeff = SLW_WATEREXTINCTION(SLWBSDF);
		const float3 ScatteringCoeff = Albedo * ExtinctionCoeff;
		const float3 AbsorptionCoeff = max(0.0, ExtinctionCoeff - ScatteringCoeff);
		const float PhaseG = SLW_WATERPHASEG(SLWBSDF);

		const float3 WaterExtinction = ScatteringCoeff + AbsorptionCoeff;
		const float3 WaterAlbedo = ScatteringCoeff / WaterExtinction;
#else
		// For single layer water we always want to treat it as front facing when evaluating parameters 
		// as hitting back face is treated as being underwater and we get completely different parameters.
		FMaterialPixelParameters WaterMaterialParameters = MaterialParameters;
		WaterMaterialParameters.TwoSidedSign = 1; 

		const float3 ScatteringCoeff = max(0.0f, LWCToFloat(GetSingleLayerWaterMaterialOutput0(WaterMaterialParameters)));
		const float3 AbsorptionCoeff = max(0.0f, LWCToFloat(GetSingleLayerWaterMaterialOutput1(WaterMaterialParameters)));
		const float PhaseG = clamp(LWCToFloat(GetSingleLayerWaterMaterialOutput2(WaterMaterialParameters)), -0.99f, 0.99f);

		const float3 WaterExtinction = ScatteringCoeff + AbsorptionCoeff;
		const float3 WaterAlbedo = ScatteringCoeff / WaterExtinction;
#endif

		Payload.ShadingModelID = SHADINGMODELID_DEFAULT_LIT; // replace shading model to avoid extra cases in raygen
		Payload.BaseColor = WaterAlbedo; // TODO: unused at the moment
		Payload.SetExtinction(WaterExtinction);
		Payload.Ior = DielectricF0ToIor(DielectricSpecularToF0(Specular));
		// we are using actual refraction, so don't apply any transparency
		Payload.TransparencyColor = 0.0;
		Payload.BSDFOpacity = 0.0; // only shade with the glass portion
	}
	else
#endif

#if MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT
	if (Payload.ShadingModelID == SHADINGMODELID_THIN_TRANSLUCENT)
	{
		const float3 TransmittanceColor = GetThinTranslucentMaterialOutput0(MaterialParameters);
		Payload.SetTransmittanceColor(TransmittanceColor);
		Payload.Ior = Ior;
		if (Ior > 0.0)
		{
			// In this mode we get rough refraction, so don't apply any transparency
			Payload.TransparencyColor = 0.0;
		}
		else
		{
			// In this mode we just get straight transparency
			const float3 V = WorldRayDirection();
			const float3 N = normalize(Payload.WorldNormal);
			const float VoN = abs(dot(V, N));
			const float3 BaseColor = Payload.BaseColor;
			const float  Metallic = Payload.Metallic;
			const float  Specular = Payload.Specular;
			const float  F0 = F0RGBToF0(ComputeF0(Specular, BaseColor, Metallic));
			Payload.TransparencyColor = (1 - Payload.BSDFOpacity) * ComputeThinSlabWeights(TransmittanceColor, VoN, 0.0, F0).Transmitted;
		}
	}
	else
#endif

#if MATERIAL_SHADINGMODEL_HAIR
	if (Payload.ShadingModelID == SHADINGMODELID_HAIR)
	{
		// TODO: encode hair specific info
#if HAIR_STRAND_MESH_FACTORY
		Payload.SetHairPrimitiveUV(MaterialParameters.HairPrimitiveUV);
#else
		Payload.SetHairPrimitiveUV(0.5);
#endif
	}
	else
#endif

#if MATERIAL_SHADINGMODEL_EYE
	if (Payload.ShadingModelID == SHADINGMODELID_EYE)
	{
		// This is all based on logic from ShadingModelsMaterial.ush
		const float IrisMask     = saturate(GetMaterialCustomData0(MaterialParameters));
		const float IrisDistance = saturate(GetMaterialCustomData1(MaterialParameters));
		Payload.SetEyeIrisMask(IrisMask);
		Payload.Metallic = 0.0;
#if NUM_MATERIAL_OUTPUTS_GETTANGENTOUTPUT > 0
		// Blend in the negative intersection normal to create some concavity
		// Not great as it ties the concavity to the convexity of the cornea surface
		// No good justification for that. On the other hand, if we're just looking to
		// introduce some concavity, this does the job.
		const float3 PlaneNormal = normalize(GetTangentOutput0(MaterialParameters));
		const float3 CausticNormal = normalize(lerp(PlaneNormal, -Payload.WorldNormal, IrisMask * IrisDistance));
		Payload.SetEyeCausticNormal(CausticNormal);
		// NOTE: calling AdjustShadingNormal on the custom normal does not seem necessary since this is only used for a diffuse calculation
#else
		const float3 PlaneNormal = Payload.WorldNormal;
		Payload.SetEyeCausticNormal(Payload.WorldNormal);
#endif

#if IRIS_NORMAL // on
		Payload.Specular = 0.25;

	#if NUM_MATERIAL_OUTPUTS_CLEARCOATBOTTOMNORMAL > 0
		float3 IrisNormal = normalize( ClearCoatBottomNormal0(MaterialParameters) );
		#if MATERIAL_TANGENTSPACENORMAL
		IrisNormal = normalize( TransformTangentVectorToWorld( MaterialParameters.TangentToWorld, IrisNormal ) );
		#endif
	#else
		float3 IrisNormal = PlaneNormal;
	#endif
		Payload.SetEyeIrisNormal(IrisNormal);
#else
		// IRIS_NORMAL off
		Payload.SetEyeIrisNormal(PlaneNormal);
#endif

#if HAVE_GetSubsurfaceMediumMaterialOutput0
		Payload.SetSubsurfaceRadius(GetSubsurfaceMediumMaterialOutput0(MaterialParameters));
#else		
		const uint ProfileId = ExtractSubsurfaceProfileInt(GetMaterialSubsurfaceDataRaw(PixelMaterialInputs).a);
		if (GetSubsurfaceProfileUseBurley(ProfileId))
		{
			// Decode SSS radius
			const float Opacity = GetMaterialOpacity(PixelMaterialInputs);
			const float3 DiffuseColor = Payload.BaseColor * (1.0 - Payload.Metallic);
			Payload.SetSubsurfaceRadius(DecodeSSSProfileRadius(ProfileId, DiffuseColor, Opacity));
		}
		else
		{
			Payload.SetSubsurfaceRadius(0.0);
		}
#endif

#if HAVE_GetSubsurfaceMediumMaterialOutput1
		float ScatteringDistribution = clamp(GetSubsurfaceMediumMaterialOutput1(MaterialParameters), -0.99f, 0.99f);
		Payload.SetSubsurfacePhaseFunction(ScatteringDistribution);
#else
		Payload.SetSubsurfacePhaseFunction(0.0);
#endif

	}
	else
#endif

#if MATERIAL_SHADINGMODEL_DEFAULT_LIT
	if (Payload.ShadingModelID == SHADINGMODELID_DEFAULT_LIT)
	{
		// only allow refraction for default lit materials since we need space for the absorption amount
#if HAVE_GetAbsorptionMediumMaterialOutput0
		Payload.SetExtinction(PathTracingGlassTransmittanceToExtinction(GetAbsorptionMediumMaterialOutput0(MaterialParameters)));
#else
		// Make the glass totally clear if no custom medium is set
		Payload.SetExtinction(0.0);
#endif
		Payload.Ior = Ior;
		if (Ior > 0.0)
		{
			// we are using actual refraction, so disable transparency
			Payload.TransparencyColor = 0.0;
		}
	}
	else
#endif
	{
		// terminal case for the conditionals above
	}

#if MATERIALBLENDING_ALPHAHOLDOUT
	// the material is already a holdout, no need to do anything else
#else
	if (PackedPayload.IsCameraRay())
	{
		if ((PrimitiveFlags & PRIMITIVE_SCENE_DATA_FLAG_HOLDOUT) != 0)
		{
			if (Payload.Ior != 0.0)
			{
				// If the surface is marked as refractive then treat it as opaque for holdout
				Payload.BSDFOpacity = 1.0;
			}
			else
			{
				// keep the opacity from the material, it might indicate partial transparency
				// so we should get a partial holdout
			}

			Payload.SetHoldout();
			Payload.ShadingModelID = SHADINGMODELID_UNLIT;
			Payload.Radiance = 0;
		}
	}
#endif

	// Only opaque surfaces can recieve decals. This is both for compatibility with raster and improving performance when we have stacks of transparent surfaces
#if MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED
	if ((PrimitiveFlags & PRIMITIVE_SCENE_DATA_FLAG_DECAL_RECEIVER) != 0)
	{
#if USE_DBUFFER
		Payload.SetDecalReceiver(MATERIALDECALRESPONSEMASK);
#	if MATERIAL_USES_DECAL_LOOKUP
		Payload.SetUseDBufferLookup();
#	endif
#else
		Payload.SetDecalReceiver(0x07);
#endif
	}
#endif

	// adjust after everything else (because SSS profile case needs to decode the dual spec info from the unmodified roughness)
	Payload.Roughness = AdjustMaterialRoughness(Payload.Roughness, PackedPayload.GetPathRoughness());

#endif


	PackedPayload = PackPathTracingPayload(Payload);
}

#if USE_MATERIAL_ANY_HIT_SHADER

RAY_TRACING_ENTRY_ANY_HIT(PathTracingMaterialAHS,
	FPackedPathTracingPayload, PackedPayload,
	FRayTracingIntersectionAttributes, Attributes)
{
#if MATERIALBLENDING_MASKED && !MATERIAL_DITHER_OPACITY_MASK
	// This is the only case which actually needs to run the full material
	ResolvedView = ResolveView();

	const float3 TranslatedWorldPosition = TranslatedWorldRayOrigin() + RayTCurrent() * WorldRayDirection();
	const float4 SvPosition = mul(float4(TranslatedWorldPosition, 1.0f), ResolvedView.TranslatedWorldToClip);

	CurrentPayloadInputFlags = PackedPayload.GetFlags();

#if VF_SUPPORTS_RAYTRACING_PREPARE_MATERIAL_PIXEL_PARAMETERS
	// this is a newer codepath that is both more flexible and allows for more direct calculation compared to the other codepath
	// TODO: implement such a method for all vertex factories
	float3 GeoNormal = 0;
	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(TranslatedWorldRayOrigin(), WorldRayDirection(), RayTCurrent(), PrimitiveIndex(), Attributes, HitKind(), GeoNormal);
#else
	FVertexFactoryInterpolantsVSToPS Interpolants;
	float3 GeoNormal = 0;
	CalcInterpolants((FRayCone)0, Attributes, Interpolants, GeoNormal);

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Interpolants, SvPosition);
#endif

	FPixelMaterialInputs PixelMaterialInputs;

	const bool bIsFrontFace = HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE;

	{
		const float4 ScreenPosition = SvPositionToResolvedScreenPosition(SvPosition);

		MaterialParameters.CameraVector = -WorldRayDirection();

		CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, TranslatedWorldPosition, TranslatedWorldPosition);
	}

	// Regardless of payload flags -- we always apply this 
	if (GetMaterialMask(PixelMaterialInputs) < 0)
	{
		IgnoreHit();
	}
#else
	// All other blending modes need to run CHS to decide what to do, or are handled via the default opaque/translucent CHS/AHS materials.
	// in these cases, the AHS should be disabled, so emit an error if we get here somehow
	#error Unexpected blend mode encountered in AHS!
#endif
}

#endif // USE_MATERIAL_ANY_HIT_SHADER
