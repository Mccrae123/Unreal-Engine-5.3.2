// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
SkyLight.usf: Light sampling functions for SkyLight implementation
===============================================================================================*/

#pragma once

Texture2D SkylightTexture;
Texture2D<float> SkylightPdf;
SamplerState SkylightTextureSampler;
float SkylightInvResolution;
int SkylightMipCount;

#define USE_HIERARCHICAL_IMPORTANCE_SAMPLING		1

float SkyLight_EstimateLight(
	int LightId,
	float3 WorldPos,
	float3 WorldNormal,
	bool IsTransmissiveMaterial
)
{
	// cancels out constant factor in pdf below
#if USE_HIERARCHICAL_IMPORTANCE_SAMPLING == 0
	return 2 * PI;
#else
	return 4 * PI * SkylightPdf.Load(int3(0, 0, SkylightMipCount - 1));
#endif
}

FLightHit SkyLight_TraceLight(RayDesc Ray, int LightId) {
	if (Ray.TMax == POSITIVE_INFINITY)
	{
		// NOTE: assumes direction is normalized

		float3 Dir = Ray.Direction;
		float2 UV = InverseEquiAreaSphericalMapping(Dir.yzx);
		float4 Result = SkylightTexture.SampleLevel(SkylightTextureSampler, UV, 0);
		float3 Radiance = Result.xyz;
#if USE_HIERARCHICAL_IMPORTANCE_SAMPLING == 0
		float Pdf = 1.0 / (2.0 * PI);
#else
		float Pdf = Result.w > 0 ? Result.w / (4 * PI * SkylightPdf.Load(int3(0, 0, SkylightMipCount - 1))) : 0.0;
#endif
		return CreateLightHit(Radiance, Pdf, POSITIVE_INFINITY);
	}
	return NullLightHit();
}

FLightSample SkyLight_SampleLight(
	int LightId,
	float4 RandSample,
	float3 WorldPos,
	float3 WorldNormal
)
{
	// Make temp structures so we can re-use the calls above
	// #dxr_todo: write optimized form that combines radiance and pdf lookup in a single step
	RayDesc Ray;
	Ray.Origin = WorldPos;

#if USE_HIERARCHICAL_IMPORTANCE_SAMPLING == 0
	float4 Direction_Tangent = UniformSampleHemisphere(RandSample.yz);
	float3 OutDirection = TangentToWorld(Direction_Tangent.xyz, WorldNormal);
	float OutPdf = Direction_Tangent.w;
	float2 UV = InverseEquiAreaSphericalMapping(OutDirection.yzx);
	float3 Radiance = SkylightTexture.SampleLevel(SkylightTextureSampler, UV, 0).xyz;
	return CreateLightSample(Radiance / OutPdf, OutPdf, OutDirection, POSITIVE_INFINITY);
#else
	float2 UV = RandSample.yz;

	int3 Pixel = int3(0, 0, SkylightMipCount - 2);
	for (; Pixel.z >= 0; Pixel.z--)
	{
		Pixel.xy *= 2;
		float P00 = SkylightPdf.Load(Pixel + int3(0, 0, 0));
		float P10 = SkylightPdf.Load(Pixel + int3(1, 0, 0));
		float P01 = SkylightPdf.Load(Pixel + int3(0, 1, 0));
		float P11 = SkylightPdf.Load(Pixel + int3(1, 1, 0));

		float L = P00 + P01;
		float R = P10 + P11;

		float ProbX = L / (L + R);
		if (UV.x < ProbX)
		{
			UV.x /= ProbX;
			float ProbY = P00 / L;
			if (UV.y < ProbY)
			{
				UV.y /= ProbY;
			}
			else
			{
				Pixel.y++;
				UV.y = (UV.y - ProbY) / (1 - ProbY);
			}
		}
		else
		{
			Pixel.x++;
			UV.x = (UV.x - ProbX) / (1 - ProbX);
			float ProbY = P10 / R;
			if (UV.y < ProbY)
			{
				UV.y /= ProbY;
			}
			else
			{
				Pixel.y++;
				UV.y = (UV.y - ProbY) / (1 - ProbY);
			}
		}
	}

	Pixel.z = 0;
	float4 Result = SkylightTexture.Load(Pixel);
	float3 Radiance = Result.xyz;
	float OutPdf = Result.w / (4 * PI * SkylightPdf.Load(int3(0, 0, SkylightMipCount - 1)));

	UV = (float2(Pixel.xy) + UV) * SkylightInvResolution;

	return CreateLightSample(Radiance / OutPdf, OutPdf, EquiAreaSphericalMapping(UV).zxy, POSITIVE_INFINITY);
#endif
}
