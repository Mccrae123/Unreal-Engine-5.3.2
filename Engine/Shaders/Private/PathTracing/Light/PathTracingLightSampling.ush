// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
LightSampling.usf: Light sampling for next-event estimation 
===============================================================================================*/

#pragma once

#ifndef ENABLE_TRANSMISSION
	#define ENABLE_TRANSMISSION 1
#endif

//#define UNIFORM_LIGHT_SELECTION

#include "PathTracingLightCommon.ush"
#include "PathTracingDirectionalLight.ush"
#include "PathTracingPointLight.ush"
#include "PathTracingRectLight.ush"
#include "PathTracingSkyLight.ush"
#include "PathTracingSpotLight.ush"

// Returns float4 packed with Radiance and Pdf
float4 TraceLight(RayDesc Ray, int LightId, float HitT)
{
	if (IsPointLight(LightId))
	{
		return PointLight_TraceLight(Ray, LightId, HitT);
	}
	else if (IsSpotLight(LightId))
	{
		return SpotLight_TraceLight(Ray, LightId, HitT);
	}
	else if (IsDirectionalLight(LightId))
	{
		return DirectionalLight_TraceLight(Ray, LightId, HitT);
	}
	else if (IsEnvironmentLight(LightId))
	{
		return SkyLight_TraceLight(Ray, LightId, HitT);
	}
	else if (IsRectLight(LightId))
	{
		return RectLight_TraceLight(Ray, LightId, HitT);
	}
	// unknown light type?
	return 0.0;
}

// Choose a point on a light as seen from the given shading point
void SampleLight(
	int LightId,
	float4 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	if (IsPointLight(LightId))
	{
		PointLight_SampleLight(LightId, RandSample, WorldPos, WorldNormal, OutDirection, OutDistance, OutRadianceOverPdf, OutPdf);
	}
	else if (IsSpotLight(LightId))
	{
		SpotLight_SampleLight(LightId, RandSample, WorldPos, WorldNormal, OutDirection, OutDistance, OutRadianceOverPdf, OutPdf);
	}
	else if (IsDirectionalLight(LightId))
	{
		DirectionalLight_SampleLight(LightId, RandSample, WorldPos, WorldNormal, OutDirection, OutDistance, OutRadianceOverPdf, OutPdf);
	}
	else if (IsEnvironmentLight(LightId))
	{
		SkyLight_SampleLight(LightId, RandSample, WorldPos, WorldNormal, OutDirection, OutDistance, OutRadianceOverPdf, OutPdf);
	}
	else if (IsRectLight(LightId))
	{
		RectLight_SampleLight(LightId, RandSample, WorldPos, WorldNormal, OutDirection, OutDistance, OutRadianceOverPdf, OutPdf);
	}
	else
	{
		// unknown light type?
		OutDirection = 0;
		OutDistance = 0;
		OutRadianceOverPdf = 0;
		OutPdf = 0;
	}
}

void GenerateLightRay(RayDesc Ray, int LightId, float3 LightUV, inout RayDesc OutLightRay)
{
	OutLightRay = (RayDesc)0; // #dxr_todo: Return false in the case of no matching light type and handle case from caller rather than blindly using a degenerate ray

	if (IsPointLight(LightId))
	{
		PointLight_GenerateLightRay(Ray, LightId, LightUV, OutLightRay);
	}
	else if (IsSpotLight(LightId))
	{
		SpotLight_GenerateLightRay(Ray, LightId, LightUV, OutLightRay);
	}
	else if (IsDirectionalLight(LightId))
	{
		DirectionalLight_GenerateLightRay(Ray, LightId, LightUV, OutLightRay);
	}
	else if (IsEnvironmentLight(LightId))
	{
		SkyLight_GenerateLightRay(Ray, LightId, LightUV, OutLightRay);
	}
	else if (IsRectLight(LightId))
	{
		RectLight_GenerateLightRay(Ray, LightId, LightUV, OutLightRay);
	}
}


void EstimateLight(
	int LightId,
	float3 WorldPos,
	float3 WorldNormal,
	uint PrimitiveLightingChannelMask,
	bool IsTransmissiveMaterial,
	inout float OutIrradiance
)
{
	OutIrradiance = 0.0f;
	if ((GetLightingChannelMask(LightId) & PrimitiveLightingChannelMask) == 0) return;

	if (IsPointLight(LightId))
	{
		PointLight_EstimateLight(LightId, WorldPos, WorldNormal, IsTransmissiveMaterial, OutIrradiance);
	}
	else if (IsSpotLight(LightId))
	{
		SpotLight_EstimateLight(LightId, WorldPos, WorldNormal, IsTransmissiveMaterial, OutIrradiance);
	}
	else if (IsEnvironmentLight(LightId))
	{
		SkyLight_EstimateLight(LightId, WorldPos, WorldNormal, IsTransmissiveMaterial, OutIrradiance);
	}
	else if (IsDirectionalLight(LightId))
	{
		DirectionalLight_EstimateLight(LightId, WorldPos, WorldNormal, IsTransmissiveMaterial, OutIrradiance);
	}
	else if (IsRectLight(LightId))
	{
		RectLight_EstimateLight(LightId, WorldPos, WorldNormal, IsTransmissiveMaterial, OutIrradiance);
	}
}

bool SampleLightSelection(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	float RandSample,
	inout int OutLightId,
	inout float OutLightSelectionPdf
)
{
	OutLightSelectionPdf = 0.0;

	if (SceneLightsData.Count == 0)
	{
		return false;
	}

#ifdef UNIFORM_LIGHT_SELECTION
	OutLightId = RandSample * SceneLightsData.Count;
	OutLightSelectionPdf = 1.0 / SceneLightsData.Count;
	return true;
#else

	// Build irradiance estimate prefix sum
	float IrradianceEstimate[RAY_TRACING_LIGHT_COUNT_MAXIMUM];

	float3 WorldPos = Payload.WorldPos;
	float3 WorldNormal = Payload.WorldNormal;
	uint PrimitiveLightingChannelMask = Payload.PrimitiveLightingChannelMask;
	
	// TODO: query transmission from material instead of light?
	EstimateLight(0, WorldPos, WorldNormal, PrimitiveLightingChannelMask, ENABLE_TRANSMISSION && HasTransmission(0), IrradianceEstimate[0]);
	{
		for (uint LightIndex = 1; LightIndex < SceneLightsData.Count; ++LightIndex)
		{
			EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, ENABLE_TRANSMISSION && HasTransmission(LightIndex), IrradianceEstimate[LightIndex]);
			IrradianceEstimate[LightIndex] += IrradianceEstimate[LightIndex - 1];
		}
	}
	
	if (IrradianceEstimate[SceneLightsData.Count - 1] == 0)
	{
		return false;
	}

	// CDF normalization
	{
		for (uint LightIndex = 0; LightIndex < SceneLightsData.Count; ++LightIndex)
		{
			IrradianceEstimate[LightIndex] /= IrradianceEstimate[SceneLightsData.Count - 1];
		}
	}
	IrradianceEstimate[SceneLightsData.Count - 1] = 1.0;

	// Draw random variable
	// dxr_todo: binary search
	for (OutLightId = 0; OutLightId < SceneLightsData.Count; ++OutLightId)
	{
		if (RandSample < IrradianceEstimate[OutLightId]) break;
	}

	OutLightSelectionPdf = IrradianceEstimate[OutLightId];
	if (OutLightId > 0)
	{
		OutLightSelectionPdf -= IrradianceEstimate[OutLightId - 1];
	}

	return true;
#endif
}

void PdfLightSelection(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	uint LightId,
	inout float OutLightSelectionPdf
)
{
	OutLightSelectionPdf = 0.0;

#ifdef UNIFORM_LIGHT_SELECTION
	OutLightSelectionPdf = 1.0 / SceneLightsData.Count;
	return;
#else
	if (SceneLightsData.Count == 0) return;

	// Build irradiance estimate prefix sum
	float IrradianceEstimate[RAY_TRACING_LIGHT_COUNT_MAXIMUM];

	float3 WorldPos = Payload.WorldPos;
	float3 WorldNormal = Payload.WorldNormal;
	uint PrimitiveLightingChannelMask = Payload.PrimitiveLightingChannelMask;

	EstimateLight(0, WorldPos, WorldNormal, PrimitiveLightingChannelMask, ENABLE_TRANSMISSION && HasTransmission(0), IrradianceEstimate[0]);
	{
		for (uint LightIndex = 1; LightIndex < SceneLightsData.Count; ++LightIndex)
		{
			EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, ENABLE_TRANSMISSION && HasTransmission(LightIndex), IrradianceEstimate[LightIndex]);
			IrradianceEstimate[LightIndex] += IrradianceEstimate[LightIndex - 1];
		}
	}
	// dxr_todo: Consider when IrradianceEstimate[SceneLightsData.Count] == 0

	// CDF normalization
	{
		for (uint LightIndex = 0; LightIndex < SceneLightsData.Count; ++LightIndex)
		{
			IrradianceEstimate[LightIndex] /= IrradianceEstimate[SceneLightsData.Count - 1];
		}
	}
	IrradianceEstimate[SceneLightsData.Count - 1] = 1.0;

	OutLightSelectionPdf = IrradianceEstimate[LightId];
	if (LightId > 0)
	{
		OutLightSelectionPdf -= IrradianceEstimate[LightId - 1];
	}
#endif
}

void PdfLight(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	int LightId,
	float3 LightUV,
	inout float OutPdf)
{
	// Light selection
	// TODO: Use radiance estimate instead of uniform random selection
	float LightSelectionPdf = 1.0 / SceneLightsData.Count;
	PdfLightSelection(Ray, Payload, LightId, LightSelectionPdf);
	float LightPdf = 0.0;

	// Light sampling
	if (IsEnvironmentLight(LightId))
	{
		SkyLight_PdfLight(Ray, LightId, LightUV, LightPdf);
	}
	else if (IsPointLight(LightId))
	{
		PointLight_PdfLight(Ray, LightId, LightUV, LightPdf);
	}
	else if (IsSpotLight(LightId))
	{
		SpotLight_PdfLight(Ray, LightId, LightUV, LightPdf);
	}
	else if (IsDirectionalLight(LightId))
	{
		DirectionalLight_PdfLight(Ray, LightId, LightUV, LightPdf);
	}
	else if (IsRectLight(LightId))
	{
		RectLight_PdfLight(Ray, LightId, LightUV, LightPdf);
	}

	OutPdf = LightSelectionPdf * LightPdf;
}

void EvalLight(
	int LightId,
	float3 LightUV,
	RayDesc Ray,
	inout float3 OutRadiance
)
{
	OutRadiance = float3(0.0f, 0.0f, 0.0f);

	if (IsPointLight(LightId))
	{
		PointLight_EvalLight(LightId, LightUV, Ray, OutRadiance);
	}
	else if (IsSpotLight(LightId))
	{
		SpotLight_EvalLight(LightId, LightUV, Ray, OutRadiance);
	}
	else if (IsEnvironmentLight(LightId))
	{
		SkyLight_EvalLight(LightId, LightUV, Ray, OutRadiance);
	}
	else if (IsDirectionalLight(LightId))
	{
		DirectionalLight_EvalLight(LightId, LightUV, Ray, OutRadiance);
	}
	else if (IsRectLight(LightId))
	{
		RectLight_EvalLight(LightId, LightUV, Ray,  OutRadiance);
	}
}

void SampleLight(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	inout int OutLightId,
	inout float3 OutLightUV,
	inout float OutPdf)
{
	OutPdf = 0.0f;

	// Light selection
	float LightSelectionPdf = 0.0;
	if (!SampleLightSelection(Ray, Payload, RandSample.x, OutLightId, LightSelectionPdf))
	{
		return;
	}

	// Light sampling
	float LightPdf = 0.0;
	if (IsPointLight(OutLightId))
	{
		PointLight_SampleLight(Ray, Payload, RandSample, OutLightId, OutLightUV, LightPdf);
	}
	else if (IsSpotLight(OutLightId))
	{
		SpotLight_SampleLight(Ray, Payload, RandSample, OutLightId, OutLightUV, LightPdf);
	}
	else if (IsDirectionalLight(OutLightId))
	{
		DirectionalLight_SampleLight(Ray, Payload, RandSample, OutLightId, OutLightUV, LightPdf);
	}
	else if (IsEnvironmentLight(OutLightId))
	{
		SkyLight_SampleLight(Ray, Payload, RandSample, OutLightId, OutLightUV, LightPdf);
	}
	else if (IsRectLight(OutLightId))
	{
		RectLight_SampleLight(Ray, Payload, RandSample, OutLightId, OutLightUV, LightPdf);
	}

	OutPdf = LightSelectionPdf * LightPdf;
}

// #dxr_todo: passing LightPickingCdf as anything but inout causes performance to drop significantly -- why ?
void InitLightPickingCdf(inout float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM])
{
	for (uint LightIndex = 0; LightIndex < SceneLightsData.Count; ++LightIndex)
	{
		LightPickingCdf[LightIndex] = float(LightIndex + 1) / float(SceneLightsData.Count);
	}
}

// #dxr_todo: passing LightPickingCdf as anything but inout causes performance to drop significantly -- why ?
bool InitLightPickingCdf(
	float3 WorldPos,
	float3 WorldNormal,
	uint PrimitiveLightingChannelMask,
	bool IsTransmissiveMaterial,
	inout float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM])
{
	// This code assumes SceneLightsData.Count > 0
#ifdef UNIFORM_LIGHT_SELECTION
	InitLightPickingCdf(LightPickingCdf);
#else
	// Build irradiance estimate prefix sum
	EstimateLight(0, WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial, LightPickingCdf[0]);
	{
		for (uint LightIndex = 1; LightIndex < SceneLightsData.Count; ++LightIndex)
		{
			EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial, LightPickingCdf[LightIndex]);
			LightPickingCdf[LightIndex] += LightPickingCdf[LightIndex - 1];
		}
	}

	if (LightPickingCdf[SceneLightsData.Count - 1] == 0)
	{
		// all the lights are invisible
		return false;
	}
	{
		// CDF normalization
		for (uint LightIndex = 0; LightIndex < SceneLightsData.Count; ++LightIndex)
		{
			LightPickingCdf[LightIndex] /= LightPickingCdf[SceneLightsData.Count - 1];
		}
		LightPickingCdf[SceneLightsData.Count - 1] = 1.0;
	}
#endif
	return true;
}

// #dxr_todo: passing LightPickingCdf as anything but inout causes performance to drop significantly -- why ?
void SelectLight(float RandSample, inout float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM], out uint LightId, out float LightPickPdf)
{
	// This code assumes SceneLightsData.Count > 0

	// Draw random variable
	// #dxr_todo: binary search
	float PreviousCdfValue = 0;
	for (LightId = 0; LightId < SceneLightsData.Count - 1; ++LightId)
	{
		if (RandSample < LightPickingCdf[LightId])
		{
			break;
		}
		PreviousCdfValue = LightPickingCdf[LightId];
	}

	LightPickPdf = LightPickingCdf[LightId] - PreviousCdfValue;
}
