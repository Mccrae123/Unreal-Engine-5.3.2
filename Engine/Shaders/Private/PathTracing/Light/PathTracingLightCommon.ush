// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
LightCommon.usf: Common utility functions for light sampling
===============================================================================================*/

#pragma once

int GetLightId(FMaterialClosestHitPayload RayHitInfo)
{
	return -1;
}

bool IsEnvironmentLight(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_TYPE_MASK) == PATHTRACING_LIGHT_SKY;
}

bool IsPointLight(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_TYPE_MASK) == PATHTRACING_LIGHT_POINT;
}

bool IsDirectionalLight(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_TYPE_MASK) == PATHTRACING_LIGHT_DIRECTIONAL;
}

bool IsRectLight(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_TYPE_MASK) == PATHTRACING_LIGHT_RECT;
}

bool IsSpotLight(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_TYPE_MASK) == PATHTRACING_LIGHT_SPOT;
}

// A light is a physical light if it can be intersected by a ray.
bool IsPhysicalLight(int LightId)
{
	return IsEnvironmentLight(LightId);
}

float3 GetLightUV(int LightId, RayDesc Ray, FMaterialClosestHitPayload RayHitInfo)
{
	float3 LightUV = 0.0;
	if (IsEnvironmentLight(LightId))
	{
		LightUV = Ray.Direction;
	}
	return LightUV;
}

float3 GetPosition(int LightId)
{
	return SceneLightsData.Position[LightId];
}

float3 GetNormal(int LightId)
{
	return SceneLightsData.Normal[LightId];
}

float3 GetdPdu(int LightId)
{
	return SceneLightsData.dPdu[LightId];
}

float3 GetdPdv(int LightId)
{
	return SceneLightsData.dPdv[LightId];
}

float GetWidth(int LightId)
{
	return SceneLightsData.Dimensions[LightId].x;
}

float GetHeight(int LightId)
{
	return SceneLightsData.Dimensions[LightId].y;
}

float2 GetRectSize(int LightId)
{
	return SceneLightsData.Dimensions[LightId].xy;
}

float GetDepth(int LightId)
{
	return SceneLightsData.Dimensions[LightId].z;
}

float2 GetCosConeAngles(int LightId)
{
	return SceneLightsData.Dimensions[LightId].xy;
}

float3 GetColor(int LightId)
{
	return SceneLightsData.Color[LightId];
}

float GetRadius(int LightId)
{
	return SceneLightsData.Dimensions[LightId].z;
}

float GetAttenuation(int LightId)
{
	return SceneLightsData.Attenuation[LightId];
}

float GetRectLightBarnCosAngle(int LightId)
{
	return SceneLightsData.RectLightBarnCosAngle[LightId];
}

float GetRectLightBarnLength(int LightId)
{
	return SceneLightsData.RectLightBarnLength[LightId];
}

#ifndef USE_ATTENUATION_TERM
	#define USE_ATTENUATION_TERM 1
#endif

float ComputeAttenuationFalloff(float DistanceSquared, int LightId)
{
#if USE_ATTENUATION_TERM
	// Mirrors GetLocalLightAttenuation() custom attenuation controls
	// #dxr_todo: UE-72508: encapsulate this function in a shared space
	float InvAttenuationRadius = GetAttenuation(LightId);
	float NormalizeDistanceSquared = DistanceSquared * Square(InvAttenuationRadius);
	if ((SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_NON_INVERSE_SQUARE_FALLOFF_MASK) == 0)
	{
		return Square(saturate(1.0 - Square(NormalizeDistanceSquared)));
	}
	else
	{
		// roughly cancel out "native" square distance falloff before applying exponent based falloff function
        // this appears to match the behavior of the deferred lighting passes
		float FalloffExponent = SceneLightsData.FalloffExponent[LightId];
		return DistanceSquared * pow(1.0 - saturate(NormalizeDistanceSquared), FalloffExponent);
	}
#else
	return 1.0;
#endif
}


Texture3D    IESTexture;
SamplerState IESTextureSampler;

float ComputeIESAttenuation(int LightId, float3 WorldPosition)
{
	float Result = 1.f;
	if (SceneLightsData.IESTextureSlice[LightId] >= 0)
	{
		float3 LightDirection = normalize(GetPosition(LightId) - WorldPosition);

		float DotProd = dot(LightDirection, GetNormal(LightId));
		float Angle = asin(DotProd);
		const float NormAngle = Angle / PI + 0.5f;

		float du = dot(LightDirection, GetdPdu(LightId));
		float dv = dot(LightDirection, GetdPdv(LightId));
		float NormTangentAngle = atan2(dv, du) / (PI * 2.f) + 0.5f;

		const float3 UVW = float3(NormAngle, NormTangentAngle, SceneLightsData.IESTextureSlice[LightId]);
		Result = Texture3DSampleLevel(IESTexture, IESTextureSampler, UVW, 0).r;
	}
	return Result;
}

bool HasTransmission(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_TRANSMISSION_MASK) != 0;
}

uint GetLightingChannelMask(int LightId)
{
	return SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_LIGHTING_CHANNEL_MASK;
}

bool IsStationary(int LightId)
{
	return (SceneLightsData.Flags[LightId] & PATHTRACER_FLAG_STATIONARY_MASK) != 0;
}
