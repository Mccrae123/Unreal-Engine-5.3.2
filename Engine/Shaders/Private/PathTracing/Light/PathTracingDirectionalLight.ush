// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
DirectionalLight.usf: Light sampling functions for Directional light implementation
===============================================================================================*/

#pragma once

#include "PathTracingLightCommon.ush"

void DirectionalLight_GenerateLightRay(
	RayDesc Ray,
	int LightId,
	float3 LightUV,
	out RayDesc OutLightRay
)
{
	OutLightRay.Origin = Ray.Origin;
	OutLightRay.TMin = 0.0;
	OutLightRay.Direction = normalize(LightUV);
	OutLightRay.TMax = 1.0e27;
}

void DirectionalLight_PdfLight(
	RayDesc Ray,
	int LightId,
	float3 LightUV,
	out float OutPdf
)
{
	OutPdf = 0.0;
}

void DirectionalLight_EvalLight(
	int LightId,
	float3 LightUV,
	RayDesc Ray,
	out float3 OutRadiance
)
{
	float3 Color = GetColor(LightId);
	float Radius = GetRadius(LightId);
	if (Radius == 0)
	{
		OutRadiance = Color;
	}
	else
	{
		// #dxr_todo: Merge Eval/Sample to avoid redundant computation
		float SinThetaMax = Radius; // currently sin(Angle / 2)
		float CosThetaMax = sqrt(1.0 - SinThetaMax * SinThetaMax);
		OutRadiance = Color * 1.0 / (2 * PI * (1 - CosThetaMax));
	}
}

void DirectionalLight_EstimateLight(
	int LightId,
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	out float OutIrradiance
)
{
	float3 LightDirection = GetNormal(LightId);
	float3 SurfaceNormal = Payload.WorldNormal;
	float NoL = 1.0;
	if (GetRadius(LightId) == 0.0)
	{
		NoL = dot(SurfaceNormal, LightDirection);
		NoL = ENABLE_TRANSMISSION && HasTransmission(LightId) ? abs(NoL) : saturate(NoL);
	}

	float LightPower = Luminance(GetColor(LightId));
	OutIrradiance = LightPower * NoL;
}

void DirectionalLight_SampleLight(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	int LightId,
	out float3 OutLightUV,
	out float OutPdf
)
{
	float3 N = normalize(GetNormal(LightId));
	float Radius = GetRadius(LightId);

	if (Radius == 0)
	{
		// singular case
		// #dxr_todo: should return +inf PDF to disable MIS
		OutLightUV = N;
		OutPdf = 1.0;
	}
	else
	{
		// soft case - build a frame, and sample the distant cone
		const float3x3 ToWorld = GetTangentBasis(N);

		float SinThetaMax = Radius; // currently sin(Angle / 2)
		float CosThetaMax = sqrt(1.0 - SinThetaMax * SinThetaMax);

		float4 DirAndPdf = UniformSampleCone(RandSample.yz, CosThetaMax);
		OutLightUV = mul(DirAndPdf.xyz, ToWorld);
		OutPdf = DirAndPdf.w;
	}
}