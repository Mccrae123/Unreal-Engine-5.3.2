// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
	RectLight.usf: Light sampling functions for Rect light implementation
===============================================================================================*/

#pragma once

#include "../../RectLight.ush"
#include "PathTracingLightCommon.ush"

float4 RectLight_TraceLight(RayDesc Ray, int LightId, float HitT)
{
	float3 LightPosition = GetPosition(LightId);
	float3 LightNormal = GetNormal(LightId);
	float3 LightDirection = LightPosition - Ray.Origin;
	float DoN = dot(Ray.Direction, LightNormal);
	float t = dot(LightDirection, LightNormal) / DoN;
	// ray points toward the plane and intersect it?
	if (DoN < 0 && t > Ray.TMin && t < HitT)
	{
		float3 LightdPdu = GetdPdu(LightId);
		float3 LightdPdv = GetdPdv(LightId);
		float2 LightExtent = 0.5 * GetRectSize(LightId);

		float3 P = t * Ray.Direction - LightDirection;
		float2 UV = float2(dot(P, LightdPdu), dot(P, LightdPdv));
		// test point against 
		if (all(abs(UV) <= LightExtent))
		{
			// Clip the Rectangle by the barndoors
			FRect Rect = GetRect(LightDirection,
				-LightNormal,
				LightdPdv,
				LightExtent.x,
				LightExtent.y,
				GetRectLightBarnCosAngle(LightId),
				GetRectLightBarnLength(LightId),
				true);
			P = t * Ray.Direction - Rect.Origin;
			// test again with the clipped extents
			UV = float2(dot(P, LightdPdu), dot(P, LightdPdv));
			if (all(abs(UV) <= Rect.Extent))
			{
				// stored color is radiance
				float3 Radiance = GetColor(LightId);
				float SolidAngle = BuildSphericalRect(Rect).SolidAngle;
				return float4(Radiance, 1.0 / SolidAngle);
			}
		}
	}
	return 0.0;
}

void RectLight_SampleLight(
	int LightId,
	float4 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	float3 LightPosition = GetPosition(LightId);
	float3 LightNormal = GetNormal(LightId);
	float3 LightdPdu = GetdPdu(LightId);
	float3 LightdPdv = GetdPdv(LightId);
	float LightWidth = GetWidth(LightId);
	float LightHeight = GetHeight(LightId);

	// Define rectangle and compute solid angle
	FRect Rect = GetRect(LightPosition - WorldPos,
		-LightNormal,
		LightdPdv,
		0.5 * LightWidth,
		0.5 * LightHeight,
		GetRectLightBarnCosAngle(LightId),
		GetRectLightBarnLength(LightId),
		true /* bComputeVisibleRect */);
	FSphericalRect SphericalRect = BuildSphericalRect(Rect);

	float3 Direction = UniformSampleSphericalRect(RandSample.yz, SphericalRect);

	OutDirection = normalize(Direction);
	OutDistance = length(Direction);
	OutRadianceOverPdf = GetColor(LightId) * SphericalRect.SolidAngle;
	OutPdf = 1.0 / SphericalRect.SolidAngle;
}

void RectLight_GenerateLightRay(
	RayDesc Ray,
	int LightId,
	float3 LightUV,
	out RayDesc OutLightRay
)
{
	OutLightRay.Origin = Ray.Origin;
	OutLightRay.TMin = 0.001;
	OutLightRay.Direction = normalize(LightUV);
	OutLightRay.TMax = length(LightUV);
}

void RectLight_PdfLight(
	RayDesc Ray,
	int LightId,
	float3 LightUV,
	out float OutPdf
)
{
	// TODO: Consider making RectLight a physical light. For now, it is analytical only.
	OutPdf = 0.0;
}

void RectLight_EvalLight(
	int LightId,
	float3 LightUV,
	RayDesc Ray,
	out float3 OutRadiance
)
{
	float3 Color = GetColor(LightId);
	float Falloff = ComputeAttenuationFalloff(Ray.TMax, GetAttenuation(LightId));
	OutRadiance = Color * Falloff;
}

void RectLight_EstimateLight(
	int LightId,
	float3 WorldPos,
	float3 WorldNormal,
	out float OutIrradiance
)
{
	// Distance to centroid
	// #dxr_todo: UE-72533 Use closest point, instead
	float3 LightDirection = GetPosition(LightId) - WorldPos;
	float LightDistanceSquared = dot(LightDirection, LightDirection);
	LightDirection = normalize(LightDirection);
	float3 LightNormal = GetNormal(LightId);

	// Light-normal culling
	if (dot(-LightDirection, LightNormal) <= 0.0)
	{
		OutIrradiance = 0.0;
		return;
	}

	// Approximate geometric term
	float3 SurfaceNormal = WorldNormal;
#if 0
	float NoL = dot(SurfaceNormal, LightDirection);
	NoL = ENABLE_TRANSMISSION && HasTransmission(LightId) ? abs(NoL) : saturate(NoL);
#else
	// Just use a trivial upper bound on cosine term 
	// #dxr_todo: UE-72533 least intrusive way of fixing the artifact cause by using LightCenter
	float NoL = 1.0;
#endif
	float Area = GetWidth(LightId) * GetHeight(LightId);

	float LightPower = Luminance(GetColor(LightId));
	float Falloff = ComputeAttenuationFalloff(sqrt(LightDistanceSquared), GetAttenuation(LightId));
	OutIrradiance = LightPower * Falloff * Area * NoL / LightDistanceSquared;
}

float3 BilinearQuadWarp(float2 uv, float W00, float W01, float W10, float W11) {
	// "Practical Product Sampling by Fitting and Composing Warps" - EGSR 2020
	// https://casual-effects.com/research/Hart2020Sampling/index.html
	// https://www.shadertoy.com/view/wljyDz

	float a = lerp(W00, W01, .5);
	float b = lerp(W10, W11, .5);
	float u = a == b ? uv.x : (sqrt(lerp(a * a, b * b, uv.x)) - a) / (b - a);
	float c = lerp(W00, W10, u);
	float d = lerp(W01, W11, u);
	float v = c == d ? uv.y : (sqrt(lerp(c * c, d * d, uv.y)) - c) / (d - c);
	float area = lerp(a, b, .5);
	float pdf = lerp(c, d, v) / area;
	return float3(u, v, pdf);
}

// #dxr_todo: This method should be moved to RectLight.ush
float4 SampleApproxProjectionSphericalRect(float2 Rand, FSphericalRect SphericalRect, float3 WorldNormal)
{
	// Construct the quad vertices
	float3 S00 = float3(SphericalRect.x0, SphericalRect.y0, SphericalRect.z0);
	float3 S10 = float3(SphericalRect.x1, SphericalRect.y0, SphericalRect.z0);
	float3 S11 = float3(SphericalRect.x1, SphericalRect.y1, SphericalRect.z0);
	float3 S01 = float3(SphericalRect.x0, SphericalRect.y1, SphericalRect.z0);
	
	// Compute the cosine of the normal against each corner of the quad
	float3 LightSpaceNormal = mul(SphericalRect.Axis, WorldNormal);
	float W00 = saturate(dot(normalize(S00), LightSpaceNormal));
	float W10 = saturate(dot(normalize(S10), LightSpaceNormal));
	float W11 = saturate(dot(normalize(S11), LightSpaceNormal));
	float W01 = saturate(dot(normalize(S01), LightSpaceNormal));
	
	// Warp a 2D sample according to the cosine at each corner of the quad
	float3 WarpedRand = BilinearQuadWarp(Rand, W00, W01, W10, W11);

	// Proceed with uniform sampling of the spherical rectangle
	float3 Direction = UniformSampleSphericalRect(WarpedRand.xy, SphericalRect);
	float OutPdf = isfinite(SphericalRect.SolidAngle) ? 1.0 / SphericalRect.SolidAngle : 0.0;

	// Return Direction vector and adjusted PDF
	return float4(Direction, OutPdf * WarpedRand.z);
}

void RectLight_SampleLight(
	RayDesc Ray,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	int LightId,
	out float3 OutLightUV,
	out float OutPdf
)
{
	float3 WorldPosition = Payload.WorldPos;
	float3 LightPosition = GetPosition(LightId);
	float3 LightNormal = GetNormal(LightId);
	float3 LightdPdu = GetdPdu(LightId);
	float3 LightdPdv = GetdPdv(LightId);
	float LightWidth = GetWidth(LightId);
	float LightHeight = GetHeight(LightId);
	
	// Define rectangle and compute solid angle
	FRect Rect = GetRect(LightPosition - WorldPosition,
						 -LightNormal,
						 LightdPdv,
						 0.5 * LightWidth,
						 0.5 * LightHeight,
						 GetRectLightBarnCosAngle(LightId),
						 GetRectLightBarnLength(LightId),
						 true /* bComputeVisibleRect */);
	FSphericalRect SphericalRect = BuildSphericalRect(Rect);

	// #dxr_todo: Analyze the overall efficiency (MSE reduction vs. time)
	//  Projected solid angle sampling converges faster at equal sample count, but is a bit slower
	// #dxr_todo: Should we switch to plain area sampling at some distance?
#if 1
	// Approximate _projected_ solidangle sampling of the spherical rectangle
	float4 Result = SampleApproxProjectionSphericalRect(RandSample.yz, SphericalRect, Payload.WorldNormal);
	OutLightUV = Result.xyz;
	OutPdf = Result.w;
#else
	// Ordinary solid angle sampling of the spherical rectangle
	OutLightUV = UniformSampleSphericalRect(RandSample.yz, SphericalRect);
	OutPdf = isfinite(SphericalRect.SolidAngle) ? 1.0 / SphericalRect.SolidAngle : 0.0;
#endif
}