// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
	PathTracingRandomSequence.ush: Reference path tracing
===============================================================================================*/

#pragma once


#include "../../QuasiRandom.ush" 

#define RANDSEQ_LCG			0
#define RANDSEQ_HALTON		1
#define RANDSEQ_OWENSOBOL	2

#ifndef RANDSEQ
#define RANDSEQ			RANDSEQ_OWENSOBOL
#endif

#ifndef RANDSEQ_RANDOMIZED
#define RANDSEQ_RANDOMIZED		1 // 1 to randomize per pixel, 0 to share the same sequence in all pixels
#endif

struct RandomSequence
{
	uint SampleIndex;		// index into the random sequence
	uint SampleSeed;		// changes as we draw samples to reflect the change in dimension
};

// TEA-based pseudo-random number generator
uint RandInit(uint Seed0, uint Seed1)
{
	// Constants cited from "GPU Random Numbers via the Tiny Encryption Algorithm"
	const uint Delta = 0x9e3779b9;
	const uint4 Key = uint4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);
	uint Rounds = 8;

	uint Sum = 0;
	uint2 Value = uint2(Seed0, Seed1);
	for (uint Index = 0; Index < Rounds; ++Index)
	{
		Sum += Delta;
		Value.x += (Value.y + Sum) ^ ((Value.y << 4) + Key.x) ^ ((Value.y >> 5) + Key.y);
		Value.y += (Value.x + Sum) ^ ((Value.x << 4) + Key.z) ^ ((Value.x >> 5) + Key.w);
	}

	return Value.x;
}

// Linear congruential generator to evolve pseudo-random numbers
float Rand(inout uint Seed)
{
	// Scale and Bias coefficients are taken from the Park-Miller RNG
	const uint Scale = 48271;
	const uint Bias = 0;
	Seed = Seed * Scale + Bias;

	// Map to significand and divide into [0, 1) range
	float Result = float(Seed & 0x00FFFFFF);
	Result /= float(0x01000000);
	return Result;
}

// #dxr_todo: convert prime factors to constant buffer
static const uint Primes512LUT[] = {
	2,3,5,7,11,13,17,19,23,29,
	31,37,41,43,47,53,59,61,67,71,
	73,79,83,89,97,101,103,107,109,113,
	127,131,137,139,149,151,157,163,167,173,
	179,181,191,193,197,199,211,223,227,229,
	233,239,241,251,257,263,269,271,277,281,
	283,293,307,311,313,317,331,337,347,349,
	353,359,367,373,379,383,389,397,401,409,
	419,421,431,433,439,443,449,457,461,463,
	467,479,487,491,499,503,509,521,523,541,
	547,557,563,569,571,577,587,593,599,601,
	607,613,617,619,631,641,643,647,653,659,
	661,673,677,683,691,701,709,719,727,733,
	739,743,751,757,761,769,773,787,797,809,
	811,821,823,827,829,839,853,857,859,863,
	877,881,883,887,907,911,919,929,937,941,
	947,953,967,971,977,983,991,997,1009,1013,
	1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,
	1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,
	1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,
	1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,
	1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,
	1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,
	1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,
	1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,
	1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,
	1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,
	1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,
	1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,
	1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,
	1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,
	2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,
	2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,
	2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,
	2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,
	2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,
	2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,
	2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,
	2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,
	2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,
	2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,
	2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,
	2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,
	3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,
	3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,
	3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,
	3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,
	3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,
	3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,
	3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,
	3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,
	3659,3671
};
uint Prime512(uint Dimension)
{
	return Primes512LUT[Dimension % 512];
}


float Halton(uint Index, uint Base)
{
	float r = 0.0;
	float f = 1.0;

	float BaseInv = 1.0 / Base;
	while (Index > 0)
	{
		f *= BaseInv;
		r += f * (Index % Base);
		Index /= Base;
	}

	return r;
}


uint FastOwenScrambling(uint Index, uint Seed) {
	// Laine and Karras / Stratified Sampling for Stochastic Transparency / EGSR 2011

	// The operations below will mix bits toward the left, so temporarily reverse the order
	// NOTE: This operation has been performed outside this call
	// Index = ReverseBits32(Index);
	
	Index += Seed; // randomize the index by our seed (pushes bits toward the left)

	// A few different options below for doing the scrambling step:
	// I'll stick to the simplest one until we have a good variance/time measurement system
#if 1
	// NOTE: Original publication has two extra xor-muls but they don't actually improve quality or convergence
	Index ^= Index * 0x6C50B47Cu;
	Index ^= Index * 0xB82F1E52u;
#elif 0
	// Better looking spectra on average - though still not perfect
	Index ^= (Index + Seed) * 0x6C50B47Cu;
	Index ^= (Index + Seed) * 0xB82F1E52u;
#else
	// This method achieves the closest results to real Owen-Scrambling
	// but (probably?) costs a bit more perf
	Index ^= Index * (Seed & ~1u);
	Seed = IntegerHash(Seed);
	Index ^= Index * (Seed & ~1u);
#endif

	// Undo the reverse so that we get left-to-right scrambling
	// thereby emulating owen-scrambling
	return ReverseBits32(Index);
}

// 32-bit Sobol matrices for dimension 1,2,3 from:
// S. Joe and F. Y. Kuo, Constructing Sobol sequences with better two-dimensional projections, SIAM J. Sci. Comput. 30, 2635-2654 (2008)
//    https://web.maths.unsw.edu.au/~fkuo/sobol/
// NOTE: we don't bother storing dimension 0 since it is just a bit reversal
// NOTE2: dimension 1 also follows a pattern that can be done procedurally but probably not worth the extra code?
// NOTE3: the matrix eleements are reversed to save one reverse in the owen scrambling
static const uint3 SobolMatrices[] = {
	uint3(0x00000001, 0x00000001, 0x00000001),
	uint3(0x00000003, 0x00000003, 0x00000003),
	uint3(0x00000005, 0x00000006, 0x00000004),
	uint3(0x0000000f, 0x00000009, 0x0000000a),
	uint3(0x00000011, 0x00000017, 0x0000001f),
	uint3(0x00000033, 0x0000003a, 0x0000002e),
	uint3(0x00000055, 0x00000071, 0x00000045),
	uint3(0x000000ff, 0x000000a3, 0x000000c9),
	uint3(0x00000101, 0x00000116, 0x0000011b),
	uint3(0x00000303, 0x00000339, 0x000002a4),
	uint3(0x00000505, 0x00000677, 0x0000079a),
	uint3(0x00000f0f, 0x000009aa, 0x00000b67),
	uint3(0x00001111, 0x00001601, 0x0000101e),
	uint3(0x00003333, 0x00003903, 0x0000302d),
	uint3(0x00005555, 0x00007706, 0x00004041),
	uint3(0x0000ffff, 0x0000aa09, 0x0000a0c3),
	uint3(0x00010001, 0x00010117, 0x0001f104),
	uint3(0x00030003, 0x0003033a, 0x0002e28a),
	uint3(0x00050005, 0x00060671, 0x000457df),
	uint3(0x000f000f, 0x000909a3, 0x000c9bae),
	uint3(0x00110011, 0x00171616, 0x0011a105),
	uint3(0x00330033, 0x003a3939, 0x002a7289),
	uint3(0x00550055, 0x00717777, 0x0079e7db),
	uint3(0x00ff00ff, 0x00a3aaaa, 0x00b6dba4),
	uint3(0x01010101, 0x01170001, 0x0100011a),
	uint3(0x03030303, 0x033a0003, 0x030002a7),
	uint3(0x05050505, 0x06710006, 0x0400079e),
	uint3(0x0f0f0f0f, 0x09a30009, 0x0a000b6d),
	uint3(0x11111111, 0x16160017, 0x1f001001),
	uint3(0x33333333, 0x3939003a, 0x2e003003),
	uint3(0x55555555, 0x77770071, 0x45004004),
	uint3(0xffffffff, 0xaaaa00a3, 0xc900a00a)
};

float4 SobolSampler(uint SampleIndex, inout uint Seed) {
	// We need a random sequence that we can advance quickly (5 steps per 4 samples)
	// constant from: https://www.pcg-random.org/posts/does-it-beat-the-minimal-standard.html
	const uint LCG_C = 1019135901;
	// first scramble the index to decorelate from other 4-tuples
	uint SobolIndex = FastOwenScrambling(SampleIndex, Seed = Seed * LCG_C + LCG_C);
	// now get Sobol' point from this index
	uint4 Result = uint4(SobolIndex, 0, 0, 0);
	for (int i = 0; SobolIndex; SobolIndex >>= 1, i++)
		Result.yzw ^= (SobolIndex & 1) * SobolMatrices[i];

	// finally scramble the points to avoid structured artifacts
	Result.x = FastOwenScrambling(Result.x, Seed = Seed * LCG_C + LCG_C);
	Result.y = FastOwenScrambling(Result.y, Seed = Seed * LCG_C + LCG_C);
	Result.z = FastOwenScrambling(Result.z, Seed = Seed * LCG_C + LCG_C);
	Result.w = FastOwenScrambling(Result.w, Seed = Seed * LCG_C + LCG_C);
	// output as float in [0,1) taking care not to skew the distribution
	// due to the non-uniform spacing of floats in this range
	return (Result >> 8) * 5.96046447754e-08; // * 2^-24
}

void RandomSequence_Initialize(inout RandomSequence RandSequence, uint PositionSeed, uint TimeSeed)
{
	// optionally disable randomization per pixel so that all pixels follow the same path in primary sample space
#if RANDSEQ_RANDOMIZED == 0
	PositionSeed = 0;
#endif

#if RANDSEQ == RANDSEQ_LCG
	RandSequence.SampleIndex = 0; // not used
	RandSequence.SampleSeed = RandInit(PositionSeed, TimeSeed);
#elif RANDSEQ == RANDSEQ_HALTON
	RandSequence.SampleIndex = TimeSeed + IntegerHash(PositionSeed);
	RandSequence.SampleSeed = 0; // this sampler just counts dimensions
#elif RANDSEQ == RANDSEQ_OWENSOBOL
	// pre-compute bit reversal needed for FastOwenScrambling since this index doesn't change
	RandSequence.SampleIndex = ReverseBits32(TimeSeed);
	RandSequence.SampleSeed  = IntegerHash(PositionSeed);
#else
#error "Unknown random sequence chosen in path tracer"
#endif
}

float RandomSequence_GenerateSample1D(inout RandomSequence RandSequence, uint DummyVariable)
{
	float Result;
#if RANDSEQ == RANDSEQ_LCG
	Result = Rand(RandSequence.SampleSeed);
#elif RANDSEQ == RANDSEQ_HALTON
	Result = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 0));
	RandSequence.SampleSeed += 1;
#elif RANDSEQ == RANDSEQ_OWENSOBOL
	// rely on compiler to optimize out dead code for now
	// #dxr_todo: benchmark and specialize if needed
	Result = SobolSampler(RandSequence.SampleIndex, RandSequence.SampleSeed).x;
#else
#error "Unknown random sequence chosen in path tracer"
#endif
	return Result;
}

float2 RandomSequence_GenerateSample2D(inout RandomSequence RandSequence, uint DummyVariable)
{
	float2 Result;
#if RANDSEQ == RANDSEQ_LCG
	Result.x = Rand(RandSequence.SampleSeed);
	Result.y = Rand(RandSequence.SampleSeed);
#elif RANDSEQ == RANDSEQ_HALTON
	Result.x = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 0));
	Result.y = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 1));
	RandSequence.SampleSeed += 2;
#elif RANDSEQ == RANDSEQ_OWENSOBOL
	// rely on compiler to optimize out dead code for now
	// #dxr_todo: benchmark and specialize if needed
	Result = SobolSampler(RandSequence.SampleIndex, RandSequence.SampleSeed).xy;
#else
#error "Unknown random sequence chosen in path tracer"
#endif
	return Result;
}

float3 RandomSequence_GenerateSample3D(inout RandomSequence RandSequence, uint DummyVariable)
{
	float3 Result;
#if RANDSEQ == RANDSEQ_LCG
	Result.x = Rand(RandSequence.SampleSeed);
	Result.y = Rand(RandSequence.SampleSeed);
	Result.z = Rand(RandSequence.SampleSeed);
#elif RANDSEQ == RANDSEQ_HALTON
	Result.x = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 0));
	Result.y = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 1));
	Result.z = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 2));
	RandSequence.SampleSeed += 3;
#elif RANDSEQ == RANDSEQ_OWENSOBOL
	// rely on compiler to optimize out dead code for now
	// #dxr_todo: benchmark and specialize if needed
	Result = SobolSampler(RandSequence.SampleIndex, RandSequence.SampleSeed).xyz;
#else
#error "Unknown random sequence chosen in path tracer"
#endif
	return Result;
}


float4 RandomSequence_GenerateSample4D(inout RandomSequence RandSequence, uint DummyVariable)
{
	float4 Result;
#if RANDSEQ == RANDSEQ_LCG
	Result.x = Rand(RandSequence.SampleSeed);
	Result.y = Rand(RandSequence.SampleSeed);
	Result.z = Rand(RandSequence.SampleSeed);
	Result.w = Rand(RandSequence.SampleSeed);
#elif RANDSEQ == RANDSEQ_HALTON
	Result.x = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 0));
	Result.y = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 1));
	Result.z = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 2));
	Result.w = Halton(RandSequence.SampleIndex, Prime512(RandSequence.SampleSeed + 3));
	RandSequence.SampleSeed += 4;
#elif RANDSEQ == RANDSEQ_OWENSOBOL
	Result = SobolSampler(RandSequence.SampleIndex, RandSequence.SampleSeed);
#else
#error "Unknown random sequence chosen in path tracer"
#endif
	return Result;
}
