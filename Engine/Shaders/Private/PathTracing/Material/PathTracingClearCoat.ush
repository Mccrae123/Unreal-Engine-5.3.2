// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
	PathTracingClearCoat.usf: Path tracing BRDF model for clear coat material
===============================================================================================*/

#pragma once

#define EVAL_TOP_LAYER 1
#define EVAL_BOTTOM_LAYER 1

#define GREY_INNER_LAYER 0

#define CLEAR_COAT_F0	0.04 // From hard-coded value in ShadingModels.ush

#include "PathTracingMaterialCommon.ush"
#include "PathTracingGlossy.ush"
#include "PathTracingFresnel.ush"
#include "PathTracingEnergyConservation.ush"


float ClearCoatFresnel(float VoH) {
	// from hardcoded logic in ClearCoatBxDF
	return CLEAR_COAT_F0 + (1.0 - CLEAR_COAT_F0) * Pow5(1 - VoH);
}

FMaterialEval ClearCoat_EvalMaterial(
	float3 IncomingDirection,
	float3 OutgoingDirection,
	inout FPathTracingPayload Payload
)
{
	FMaterialEval Result = NullMaterialEval();
	
	const float3 V_World = -IncomingDirection;
	const float3 L_World = OutgoingDirection;

	float2 CoatAlpha = 0;
	float2 SpecAlpha = 0;
	const float3x3 CoatBasis = GetGGXBasis(Payload.GetClearCoatRoughness(), Payload.WorldNormal, CoatAlpha);
	const float3x3 BaseBasis = GetGGXBasis(Payload.Roughness, Payload.Anisotropy, Payload.GetClearCoatBottomNormal(), Payload.WorldTangent, SpecAlpha);

	// move vectors into right shading frame
	const float3 CoatV = mul(CoatBasis, V_World);
	const float3 CoatL = mul(CoatBasis, L_World);
	const float3 CoatH = normalize(CoatV + CoatL);

	const float3 BaseV = mul(BaseBasis, V_World);
	const float3 BaseL = mul(BaseBasis, L_World);
	const float3 BaseH = normalize(BaseV + BaseL);


	const float CoatNoL = saturate(CoatL.z);
	const float CoatNoV = saturate(CoatV.z);
	const float CoatNoH = saturate(CoatH.z);
	const float CoatVoH = saturate(dot(CoatV, CoatH));

	const float BaseNoL = saturate(BaseL.z);
	const float BaseNoV = saturate(BaseV.z);
	const float BaseNoH = saturate(BaseH.z);
	const float BaseVoH = saturate(dot(BaseV, BaseH));

#if EVAL_BOTTOM_LAYER
#if GREY_INNER_LAYER
	const float3 SpecColor = 0.0;
	const float3 DiffColor = 0.18;
#else
	const float3 SpecColor = Payload.SpecularColor;
	const float3 DiffColor = Payload.DiffuseColor;
#endif
#else
	const float3 SpecColor = 0.0;
	const float3 DiffColor = 0.0;
#endif

#if EVAL_TOP_LAYER
	const float ClearCoat = Payload.GetClearCoat();
#else
	const float ClearCoat = 0.0;
#endif

	const FBxDFEnergyTerms Coat = ComputeGGXSpecEnergyTerms(Payload.GetClearCoatRoughness(), CoatNoV, CLEAR_COAT_F0);
	const FBxDFEnergyTerms Spec = ComputeGGXSpecEnergyTerms(Payload.Roughness              , BaseNoV, SpecColor);

	const float3 CoatE = ClearCoat * Coat.E;
	const float2 LobeCdf = LobeSelectionCdf(CoatE, (1.0 - CoatE) * Spec.E, (1.0 - CoatE) * (1.0 - Spec.E) * DiffColor);
	const float3 LobePdf = LobeSelectionPdf(LobeCdf);

	// Coat Specular lobe
	const float2 CoatGGXResult = GGXEvalReflection(CoatL, CoatV, CoatH, CoatAlpha);
	const float3 CoatWeight = ClearCoat * ClearCoatFresnel(CoatVoH) * CoatGGXResult.x * Coat.W;
	const float CoatPdf = CoatGGXResult.y;

	// Calculate transmission through substrate
	float3 Transmission = (1.0 - CoatE) * lerp(1.0, SimpleClearCoatTransmittance(CoatNoL, CoatNoV, Payload.Metallic, Payload.BaseColor), ClearCoat);

	// Base Specular lobe
	const float2 SpecGGXResult = GGXEvalReflection(BaseL, BaseV, BaseH, SpecAlpha);
	const float3 SpecWeight = Transmission * F_Schlick(SpecColor, BaseVoH) * CoatGGXResult.x * Spec.W;
	const float SpecPdf = SpecGGXResult.y;

	// Base Diffuse lobe
	const float3 Diffuse = GetPathTracingDiffuseModel(DiffColor, Payload.Roughness, BaseNoV, BaseNoL, BaseVoH, BaseNoH);
	const float3 DiffWeight = Transmission * (1 - Spec.E) * Diffuse * ShadowTerminatorTerm(L_World, Payload.WorldNormal, Payload.WorldSmoothNormal);
	const float DiffPdf = BaseNoL / PI;

	// Combine all lobes together
	AddLobeWithMIS(Result.Weight, Result.Pdf, CoatWeight, CoatPdf, LobePdf.x);
	AddLobeWithMIS(Result.Weight, Result.Pdf, SpecWeight, SpecPdf, LobePdf.y);
	AddLobeWithMIS(Result.Weight, Result.Pdf, DiffWeight, DiffPdf, LobePdf.z);
	
	return Result;
}

FMaterialSample ClearCoat_SampleMaterial(
	float3 RayDirection,
	FPathTracingPayload Payload,
	float4 RandSample
)
{
	float3 V_World = -RayDirection;


	float2 CoatAlpha = 0;
	float2 SpecAlpha = 0;
	const float3x3 CoatBasis = GetGGXBasis(Payload.GetClearCoatRoughness(), Payload.WorldNormal, CoatAlpha);
	const float3x3 BaseBasis = GetGGXBasis(Payload.Roughness, Payload.Anisotropy, Payload.GetClearCoatBottomNormal(), Payload.WorldTangent, SpecAlpha);

	// move view vector into right shading frame
	const float3 CoatV = mul(CoatBasis, V_World);
	const float3 BaseV = mul(BaseBasis, V_World);
	const float CoatNoV = saturate(CoatV.z);
	const float BaseNoV = saturate(BaseV.z);


#if EVAL_BOTTOM_LAYER
#if GREY_INNER_LAYER
	const float3 SpecColor = 0.0;
	const float3 DiffColor = 0.18;
#else
	const float3 SpecColor = Payload.SpecularColor;
	const float3 DiffColor = Payload.DiffuseColor;
#endif
#else
	const float3 SpecColor = 0.0;
	const float3 DiffColor = 0.0;
#endif

#if EVAL_TOP_LAYER
	const float ClearCoat = Payload.GetClearCoat();
#else
	const float ClearCoat = 0.0;
#endif

	const FBxDFEnergyTerms Coat = ComputeGGXSpecEnergyTerms(Payload.GetClearCoatRoughness(), CoatNoV, CLEAR_COAT_F0);
	const FBxDFEnergyTerms Spec = ComputeGGXSpecEnergyTerms(Payload.Roughness              , BaseNoV, Payload.SpecularColor);

	const float3 CoatE = ClearCoat * Coat.E;
	const float2 LobeCdf = LobeSelectionCdf(CoatE, (1.0 - CoatE) * Spec.E, (1.0 - CoatE) * (1.0 - Spec.E) * DiffColor);
	const float3 LobePdf = LobeSelectionPdf(LobeCdf);

	// choose between layers
	float3 OutDirection = 0;
	float OutRoughness = 0;
	if (RandSample.x < LobeCdf.x)
	{
		// Sampled coating
		RandSample.x /= LobeCdf.x;

		float3 V = -mul(CoatBasis, RayDirection);

		// #dxr_todo: Switch to UniformSampleDiskConcentric after fixing 0/0 bug
		float3 H = ImportanceSampleVisibleGGX_aniso(UniformSampleDisk(RandSample.xy), CoatAlpha, V).xyz;

		float3 L = reflect(-V, H);
		if (L.z <= 0)
		{
			// invalid output direction, skip some work
			return NullMaterialSample();
		}
		// reflect and transform
		OutDirection = mul(L, CoatBasis);
		OutRoughness = Payload.GetClearCoatRoughness();
	}
	else if (RandSample.x < LobeCdf.y)
	{
		// Sampled base spec
		RandSample.x -= LobeCdf.x;
		RandSample.x /= LobeCdf.y - LobeCdf.x;

		float3 V = -mul(BaseBasis, RayDirection);
		float3 H = ImportanceSampleVisibleGGX_aniso(UniformSampleDisk(RandSample.xy), SpecAlpha, V).xyz;
		float3 L = reflect(-V, H);
		if (L.z <= 0)
		{
			// invalid output direction, exit early
			return NullMaterialSample();
		}

		OutDirection = mul(L, BaseBasis);
		OutRoughness = Payload.Roughness;
	}
	else
	{
		// Sampled base diffuse
		RandSample.x -= LobeCdf.y;
		RandSample.x /= 1.0 - LobeCdf.y;

		float3 L = CosineSampleHemisphere(RandSample.xy).xyz;
		OutDirection = mul(L, BaseBasis);
		OutRoughness = 1.0;
	}


	// move light vector into right shading frame
	const float3 L_World = OutDirection;

	const float3 CoatL = mul(CoatBasis, L_World);
	const float3 CoatH = normalize(CoatV + CoatL);

	const float3 BaseL = mul(BaseBasis, L_World);
	const float3 BaseH = normalize(BaseV + BaseL);

	const float CoatNoL = saturate(CoatL.z);
	const float CoatNoH = saturate(CoatH.z);
	const float CoatVoH = saturate(dot(CoatV, CoatH));

	const float BaseNoL = saturate(BaseL.z);
	const float BaseNoH = saturate(BaseH.z);
	const float BaseVoH = saturate(dot(BaseV, BaseH));

	// Coat Specular lobe
	const float2 CoatGGXResult = GGXEvalReflection(CoatL, CoatV, CoatH, CoatAlpha);
	const float3 CoatWeight = ClearCoat * ClearCoatFresnel(CoatVoH) * CoatGGXResult.x * Coat.W;
	const float CoatPdf = CoatGGXResult.y;

	// Calculate transmission through substrate
	float3 Transmission = (1.0 - CoatE) * lerp(1.0, SimpleClearCoatTransmittance(CoatNoL, CoatNoV, Payload.Metallic, Payload.BaseColor), ClearCoat);

	// Base Specular lobe
	const float2 SpecGGXResult = GGXEvalReflection(BaseL, BaseV, BaseH, SpecAlpha);
	const float3 SpecWeight = Transmission * F_Schlick(SpecColor, BaseVoH) * CoatGGXResult.x * Spec.W;
	const float SpecPdf = SpecGGXResult.y;

	// Base Diffuse lobe
	const float3 Diffuse = GetPathTracingDiffuseModel(DiffColor, Payload.Roughness, BaseNoV, BaseNoL, BaseVoH, BaseNoH);
	const float3 DiffWeight = Transmission * (1 - Spec.E) * Diffuse * ShadowTerminatorTerm(L_World, Payload.WorldNormal, Payload.WorldSmoothNormal);
	const float DiffPdf = BaseNoL / PI;

	// Combine all lobes together
	float3 OutWeight = 0.0;
	float OutPdf = 0.0;
	AddLobeWithMIS(OutWeight, OutPdf, CoatWeight, CoatPdf, LobePdf.x);
	AddLobeWithMIS(OutWeight, OutPdf, SpecWeight, SpecPdf, LobePdf.y);
	AddLobeWithMIS(OutWeight, OutPdf, DiffWeight, DiffPdf, LobePdf.z);

	return CreateMaterialSample(OutDirection, OutWeight, OutPdf, 1.0, OutRoughness);
}
