// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingSpecularTransmission.usf: Pure specular transmission BTDF sampling functions
===============================================================================================*/

#pragma once

void SpecularRefraction_SampleMaterial(
	float3 RayDirection,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	out float3 OutDirection,
	out float3 OutWeight,
	out float OutPdf,
	out float OutPositionBiasSign)
{
	// NOTE: IsFrontFace() determines polygon orientation, because the normal is always flipped towards in the incoming ray
	bool bIsEntering = Payload.IsFrontFace();
	float3 WorldNormal = GetWorldNormal(Payload);

	// #dxr_todo: Maintain a refraction stack on the path tracing payload
	// #dxr_todo Determine if parameterization from Specular is still the proper path forward
	//float Ior = Payload.Ior;
	float Ior = DielectricF0ToIor(DielectricSpecularToF0(Payload.Specular));
	float Eta = bIsEntering ? Ior : 1.0 / Ior;

	// Throughput is 1 since we pick reflect/refract according to the fresnel term
	OutWeight = 1.0;
	OutPdf = POSITIVE_INFINITY;

	if (SampleRefraction(RayDirection, WorldNormal, Eta, RandSample.x, OutDirection))
	{
		OutPositionBiasSign = -1;
	}
	else
	{
		OutPositionBiasSign = 1;
	}
} 

void SpecularTransmission_EvalMaterial(out float3 OutThroughput, out float OutPdf)
{
	OutThroughput = 0;
	OutPdf = 0;
}