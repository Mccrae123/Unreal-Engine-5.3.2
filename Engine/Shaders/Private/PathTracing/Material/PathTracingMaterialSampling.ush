// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingMaterialSampling.usf: Material sampling functions
===============================================================================================*/

#pragma once

#include "PathTracingMaterialCommon.ush"
#include "PathTracingFresnel.ush"
#include "PathTracingLambert.ush"
#include "PathTracingRadianceProbe.ush"
#include "PathTracingGlossy.ush"
#include "PathTracingSpecularReflection.ush"
#include "PathTracingSpecularTransmission.ush"
#include "PathTracingDefaultLit.ush"
#include "PathTracingClearCoat.ush"
#include "PathTracingTwoSidedFoliage.ush"

#ifndef FORCE_ALL_MATERIALS_DIFFUSE
	#define FORCE_ALL_MATERIALS_DIFFUSE 0
#endif

bool IsNeeValidMaterial(FMaterialClosestHitPayload Payload)
{
	// Checks done in the same order as other sampling and evaluation functions to ensure consistency
	
#if FORCE_ALL_MATERIALS_DIFFUSE
	return true;
#else

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_MODULATE ||
		Payload.BlendingMode == RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT)
	{
		return false;
	}

	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			return false;
		case SHADINGMODELID_DEFAULT_LIT:		
		case SHADINGMODELID_CLEAR_COAT:			
		case SHADINGMODELID_TWOSIDED_FOLIAGE:	
		default:
			return true;
	}
#endif
}

void SampleMaterial(
	float3 RayDirection,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	bool bForceRadianceProbe,
	out float3 OutDirection,
	out float3 OutWeight,
	out float OutPdf,
	out float OutPositionBiasSign)
{
	OutPositionBiasSign = 1;
	
	if (bForceRadianceProbe)
	{
		RadianceProbe_SampleMaterial(Payload, RandSample, OutDirection, OutWeight, OutPdf);
		return;
	}
	
#if FORCE_ALL_MATERIALS_DIFFUSE
	{
		Lambert_SampleMaterial(Payload, RandSample, OutDirection, OutWeight, OutPdf);
	}
#else

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_MODULATE)
	{
		OutDirection = RayDirection;
		OutWeight = Payload.Radiance;
		OutPdf = POSITIVE_INFINITY;
		OutPositionBiasSign = -1;
		return;
	}

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT)
	{
		OutDirection = RayDirection;
		OutWeight = 1;
		OutPdf = POSITIVE_INFINITY;
		OutPositionBiasSign = -1;
		return;
	}

	// Decide the overall weight of the BRDF portion vs. the translucent portion
	// Note that the translucent portion could be refraction, transparency or SSS
	float BrdfWeight = 1;
	float TransWeight = 0;
	float BrdfProb = 1;
	switch (Payload.BlendingMode)
	{
		case RAY_TRACING_BLEND_MODE_TRANSLUCENT:
			BrdfWeight = 1;
			TransWeight = 1;
			BrdfProb = Payload.Opacity;
			break;
		case RAY_TRACING_BLEND_MODE_ADDITIVE:
			BrdfWeight = 1 + Payload.Opacity;
			TransWeight = 1 + Payload.Opacity;
			BrdfProb = Payload.Opacity / (1 + Payload.Opacity);
			break;
		case RAY_TRACING_BLEND_MODE_ALPHA_COMPOSITE:
			BrdfWeight = 2 - Payload.Opacity;;
			TransWeight = 2 - Payload.Opacity;
			BrdfProb = 1 / (2 - Payload.Opacity);
			break;
		default:
			// opaque or one of the modes handled above
			break;
	}

	if (RandSample.x < BrdfProb)
	{
		// we randomly decided to sample the brdf portion of the material
		RandSample.x /= BrdfProb;
	}
	else
	{
		// we randomly decided to sample the translucent portion
		RandSample.x = (RandSample.x - BrdfProb) / (1 - BrdfProb);
		// now decide what to do based on blend mode
		if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_TRANSLUCENT && Payload.Ior != 1.0)
		{
			// refraction model
			if (Payload.Roughness == 0)
			{
				SpecularRefraction_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
			}
			else
			{
				RoughGlass_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
			}
			OutWeight *= TransWeight;
			OutPdf *= 1 - BrdfProb;
		}
		else
		{
			// plain transparency
			OutDirection = RayDirection;
			OutWeight = TransWeight;
			OutPdf = POSITIVE_INFINITY; // * 1 - BrdfProb
			OutPositionBiasSign = -1;
		}
		return;
	}

	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			// Nothing to do, material does not scatter light
			OutDirection = 0;
			OutWeight = 0;
			OutPdf = 0;
			return;
		case SHADINGMODELID_DEFAULT_LIT:
			DefaultLit_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_CLEAR_COAT:
			ClearCoat_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_TWOSIDED_FOLIAGE:
			TwoSidedFoliage_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
			break;
		default:
			Lambert_SampleMaterial(Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
	}

	// final adjustment to weight / prob based on the stochastic decision for translucency earlier
	OutWeight *= BrdfWeight;
	OutPdf *= BrdfProb;
#endif
}

void EvalMaterial(
	float3 IncomingDirection,
	float3 OutgoingDirection,
	FMaterialClosestHitPayload Payload,
	bool bForceRadianceProbe,
	out float3 OutWeight,
	out float OutPdf
)
{
	if (bForceRadianceProbe)
	{
		RadianceProbe_EvalMaterial(OutgoingDirection, Payload, OutWeight, OutPdf);
		return;
	}
	
#if FORCE_ALL_MATERIALS_DIFFUSE
	{
		Lambert_EvalMaterial(OutgoingDirection, Payload, OutWeight, OutPdf);
	}
#else

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_MODULATE ||
		Payload.BlendingMode == RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT)
	{
		OutWeight = 0;
		OutPdf = 0;
		return;
	}

	// Decide the overall weight of the BRDF portion vs. the translucent portion
	// Note that the translucent portion could be refraction, transparency or SSS
	float BrdfWeight = 1;
	float TransWeight = 0;
	float BrdfProb = 1;
	switch (Payload.BlendingMode)
	{
		case RAY_TRACING_BLEND_MODE_TRANSLUCENT:
			// brdf:   Opacity
			// glass:  1.0 - Opacity
			BrdfWeight = 1;
			TransWeight = 1;
			BrdfProb = Payload.Opacity;
			break;
		case RAY_TRACING_BLEND_MODE_ADDITIVE:
			// brdf:   Opacity
			// transp: 1.0
			BrdfWeight = 1 + Payload.Opacity;
			TransWeight = 1 + Payload.Opacity;
			BrdfProb = Payload.Opacity / (1 + Payload.Opacity);
			break;
		case RAY_TRACING_BLEND_MODE_ALPHA_COMPOSITE:
			// brdf:   1.0
			// transp: 1.0 - Opacity
			BrdfWeight = 2 - Payload.Opacity;;
			TransWeight = 2 - Payload.Opacity;
			BrdfProb = 1 / (2 - Payload.Opacity);
			break;
		default:
			// opaque or one of the modes handled above
			break;
	}

	// NOTE: the translucent portions are all singular -- so we can ignore them in the eval method for now as they have Pdf=+inf for a single direction only

	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			OutWeight = 0.0;
			OutPdf = 0.0;
			break;
		case SHADINGMODELID_DEFAULT_LIT:
			DefaultLit_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_CLEAR_COAT:
			ClearCoat_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_TWOSIDED_FOLIAGE:
			TwoSidedFoliage_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		default:
			Lambert_EvalMaterial(OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
	}

	// final adjustment to weight / prob for translucency
	OutWeight *= BrdfWeight;
	OutPdf *= BrdfProb;

	if (BrdfProb < 1.0)
	{
		if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_TRANSLUCENT && Payload.Ior != 1.0)
		{
			// refraction model (only evaluate for rough case as singular can't be evaluated)
			if (Payload.Roughness != 0)
			{
				float3 GlassWeight = 0;
				float GlassPdf = 0;
				RoughGlass_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, GlassWeight, GlassPdf);

				AddLobeWithMIS(OutWeight, OutPdf, GlassWeight, GlassPdf, 1.0 - BrdfProb);
			}
		}
	}
#endif
}


void PdfMaterial(
	float3 IncomingDirection,
	float3 OutgoingDirection,
	FMaterialClosestHitPayload Payload,
	bool bForceRadianceProbe,
	out float OutPdf
)
{
	// NOTE: rely on compiler to optimize unused calculations
	float3 Weight = 0;
	EvalMaterial(IncomingDirection, OutgoingDirection, Payload, bForceRadianceProbe, Weight, OutPdf);
}
