// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingRayGenShader.usf: Reference path tracing
===============================================================================================*/

#define PATH_TRACING  

#include "../Common.ush"
#include "../PostProcessCommon.ush"
#include "../RectLight.ush"
#include "../RayTracing/RayTracingCommon.ush"

#include "PathTracingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"

#include "../ShadingModels.ush"
#include "./Utilities/PathTracingRandomSequence.ush"
#include "./Light/PathTracingLightSampling.ush"
#include "./Material/PathTracingMaterialSampling.ush"
#include "PathTracingCamera.ush"


RWTexture2D<float4> RadianceTexture;
RaytracingAccelerationStructure TLAS;
int3 TileOffset;

void AccumulateRadiance(inout float3 TotalRadiance, float3 PathRadiance)
{
	if (PathTracingData.MaxPathIntensity > 0)
	{
		// User asked for path contributions to be clamped to reduce fireflies.
		// Depending on how aggressive this value is, the image could be quite biased
		TotalRadiance += min(PathRadiance, PathTracingData.MaxPathIntensity);
	}
	else
	{
		// Just average values directly
		TotalRadiance += PathRadiance;
	}
}

RAY_TRACING_ENTRY_RAYGEN(PathTracingMainRG)
{
	uint2 LaunchIndex = DispatchRaysIndex().xy + View.ViewRectMin.xy + TileOffset.xy;
	
	// Initialize random sequence 
	float2 BufferSize = View.BufferSizeAndInvSize.xy; 
	uint LinearIndex = LaunchIndex.x + (LaunchIndex.y * BufferSize.x); 
	RandomSequence RandSequence;

	if (PathTracingData.UseErrorDiffusion)
	{
		// z-sampler init
		RandomSequence_Initialize(RandSequence, LaunchIndex, PathTracingData.Iteration, PathTracingData.TemporalSeed - PathTracingData.Iteration, PathTracingData.MaxSamples);
	}
	else
	{
		// random sobol init
		RandomSequence_Initialize(RandSequence, LinearIndex, PathTracingData.TemporalSeed);
	}

	float3 Radiance = 0;

	// Initialize ray and payload
	RayDesc Ray;
	uint2 Pixel;
	float EmitterPdf;
	SampleEmitter(LaunchIndex, RandSequence, 0, 0, Ray, Pixel, EmitterPdf);

	// This array will hold a CDF for light picking
	// Seed the array with a uniform CDF at first so that we always have a valid CDF
	float LightPickingCdf[RAY_TRACING_LIGHT_COUNT_MAXIMUM];

	InitLightPickingCdf(LightPickingCdf);

	Ray.Direction = normalize(Ray.Direction);

	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;

	// Cast ray
	const uint InitialRayFlags = 0;
	const bool bInitialDisableSkyLightContribution = false;
	const bool bIgnoreTranslucentMaterials = false;

	// path state variables (these cary information between bounces)
	float3 PathThroughput = 1.0;

	// 0: only Material sampling
	// 1: only Light sampling
	// 2: both Material and Light
	const int MISMode = PathTracingData.MISMode;

	for (int Bounce = 0; Bounce <= PathTracingData.MaxBounces; Bounce++)
	{
		FMaterialClosestHitPayload Payload = TraceMaterialRay(
			TLAS,
			InitialRayFlags,
			RAY_TRACING_MASK_ALL,
			Ray,
			RayCone,
			LaunchIndex,
			bInitialDisableSkyLightContribution,
			bIgnoreTranslucentMaterials);

		// directly visible lights
		if (Bounce == 0 && SceneLightCount > 0)
		{
			uint NumLights = 0;
			if (PathTracingData.VisibleLights)
			{
				// user wants to see all lights
				NumLights = SceneLightCount;
			}
			else if (IsEnvironmentLight(0))
			{
				// user doesn't want to see all lights - still check the first one in case its a skydome (there can be only one, and it always comes first if it is there)
				NumLights = 1;
			}
			// Loop over lights to capture their contribution
			// #dxr_todo: if we have lots of lights, having some hierarchical structure would be better ....
			for (uint LightId = 0; LightId < NumLights; ++LightId)
			{
				float HitT = Payload.IsMiss() ? Ray.TMax : Payload.HitT;
				float3 LightRadiance = TraceLight(Ray, LightId, HitT).xyz;
				AccumulateRadiance(Radiance, PathThroughput * LightRadiance);
			}
		}

		if (Payload.IsMiss())
		{
			// Ray didn't hit any real geometry, so nothing left to do
			break;
		}

		if (Payload.ShadingModelID == SHADINGMODELID_SUBSURFACE)
		{
			// for now just approximate SSS by moving it into the diffuse color
			Payload.DiffuseColor += Payload.CustomData.xyz;
			Payload.Opacity = 1; // overwrite radius
			Payload.ShadingModelID == SHADINGMODELID_DEFAULT_LIT;
		}

		// add in surface emission (except for modulate blend mode which uses Radiance as the transparency multiplier)
		if (Payload.BlendingMode != RAY_TRACING_BLEND_MODE_MODULATE)
		{
			AccumulateRadiance(Radiance, PathThroughput * Payload.Radiance);
		}

		if (Bounce == PathTracingData.MaxBounces)
		{
			// we've arrived at the last bounce - nothing left to do
			break;
		}

		// Update origin
		Ray.Origin = Payload.WorldPos;

		// Make sure the surface normal points toward the viewer
		if (dot(Ray.Direction, Payload.WorldNormal) > 0.0)
		{
			Payload.WorldNormal = -Payload.WorldNormal;
		}

		// Choose a random number for both Light sampling and BxDF sampling
		float4 RandSample = RandomSequence_GenerateSample4D(RandSequence);

		// Does this material require NEE? (will be false if MaterialPdf is always +inf)
		bool bIsNeeValid = IsNeeValidMaterial(Payload);

		// If we are using Light sampling and the material can use it ...
		if (MISMode != 0 && bIsNeeValid && SceneLightCount > 0)
		{
			// Choose a light and sample it
			float3 WorldPos = Payload.WorldPos;
			float3 WorldNormal = Payload.WorldNormal;
			uint PrimitiveLightingChannelMask = Payload.PrimitiveLightingChannelMask;

			bool IsTransmissiveMaterial = ENABLE_TRANSMISSION && IsMaterialTransmissive(Payload);

			if (InitLightPickingCdf(WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial, LightPickingCdf))
			{
				// init worked
				int LightId;
				float LightPickPdf = 0;

				SelectLight(RandSample.x, LightPickingCdf, LightId, LightPickPdf);

				RayDesc LightRay;
				LightRay.Origin = WorldPos;
				LightRay.TMin = 0;
				float3 RadianceOverPdf;
				float LightPdf;
				SampleLight(LightId, RandSample, WorldPos, WorldNormal,
					LightRay.Direction,
					LightRay.TMax,
					RadianceOverPdf,
					LightPdf);
				RadianceOverPdf /= LightPickPdf;
				LightPdf *= LightPickPdf;
				if (LightPdf > 0)
				{
					float SignedPositionBias = 1.0;
					if (IsTransmissiveMaterial)
					{
						// for transmissive materials, bias the position to the other side of the surface if the light is coming from behind
						float NoL = dot(Payload.WorldNormal, LightRay.Direction);
						SignedPositionBias = sign(NoL);
					}
					ApplyPositionBias(LightRay, SignedPositionBias * Payload.WorldNormal, PathTracingData.MaxNormalBias);

					bool LightIsVisible = true;
					if (CastsShadow(LightId))
					{
						const uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
						const uint InstanceInclusionMask = RAY_TRACING_MASK_SHADOW;

						FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;

						TraceVisibilityRayPacked(PackedPayload, TLAS, RayFlags, InstanceInclusionMask, LaunchIndex, LightRay);

						LightIsVisible = PackedPayload.IsMiss();
					}

					// #dxr_todo: Is it cheaper to fire the ray first? Or eval the material first?
					if (LightIsVisible)
					{
						// Evaluate material
						float3 MaterialWeight;
						float MaterialPdf = 0.0;
						EvalMaterial(Ray.Direction, LightRay.Direction, Payload, false, MaterialWeight, MaterialPdf);

						float3 MaterialEval = MaterialWeight * MaterialPdf;

						float MISWeight = MISMode == 2 ? MISWeightRobust(LightPdf, MaterialPdf) : 1.0;

						// Record the contribution
						AccumulateRadiance(Radiance, MISWeight * PathThroughput * RadianceOverPdf * MaterialEval);
					}
				}
			}
		}

		// Sample material
		float3 Direction;
		float3 MaterialWeight;
		float SignedPositionBias;
		float MaterialSamplePdf;
		SampleMaterial(Ray.Direction, Payload, RandSample, false, Direction, MaterialWeight, MaterialSamplePdf, SignedPositionBias);

		if (MaterialSamplePdf < 0 || asuint(MaterialSamplePdf) > 0x7F800000)
		{
			// Pdf became invalid (either negative or NaN)
			Radiance = float3(1, 0, 1);
			break;
		}

		if (!(MaterialSamplePdf > 0))
		{
			// No valid direction -- we are done
			break;
		}

		float3 NextPathThroughput = PathThroughput * MaterialWeight;
		if (!any(NextPathThroughput > 0))
		{
			// no energy left in this path
			break;
		}

		// Russian roulette:
		//   The probability of keeping the path should be roughly proportional to the weight at the current shade point,
		//  but just using MaterialWeight would miss out on cases where the path throughput changes color (like in a cornell
		//  box when bouncing between walls of different colors). So use the ratio of the brightest color channel in the
		//  previous and next throughput.
		//   The second tweak is to add a sqrt() around the probability to soften the termination probability (paths will last
		//  a little longer). This allows paths to go a bit deeper than the naive heuristic while still allowing them to terminate
		//  early. This makes RR effective from the very first bounce without needing to delay it.
		float ContinuationProb = sqrt(saturate(max(NextPathThroughput.x, max(NextPathThroughput.y, NextPathThroughput.z)) / max(PathThroughput.x, max(PathThroughput.y, PathThroughput.z))));
		if (ContinuationProb < 1)
		{
			// If there is some chance we should terminate the ray, draw an extra random value
			float RussianRouletteRand = RandSample.w; // SampleMaterial does not use this value at the moment
			//RussianRouletteRand = RandomSequence_GenerateSample1D(RandSequence);
			if (RussianRouletteRand >= ContinuationProb)
			{
				// stochastically terminate the path
				break;
			}
			PathThroughput = NextPathThroughput / ContinuationProb;
		}
		else
		{
			PathThroughput = NextPathThroughput;
		}

		// Update ray according to material sample
		Ray.Direction = Direction;
		Ray.TMin = 0;
		Ray.TMax = POSITIVE_INFINITY;
		ApplyPositionBias(Ray, SignedPositionBias * Payload.WorldNormal, PathTracingData.MaxNormalBias);

		// If we are using Material sampling for lights
		if (MISMode != 1)
		{
			// Check which lights can be seen by the material ray and trace a dedicated shadow ray
			// While it would be possible to just loop around and use the indirect ray to do this, it would prevent the application
			// of shadow ray specific logic for transparent shadows or various per light tricks like shadow casting
			float PreviousCdfValue = 0.0;
			for (uint LightId = 0; LightId < SceneLightCount; ++LightId)
			{
				if ((Payload.PrimitiveLightingChannelMask & GetLightingChannelMask(LightId)) == 0)
				{
					// light does not affect the current ray
					continue;
				}

				float HitT = Ray.TMax;
				float4 LightResult = TraceLight(Ray, LightId, HitT);
				float3 LightRadiance = LightResult.xyz;

				float3 LightContrib = PathThroughput * LightRadiance;
				if (MISMode == 2)
				{
					float LightPdf = LightResult.w;
					float LightPickPdf =  LightPickingCdf[LightId] - PreviousCdfValue;
					PreviousCdfValue = LightPickingCdf[LightId];

					LightPdf *= LightPickPdf;
					LightContrib *= MISWeightRobust(MaterialSamplePdf, LightPdf);
				}

				if (any(LightContrib > 0))
				{
					bool LightIsVisible = true;
					if (CastsShadow(LightId))
					{
						const uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
						const uint InstanceInclusionMask = RAY_TRACING_MASK_SHADOW;
						FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;
						RayDesc LightRay = Ray;
						LightRay.TMax = HitT;
						TraceVisibilityRayPacked(PackedPayload, TLAS, RayFlags, InstanceInclusionMask, LaunchIndex, LightRay);
						LightIsVisible = PackedPayload.IsMiss();
					}
					if (LightIsVisible)
					{
						// the light made some contribution, and there was nothing along the shadow ray
						AccumulateRadiance(Radiance, LightContrib);
					}
				}
			}
		}
	}


	// Accumulate radiance and update pixel variance
	uint NumSamples = PathTracingData.Iteration + 1;
	float BlendFactor = 1.0 / float(NumSamples);
	// Avoid reading the old pixel on the first sample on the off-chance there is a NaN/Inf pixel ...
	float4 OldPixel = NumSamples > 1 ? RadianceTexture[LaunchIndex] : 0;
	float3 OldRadiance = OldPixel.rgb;
	float OldVariance = OldPixel.a;

	float3 NewRadiance = lerp(OldRadiance, Radiance, BlendFactor);

	float RadianceY = Luminance(Radiance);

	// https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm
	float DeviationSquared = (RadianceY - Luminance(NewRadiance)) * (RadianceY - Luminance(OldRadiance));
	float NewVariance = lerp(OldVariance, DeviationSquared, BlendFactor);

	RadianceTexture[LaunchIndex] = float4(NewRadiance, NewVariance);
}
