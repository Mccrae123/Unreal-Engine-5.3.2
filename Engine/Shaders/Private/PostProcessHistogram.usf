// Copyright Epic Games, Inc. All Rights Reserved.

#include "Common.ush"
#include "PostProcessHistogramCommon.ush"

//------------------------------------------------------- CONFIG

#define GROUP_SIZE 16

// Number of independent histogram in DLS to reduce atomic contention.
#define CONFIG_HISTOGRAM_COUNT ((GROUP_SIZE * GROUP_SIZE) / HISTOGRAM_SIZE)

#define CONFIG_LOOP_SIZE 8

#define CONFIG_QUANTIZATION 64.0


//------------------------------------------------------- PARAMETERS


float2 InputSceneColorViewportExtentInverse;
uint4 InputSceneColorViewportMinMax;
Texture2D<float3> InputSceneColorTexture;
RWStructuredBuffer<uint> HistogramOutput;

float AreaNormalizeFactor;
Texture2D EyeAdaptationTexture;
StructuredBuffer<uint> HistogramBuffer;
RWTexture2D<float4> HistogramTextureOutput;


//------------------------------------------------------- LDS

groupshared uint SharedHistograms[HISTOGRAM_SIZE * CONFIG_HISTOGRAM_COUNT];


//------------------------------------------------------- ENTRY POINT

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	// Clear the shared histogram in one go. Use all 256 threads to clear 4x 64 bin histograms.
	SharedHistograms[GroupThreadIndex] = 0;
	 
	GroupMemoryBarrierWithGroupSync();

	uint2 GroupThreadId = uint2(GroupThreadIndex % GROUP_SIZE, GroupThreadIndex / GROUP_SIZE);
	uint2 GroupOffset = uint(GROUP_SIZE * CONFIG_LOOP_SIZE) * GroupId.xy + InputSceneColorViewportMinMax.xy;

	LOOP
	for (uint y = 0; y < CONFIG_LOOP_SIZE; y ++)
	{
		BRANCH
		if (GroupOffset.y + y * CONFIG_LOOP_SIZE >= InputSceneColorViewportMinMax.w)
		{
			break;
		}

		bool bProcess[CONFIG_LOOP_SIZE];
		float3 SceneColor[CONFIG_LOOP_SIZE];
		float ScreenWeight[CONFIG_LOOP_SIZE];
		ISOLATE
		{
			UNROLL_N(CONFIG_LOOP_SIZE)
			for (uint x = 0; x < CONFIG_LOOP_SIZE; x++)
			{
				const uint2 TileOffset = uint2(x, y) * GROUP_SIZE;
				uint2 TexelPos = (GroupOffset + TileOffset) + GroupThreadId;
				
				const uint SampleId = x;
				bProcess[SampleId] = all(TexelPos < InputSceneColorViewportMinMax.zw);
				SceneColor[SampleId] = InputSceneColorTexture[TexelPos];

				float2 ScreenUV = float2(TexelPos - InputSceneColorViewportMinMax.xy) * InputSceneColorViewportExtentInverse;
				ScreenWeight[SampleId] = AdaptationWeightTexture(ScreenUV);
			}
		}
			
		UNROLL_N(CONFIG_LOOP_SIZE)
		for (uint SampleId = 0; SampleId < CONFIG_LOOP_SIZE; SampleId++)
		{
			float LuminanceVal = max(dot(SceneColor[SampleId].xyz, float3(1.0f, 1.0f, 1.0f)/3.0f), EyeAdaptation_LuminanceMin);
			float LogLuminance = ComputeHistogramPositionFromLuminance(LuminanceVal);
			
			float fBucket = saturate(LogLuminance) * float((HISTOGRAM_SIZE - 1) * 0.9999f);
			fBucket = clamp(fBucket, float(0.0), float(HISTOGRAM_SIZE - 1.0));

			uint Bucket0 = (uint)(fBucket);
			Bucket0 = clamp(fBucket, 0, HISTOGRAM_SIZE - 1);

			float Weight1 = frac(fBucket) * ScreenWeight[SampleId];
			float Weight0 = (1.0f - Weight1) * ScreenWeight[SampleId];
			
			// accumulate the weight to the nearby history buckets
			// NOTE: Pack "overflow" to next bucket to same counter high bits. This halves the number of atomics. 
			uint PackedHistogram = (uint(Weight1 * CONFIG_QUANTIZATION) << 16) | uint(Weight0 * CONFIG_QUANTIZATION);
                   
			uint Offset = HISTOGRAM_SIZE * (GroupThreadIndex % CONFIG_HISTOGRAM_COUNT);
			
			if (bProcess[SampleId])
			{
				InterlockedAdd(SharedHistograms[Bucket0 + Offset], PackedHistogram);
			}
		}
	} // for (uint y = 0; y < CONFIG_LOOP_SIZE; y ++)

	GroupMemoryBarrierWithGroupSync();

	BRANCH
	if (GroupThreadIndex < HISTOGRAM_SIZE)
	{
		uint Sum = 0;
		
		{
			uint SumLow = 0;
			uint SumHi = 0;

			UNROLL_N(CONFIG_HISTOGRAM_COUNT)
			for (uint LDSHistogramId = 0; LDSHistogramId < CONFIG_HISTOGRAM_COUNT; LDSHistogramId++)
			{
				SumLow += SharedHistograms[GroupThreadIndex + HISTOGRAM_SIZE * LDSHistogramId];
				SumHi += SharedHistograms[GroupThreadIndex + HISTOGRAM_SIZE * LDSHistogramId - 1];
			}

			FLATTEN
			if (GroupThreadIndex == 0)
			{
				Sum = SumLow;
			}
			else
			{
				Sum = (SumLow + (SumHi >> 16));
			}

			Sum = Sum & 0xFFFF;
		}

		// Accumulate groups to shared histogram
		InterlockedAdd(HistogramOutput[GroupThreadIndex], Sum);
	}
}


//------------------------------------------------------- ENTRY POINT

[numthreads(HISTOGRAM_SIZE / 4, 1, 1)]
void MainConvertCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	BRANCH
	if (GroupId.x == 0)
	{
		uint4 HistogramUint = uint4(
			HistogramBuffer[GroupThreadIndex * 4 + 0],
			HistogramBuffer[GroupThreadIndex * 4 + 1],
			HistogramBuffer[GroupThreadIndex * 4 + 2],
			HistogramBuffer[GroupThreadIndex * 4 + 3]);
	
		float4 Luma = float4(HistogramUint) * (rcp(CONFIG_QUANTIZATION) * AreaNormalizeFactor);

		// When EyeAdaptation_BlackHistogramBucketInfluence=.0, we will ignore the last bucket. The main use
		// case is so the black background pixels in the editor have no effect. But if we have cases where
		// pixel values can actually be black, we want to set EyeAdaptation_LastHistogramBucketInfluence=1.0.
		// This value is controlled by the cvar "r.EyeAdaptation.BlackHistogramBucketInfluence"
		Luma.r *= GroupThreadIndex == 0 ? EyeAdaptation_BlackHistogramBucketInfluence : 1.0;

		HistogramTextureOutput[uint2(GroupThreadIndex, 0)] = Luma;
	}
	else
	{
		// line 1: store 4 channels of EyeAdaptationTexture (copied over so we can read the value in EyeAdaptation pass which is writing to eye adaptation)
		float4 OldExposureScale = EyeAdaptationTexture.Load(int3(0, 0, 0));
		
		HistogramTextureOutput[uint2(GroupThreadIndex, 1)] = OldExposureScale;
	}
}
