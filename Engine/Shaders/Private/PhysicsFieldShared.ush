// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PhysicsFieldShared.ush
=============================================================================*/

#pragma once

#include "Common.ush"

#define MAX_TARGETS_ARRAY 16

float3 PhysicsField_ComputeSampleUV(in float3 LocalPosition, in int ClipmapIndex, in float ClipmapDistance, in int ClipmapExponent, in int ClipmapCount)
{
	const float ClipmapExtent = 2.0 * ClipmapDistance * pow((float) ClipmapExponent, (float) (ClipmapIndex + 1 - ClipmapCount));
	return LocalPosition / ClipmapExtent + 0.5;
}

int2 PhysicsField_ComputeTargetOffsets(in int ClipmapIndex, in int TargetIndex, in int TargetCount, in int ClipmapCount, in int ClipmapResolution)
{
	const int ExtentedResolution = ClipmapResolution + 1;
	const int DatasIndex = ClipmapCount * TargetIndex + ClipmapIndex;
	const int DatasCount = ClipmapCount * TargetCount;
	
	return int2(DatasIndex * ExtentedResolution, DatasCount * ExtentedResolution - 1);
}

int PhysicsField_GetClipmapIndex(in float3 LocalPosition, in float ClipmapDistance, in int ClipmapExponent, in int ClipmapCount)
{
	const int3 ClipmapIndices = floor(log(abs(LocalPosition) / ClipmapDistance) / log((float) (ClipmapExponent)) + int3(ClipmapCount, ClipmapCount, ClipmapCount));
	const int ClipmapIndex = max(max(ClipmapIndices[0], ClipmapIndices[1]), ClipmapIndices[2]);
	
	return clamp(ClipmapIndex, 0, ClipmapCount - 1);
}

float3 PhysicsField_SamplePhysicsVectorField(in float3 WorldPosition, in int VectorTarget, in int VectorTargets[MAX_TARGETS_ARRAY], in int TargetCount, in float3 ClipmapCenter,
			in float ClipmapDistance, in int ClipmapExponent, in int ClipmapCount, in int ClipmapResolution, in Texture3D<float4> ClipmapTexture, in SamplerState ClipmapSampler)
{
	const float3 LocalPosition = WorldPosition - ClipmapCenter;
	
	float3 FieldValue = float3(0, 0, 0);
	if (VectorTarget != -1 && VectorTarget < MAX_TARGETS_ARRAY && all(abs(LocalPosition) < float3(ClipmapDistance, ClipmapDistance, ClipmapDistance)))
	{
		const int TargetIndex = VectorTargets[VectorTarget];
		if (TargetIndex != -1)
		{
			const int ClipmapIndex = PhysicsField_GetClipmapIndex(LocalPosition, ClipmapDistance, ClipmapExponent, ClipmapCount);
			float3 SampleUV = PhysicsField_ComputeSampleUV(LocalPosition, ClipmapIndex, ClipmapDistance, ClipmapExponent, ClipmapCount);
			float SampleOffset = SampleUV.z * ClipmapResolution;
			
			const int2 TargetOffsets = PhysicsField_ComputeTargetOffsets(ClipmapIndex, TargetIndex, TargetCount, ClipmapCount, ClipmapResolution);
			SampleUV.z = (TargetOffsets.y != 0) ? (SampleOffset + TargetOffsets.x) / TargetOffsets.y : 0.5;
			FieldValue = ClipmapTexture.SampleLevel(ClipmapSampler, SampleUV, 0).xyz;
		}
	}
	return FieldValue;
}

float PhysicsField_SamplePhysicsScalarField(in float3 WorldPosition, in int ScalarTarget, in int ScalarTargets[MAX_TARGETS_ARRAY], in int TargetCount, in float3 ClipmapCenter,
			in float ClipmapDistance, in int ClipmapExponent, in int ClipmapCount, in int ClipmapResolution, in Texture3D<float4> ClipmapTexture, in SamplerState ClipmapSampler)
{
	const float3 LocalPosition = WorldPosition - ClipmapCenter;
	
	float FieldValue = 0.0;
	if (ScalarTarget != -1 && ScalarTarget < MAX_TARGETS_ARRAY && all(abs(LocalPosition) < float3(ClipmapDistance, ClipmapDistance, ClipmapDistance)))
	{
		const int TargetIndex = ScalarTargets[ScalarTarget];
		if (TargetIndex != -1)
		{
			const int ClipmapIndex = PhysicsField_GetClipmapIndex(LocalPosition, ClipmapDistance, ClipmapExponent, ClipmapCount);
			float3 SampleUV = PhysicsField_ComputeSampleUV(LocalPosition, ClipmapIndex, ClipmapDistance, ClipmapExponent, ClipmapCount);
			float SampleOffset = SampleUV.z * ClipmapResolution;
			
			const int2 TargetOffsets = PhysicsField_ComputeTargetOffsets(ClipmapIndex, TargetIndex, TargetCount, ClipmapCount, ClipmapResolution);
			SampleUV.z = (TargetOffsets.y != 0) ? (SampleOffset + TargetOffsets.x) / TargetOffsets.y : 0.5;
			FieldValue = ClipmapTexture.SampleLevel(ClipmapSampler, SampleUV, 0).w;
		}
	}
	return FieldValue;
}

int PhysicsField_SamplePhysicsIntegerField(in float3 WorldPosition, in int IntegerTarget, in int IntegerTargets[MAX_TARGETS_ARRAY], in int TargetCount, in float3 ClipmapCenter,
			in float ClipmapDistance, in int ClipmapExponent, in int ClipmapCount, in int ClipmapResolution, in Texture3D<float4> ClipmapTexture, in SamplerState ClipmapSampler)
{
	const float3 LocalPosition = WorldPosition - ClipmapCenter;
	
	int FieldValue = 0.0;
	if (IntegerTarget != -1 && IntegerTarget < MAX_TARGETS_ARRAY && all(abs(LocalPosition) < float3(ClipmapDistance, ClipmapDistance, ClipmapDistance)))
	{
		const int TargetIndex = IntegerTargets[IntegerTarget];
		if (TargetIndex != -1)
		{
			const int ClipmapIndex = PhysicsField_GetClipmapIndex(LocalPosition, ClipmapDistance, ClipmapExponent, ClipmapCount);
			float3 SampleUV = PhysicsField_ComputeSampleUV(LocalPosition, ClipmapIndex, ClipmapDistance, ClipmapExponent, ClipmapCount);
			float SampleOffset = SampleUV.z * ClipmapResolution;
			
			const int2 TargetOffsets = PhysicsField_ComputeTargetOffsets(ClipmapIndex, TargetIndex, TargetCount, ClipmapCount, ClipmapResolution);
			SampleUV.z = (TargetOffsets.y != 0) ? (SampleOffset + TargetOffsets.x) / TargetOffsets.y : 0.5;
			FieldValue = ClipmapTexture.SampleLevel(ClipmapSampler, SampleUV, 0).w;
		}
	}
	return FieldValue;
}

