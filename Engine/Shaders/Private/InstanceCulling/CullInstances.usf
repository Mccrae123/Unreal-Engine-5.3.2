// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../Nanite/NaniteDataDecode.ush"
#include "../Nanite/HZBCull.ush"

//StructuredBuffer<FPackedNaniteView> Views;
RWStructuredBuffer<uint> InstanceVisibilityFlagsOut;
uint NumInstances;
uint NumInstanceFlagWords;
uint NumViews;
uint InstanceDataSOAStride;

/**
 */
[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CullInstancesCs(uint InstanceId : SV_DispatchThreadID)
{
	if (InstanceId >= NumInstances)
	{
		return;
	}

	const bool bNearClip = true;

	FInstanceSceneData InstanceData = GetInstanceData(InstanceId, InstanceDataSOAStride);
	uint WordMask = 1U << (InstanceId % 32U);
	uint InstanceWordOffset = InstanceId / 32U;

	bool bIsVisible = InstanceData.PrimitiveId != 0xFFFFFFFFu;

	if (!bIsVisible)
	{
		return;
	}

	for (uint ViewId = 0; ViewId < NumViews; ++ViewId)
	{
		FNaniteView NaniteView = GetNaniteView(ViewId);

		float4x4 LocalToTranslatedWorld = InstanceData.LocalToWorld;
		LocalToTranslatedWorld[3].xyz += NaniteView.PreViewTranslation.xyz;
		float4x4 LocalToClip = mul(LocalToTranslatedWorld, NaniteView.TranslatedWorldToClip);

		FFrustumCullData Cull = BoxCullFrustum(InstanceData.LocalBoundsCenter, InstanceData.LocalBoundsExtent, LocalToClip, bNearClip, false);

		uint Flag = (Cull.bIsVisible ? WordMask : 0U);

		// TODO: we can use ballot etc to do this without atomics (and without clearing) - but it would need to be portable and not sure if 
		// we'll keep this code anyway.
		if (Flag != 0U)
		{
			uint WordOffset = NumInstanceFlagWords * ViewId + InstanceWordOffset;
			InterlockedOr(InstanceVisibilityFlagsOut[WordOffset], Flag);
		}
	}
}
