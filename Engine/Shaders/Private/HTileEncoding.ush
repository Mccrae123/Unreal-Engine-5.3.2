#pragma once

#include "Common.ush"

#ifdef OVERRIDE_HTILELOOKUP_USH

	#include "/Platform/Private/HTileLookup.ush"

#else

	uint ComputeTileOffset(uint2 PixelPos, uint PixelsWide, uint PlatformConfig)
	{
		return 0;
	}

#endif

#ifndef PLATFORM_SUPPORTS_HTILE_LOOKUP
#define PLATFORM_SUPPORTS_HTILE_LOOKUP 0
#endif

uint EncodeTileDepth(float Depth, uint DepthBias, bool bReverseZ, bool bHiStencil)
{
	const float MaxDepthRange = float((1 << 14) - 1);

	int DepthInt;
	if (bReverseZ)
	{
		// Smaller depth values are further away
		DepthInt = int(floor(Depth * MaxDepthRange));
	}
	else
	{
		// Larger depth values are further away
		DepthInt = int(ceil(Depth * MaxDepthRange));
	}

	const uint FinalDepth = clamp(DepthInt + int(DepthBias), 0, int(MaxDepthRange));

	uint HTileValue;
	if (bHiStencil)
	{
		// With hi-stencil, 14 bits for near and a 6 bit delta towards the far plane.
		// With a single depth value, the delta value is zero.
		HTileValue = (FinalDepth << 18);
	}
	else
	{
		// Without hi-stencil, min and max depth are encoded with two 14 bit pairs.
		HTileValue = (FinalDepth << 18) | (FinalDepth << 4);
	}
	
	// The bottom 4 bits is the z-mask, which is set to zero to present 'clear'.
	return HTileValue;
}

#if COMPILER_SUPPORTS_BITFIELD_INTRINSICS

#if COMPILER_SUPPORTS_PACK_INTRINSICS

// Optimized version for no hi-stencil, just min and max depth.
uint EncodeTileMinMaxDepth(float MinDepth, float MaxDepth)
{
	// Convert min and max depth to UNORM14.
	uint HTileValue = PackFloat32ToUNorm16(MinDepth - 0.5 / 65535.0,
										   MaxDepth + 3.5 / 65535.0);

	// Shift up min by 2 bits, then set all four low bits.
	HTileValue = BitFieldInsertU32(BitFieldMaskU32(14, 18), HTileValue, HTileValue << 2);
	// TODO: needs fixing HTILE_ZMASK_EXPANDED is missing now
	#ifdef HTILE_ZMASK_EXPANDED
		return HTileValue |= HTILE_ZMASK_EXPANDED;
	#else
		return HTileValue;
	#endif
}

#endif // COMPILER_SUPPORTS_PACK_INTRINSICS

// Decodes 6 bit depth delta coding for hi-stencil.
uint DecodeDepthDelta(uint DeltaZ)
{
	// 000DDD -> 00000000000DDD
	// 001DDD -> 00000000001DDD
	// 010DDD -> 0000000001DDD1
	// 011DDD -> 000000001DDD11
	// 1000DD -> 00000001DD1111
	// 1001DD -> 0000001DD11111
	// 1010DD -> 000001DD111111
	// 1011DD -> 00001DD1111111
	// 1100DD -> 0001DD11111111
	// 1101DD -> 001DD111111111
	// 1110DD -> 01DD1111111111
	// 1111DD -> 1DD11111111111

	const bool TwoBitDelta = BitFieldExtractU32(DeltaZ, 1, 5);
	const uint DeltaBits   = TwoBitDelta ? 2 : 3;
	const uint Delta       = BitFieldExtractU32(DeltaZ, DeltaBits, 0);
	const uint Code        = BitFieldExtractU32(DeltaZ, 3, DeltaBits);

	const uint LeadingOne = Code + (TwoBitDelta ? 6 : 2);
	const uint Ones = (1 << (LeadingOne + 1)) - 1;
	const uint DeltaStart = (LeadingOne >= DeltaBits) ? (LeadingOne - DeltaBits) : 0;

	const uint Mask = BitFieldMaskU32(DeltaBits, DeltaStart);
	return BitFieldInsertU32(Mask, Delta << DeltaStart, Ones);
}

// Decodes the hi-z information in the tile as a 14 bit integer min and max.
uint2 DecodeTileMinMax(uint HTileValue, bool HiStencil, bool CompareMinZ)
{
	uint MinZ;
	uint MaxZ;

	if (HiStencil)
	{
		const uint ZBase  = BitFieldExtractU32(HTileValue, 14, 18); // 14 bit fixed point.
		const uint ZDelta = BitFieldExtractU32(HTileValue,  6, 12); //  6 bit delta coding.

		// Base is closest to near plane; delta is towards far plane.
		MinZ = CompareMinZ ? (ZBase - DecodeDepthDelta(ZDelta)) : ZBase;
		MaxZ = CompareMinZ ?  ZBase : (ZBase + DecodeDepthDelta(ZDelta));
	}
	else
	{
		// Both values are 14 bit fixed point.
		MinZ = BitFieldExtractU32(HTileValue, 14,  4);
		MaxZ = BitFieldExtractU32(HTileValue, 14, 18);
	}

	return uint2(MinZ, MaxZ);
}

// Decodes the hi-stencil information in the tile as a pair of 2 bit values.
uint2 ExtractTileHiStencil(uint HTileValue, bool HiStencil)
{
	uint HiStencil0;
	uint HiStencil1;

	if (HiStencil)
	{
		HiStencil0 = BitFieldExtractU32(HTileValue, 2, 4);
		HiStencil1 = BitFieldExtractU32(HTileValue, 2, 6);
	}
	else
	{
		HiStencil0 = 0;
		HiStencil1 = 0;
	}

	return uint2(HiStencil0, HiStencil1);
}

#endif // COMPILER_SUPPORTS_BITFIELD_INTRINSICS

struct HTileEncodingData
{
	int4 HiStencilModeTable[64];
};

/*
const uint HiStencilModeTable[64][4] =
{
	{0x0000}, // 00000000000000
	{0x0001}, // 00000000000001
	{0x0002}, // 00000000000010
	{0x0003}, // 00000000000011
	{0x0004}, // 00000000000100
	{0x0005}, // 00000000000101
	{0x0006}, // 00000000000110
	{0x0007}, // 00000000000111

	{0x0008}, // 00000000001000
	{0x0009}, // 00000000001001
	{0x000a}, // 00000000001010
	{0x000b}, // 00000000001011
	{0x000c}, // 00000000001100
	{0x000d}, // 00000000001101
	{0x000e}, // 00000000001110
	{0x000f}, // 00000000001111

	{0x0011}, // 00000000010001
	{0x0013}, // 00000000010011
	{0x0015}, // 00000000010101
	{0x0017}, // 00000000010111
	{0x0019}, // 00000000011001
	{0x001b}, // 00000000011011
	{0x001d}, // 00000000011101
	{0x001f}, // 00000000011111

	{0x0023}, // 00000000100011
	{0x0027}, // 00000000100111
	{0x002b}, // 00000000101011
	{0x002f}, // 00000000101111
	{0x0033}, // 00000000110011
	{0x0037}, // 00000000110111
	{0x003b}, // 00000000111011
	{0x003f}, // 00000000111111

	{0x004f}, // 00000001001111
	{0x005f}, // 00000001011111
	{0x006f}, // 00000001101111
	{0x007f}, // 00000001111111

	{0x009f}, // 00000010011111
	{0x00bf}, // 00000010111111
	{0x00df}, // 00000011011111
	{0x00ff}, // 00000011111111

	{0x013f}, // 00000100111111
	{0x017f}, // 00000101111111
	{0x01bf}, // 00000110111111
	{0x01ff}, // 00000111111111

	{0x027f}, // 00001001111111
	{0x02ff}, // 00001011111111
	{0x037f}, // 00001101111111
	{0x03ff}, // 00001111111111

	{0x04ff}, // 00010011111111
	{0x05ff}, // 00010111111111
	{0x06ff}, // 00011011111111
	{0x07ff}, // 00011111111111

	{0x09ff}, // 00100111111111
	{0x0bff}, // 00101111111111
	{0x0dff}, // 00110111111111
	{0x0fff}, // 00111111111111

	{0x13ff}, // 01001111111111
	{0x17ff}, // 01011111111111
	{0x1bff}, // 01101111111111
	{0x1fff}, // 01111111111111

	{0x27ff}, // 10011111111111
	{0x2fff}, // 10111111111111
	{0x37ff}, // 11011111111111
	{0x3fff}, // 11111111111111
};
*/
