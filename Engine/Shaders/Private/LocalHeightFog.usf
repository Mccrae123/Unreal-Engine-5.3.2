// Copyright Epic Games, Inc. All Rights Reserved.

#include "Common.ush"
#include "SceneTexturesCommon.ush"
#include "HeightFogCommon.ush"
#include "ParticipatingMediaCommon.ush"


struct FLocalHeightFogGPUInstanceData
{
	float4x4 Transform;
	float4x4 InvTransform;

	float4x4 InvTranformNoScale;
	float4x4 TransformScaleOnly;

	float Density;
	float HeightFalloff;
	float HeightOffset;
	float RadialAttenuation;

	float3 Albedo;
	float  PhaseG;
	float3 Emissive;
	float RadialAttenuationHermiteTangent;
};

StructuredBuffer<FLocalHeightFogGPUInstanceData> LocalHeightFogInstances;


struct FLocalHeightFogVertexOutput
{
	nointerpolation uint InstanceId : TEXCOORD0;
};

void LocalHeightFogSplatVS(
	in float4 InPosition : ATTRIBUTE0,
	uint InstanceIndex : SV_InstanceID,
	out float4 OutPosition : SV_POSITION,
	out FLocalHeightFogVertexOutput OtherVertexOutput
)
{
	ResolvedView = ResolveView();

	float4 LocalPosition = InPosition;

	FLocalHeightFogGPUInstanceData FogInstance = LocalHeightFogInstances[InstanceIndex];

	float4x4 FogTransform = FogInstance.Transform;

	float4 WorldPosition = mul(float4(LocalPosition.xyz, 1.0f), FogTransform);

	float4 TranslatedWorldPosition = float4(WorldPosition.xyz + LWCHackToFloat(PrimaryView.PreViewTranslation), 1);

	OutPosition = mul(TranslatedWorldPosition, PrimaryView.TranslatedWorldToClip);
	OtherVertexOutput.InstanceId = InstanceIndex;
} 

// CameraPos can be behind of RayStart if the camera is out of the volume
struct FFogData
{
	float IntegratedLuminanceFactor;
	float Coverage;
};

// Height fog is evaluated according to spatially varying density defined as "Density * Exp[-HeightFalloff * z]"
FFogData EvaluateHeightFogIntegral(FLocalHeightFogGPUInstanceData FogInstance,  float3 CameraPos, float3 RayStart, float3 RayDir, float RayLength, float RadialAttenuation)
{
	FFogData FogData;

	float StartHeight = RayStart.z - FogInstance.HeightOffset; // accoutn for the fog offset.

	float OpticalDepth = 0.0f;
#if 1
	// Original integral, less artefact
	OpticalDepth = (FogInstance.Density / FogInstance.HeightFalloff) * exp(-StartHeight * FogInstance.HeightFalloff) * (1.0 - exp(-RayDir.z * RayLength * FogInstance.HeightFalloff)) / RayDir.z;
#elif 0
	// Reworked to avoid large value as input to exp
	OpticalDepth = (FogInstance.Density / FogInstance.HeightFalloff) * (exp(-StartHeight * FogInstance.HeightFalloff) - exp(-StartHeight * FogInstance.HeightFalloff - RayDir.z * RayLength * FogInstance.HeightFalloff)) / RayDir.z;
#endif

	// Transmittance is the 
	float Transmittance = exp(-OpticalDepth);
	// Assuming extinction is grey scale, we can compute a single coverage value from transmittance
	FogData.Coverage = (1.0 - Transmittance) * RadialAttenuation;
	// Assuming extinction==scattering, i.e. albedo=1, we can compute the integrale for each point on a ray while accouting for transmittance back to the view.
	// It turns out that, under these conditions, the luminance and emissive factor is simply coverage. => see Mathematica details at the bottom of this page.
	FogData.IntegratedLuminanceFactor = FogData.Coverage;

	return FogData;
}


float3 ComputeFogInscattering(in FLocalHeightFogGPUInstanceData FogInstance, in FFogData FogData, in float3 RayDirWorld)
{
	half3 InScattering = 0;

#if PROJECT_SUPPORT_SKY_ATMOSPHERE_AFFECTS_HEIGHFOG
	InScattering +=  Texture2DSampleLevel(View.DistantSkyLightLutTexture, View.DistantSkyLightLutTextureSampler, float2(0.5f, 0.5f), 0.0f).rgb;

	// No need to test View.AtmosphereLightIlluminanceOnGroundPostTransmittance[0].a because InscatteringLightDirection.w above is doing the same test already.
	InScattering += View.AtmosphereLightIlluminanceOnGroundPostTransmittance[0].rgb * SchlickPhase(-FogInstance.PhaseG, dot(RayDirWorld, View.AtmosphereLightDirection[0].xyz));

	if (View.AtmosphereLightIlluminanceOnGroundPostTransmittance[1].a > 0.0f) // Skip the second light when disabled.
	{
		InScattering += View.AtmosphereLightIlluminanceOnGroundPostTransmittance[0].rgb * SchlickPhase(-FogInstance.PhaseG, dot(RayDirWorld, View.AtmosphereLightDirection[1].xyz));
	}
#endif

	InScattering *= FogInstance.Albedo * View.SkyAtmosphereHeightFogContribution.xxx;

	// Now account for emissive luminance after albedo and heighfog contribution has been accounted for.
	InScattering += FogInstance.Emissive;

	return InScattering * FogData.IntegratedLuminanceFactor;
}

#define LHFV_FOLLOWS_ROTATIONS 1

void LocalHeightFogSplatPS(
	in float4 SVPos : SV_POSITION,
	in FLocalHeightFogVertexOutput OtherVertexOutput,
	out float4 OutColor : SV_Target0)
{
	ResolvedView = ResolveView();
	uint InstanceIndex = OtherVertexOutput.InstanceId;

	float3 CamRayTranslatedWorldOrigin	= PrimaryView.TranslatedWorldCameraOrigin;
	float3 CamRayTranslatedWorldDir = normalize(SvPositionToTranslatedWorld(float4(SVPos.xy, 0.5, 1.0)));
	float3 CamRayWorldDir = CamRayTranslatedWorldDir;

	FLocalHeightFogGPUInstanceData FogInstance = LocalHeightFogInstances[InstanceIndex];
	float4x4 Transform = FogInstance.Transform;
	float4x4 InvTransform = FogInstance.InvTransform;

	OutColor = float4(0, 0, 0, 1);

	float3 CamRayWorldOrigin = CamRayTranslatedWorldOrigin - LWCHackToFloat(PrimaryView.PreViewTranslation);

	// The "U" prefix is for all compuation done in the Unit Sphere space.
	float3 RayPosU = mul(float4(CamRayWorldOrigin,        1.0f), FogInstance.InvTransform).xyz;
	float3 RayDirU = mul(float4(CamRayTranslatedWorldDir, 0.0f), FogInstance.InvTransform).xyz; // Try to use InverseTranspose to correctly handle direction transform with scaling.
	RayDirU.xyz = normalize(RayDirU);

	float2 TsU = RayIntersectSphere(RayPosU, RayDirU, float4(0.0, 0.0, 0.0, 1.0));
	if (any(TsU > 0.0))
	{
		const float DeviceZ = LookupDeviceZ(uint2(SVPos.xy));
		float3 DepthBufferTranslatedWorldPos = SvPositionToTranslatedWorld(float4(SVPos.xy, DeviceZ, 1.0));
		float LengthD = length(DepthBufferTranslatedWorldPos - CamRayTranslatedWorldOrigin);

		float3 P0U = RayPosU + max(0.0, TsU.x) * RayDirU;
		float3 P1U = RayPosU + max(0.0, TsU.y) * RayDirU;
#if LHFV_FOLLOWS_ROTATIONS
		// Computations are all done transformed with Space = local fog volume but ignoring scaling.
		float3 P0Space = mul(float4(P0U, 1.0), FogInstance.TransformScaleOnly).xyz;
		float3 P1Space = mul(float4(P1U, 1.0), FogInstance.TransformScaleOnly).xyz;
		float3 CamRayOriginSpace = mul(float4(CamRayWorldOrigin, 1.0), FogInstance.InvTranformNoScale).xyz;
		float3 CamRayDirSpace    = mul(float4(CamRayWorldDir,    0.0), FogInstance.InvTranformNoScale).xyz;	// No scale so no need for a special InverseTranspose matrix.
		CamRayDirSpace = normalize(CamRayDirSpace);
#else
		// Computations are all done with Space = world space
		float3 P0Space = mul(float4(P0U, 1.0), FogInstance.Transform).xyz;
		float3 P1Space = mul(float4(P1U, 1.0), FogInstance.Transform).xyz;
		float3 CamRayOriginSpace = CamRayWorldOrigin;
		float3 CamRayDirSpace    = CamRayWorldDir;
#endif

		float Length0 = length(P0Space - CamRayOriginSpace);
		float Length1 = length(P1Space - CamRayOriginSpace);

		// Radial attenuation based on the distance travelled in the unit sphere and ignoring depth buffer intersection. 
		// This is only to soften sphere edge.
		float RadialAttenuation = saturate(abs(max(0.0, TsU.y) - max(0.0, TsU.x)) / FogInstance.RadialAttenuation);
		// The attenuation is linear but it can be made soft using an Hermit interpolation by controling the tangents.
		{
			const float t = RadialAttenuation;
			const float t2 = t * t;
			const float t3 = t2 * t;
			const float HP0 = 0;
			const float HM0 = saturate(FogInstance.RadialAttenuationHermiteTangent);
			const float HP1 = 1;
			const float HM1 = saturate(FogInstance.RadialAttenuationHermiteTangent);
			RadialAttenuation = saturate((2 * t3 - 3 * t2 + 1) * HP0 + (t3 - 2 * t2 + t) * HM0 + (-2 * t3 + 3 * t2) * HP1 + (t3 - t2) * HM1);
		}

		// Clamp the traced distance to depth and compute world length.
		Length0 = min(LengthD, Length0);
		Length1 = min(LengthD, Length1);
		float RayTracedLength = max(0.0, abs(Length1 - Length0));

		if (RayTracedLength > 0.0)
		{
			FFogData FogData = EvaluateHeightFogIntegral(FogInstance, CamRayOriginSpace, CamRayOriginSpace + CamRayDirSpace * Length0, CamRayDirSpace, RayTracedLength, RadialAttenuation);

			OutColor.xyz	= ComputeFogInscattering(FogInstance, FogData, CamRayWorldDir);	// = Luminance
			OutColor.a		= 1.0 - FogData.Coverage;										// = Transmittance
		}
		else
		{
			clip(-1.0);
		}

		OutColor.xyz *= PrimaryView.PreExposure;
	}
	else
	{
		clip(-1.0);
	}
}


/*

Proof of the height fog integral equations using Mathematica

(*Density of matter according to height Y*)
Density [y_] := A * Exp[-B * y]
 
(*Ray position*)
Ray[t_] := Oz + t * Rz

(*Integrate Optical Depth for a distance T*)
Fog[T_] := Integrate[Density[Ray[t]], {t, 0, T}]

(*Optical Depth integration equation*)
Fog[T]

(*Transmittance from Optical Depth*)
Exp[-Integrate[Density[Ray[t]], {t, 0, T}]]

(*Transmittance from a position to the origin of tracing*)
Trans[T_] := Exp[-Integrate[Density[Ray[t]], {t, 0, T}]]

(*Integrate emissive and scattering from height fog, assuming density \
is extinction and extinction=scattering, thus albedo=1*)
Integrate[Density[Ray[t]]*EmSc *Trans[t], {t, 0, T}]

=> this leads to EmSc - Transmittance * EmSc
				 EmSc * (1 - Transmittance)
				 EmSc * Coverage

*/