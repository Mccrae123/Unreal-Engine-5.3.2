// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct FTraceRayInlineTraversalStatistics
{
	uint NodeIntersectionCount;
	uint ClusterIntersectionCount;
	uint TriangleIntersectionCount;
	uint IterationCount;

	uint WaveNodeIntersectionCount;
	uint WaveTriangleIntersectionCount;

	uint RayCount;
	uint WavefrontCount;

	uint ActiveLaneCount;
	uint TotalLaneCount;
};

static FTraceRayInlineTraversalStatistics TraceRayInlineTraversalStatistics_Sample;
RWStructuredBuffer<FTraceRayInlineTraversalStatistics> TraceRayInlineTraversalStatistics_Accumulator;

void TraceRayInlineAccumulateStatistics()
{
#if ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
	if (WaveIsFirstLane())
	{
		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].RayCount, TraceRayInlineTraversalStatistics_Sample.RayCount);
		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].WavefrontCount, TraceRayInlineTraversalStatistics_Sample.WavefrontCount);

		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].ActiveLaneCount, TraceRayInlineTraversalStatistics_Sample.ActiveLaneCount);
		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].TotalLaneCount, TraceRayInlineTraversalStatistics_Sample.TotalLaneCount);

		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].IterationCount, TraceRayInlineTraversalStatistics_Sample.IterationCount);

		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].WaveNodeIntersectionCount, TraceRayInlineTraversalStatistics_Sample.WaveNodeIntersectionCount);
		InterlockedAdd(TraceRayInlineTraversalStatistics_Accumulator[0].WaveTriangleIntersectionCount, TraceRayInlineTraversalStatistics_Sample.WaveTriangleIntersectionCount);
	}
#endif
}

struct FTraceRayInlineResult
{
	float HitT;
	float2 Barycentrics;
	uint InstanceIndex;
	uint InstanceID;
	uint InstanceContributionToHitGroupIndex;
	uint GeometryIndex;
	uint PrimitiveIndex;
	bool bIsFrontFace;

	uint Bookmark[2];

	// Only valid when PLATFORM_SUPPORTS_INLINE_RAY_TRACING_INSTANCE_MATRIX is 1
	float3x4 ObjectToWorld3x4;

	// Only valid when PLATFORM_SUPPORTS_INLINE_RAY_TRACING_TRIANGLE_NORMALS is 1
	float3 WorldGeometryNormal;

	// Can be false only if PLATFORM_SUPPORTS_INLINE_RAY_TRACING_MAX_ITERATIONS is 1
	bool bIsCompleted;

	// Only valid if shader was compiled with ENABLE_TRACE_RAY_INLINE_TRAVERSAL_STATISTICS
	FTraceRayInlineTraversalStatistics TraversalStatistics;

	bool IsMiss() { return HitT < 0; }
	bool IsHit() { return !IsMiss(); }

	void SetMiss() { HitT = -1; }
};

struct FTraceRayInlineContext
{
	// Only used if PLATFORM_SUPPORTS_INLINE_RAY_TRACING_MAX_ITERATIONS is 1
	uint MaxIterations;

	// Only used if shader was compiled with ENABLE_TRACE_RAY_INLINE_PROCEDURAL_PRIMITIVE
	bool bProcedural;
	float NaniteCutError;
};

FTraceRayInlineContext CreateTraceRayInlineContext()
{
	FTraceRayInlineContext Context;
	Context.bProcedural = false;
	Context.MaxIterations = 0xFFFFFFFF;
	Context.NaniteCutError = 0.0f;
	return Context;
}
