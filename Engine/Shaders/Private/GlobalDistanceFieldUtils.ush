// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	GlobalDistanceFieldUtils.ush
=============================================================================*/

uint ComputeGlobalDistanceFieldClipmapIndex(float3 WorldPosition)
{
	uint FoundClipmapIndex = 0;

	for (uint ClipmapIndex = 0; ClipmapIndex < NumGlobalSDFClipmaps; ClipmapIndex++)
	{
		float DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[ClipmapIndex].xyz, GlobalVolumeCenterAndExtent[ClipmapIndex].www, WorldPosition);

		if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize)
		{
			FoundClipmapIndex = ClipmapIndex;
			break;
		}
	}

	return FoundClipmapIndex;
}

struct FGlobalSDFTraceInput
{
	float3 WorldRayStart;
	float3 WorldRayDirection;
	float MinTraceDistance;
	float MaxTraceDistance;
	float StepFactor;
	float MinStepFactor;
	// The SDF surface is expanded to reduce leaking through thin surfaces, especially foliage meshes with bGenerateDistanceFieldAsIfTwoSided
	// Expanding as RayTime increases errors on the side of over-occlusion, especially at grazing angles, which can be desirable for diffuse GI.
	// Expanding as MaxDistance increases has less incorrect self-intersection which is desirable for reflections rays.
	bool bExpandSurfaceUsingRayTimeInsteadOfMaxDistance;
	float InitialMaxDistance;
};

FGlobalSDFTraceInput SetupGlobalSDFTraceInput(float3 InWorldRayStart, float3 InWorldRayDirection, float InMinTraceDistance, float InMaxTraceDistance, float InStepFactor, float InMinStepFactor)
{
	FGlobalSDFTraceInput TraceInput;
	TraceInput.WorldRayStart = InWorldRayStart;
	TraceInput.WorldRayDirection = InWorldRayDirection;
	TraceInput.MinTraceDistance = InMinTraceDistance;
	TraceInput.MaxTraceDistance = InMaxTraceDistance;
	TraceInput.StepFactor = InStepFactor;
	TraceInput.MinStepFactor = InMinStepFactor;
	TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance = true;
	TraceInput.InitialMaxDistance = 0;
	return TraceInput;
}

struct FGlobalSDFTraceResult
{
	float HitTime;
	uint HitClipmapIndex;
	uint TotalStepsTaken;

	bool IsHit()
	{ 
		return HitTime >= 0.0f;
	}
};

FGlobalSDFTraceResult RayTraceGlobalDistanceField(FGlobalSDFTraceInput TraceInput)
{
	FGlobalSDFTraceResult TraceResult;
	TraceResult.HitTime = -1.0f;
	TraceResult.HitClipmapIndex = 0;
	TraceResult.TotalStepsTaken = 0;

	uint MinClipmapIndex = ComputeGlobalDistanceFieldClipmapIndex(TraceInput.WorldRayStart);
	float MaxDistance = TraceInput.InitialMaxDistance;

	// Bias
	float RayStartDistance = max(TraceInput.MinTraceDistance, GlobalVolumeCenterAndExtent[MinClipmapIndex].w * GlobalVolumeTexelSize);
	float SampleRayTime = RayStartDistance;

	int3 VoxelStep = (TraceInput.WorldRayDirection < 0) ? int3(-1, -1, -1) : int3(1, 1, 1);
	const float NumPagesPerClipmap = GlobalDistanceFieldClipmapSizeInPages;
	const float InvNumPagesPerClipmap = rcp(NumPagesPerClipmap);

	LOOP
	for (uint ClipmapIndex = MinClipmapIndex; ClipmapIndex < NumGlobalSDFClipmaps && TraceResult.HitTime < 0.0f && SampleRayTime < TraceInput.MaxTraceDistance; ++ClipmapIndex)
	{
		float3 GlobalVolumeCenter = GlobalVolumeCenterAndExtent[ClipmapIndex].xyz;
		float GlobalVolumeExtent = GlobalVolumeCenterAndExtent[ClipmapIndex].w;

		float VoxelSize = 2.0f * GlobalVolumeExtent * InvNumPagesPerClipmap;
		float3 GlobalClipmapMin = GlobalVolumeCenter - GlobalVolumeExtent;
		float3 GlobalClipmapSize = 2.0f * GlobalVolumeExtent;

		float3 SampleWorldPosition = TraceInput.WorldRayStart + TraceInput.WorldRayDirection * SampleRayTime;
		int3 VoxelCoord = NumPagesPerClipmap * (SampleWorldPosition - GlobalClipmapMin) / GlobalClipmapSize;
		float3 VoxelMin = (VoxelCoord - 0.0f) * VoxelSize + GlobalClipmapMin;
		float3 VoxelMax = (VoxelCoord + 1.0f) * VoxelSize + GlobalClipmapMin;
		float3 MaxNegT = (VoxelMin - TraceInput.WorldRayStart) / TraceInput.WorldRayDirection;
		float3 MaxPosT = (VoxelMax - TraceInput.WorldRayStart) / TraceInput.WorldRayDirection;
		float3 NextVoxelFaceT = (TraceInput.WorldRayDirection < 0) ? MaxNegT : MaxPosT;
		float3 VoxelFaceStepT = abs(VoxelSize / TraceInput.WorldRayDirection);

		float ClipmapVoxelExtent = GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize;
		float MinStepSize = TraceInput.MinStepFactor * ClipmapVoxelExtent;
		float ExpandSurfaceDistance = ClipmapVoxelExtent;
		const float ClipmapInfluenceRange = GLOBAL_DISTANCE_FIELD_INFLUENCE_RANGE_IN_VOXELS * 2.0f * GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize;

		uint StepIndex = 0;
		const uint MaxSteps = 256;

		LOOP
		for (; StepIndex < MaxSteps; ++StepIndex)
		{
			int3 PageTableCoord = frac(VoxelCoord * InvNumPagesPerClipmap + GlobalDistanceFieldPageTableScrollOffset[ClipmapIndex]) * NumPagesPerClipmap
				+ int3(0, 0, ClipmapIndex * GlobalDistanceFieldClipmapSizeInPages);

			const uint PageIndex = GlobalDistanceFieldPageTableTexture.Load(int4(PageTableCoord, 0));
			const float MinNextVoxelFaceT = min3(NextVoxelFaceT.x, NextVoxelFaceT.y, NextVoxelFaceT.z);

			if (PageIndex != GLOBAL_DISTANCE_FIELD_INVALID_PAGE_ID && SampleRayTime < MinNextVoxelFaceT)
			{
				float3 BasePagePos = -(GlobalClipmapMin + VoxelCoord * VoxelSize) / VoxelSize;
				float3 BasePageCoord = GlobalDistanceFieldPageLinearIndexToPageAtlasCoord(PageIndex) + BasePagePos * GLOBAL_DISTANCE_FIELD_PAGE_RESOLUTION + 1.0f;
				float3 BasePageUV = BasePageCoord * GlobalDistanceFieldInvPageAtlasSize;

				// Trace single page
				LOOP
				for (; StepIndex < MaxSteps; ++StepIndex)
				{
					SampleWorldPosition = TraceInput.WorldRayStart + TraceInput.WorldRayDirection * SampleRayTime;
					float3 PageUV = BasePageUV + (SampleWorldPosition / VoxelSize) * GLOBAL_DISTANCE_FIELD_PAGE_RESOLUTION * GlobalDistanceFieldInvPageAtlasSize;

					float DistanceFieldValue = Texture3DSampleLevel(GlobalDistanceFieldPageAtlasTexture, GlobalTrilinearWrappedSampler, PageUV, 0).x;
					float DistanceField = DecodeGlobalDistanceFieldPageDistance(DistanceFieldValue, ClipmapInfluenceRange);

					MaxDistance = max(DistanceField, MaxDistance);
					float ExpandSurfaceTime = TraceInput.bExpandSurfaceUsingRayTimeInsteadOfMaxDistance ? SampleRayTime : MaxDistance;

					float ExpandSurfaceFalloff = ExpandSurfaceDistance;
					float ExpandSurfaceAmount = ExpandSurfaceDistance * saturate((ExpandSurfaceTime - ExpandSurfaceFalloff) / ExpandSurfaceFalloff);

					if (DistanceField < ExpandSurfaceAmount)
					{
						TraceResult.HitTime = max(SampleRayTime + DistanceField - ExpandSurfaceAmount, RayStartDistance);
						TraceResult.HitClipmapIndex = ClipmapIndex;
						break;
					}

					float StepDistance = max(DistanceField * TraceInput.StepFactor, MinStepSize);
					SampleRayTime += StepDistance;

					// Terminate the trace if we went past the end of page or hit something
					if (SampleRayTime >= MinNextVoxelFaceT || SampleRayTime >= TraceInput.MaxTraceDistance)
					{
						break;
					}
				}
			}

			// Step to the next voxel (page)
			uint3 StepInc = int3(NextVoxelFaceT == MinNextVoxelFaceT);
			SampleRayTime = max(SampleRayTime, MinNextVoxelFaceT);
			NextVoxelFaceT += StepInc * VoxelFaceStepT;
			VoxelCoord += StepInc * VoxelStep;

			// Next clipmap if we are out of bounds
			if (any(VoxelCoord < 0) || any(VoxelCoord >= NumPagesPerClipmap) || TraceResult.HitTime >= 0.0f || SampleRayTime > TraceInput.MaxTraceDistance)
			{
				break;
			}
		}

		TraceResult.TotalStepsTaken += StepIndex;
	}

	if (TraceResult.HitTime > TraceInput.MaxTraceDistance)
	{
		TraceResult.HitTime = -1;
	}

	return TraceResult;
}