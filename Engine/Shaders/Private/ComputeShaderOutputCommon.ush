// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ComputeShaderOutputCommon.ush: To allow CS input/output passed into functions 
through a single struct, allowing for a more readable code
(less #ifdefs, reducing the boolean hell)
=============================================================================*/

#include "ShaderOutputCommon.ush"
#include "GammaCorrectionCommon.ush"
#include "VariableRateShading/VRSShadingRateCommon.ush"
#include "Nanite/NaniteShadeCommon.ush"

// .xy = min, .zw = max
uint4 ViewRect;

// .x = shading bin, y = VRS tile size, .z = Quad Binning Flag, .w = unused
uint4 PassData; 

// TODO: Is this ever used? (see bHighPrecisionGBuffers)
#define HIGH_PRECISION_GBUFFERS 0

#if STRATA_OPAQUE_DEFERRED
	#if STRATA_BASE_PASS_MRT_OUTPUT_COUNT != 3
		#error Strata STRATA_BASE_PASS_MRT_OUTPUT_COUNT has been updated but not the uint MRTs
	#endif
	#if PIXELSHADEROUTPUT_MRT3
		#error Strata cannot map to such a case
	#endif
#endif

#if PIXELSHADEROUTPUT_MRT0
	#if DUAL_SOURCE_COLOR_BLENDING_ENABLED && MATERIAL_WORKS_WITH_DUAL_SOURCE_COLOR_BLENDING
		RWTexture2D<float4> OutTarget0UAV; // DUAL_SOURCE_BLENDING_SLOT(0)
	#else
		RWTexture2D<float4> OutTarget0UAV;
	#endif
#endif

#if PIXELSHADEROUTPUT_MRT1
	#if DUAL_SOURCE_COLOR_BLENDING_ENABLED && MATERIAL_WORKS_WITH_DUAL_SOURCE_COLOR_BLENDING
		RWTexture2D<float4> OutTarget1UAV; // DUAL_SOURCE_BLENDING_SLOT(1)
	#else
		RWTexture2D<float4> OutTarget1UAV;
	#endif
#endif

#if PIXELSHADEROUTPUT_MRT2
	RWTexture2D<float4> OutTarget2UAV;
#endif

#if STRATA_OPAQUE_DEFERRED
	#if PIXELSHADEROUTPUT_MRT2
		RWTexture2D<uint> StrataOutput3UAV;
		RWTexture2D<uint> StrataOutput4UAV;
		RWTexture2D<uint> StrataOutput5UAV;
		RWTexture2D<uint> StrataOutput6UAV;
	#elif PIXELSHADEROUTPUT_MRT1
		RWTexture2D<uint> StrataOutput2UAV;
		RWTexture2D<uint> StrataOutput3UAV;
		RWTexture2D<uint> StrataOutput4UAV;
		RWTexture2D<uint> StrataOutput5UAV;
	#else
		RWTexture2D<uint> StrataOutput1UAV;
		RWTexture2D<uint> StrataOutput2UAV;
		RWTexture2D<uint> StrataOutput3UAV;
		RWTexture2D<uint> StrataOutput4UAV;
	#endif

#else // STRATA_OPAQUE_DEFERRED

	#if PIXELSHADEROUTPUT_MRT3
		RWTexture2D<float4> OutTarget3UAV;
	#endif

	#if PIXELSHADEROUTPUT_MRT4
		RWTexture2D<float4> OutTarget4UAV;
	#endif

	#if PIXELSHADEROUTPUT_MRT5
		RWTexture2D<float4> OutTarget5UAV;
	#endif

	#if PIXELSHADEROUTPUT_MRT6
		RWTexture2D<float4> OutTarget6UAV;
	#endif

	#if PIXELSHADEROUTPUT_MRT7
		RWTexture2D<float4> OutTarget7UAV;
	#endif

#endif // STRATA_OPAQUE_DEFERRED

FPixelShaderOut ShadePixel(const uint2 PixelPos, uint QuadIndex)
{
#if PIXELSHADEROUTPUT_INTERPOLANTS || PIXELSHADEROUTPUT_BASEPASS
#if IS_NANITE_PASS
	FNaniteFullscreenVSToPS NaniteInterpolants = (FNaniteFullscreenVSToPS)0;
	NaniteInterpolants.TileIndex = QuadIndex;
#else
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
#endif
#endif

#if IS_NANITE_PASS && (PIXELSHADEROUTPUT_INTERPOLANTS || PIXELSHADEROUTPUT_BASEPASS)
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
	Interpolants.ViewIndex = NaniteInterpolants.ViewIndex; // TODO: NANITE_MATERIAL_MULTIVIEW
#endif

	FPixelShaderIn PixelShaderIn = (FPixelShaderIn)0;
	FPixelShaderOut PixelShaderOut = (FPixelShaderOut)0;

	const float2 HalfPixelOffset = float2(0.5f, 0.5f);
	PixelShaderIn.SvPosition = float4(float2(PixelPos) + HalfPixelOffset, 0.0f, 1.0f);

	// Nanite does not support OPTIONAL_IsFrontFace, Instead, Nanite determines this in GetMaterialPixelParameters().
	PixelShaderIn.bIsFrontFace = false;

#if PIXELSHADEROUTPUT_BASEPASS
	FBasePassInterpolantsVSToPS BasePassInterpolants = (FBasePassInterpolantsVSToPS)0;
	FPixelShaderInOut_MainPS(Interpolants, BasePassInterpolants, PixelShaderIn, PixelShaderOut);
#endif

#if !HIGH_PRECISION_GBUFFERS
	PixelShaderOut.MRT[3] = float4(LinearToSrgb(PixelShaderOut.MRT[3].rgb), PixelShaderOut.MRT[3].a); // BaseColor is sRGB
#endif

	return PixelShaderOut;
}

FPixelShaderOut WaveReadLaneAt(FPixelShaderOut ShadedPixel, uint SrcIndex)
{
	FPixelShaderOut Result = (FPixelShaderOut)0;

#if PIXELSHADEROUTPUT_MRT0
	Result.MRT[0] = WaveReadLaneAt(ShadedPixel.MRT[0], SrcIndex);
#endif

#if PIXELSHADEROUTPUT_MRT1
	Result.MRT[1] = WaveReadLaneAt(ShadedPixel.MRT[1], SrcIndex);
#endif

#if PIXELSHADEROUTPUT_MRT2
	Result.MRT[2] = WaveReadLaneAt(ShadedPixel.MRT[2], SrcIndex);
#endif

#if STRATA_OPAQUE_DEFERRED

	Result.StrataOutput[0]		= WaveReadLaneAt(ShadedPixel.StrataOutput[0],		SrcIndex);
	Result.StrataOutput[1]		= WaveReadLaneAt(ShadedPixel.StrataOutput[1],		SrcIndex);
	Result.StrataOutput[2]		= WaveReadLaneAt(ShadedPixel.StrataOutput[2],		SrcIndex);
	Result.StrataTopLayerData	= WaveReadLaneAt(ShadedPixel.StrataTopLayerData,	SrcIndex);

#else // STRATA_OPAQUE_DEFERRED

#if PIXELSHADEROUTPUT_MRT3
	Result.MRT[3] = WaveReadLaneAt(ShadedPixel.MRT[3], SrcIndex);
#endif

#if PIXELSHADEROUTPUT_MRT4
	Result.MRT[4] = WaveReadLaneAt(ShadedPixel.MRT[4], SrcIndex);
#endif

#if PIXELSHADEROUTPUT_MRT5
	Result.MRT[5] = WaveReadLaneAt(ShadedPixel.MRT[5], SrcIndex);
#endif

#if PIXELSHADEROUTPUT_MRT6
	Result.MRT[6] = WaveReadLaneAt(ShadedPixel.MRT[6], SrcIndex);
#endif

#if PIXELSHADEROUTPUT_MRT7
	Result.MRT[7] = WaveReadLaneAt(ShadedPixel.MRT[7], SrcIndex);
#endif

#endif // STRATA_OPAQUE_DEFERRED

	Result.Coverage	= WaveReadLaneAt(ShadedPixel.Coverage, SrcIndex);
	Result.Depth	= WaveReadLaneAt(ShadedPixel.Depth, SrcIndex);

	return Result;
}

void ExportPixel(const float2 PixelPos, FPixelShaderOut ShadedPixel)
{
#if PIXELSHADEROUTPUT_COVERAGE || PIXELSHADEROUTPUT_A2C
	// TODO: OutCoverage = PixelShaderOut.Coverage;
#endif 

#if OUTPUT_PIXEL_DEPTH_OFFSET
	// TODO: OutDepth = PixelShaderOut.Depth;
#endif 

#if PIXELSHADEROUTPUT_MRT0
	OutTarget0UAV[PixelPos] = ShadedPixel.MRT[0];
#endif

#if PIXELSHADEROUTPUT_MRT1
	OutTarget1UAV[PixelPos] = ShadedPixel.MRT[1];
#endif

#if PIXELSHADEROUTPUT_MRT2
	OutTarget2UAV[PixelPos] = ShadedPixel.MRT[2];
#endif

#if PIXELSHADEROUTPUT_MRT3
	OutTarget3UAV[PixelPos] = ShadedPixel.MRT[3];
#endif

#if STRATA_OPAQUE_DEFERRED

	// In this case, here is the gbuffer pattern
	// MRT0 is pixel color
	// MRT1 is velocity if enabled or precomputed shadow if velocity if disabled and precomputed shadow enabled
	// MRT2 is precomputed shadow if both velocity and prec shadow are enabled.
	// After, Strata output are appended (3 uint output)

#if PIXELSHADEROUTPUT_MRT3
	StrataOutput4UAV[PixelPos] = ShadedPixel.StrataOutput[0];
	StrataOutput5UAV[PixelPos] = ShadedPixel.StrataOutput[1];
	StrataOutput6UAV[PixelPos] = ShadedPixel.StrataOutput[2];
	StrataOutput7UAV[PixelPos] = ShadedPixel.StrataTopLayerData;
#elif PIXELSHADEROUTPUT_MRT2
	StrataOutput3UAV[PixelPos] = ShadedPixel.StrataOutput[0];
	StrataOutput4UAV[PixelPos] = ShadedPixel.StrataOutput[1];
	StrataOutput5UAV[PixelPos] = ShadedPixel.StrataOutput[2];
	StrataOutput6UAV[PixelPos] = ShadedPixel.StrataTopLayerData;
#elif PIXELSHADEROUTPUT_MRT1
	StrataOutput2UAV[PixelPos] = ShadedPixel.StrataOutput[0];
	StrataOutput3UAV[PixelPos] = ShadedPixel.StrataOutput[1];
	StrataOutput4UAV[PixelPos] = ShadedPixel.StrataOutput[2];
	StrataOutput5UAV[PixelPos] = ShadedPixel.StrataTopLayerData;
#else
	StrataOutput1UAV[PixelPos] = ShadedPixel.StrataOutput[0];
	StrataOutput2UAV[PixelPos] = ShadedPixel.StrataOutput[1];
	StrataOutput3UAV[PixelPos] = ShadedPixel.StrataOutput[2];
	StrataOutput4UAV[PixelPos] = ShadedPixel.StrataTopLayerData;
#endif

#else // STRATA_OPAQUE_DEFERRED

#if PIXELSHADEROUTPUT_MRT4
	OutTarget4UAV[PixelPos] = ShadedPixel.MRT[4];
#endif

#if PIXELSHADEROUTPUT_MRT5
	OutTarget5UAV[PixelPos] = ShadedPixel.MRT[5];
#endif

#if PIXELSHADEROUTPUT_MRT6
	OutTarget6UAV[PixelPos] = ShadedPixel.MRT[6];
#endif

#if PIXELSHADEROUTPUT_MRT7
	OutTarget7UAV[PixelPos] = ShadedPixel.MRT[7];
#endif

#endif // STRATA_OPAQUE_DEFERRED
}

struct FShadingQuadSwizzle
{
	bool bActiveLane;
	uint SwizzleIndex;
};

FShadingQuadSwizzle GetShadingQuad(uint QuadX, uint QuadY, uint LaneIndex, uint ShadingRate)
{
	FShadingQuadSwizzle ShadingQuad;

	// https://microsoft.github.io/DirectX-Specs/d3d/HLSL_SM_6_6_Derivatives.html
	// https://microsoft.github.io/DirectX-Specs/d3d/VariableRateShading.html
	
	// D3D12_SHADING_RATE_1X1
	ShadingQuad.bActiveLane = true;
	ShadingQuad.SwizzleIndex = LaneIndex;

	const uint QuadIndex = QuadX * QuadY * 2u;

#if 1
	const bool bTopLeft		= ((QuadIndex & 3u) == 0u);
	const bool bTopRight	= ((QuadIndex & 3u) == 1u);
	const bool bBottomLeft	= ((QuadIndex & 3u) == 2u);
	const bool bBottomRight	= ((QuadIndex & 3u) == 3u);
#else
	// To test the QuadRead swizzles
	const int XSigned = int(X);
	const int YSigned = int(Y);
	int LaneXDelta = QuadReadAcrossX(XSigned) - XSigned;
	int LaneYDelta = QuadReadAcrossY(YSigned) - YSigned;
	const bool bTopLeft		= (LaneXDelta > 0 && LaneYDelta > 0);
	const bool bTopRight	= (LaneXDelta < 0 && LaneYDelta > 0);
	const bool bBottomLeft	= (LaneXDelta > 0 && LaneYDelta < 0);
	const bool bBottomRight	= (LaneXDelta < 0 && LaneYDelta < 0);
#endif

	if (ShadingRate == D3D12_SHADING_RATE_1X2)
	{
		// [A]
		// [B]
		ShadingQuad.bActiveLane  = (QuadIndex & 1u) == 0u;
		ShadingQuad.SwizzleIndex = select(ShadingQuad.bActiveLane, LaneIndex, QuadReadAcrossX(LaneIndex));
	}
	else if (ShadingRate == D3D12_SHADING_RATE_2X1)
	{
		// [A][B]
		ShadingQuad.bActiveLane  = (QuadIndex & 1u) == 0u;
		ShadingQuad.SwizzleIndex = select(ShadingQuad.bActiveLane, LaneIndex, QuadReadAcrossY(LaneIndex));
	}
	else if (ShadingRate == D3D12_SHADING_RATE_2X2)
	{
		// [A][B]
		// [C][D]
		ShadingQuad.bActiveLane  = (QuadIndex & 3u) == 0u;
		ShadingQuad.SwizzleIndex = 
			select(
				ShadingQuad.bActiveLane,
				LaneIndex,
				select(
					bBottomRight,
					QuadReadAcrossDiagonal(LaneIndex),
					select(
						bBottomLeft,
						QuadReadAcrossY(LaneIndex),
						QuadReadAcrossX(LaneIndex)
					)
				)
			)
		;
	}
	else if (ShadingRate == D3D12_SHADING_RATE_2X4) // not generated yet
	{
		// [A][B]
		// [C][D]
		// [E][F]
		// [G][H]
	}
	else if (ShadingRate == D3D12_SHADING_RATE_4X2) // not generated yet
	{
		// [A][B][C][D]
		// [E][F][G][H]
	}
	else if (ShadingRate == D3D12_SHADING_RATE_4X4) // not generated yet
	{
		// [A][B][C][D]
		// [E][F][G][H]
		// [I][J][K][L]
		// [M][N][O][P]
	}

	return ShadingQuad;
}

#define VIS_HELPER_LANES 0

[numthreads(64, 1, 1)]
void MainCS(uint ThreadIndex : SV_GroupIndex, uint GroupID : SV_GroupID, uint3 GroupThreadID : SV_GroupThreadID, uint3 DispatchThreadID : SV_DispatchThreadID)
{
	const uint ShadingBin = PassData.x;

	// Just like pixel shaders, compute 2x2 CS quads from thread index so we can leverage the 4 lane cross bar.
	// [0 1][2 3] -> [0 1][4 5]
	// [4 5][6 7] -> [2 3][6 7]
	//const uint SwizzleX = BitFieldInsertU32(BitFieldMaskU32(1u, 0u), ThreadIndex, BitFieldExtractU32(ThreadIndex, 3u, 2u));
	//const uint SwizzleY = BitFieldInsertU32(BitFieldMaskU32(2u, 0u), BitFieldExtractU32(ThreadIndex, 2u, 1u), BitFieldExtractU32(ThreadIndex, 3u, 3u));
	//const uint SampleIndex	= SwizzleX * SwizzleY * 2u;

	const bool bQuadBinning = PassData.z != 0u;

	uint2 PixelPos;
	uint QuadIndex;
	bool bActiveLane = true;

#if VIS_HELPER_LANES
	uint HelperLaneCount = 0u;
#endif

	bool3 PixelCopy = bool3(false, false, false); // H, V, D

	BRANCH
	if (bQuadBinning)
	{
		// New 2x2 shading quad every 4 samples
		const uint CornerIndex = ThreadIndex & 3u;
		QuadIndex = GroupID * 16u + (ThreadIndex >> 2u);

		const bool bIsQuadTL = CornerIndex == 0u;
		const bool bIsQuadTR = CornerIndex == 1u;
		const bool bIsQuadBL = CornerIndex == 2u;
		const bool bIsQuadBR = CornerIndex == 3u;
	
		const uint LaneTL = WaveGetLaneIndex() & ~3u;

		uint PackedQuad = 0u;
		if (bIsQuadTL)
		{
			const uint QuadCount = Nanite.ShadingBinMeta[ShadingBin].x;
			if (QuadIndex < QuadCount)
			{
				const uint QuadStart = Nanite.ShadingBinMeta[ShadingBin].z;
				PackedQuad = Nanite.ShadingBinData[QuadStart + QuadIndex];
			}
		}
		PackedQuad = WaveReadLaneAt(PackedQuad, LaneTL);
		FShadingQuad Quad = UnpackShadingQuad(PackedQuad);
		if (!any(Quad.Coverage))
		{
			// None of the 2x2 pixels have coverage (likely an out of bounds wave).
			return;
		}

		bActiveLane = Quad.Coverage[CornerIndex];

	#if VIS_HELPER_LANES
		HelperLaneCount = 4u;

		UNROLL
		for (uint CoverageIndex = 0; CoverageIndex < 4u; ++CoverageIndex)
		{
			HelperLaneCount -= Quad.Coverage[CoverageIndex] ? 1u : 0u;
		}
	#endif

		// Determine final pixel position on the screen for shading
		PixelPos = Quad.TopLeft + uint2(CornerIndex & 1u, (CornerIndex >> 1u) & 1u);
	}
	else
	{
		const uint PixelIndex = DispatchThreadID.x;
		QuadIndex = PixelIndex;
		const uint PixelCount = Nanite.ShadingBinMeta[ShadingBin].y;
		if (PixelIndex >= PixelCount)
		{
			return;
		}

		const uint PixelStart = Nanite.ShadingBinMeta[ShadingBin].z;
		FShadingPixel Pixel = UnpackShadingPixel(Nanite.ShadingBinData[PixelStart + PixelIndex]);
		PixelPos = Pixel.PosXY;
		PixelCopy = Pixel.Copy;
	}

	// All lanes shade (regardless of export - so ddx/ddy are valid)
	FPixelShaderOut ShadedPixel = ShadePixel(PixelPos, QuadIndex);

#if VIS_HELPER_LANES
	ShadedPixel.MRT[3].rgb = ColorMapTurbo(float(HelperLaneCount) / 4.0f);
#elif 0
	ShadedPixel.MRT[3].rgb = ColorMapTurbo(50.0);
#elif 0
	// Coherency vis
	float R =  (DispatchThreadID.x & 0xFFu) / 255.0f;
	float G = ((DispatchThreadID.x & 0xFF00u) >> 8u) / 255.0f;
	float B = ((DispatchThreadID.x & 0xFF0000u) >> 16u) / 255.0f;
	ShadedPixel.MRT[3].rgb = float3(R, G, B);
#elif 0
	ShadedPixel.MRT[3].rgb = IntToColor(ShadingBin);
#elif 0
	ShadedPixel.MRT[3].rgb = IntToColor(QuadIndex);
#elif 0
	ShadedPixel.MRT[3].rgb = VisualizeShadingRate(ShadingRate).rgb;
#endif

	// Disable helper lanes from final export
	if (bActiveLane)
	{
		ExportPixel(PixelPos, ShadedPixel);

		BRANCH
		if (PixelCopy.x) // Copy H
		{
			ExportPixel(PixelPos + uint2(1, 0), ShadedPixel);
		}

		BRANCH
		if (PixelCopy.y) // Copy V
		{
			ExportPixel(PixelPos + uint2(0, 1), ShadedPixel);
		}

		BRANCH
		if (PixelCopy.z) // Copy D
		{
			ExportPixel(PixelPos + uint2(1, 1), ShadedPixel);
		}
	}
}

