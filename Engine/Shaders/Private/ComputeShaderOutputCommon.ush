// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ComputeShaderOutputCommon.ush: To allow CS input/output passed into functions 
through a single struct, allowing for a more readable code
(less #ifdefs, reducing the boolean hell)
=============================================================================*/

#include "ShaderOutputCommon.ush"
#include "GammaCorrectionCommon.ush"
#include "VariableRateShading/VRSShadingRateCommon.ush"
#include "Nanite/NaniteShadeCommon.ush"

// .xy = min, .zw = max
uint4 ViewRect;

// .x = shading bin, y = VRS tile size, .z = Quad Binning Flag, .w = unused
uint4 PassData; 

// TODO: Is this ever used? (see bHighPrecisionGBuffers)
#define HIGH_PRECISION_GBUFFERS 0

#if STRATA_OPAQUE_DEFERRED
	#if STRATA_BASE_PASS_MRT_OUTPUT_COUNT != 3
		#error Strata STRATA_BASE_PASS_MRT_OUTPUT_COUNT has been updated but not the uint MRTs
	#endif
	#if PIXELSHADEROUTPUT_MRT4
		#error Strata cannot map to such a case
	#endif
#endif

#if PIXELSHADEROUTPUT_MRT0
	#if DUAL_SOURCE_COLOR_BLENDING_ENABLED && MATERIAL_WORKS_WITH_DUAL_SOURCE_COLOR_BLENDING
		RWTexture2D<float4> OutTarget0; // DUAL_SOURCE_BLENDING_SLOT(0)
	#else
		RWTexture2D<float4> OutTarget0;
	#endif
#endif

#if PIXELSHADEROUTPUT_MRT1
	#if DUAL_SOURCE_COLOR_BLENDING_ENABLED && MATERIAL_WORKS_WITH_DUAL_SOURCE_COLOR_BLENDING
		RWTexture2D<float4> OutTarget1; // DUAL_SOURCE_BLENDING_SLOT(1)
	#else
		RWTexture2D<float4> OutTarget1;
	#endif
#endif

#if PIXELSHADEROUTPUT_MRT2
	RWTexture2D<float4> OutTarget2;
#endif

#if STRATA_OPAQUE_DEFERRED
	RWTexture2DArray<uint> OutTargets;

	#if PIXELSHADEROUTPUT_MRT3
		RWTexture2D<STRATA_TOP_LAYER_TYPE> OutTarget4;
	#elif PIXELSHADEROUTPUT_MRT2
		RWTexture2D<STRATA_TOP_LAYER_TYPE> OutTarget3;
	#elif PIXELSHADEROUTPUT_MRT1
		RWTexture2D<STRATA_TOP_LAYER_TYPE> OutTarget2;
	#else
		RWTexture2D<STRATA_TOP_LAYER_TYPE> OutTarget1;
	#endif

#else // STRATA_OPAQUE_DEFERRED

	#if PIXELSHADEROUTPUT_MRT3
		RWTexture2D<float4> OutTarget3;
	#endif

	#if PIXELSHADEROUTPUT_MRT4
		RWTexture2D<float4> OutTarget4;
	#endif

	#if PIXELSHADEROUTPUT_MRT5
		RWTexture2D<float4> OutTarget5;
	#endif

	#if PIXELSHADEROUTPUT_MRT6
		RWTexture2D<float4> OutTarget6;
	#endif

	#if PIXELSHADEROUTPUT_MRT7
		RWTexture2D<float4> OutTarget7;
	#endif

#endif // STRATA_OPAQUE_DEFERRED

FPixelShaderOut ShadePixel(const uint2 PixelPos, uint QuadIndex)
{
#if PIXELSHADEROUTPUT_INTERPOLANTS || PIXELSHADEROUTPUT_BASEPASS
#if IS_NANITE_PASS
	FNaniteFullscreenVSToPS NaniteInterpolants = (FNaniteFullscreenVSToPS)0;
	NaniteInterpolants.TileIndex = QuadIndex;
#else
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
#endif
#endif

	const float2 HalfPixelOffset = float2(0.5f, 0.5f);
	const float4 SvPosition = float4(float2(PixelPos) + HalfPixelOffset, 0.0f, 1.0f);

#if IS_NANITE_PASS && (PIXELSHADEROUTPUT_INTERPOLANTS || PIXELSHADEROUTPUT_BASEPASS)
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
	Interpolants.ViewIndex = NaniteInterpolants.ViewIndex; // TODO: NANITE_MATERIAL_MULTIVIEW

#if INSTANCED_STEREO
	// Revisit if we need to support > 1 instanced view or non side-by-side views
	Interpolants.EyeIndex = (SvPosition.x >= (View.ViewRectMin.x + View.ViewSizeAndInvSize.x)) ? 1 : 0;
#endif
#endif

	FPixelShaderIn PixelShaderIn = (FPixelShaderIn)0;
	FPixelShaderOut PixelShaderOut = (FPixelShaderOut)0;

	PixelShaderIn.SvPosition = SvPosition;

	// Nanite does not support OPTIONAL_IsFrontFace, Instead, Nanite determines this in GetMaterialPixelParameters().
	PixelShaderIn.bIsFrontFace = false;

#if PIXELSHADEROUTPUT_BASEPASS
	FBasePassInterpolantsVSToPS BasePassInterpolants = (FBasePassInterpolantsVSToPS)0;
	FPixelShaderInOut_MainPS(Interpolants, BasePassInterpolants, PixelShaderIn, PixelShaderOut);
#endif

#if !HIGH_PRECISION_GBUFFERS
	PixelShaderOut.MRT[3] = float4(LinearToSrgb(PixelShaderOut.MRT[3].rgb), PixelShaderOut.MRT[3].a); // BaseColor is sRGB
#endif

	return PixelShaderOut;
}

void ExportPixel(const uint2 PixelPos, FPixelShaderOut ShadedPixel)
{
#if PIXELSHADEROUTPUT_COVERAGE || PIXELSHADEROUTPUT_A2C
	// TODO: OutCoverage = PixelShaderOut.Coverage;
#endif 

#if OUTPUT_PIXEL_DEPTH_OFFSET
	// TODO: OutDepth = PixelShaderOut.Depth;
#endif 

#if PIXELSHADEROUTPUT_MRT0
	OutTarget0[PixelPos] = ShadedPixel.MRT[0];
#endif

#if PIXELSHADEROUTPUT_MRT1
	OutTarget1[PixelPos] = ShadedPixel.MRT[1];
#endif

#if PIXELSHADEROUTPUT_MRT2
	OutTarget2[PixelPos] = ShadedPixel.MRT[2];
#endif

#if PIXELSHADEROUTPUT_MRT3
	OutTarget3[PixelPos] = ShadedPixel.MRT[3];
#endif

#if STRATA_OPAQUE_DEFERRED

	// In this case, here is the gbuffer pattern
	// MRT0 is pixel color
	// MRT1 is velocity if enabled or precomputed shadow if velocity if disabled and precomputed shadow enabled
	// MRT2 is precomputed shadow if both velocity and prec shadow are enabled.
	// After, Substrate top layer data appended. Remaining Substrate outputs are in the 2d array UAV

#if PIXELSHADEROUTPUT_MRT3
	OutTargets[uint3(PixelPos, 0)]	= ShadedPixel.StrataOutput[0];
	OutTargets[uint3(PixelPos, 1)]	= ShadedPixel.StrataOutput[1];
	OutTargets[uint3(PixelPos, 2)]	= ShadedPixel.StrataOutput[2];
	OutTarget4[PixelPos]			= ShadedPixel.StrataTopLayerData;
#elif PIXELSHADEROUTPUT_MRT2
	OutTargets[uint3(PixelPos, 0)]	= ShadedPixel.StrataOutput[0];
	OutTargets[uint3(PixelPos, 1)]	= ShadedPixel.StrataOutput[1];
	OutTargets[uint3(PixelPos, 2)]	= ShadedPixel.StrataOutput[2];
	OutTarget3[PixelPos]			= ShadedPixel.StrataTopLayerData;
#elif PIXELSHADEROUTPUT_MRT1
	OutTargets[uint3(PixelPos, 0)]	= ShadedPixel.StrataOutput[0];
	OutTargets[uint3(PixelPos, 1)]	= ShadedPixel.StrataOutput[1];
	OutTargets[uint3(PixelPos, 2)]	= ShadedPixel.StrataOutput[2];
	OutTarget2[PixelPos]			= ShadedPixel.StrataTopLayerData;
#else
	OutTargets[uint3(PixelPos, 0)]	= ShadedPixel.StrataOutput[0];
	OutTargets[uint3(PixelPos, 1)]	= ShadedPixel.StrataOutput[1];
	OutTargets[uint3(PixelPos, 2)]	= ShadedPixel.StrataOutput[2];
	OutTarget1[PixelPos]			= ShadedPixel.StrataTopLayerData;
#endif

#else // STRATA_OPAQUE_DEFERRED

#if PIXELSHADEROUTPUT_MRT4
	OutTarget4[PixelPos] = ShadedPixel.MRT[4];
#endif

#if PIXELSHADEROUTPUT_MRT5
	OutTarget5[PixelPos] = ShadedPixel.MRT[5];
#endif

#if PIXELSHADEROUTPUT_MRT6
	OutTarget6[PixelPos] = ShadedPixel.MRT[6];
#endif

#if PIXELSHADEROUTPUT_MRT7
	OutTarget7[PixelPos] = ShadedPixel.MRT[7];
#endif

#endif // STRATA_OPAQUE_DEFERRED
}

#define VIS_HELPER_LANES 0

void ProcessPixel(bool bActiveLane, uint ShadingBin, const uint2 PixelPos, uint QuadIndex, uint DispatchIndex, bool3 PixelCopy, uint HelperLaneCount)
{
	// All lanes shade (regardless of export - so ddx/ddy are valid)
	FPixelShaderOut ShadedPixel = ShadePixel(PixelPos, QuadIndex);

#if VIS_HELPER_LANES
	ShadedPixel.MRT[3].rgb = ColorMapTurbo(float(HelperLaneCount) / 4.0f);
#elif 0
	ShadedPixel.MRT[3].rgb = ColorMapTurbo(50.0);
#elif 0
	// Coherency vis
	float R =  (DispatchIndex & 0xFFu) / 255.0f;
	float G = ((DispatchIndex & 0xFF00u) >> 8u) / 255.0f;
	float B = ((DispatchIndex & 0xFF0000u) >> 16u) / 255.0f;
	ShadedPixel.MRT[3].rgb = float3(R, G, B);
#elif 0
	ShadedPixel.MRT[3].rgb = IntToColor(ShadingBin);
#elif 0
	ShadedPixel.MRT[3].rgb = IntToColor(QuadIndex);
#elif 0
	ShadedPixel.MRT[3].rgb = VisualizeShadingRate(ShadingRate).rgb;
#endif

	// Disable helper lanes from final export
	BRANCH
	if (bActiveLane)
	{
		ExportPixel(PixelPos, ShadedPixel);

		BRANCH
		if (PixelCopy.x) // Copy H
		{
			ExportPixel(PixelPos + uint2(1, 0), ShadedPixel);
		}

		BRANCH
		if (PixelCopy.y) // Copy V
		{
			ExportPixel(PixelPos + uint2(0, 1), ShadedPixel);
		}

		BRANCH
		if (PixelCopy.z) // Copy D
		{
			ExportPixel(PixelPos + uint2(1, 1), ShadedPixel);
		}
	}
}

[numthreads(64, 1, 1)]
void MainCS(uint ThreadIndex : SV_GroupIndex, uint GroupID : SV_GroupID, uint3 GroupThreadID : SV_GroupThreadID, uint3 DispatchThreadID : SV_DispatchThreadID)
{
	const uint ShadingBin = PassData.x;

	// Just like pixel shaders, compute 2x2 CS quads from thread index so we can leverage the 4 lane cross bar.
	// [0 1][2 3] -> [0 1][4 5]
	// [4 5][6 7] -> [2 3][6 7]
	//const uint SwizzleX = BitFieldInsertU32(BitFieldMaskU32(1u, 0u), ThreadIndex, BitFieldExtractU32(ThreadIndex, 3u, 2u));
	//const uint SwizzleY = BitFieldInsertU32(BitFieldMaskU32(2u, 0u), BitFieldExtractU32(ThreadIndex, 2u, 1u), BitFieldExtractU32(ThreadIndex, 3u, 3u));
	//const uint SampleIndex	= SwizzleX * SwizzleY * 2u;

	const bool bQuadBinning = PassData.z != 0u;

	uint HelperLaneCount = 0u;

	uint CornerIndex = 0;
	uint QuadIndex = 0;
	bool3 PixelCopy = bool3(false, false, false);

	FShadingQuad Quad;

	BRANCH
	if (bQuadBinning)
	{
		// New 2x2 shading quad every 4 samples
		CornerIndex = ThreadIndex & 3u;
		QuadIndex = GroupID * 16u + (ThreadIndex >> 2u);

		const bool bIsQuadTL = CornerIndex == 0u;
		const bool bIsQuadTR = CornerIndex == 1u;
		const bool bIsQuadBL = CornerIndex == 2u;
		const bool bIsQuadBR = CornerIndex == 3u;
	
		const uint LaneTL = WaveGetLaneIndex() & ~3u;

		uint PackedQuad = 0u;
		if (bIsQuadTL)
		{
			const uint QuadCount = Nanite.ShadingBinMeta[ShadingBin].x;
			if (QuadIndex < QuadCount)
			{
				const uint QuadStart = Nanite.ShadingBinMeta[ShadingBin].z;
				PackedQuad = Nanite.ShadingBinData[QuadStart + QuadIndex];
			}
		}
		PackedQuad = WaveReadLaneAt(PackedQuad, LaneTL);
		Quad = UnpackShadingQuad(PackedQuad);
	}
	else
	{
		const uint PixelIndex = DispatchThreadID.x;
		const uint PixelCount = Nanite.ShadingBinMeta[ShadingBin].y;
		
		if (PixelIndex >= PixelCount)
		{
			Quad.Coverage = bool4(false, false, false, false);
		}
		else
		{
			Quad.Coverage = bool4(true, true, true, true);

			const uint PixelStart = Nanite.ShadingBinMeta[ShadingBin].z;
			FShadingPixel Pixel = UnpackShadingPixel(Nanite.ShadingBinData[PixelStart + PixelIndex]);
			Quad.TopLeft = Pixel.PosXY;
			PixelCopy = Pixel.Copy;
		}
	}

	if (!any(Quad.Coverage))
	{
		// None of the 2x2 pixels have coverage (likely an out of bounds wave).
		return;
	}

	const bool bActiveLane = Quad.Coverage[CornerIndex];

#if VIS_HELPER_LANES
	HelperLaneCount = 4u;

	UNROLL
	for (uint CoverageIndex = 0; CoverageIndex < 4u; ++CoverageIndex)
	{
		HelperLaneCount -= Quad.Coverage[CoverageIndex] ? 1u : 0u;
	}
#endif

	// Determine final pixel position on the screen for shading
	const uint2 PixelPos = Quad.TopLeft + uint2(CornerIndex & 1u, (CornerIndex >> 1u) & 1u);

	// Shade and export quad
	ProcessPixel(bActiveLane, ShadingBin, PixelPos, QuadIndex, DispatchThreadID.x, PixelCopy, HelperLaneCount);
}
