// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	WideCustomResolveShaders.usf: Custom wider filter resolve shaders
	These versions of the shaders support FMASK, details of which may be under PS4 platform NDA.
  =============================================================================*/

float2 ResolveOrigin;

float4 WideCustomResolveVS(uint Id : SV_VertexID) : SV_POSITION
{
	int x = Id &  1;
	int y = Id >> 1;

	return float4(x * 4 - 1, y * 4 - 1, 0, 1);
}

float ModifySampleWeight(float3 Sample)
{
	// Inverse luminance filtering
	return rcp(1.0 + Luminance(Sample));
}

float CalcSampleWeight(float w, float3 Sample)
{
	// Inverse luminance filtering
	float lum = dot(Sample, MaterialFloat3(0.3, 0.59, 0.11)/w);
	return rcp(1.0/w + lum);
}

#if USE_FMASK
Texture2D<int2> FMaskTex;

int getFptr(int index, int2 fmask)
{
	const int     bitShift = 4;     // fmask load always returns a 4bit fragment index (fptr) per coverage sample, regardless of actual number of fragments.
	const int     mask = (1 << bitShift) - 1;
	if (index < 8)
		return (fmask.x >> (index*bitShift)) & mask;
	else
		return (fmask.y >> ((index - 8)*bitShift)) & mask;
}

int2 LoadFMask(uint2 position)
{
	int2 fmask;
	fmask.x = FMaskTex.Load(int3(position.xy, 0)).x;
	fmask.y = 0x88888888; // all invalid -- though in theory we shouldn't need to refer to them at all.
	return fmask;
}

void LoadTexSampleAndWeight(Texture2DMS<float4> TargetTex, uint2 position, int2 fmask, int sampleIndex, float weight, inout float3 sampleSum, inout float weightSum)
{
	int fptr = getFptr(sampleIndex, fmask);
	int unknown = 1 << 3; // color "unknown" is always represented as high bit in the 4bit fragment index
	float known = float(fptr != unknown);

	float3 texSample = TargetTex.Load((int2)position, fptr).xyz;
	float sampleW = known*CalcSampleWeight(weight, texSample);
	sampleSum += texSample*sampleW;
	weightSum += sampleW;
}

#else

int2 LoadFMask(uint2 position)
{
	return int2(0, 0);
}

void LoadTexSampleAndWeight(Texture2DMS<float4> TargetTex, uint2 position, int2 fmask, int sampleIndex, float weight, inout float3 sampleSum, inout float weightSum)
{
	float3 texSample = TargetTex.Load((int2)position, sampleIndex).xyz;
	float sampleW = CalcSampleWeight(weight, texSample);
	sampleSum += texSample*sampleW;
	weightSum += sampleW;
}

#endif

#if defined(MSAA_SAMPLE_COUNT)
# if MSAA_SAMPLE_COUNT == 0

Texture2D<float4> Tex;

float4 WideCustomResolvePS(float4 Pos : SV_POSITION) : SV_Target0
{
	uint2 P = uint2(ResolveOrigin + Pos.xy);
	return float4(Tex.Load(int3(P, 0)).rgb, 0);
}

# else

Texture2DMS<float4,MSAA_SAMPLE_COUNT> Tex; // Input MSAA color

# if WIDE_RESOLVE_WIDTH == 0
// Box filter
float3 resolve_bspline(uint2 pos)
{
#if USE_FMASK
	int2 fmask = LoadFMask(pos);
	float3 sampleSum = 0;
	float weightSum = 0;

	for (int i = 0; i < MSAA_SAMPLE_COUNT; ++i)
	{
		LoadTexSampleAndWeight(Tex, pos, fmask, i, 1.0, sampleSum, weightSum);
	}

	return sampleSum / weightSum;
#else
	return (Tex.Load(pos, 0) + Tex.Load(pos, 1) + Tex.Load(pos, 2) + Tex.Load(pos, 3)) * .25;
#endif
}
# elif WIDE_RESOLVE_WIDTH == 1
#  include "WideCustomResolve_Wide.ush"
# elif WIDE_RESOLVE_WIDTH == 2
#  include "WideCustomResolve_Wider.ush"
# elif WIDE_RESOLVE_WIDTH == 3
#  include "WideCustomResolve_Widest.ush"
# else
#  error "Unknown filter width"
# endif

float4 WideCustomResolvePS(float4 Pos : SV_POSITION) : SV_Target0
{
	uint2 P = uint2(ResolveOrigin + Pos.xy);
	return float4(resolve_bspline(P), 0);
}

# endif
#endif
