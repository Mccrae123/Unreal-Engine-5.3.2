// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadianceCacheCommon.ush
=============================================================================*/

#include "LumenOctahedralProbe.ush"

#define RADIANCE_PROBE_MAX_CLIPMAPS 6
#define RADIANCE_CACHE_USE_INTERPOLATION 1
#define RADIANCE_CACHE_USE_HIERARCHY 0
#define INVALID_PROBE_INDEX 0xFFFFFFFF

Texture3D<uint> RadianceProbeIndirectionTexture;
Texture2D<float3> RadianceCacheFinalRadianceAtlas;

float RadianceProbeClipmapTMin[RADIANCE_PROBE_MAX_CLIPMAPS];
float WorldPositionToRadianceProbeCoordScale[RADIANCE_PROBE_MAX_CLIPMAPS];
float3 WorldPositionToRadianceProbeCoordBias[RADIANCE_PROBE_MAX_CLIPMAPS];
float RadianceProbeCoordToWorldPositionScale[RADIANCE_PROBE_MAX_CLIPMAPS];
float3 RadianceProbeCoordToWorldPositionBias[RADIANCE_PROBE_MAX_CLIPMAPS];
float ReprojectionRadiusScale;

uint2 ProbeAtlasResolutionInProbes;
float2 InvRadianceProbeAtlasResolution;

uint NumRadianceProbeClipmaps;
uint RadianceProbeClipmapResolution;
// Resolution of Octahedral layout during tracing
uint RadianceProbeResolution; 
// Resolution of Octahedral layout during sampling
uint FinalProbeResolution;
uint OverrideCacheOcclusionLighting;
uint ShowBlackRadianceCacheLighting;

uint GetRadianceProbeClipmap(float3 WorldSpacePosition)
{
	uint ClipmapIndex = 0;
	for (; ClipmapIndex < NumRadianceProbeClipmaps; ++ClipmapIndex)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

		int3 ProbeMinCoord;
		int3 ProbeMaxCoord;

#if RADIANCE_CACHE_USE_INTERPOLATION
		ProbeMinCoord = ProbeCoordFloat - .5f;
		ProbeMaxCoord = ProbeMinCoord + 1;
#else
		ProbeMinCoord = ProbeCoordFloat;
		ProbeMaxCoord = ProbeMinCoord;
#endif

		if (all(ProbeMinCoord >= 0) && all(ProbeMaxCoord < (int3)RadianceProbeClipmapResolution))
		{
			return ClipmapIndex;
		}
	}

	return NumRadianceProbeClipmaps;
}

float GetRadianceProbeTMin(uint ClipmapIndex)
{
	return RadianceProbeClipmapTMin[ClipmapIndex];
}

float GetRadianceProbeOcclusionDistanceWithInterpolation(float3 RayOrigin, float3 RayDirection, out bool bCoveredByRadianceCache)
{
	uint ClipmapIndex = GetRadianceProbeClipmap(RayOrigin);

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		bCoveredByRadianceCache = true;
		// Should technically be diagonal voxel length
		return GetRadianceProbeTMin(ClipmapIndex) + RadianceProbeCoordToWorldPositionScale[ClipmapIndex];
	}
	else
	{
		bCoveredByRadianceCache = false;
		return 10000000.0f;
	}
}

float3 SampleRadianceCacheProbe(uint ProbeIndex, float3 WorldSpaceDirection)
{
	uint ClipmapResolution = RadianceProbeClipmapResolution;
	uint NumClipmaps = NumRadianceProbeClipmaps;

	uint2 ProbeAtlasCoord = FinalProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeUV = DirectionToOctahedralMap(WorldSpaceDirection);

	float2 ProbeTexelCoord = ProbeUV * RadianceProbeResolution + 1;
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * InvRadianceProbeAtlasResolution;

	float3 UnmappedDebugColor = 0.0f;
	// Uncomment to see bright green when an unallocated probe is sampled
	// This indicates a mismatch between probe placement and probe usage
	// Off by default as downsampled GBuffer placement causes some unmapped accesses
	UnmappedDebugColor = float3(0.0f, 10.0f, 0.0f);
	return ProbeIndex == INVALID_PROBE_INDEX ? UnmappedDebugColor : RadianceCacheFinalRadianceAtlas.SampleLevel(GlobalBilinearClampedSampler, ProbeAtlasUV, 0);
}

uint GetProbeIndexFromIndirectionTexture(uint3 ProbeCoord, uint ClipmapIndex)
{
	uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, ProbeCoord.yz);
	return RadianceProbeIndirectionTexture.Load(uint4(ProbeIndirectionTextureCoord, 0));
}

float3 SampleRadianceCacheProbeWithParallaxCorrection(uint3 ProbeCoord, uint ProbeClipmapIndex, float3 WorldSpacePosition, float3 WorldSpaceDirection)
{
	float3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPositionScale[ProbeClipmapIndex] + RadianceProbeCoordToWorldPositionBias[ProbeClipmapIndex];
	float ReprojectionRadius = ReprojectionRadiusScale * GetRadianceProbeTMin(ProbeClipmapIndex);
	float3 IntersectionPosition = WorldSpacePosition + WorldSpaceDirection * RayIntersectSphere(WorldSpacePosition, WorldSpaceDirection, float4(ProbeWorldPosition, ReprojectionRadius)).y;
	float3 ReprojectedDirection = IntersectionPosition - ProbeWorldPosition;
	uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ProbeClipmapIndex);
	return SampleRadianceCacheProbe(ProbeIndex, ReprojectedDirection);
}

float3 SampleRadianceCacheInterpolated(float3 WorldSpacePosition, float3 WorldSpaceDirection, float3 Random)
{
	uint ClipmapIndex = GetRadianceProbeClipmap(WorldSpacePosition);

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

#if RADIANCE_CACHE_USE_INTERPOLATION
		float3 CornerProbeCoordFloat = ProbeCoordFloat - .5f;
		int3 CornerProbeCoord = CornerProbeCoordFloat;
		float3 LerpAlphas = frac(CornerProbeCoordFloat);

#define STOCHASTIC_INTERPOLATION 0
#if STOCHASTIC_INTERPOLATION
		int3 StochasticProbeCoord = CornerProbeCoord + int3(Random < LerpAlphas ? 1 : 0);
		return SampleRadianceCacheProbeWithParallaxCorrection(StochasticProbeCoord, ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
#else
		float3 Lighting000 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting001 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting010 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting011 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting100 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting101 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting110 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);
		float3 Lighting111 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection);

		float3 ZLerp00 = lerp(Lighting000, Lighting001, LerpAlphas.z);
		float3 ZLerp01 = lerp(Lighting010, Lighting011, LerpAlphas.z);
		float3 ZLerp10 = lerp(Lighting100, Lighting101, LerpAlphas.z);
		float3 ZLerp11 = lerp(Lighting110, Lighting111, LerpAlphas.z);

		float3 YLerp0 = lerp(ZLerp00, ZLerp01, LerpAlphas.y);
		float3 YLerp1 = lerp(ZLerp10, ZLerp11, LerpAlphas.y);

		return lerp(YLerp0, YLerp1, LerpAlphas.x);
#endif

#else
		int3 ProbeCoord = ProbeCoordFloat;
		uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ClipmapIndex);
		return SampleRadianceCacheProbe(ProbeIndex, WorldSpaceDirection);
#endif
	}

	return float3(0.0f, 0.0f, 0.0f);
}

void SampleRadianceCacheAndApply(float3 WorldSpacePosition, float3 WorldSpaceDirection, float3 Random, inout float3 Lighting, inout float Transparency)
{
	float3 RadianceCacheLighting = SampleRadianceCacheInterpolated(WorldSpacePosition, WorldSpaceDirection, Random);

	if (ShowBlackRadianceCacheLighting > 0)
	{
		Lighting = 0;
	}
	else if (OverrideCacheOcclusionLighting > 0)
	{
		Lighting = RadianceCacheLighting;
	}
	else
	{
		Lighting += RadianceCacheLighting * Transparency;
	}
	
	Transparency = 0.0f;
}