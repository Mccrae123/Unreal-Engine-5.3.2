// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadianceCacheCommon.ush
=============================================================================*/

#include "LumenOctahedralProbe.ush"

#ifndef LUMEN_HARDWARE_RAYTRACING
#define LUMEN_HARDWARE_RAYTRACING 0
#endif

#define RADIANCE_PROBE_MAX_CLIPMAPS 6
#define RADIANCE_CACHE_USE_INTERPOLATION 1
#define RADIANCE_CACHE_STORE_DEPTHS 1
#define INVALID_PROBE_INDEX 0xFFFFFFFF

Texture3D<uint> RadianceProbeIndirectionTexture;
Texture2D<float3> RadianceCacheFinalRadianceAtlas;

#if RADIANCE_CACHE_STORE_DEPTHS
Texture2D<float> RadianceCacheDepthAtlas;
#endif

#if LUMEN_HARDWARE_RAYTRACING
	// Temporary hack to access SHADER_PARAMETER_ARRAY in RGS
	// Workaround for error "subscripted value is not an array, matrix, or vector" in DXC when SHADER_PARAMETER_ARRAY is used in RGS
	#define RadianceProbeClipmapTMin  RGSRadianceCacheParameters.RadianceProbeClipmapTMin
	#define WorldPositionToRadianceProbeCoordScale RGSRadianceCacheParameters.WorldPositionToRadianceProbeCoordScale
	#define WorldPositionToRadianceProbeCoordBias RGSRadianceCacheParameters.WorldPositionToRadianceProbeCoordBias
	#define RadianceProbeCoordToWorldPositionScale RGSRadianceCacheParameters.RadianceProbeCoordToWorldPositionScale
	#define RadianceProbeCoordToWorldPositionBias RGSRadianceCacheParameters.RadianceProbeCoordToWorldPositionBias
#else
	float RadianceProbeClipmapTMin[RADIANCE_PROBE_MAX_CLIPMAPS];
	float WorldPositionToRadianceProbeCoordScale[RADIANCE_PROBE_MAX_CLIPMAPS];
	float3 WorldPositionToRadianceProbeCoordBias[RADIANCE_PROBE_MAX_CLIPMAPS];
	float RadianceProbeCoordToWorldPositionScale[RADIANCE_PROBE_MAX_CLIPMAPS];
	float3 RadianceProbeCoordToWorldPositionBias[RADIANCE_PROBE_MAX_CLIPMAPS];
#endif

float ReprojectionRadiusScale;
float FinalRadianceAtlasMaxMip;

uint2 ProbeAtlasResolutionInProbes;
float2 InvProbeFinalRadianceAtlasResolution;
float2 InvProbeDepthAtlasResolution;

uint NumRadianceProbeClipmaps;
uint RadianceProbeClipmapResolution;
// Resolution of Octahedral layout during tracing
uint RadianceProbeResolution; 
// Resolution of Octahedral layout during sampling
uint FinalProbeResolution;
uint OverrideCacheOcclusionLighting;
uint ShowBlackRadianceCacheLighting;

uint GetRadianceProbeClipmap(float3 WorldSpacePosition)
{
	uint ClipmapIndex = 0;
	for (; ClipmapIndex < NumRadianceProbeClipmaps; ++ClipmapIndex)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

		int3 ProbeMinCoord;
		int3 ProbeMaxCoord;

#if RADIANCE_CACHE_USE_INTERPOLATION
		ProbeMinCoord = ProbeCoordFloat - .5f;
		ProbeMaxCoord = ProbeMinCoord + 1;
#else
		ProbeMinCoord = ProbeCoordFloat;
		ProbeMaxCoord = ProbeMinCoord;
#endif

		if (all(ProbeMinCoord >= 0) && all(ProbeMaxCoord < (int3)RadianceProbeClipmapResolution))
		{
			return ClipmapIndex;
		}
	}

	return NumRadianceProbeClipmaps;
}

float GetRadianceProbeTMin(uint ClipmapIndex)
{
	return RadianceProbeClipmapTMin[ClipmapIndex];
}

float GetRadianceProbeOcclusionDistanceWithInterpolation(float3 RayOrigin, float3 RayDirection, out bool bCoveredByRadianceCache)
{
	uint ClipmapIndex = GetRadianceProbeClipmap(RayOrigin);

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		bCoveredByRadianceCache = true;

		float CellOcclusionDistance = RadianceProbeCoordToWorldPositionScale[ClipmapIndex] * sqrt(3.0f);
		return GetRadianceProbeTMin(ClipmapIndex) + CellOcclusionDistance;
	}
	else
	{
		bCoveredByRadianceCache = false;
		return 10000000.0f;
	}
}

float3 SampleRadianceCacheProbe(uint ProbeIndex, float3 WorldSpaceDirection, float MipLevel)
{
	float2 ProbeUV = DirectionToOctahedralMap(WorldSpaceDirection);

#define VISUALIZE_PROBE_DEPTH 0
#if VISUALIZE_PROBE_DEPTH && RADIANCE_CACHE_STORE_DEPTHS
	uint2 ProbeAtlasCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeTexelCoord = ProbeUV * RadianceProbeResolution;
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * InvProbeDepthAtlasResolution;
	return RadianceCacheDepthAtlas.SampleLevel(GlobalPointClampedSampler, ProbeAtlasUV, MipLevel).x / 10000.0f;
#else
	uint2 ProbeAtlasCoord = FinalProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeTexelCoord = ProbeUV * RadianceProbeResolution + exp2(FinalRadianceAtlasMaxMip);
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * InvProbeFinalRadianceAtlasResolution;

	float3 UnmappedDebugColor = 0.0f;
	// Show bright green when an unallocated probe is sampled
	UnmappedDebugColor = float3(0.0f, 10.0f, 0.0f);
	return ProbeIndex == INVALID_PROBE_INDEX ? UnmappedDebugColor : RadianceCacheFinalRadianceAtlas.SampleLevel(GlobalBilinearClampedSampler, ProbeAtlasUV, MipLevel);
#endif
}

uint GetProbeIndexFromIndirectionTexture(uint3 ProbeCoord, uint ClipmapIndex)
{
	uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, ProbeCoord.yz);
	return RadianceProbeIndirectionTexture.Load(uint4(ProbeIndirectionTextureCoord, 0));
}

float3 SampleRadianceCacheProbeWithParallaxCorrection(uint3 ProbeCoord, uint ProbeClipmapIndex, float3 WorldSpacePosition, float3 WorldSpaceDirection, float MipLevel)
{
	float3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPositionScale[ProbeClipmapIndex] + RadianceProbeCoordToWorldPositionBias[ProbeClipmapIndex];
	float ProbeTMin = GetRadianceProbeTMin(ProbeClipmapIndex);
	uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ProbeClipmapIndex);
	float3 ReprojectedDirection = WorldSpaceDirection;

#define SIMPLE_SPHERE_PARALLAX 1
#define TRACE_THROUGH_PROBE_DEPTHS_REFERENCE 0

#if SIMPLE_SPHERE_PARALLAX

	float ReprojectionRadius = ReprojectionRadiusScale * ProbeTMin;
	float3 IntersectionPosition = WorldSpacePosition + WorldSpaceDirection * RayIntersectSphere(WorldSpacePosition, WorldSpaceDirection, float4(ProbeWorldPosition, ReprojectionRadius)).y;
	ReprojectedDirection = IntersectionPosition - ProbeWorldPosition;

#elif TRACE_THROUGH_PROBE_DEPTHS_REFERENCE && RADIANCE_CACHE_STORE_DEPTHS
	//@note - no depth mips implemented
	float3 ProbeTraceStart = WorldSpacePosition + WorldSpaceDirection * RayIntersectSphere(WorldSpacePosition, WorldSpaceDirection, float4(ProbeWorldPosition, ProbeTMin)).y;
	float3 ProbeTraceEnd = ProbeWorldPosition + WorldSpaceDirection * 10000.0f;
	float3 ProbeTraceDirection = ProbeTraceEnd - ProbeTraceStart;
	uint2 ProbeAtlasCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

	float NumSamples = 100.0f;

	for (float StepIndex = 0; StepIndex < NumSamples; StepIndex++)
	{
		float3 StepPosition = ProbeTraceStart + StepIndex / (NumSamples - 1) * ProbeTraceDirection;
		float3 ProbeToStepPosition = StepPosition - ProbeWorldPosition;
		float2 ProbeUV = DirectionToOctahedralMap(ProbeToStepPosition);
		float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeUV * RadianceProbeResolution) * InvProbeDepthAtlasResolution;
		float StepHitDistanceFromProbe = RadianceCacheDepthAtlas.SampleLevel(GlobalPointClampedSampler, ProbeAtlasUV, MipLevel).x;
		float StepRayDistanceFromProbeSq = dot(ProbeToStepPosition, ProbeToStepPosition);

		if (StepHitDistanceFromProbe * StepHitDistanceFromProbe < StepRayDistanceFromProbeSq)
		{
			ReprojectedDirection = ProbeToStepPosition;
			break;
		}
	}

#endif

	return SampleRadianceCacheProbe(ProbeIndex, ReprojectedDirection, MipLevel);
}

float3 SampleRadianceCacheInterpolated(float3 WorldSpacePosition, float3 WorldSpaceDirection, float ConeHalfAngle, float3 Random)
{
	uint ClipmapIndex = GetRadianceProbeClipmap(WorldSpacePosition);

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

		//float ConeHalfAngle = acosFast(1.0f - NumTexels * NumTexels / (float)(RadianceProbeResolution * RadianceProbeResolution));
		float NumTexels = sqrt(1.0f - cos(ConeHalfAngle)) * RadianceProbeResolution;
		float MipLevel = clamp(log2(NumTexels), 0, FinalRadianceAtlasMaxMip);

#if RADIANCE_CACHE_USE_INTERPOLATION
		float3 CornerProbeCoordFloat = ProbeCoordFloat - .5f;
		int3 CornerProbeCoord = CornerProbeCoordFloat;
		float3 LerpAlphas = frac(CornerProbeCoordFloat);

#define STOCHASTIC_INTERPOLATION 0
#if STOCHASTIC_INTERPOLATION
		int3 StochasticProbeCoord = CornerProbeCoord + int3(Random < LerpAlphas ? 1 : 0);
		return SampleRadianceCacheProbeWithParallaxCorrection(StochasticProbeCoord, ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
#else
		//@todo - parallax correct using a single sphere bounding all the probes
		float3 Lighting000 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting001 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting010 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting011 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting100 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting101 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting110 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting111 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);

		float3 ZLerp00 = lerp(Lighting000, Lighting001, LerpAlphas.z);
		float3 ZLerp01 = lerp(Lighting010, Lighting011, LerpAlphas.z);
		float3 ZLerp10 = lerp(Lighting100, Lighting101, LerpAlphas.z);
		float3 ZLerp11 = lerp(Lighting110, Lighting111, LerpAlphas.z);

		float3 YLerp0 = lerp(ZLerp00, ZLerp01, LerpAlphas.y);
		float3 YLerp1 = lerp(ZLerp10, ZLerp11, LerpAlphas.y);

		return lerp(YLerp0, YLerp1, LerpAlphas.x);
#endif

#else
		int3 ProbeCoord = ProbeCoordFloat;
		uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ClipmapIndex);
		return SampleRadianceCacheProbe(ProbeIndex, WorldSpaceDirection, MipLevel);
#endif
	}

	return float3(0.0f, 0.0f, 0.0f);
}

void SampleRadianceCacheAndApply(float3 WorldSpacePosition, float3 WorldSpaceDirection, float ConeHalfAngle, float3 Random, inout float3 Lighting, inout float Transparency)
{
	float3 RadianceCacheLighting = SampleRadianceCacheInterpolated(WorldSpacePosition, WorldSpaceDirection, ConeHalfAngle, Random);

	if (OverrideCacheOcclusionLighting > 0)
	{
		Lighting = RadianceCacheLighting;
	}
	else if (ShowBlackRadianceCacheLighting == 0)
	{
		Lighting += RadianceCacheLighting * Transparency;
	}
	
	Transparency = 0.0f;
}