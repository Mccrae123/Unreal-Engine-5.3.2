// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenVoxelLighting.usf
=============================================================================*/

#define RASTERIZE_ONTO_WORLD_Z 0
#define RASTERIZE_ONTO_LARGEST_AXES 1
#define RASTERIZE_ONTO_FACE_DIRECTION 2

#define RASTERIZE_MODE RASTERIZE_ONTO_FACE_DIRECTION

#include "../Common.ush"
#include "LumenCardCommon.ush"
// 16 bit render target accumulation
#define DEPTH_WEIGHTED_OIT_32_BIT 0
#include "LumenTracingCommon.ush"

#ifndef THREADGROUP_SIZE
	#define THREADGROUP_SIZE 1
#endif

#define NUM_VOXEL_DIRECTIONS 6
#define SCATTER_BATCH_SIZE 32

uint3 CullGridSize;
float3 GridMin;
float3 GridVoxelSize;
float GridConeRadiusSq;

uint TargetClipmapIndex;
uint3 GridResolution;
RWTexture3D<float4> RWVoxelLighting;

Buffer<uint> CulledCardGridHeader;
uint CullGridFactor;

uint NumClipmaps;
float4 ClipmapWorldMin[MAX_VOXEL_CLIPMAP_LEVELS];
float4 ClipmapWorldSize[MAX_VOXEL_CLIPMAP_LEVELS];
float3 ClipmapToGridScale[MAX_VOXEL_CLIPMAP_LEVELS];
float3 ClipmapToGridBias[MAX_VOXEL_CLIPMAP_LEVELS];

RWBuffer<uint> RWQuadAllocator;
RWBuffer<uint> RWQuadData;

void AddQuadsForIntersectingObject(uint ObjectIndex, float3 WorldObjectCenter, float3 WorldObjectExtent)
{
	uint NumClipmapsToUpdate = NumClipmaps;

	#if SINGLE_CLIPMAP_TO_UPDATE
		// Fast path for common case when we update only 1 clipmap
		NumClipmapsToUpdate = 1;
	#endif

	for (uint ClipmapIndex = 0; ClipmapIndex < NumClipmapsToUpdate; ClipmapIndex++)
	{
		float DistanceSq = ComputeSquaredDistanceBetweenAABBs(ClipmapWorldCenter[ClipmapIndex].xyz, ClipmapWorldExtent[ClipmapIndex].xyz, WorldObjectCenter, WorldObjectExtent);
	
		if (DistanceSq < 0.01f)
		{
			uint NumDirections = 6;
			uint QuadDataStart;
			InterlockedAdd(RWQuadAllocator[0], NumDirections, QuadDataStart);

			uint QuadIndex = QuadDataStart;

			for (uint DirectionIndex = 0; DirectionIndex < NumDirections; DirectionIndex++)
			{
				uint Packed = (ObjectIndex & 0xFFFFFF) | ((ClipmapIndex & 0xF) << 24) | ((DirectionIndex & 0xF) << 28);
				RWQuadData[QuadIndex] = Packed;
				QuadIndex++;
			}
		}
	}
}

bool WorldObjectToGrid(float3 WorldObjectCenter, float3 WorldObjectExtent, uint ClipmapIndex, out uint3 OutObjectGridMin, out uint3 OutObjectGridMax, out uint3 OutObjectGridSize)
{
	float3 ConservativeRasterizationExtent = 0.5 * ClipmapVoxelSizeAndRadius[ClipmapIndex].xyz;
	WorldObjectExtent += ConservativeRasterizationExtent;

	int3 ObjectGridMin = (WorldObjectCenter - WorldObjectExtent) * ClipmapToGridScale[ClipmapIndex] + ClipmapToGridBias[ClipmapIndex];
	int3 ObjectGridMax = (WorldObjectCenter + WorldObjectExtent) * ClipmapToGridScale[ClipmapIndex] + ClipmapToGridBias[ClipmapIndex];

	ObjectGridMin = clamp(ObjectGridMin, int3(0, 0, 0), (int3)GridResolution);
	ObjectGridMax = clamp(ObjectGridMax, int3(0, 0, 0), (int3)GridResolution);
	int3 ObjectGridSize = ObjectGridMax - ObjectGridMin;

	// Convert int3 -> uint32
	OutObjectGridMin = ObjectGridMin;
	OutObjectGridMax = ObjectGridMax;
	OutObjectGridSize = ObjectGridSize;

	return all(ObjectGridSize > 0);
}

void AddComputeScatterQuadsForIntersectingObject(uint ObjectIndex, float3 WorldObjectCenter, float3 WorldObjectExtent)
{
	uint NumClipmapsToUpdate = NumClipmaps;

	#if SINGLE_CLIPMAP_TO_UPDATE
		// Fast path for common case when we update only 1 clipmap
		NumClipmapsToUpdate = 1;
	#endif

	for (uint ClipmapIndex = 0; ClipmapIndex < NumClipmapsToUpdate; ClipmapIndex++)
	{
		uint3 ObjectGridMin;
		uint3 ObjectGridMax;
		uint3 ObjectGridSize;
		bool bValid = WorldObjectToGrid(WorldObjectCenter, WorldObjectExtent, ClipmapIndex, ObjectGridMin, ObjectGridMax, ObjectGridSize);

		if (bValid)
		{
			uint NumQuads = (ObjectGridSize.x * ObjectGridSize.y + SCATTER_BATCH_SIZE - 1) / SCATTER_BATCH_SIZE;

			uint BaseQuadIndex;
			InterlockedAdd(RWQuadAllocator[0], NumQuads, BaseQuadIndex);

			for (uint QuadIndex = 0; QuadIndex < NumQuads; ++QuadIndex)
			{
				uint PackedData0 = ObjectIndex;
				uint PackedData1 = QuadIndex;
				#if !SINGLE_CLIPMAP_TO_UPDATE
					PackedData1 |= (ClipmapIndex << 28);
				#endif
				RWQuadData[(BaseQuadIndex + QuadIndex) * 2 + 0] = PackedData0;
				RWQuadData[(BaseQuadIndex + QuadIndex) * 2 + 1] = PackedData1;
			}
		}
	}
}

float MeshSDFRadiusThreshold;
float MeshSDFScreenSizeThreshold;
uint OutermostClipmapIndex;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void SetupMeshSDFScatterInstancesCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ObjectIndex = DispatchThreadId.x;

	if (ObjectIndex < NumSceneObjects)
	{
		uint SourceIndex = ObjectIndex;

		float3 WorldObjectCenter = SceneObjectBounds[SourceIndex * OBJECT_BOUNDS_STRIDE + 0].xyz;
		float3 WorldObjectExtent = SceneObjectBounds[SourceIndex * OBJECT_BOUNDS_STRIDE + 1].xyz * LUMEN_SDF_APPROX_MARGIN;
		
		float BoundsRadius = length(WorldObjectExtent);

		float DistanceSq = ComputeSquaredDistanceBetweenAABBs(ClipmapWorldCenter[OutermostClipmapIndex].xyz, ClipmapWorldExtent[OutermostClipmapIndex].xyz, WorldObjectCenter, WorldObjectExtent);
		float DistanceToView = length(View.WorldCameraOrigin - WorldObjectCenter);

		if (DistanceSq < 0.01f
			&& BoundsRadius > MeshSDFRadiusThreshold
			&& BoundsRadius / DistanceToView > MeshSDFScreenSizeThreshold) 
		{
#if COMPUTE_SCATTER
			AddComputeScatterQuadsForIntersectingObject(SourceIndex, WorldObjectCenter, WorldObjectExtent);
#else
			AddQuadsForIntersectingObject(SourceIndex, WorldObjectCenter, WorldObjectExtent);
#endif
        }
	}
}

RWTexture3D<uint> RWVoxelMask;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ClearVoxelMaskCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	RWVoxelMask[DispatchThreadId] = 0;
}

struct FCardVoxelizeVSToPS
{
	nointerpolation uint ObjectIndex : OBJECT_INDEX;
	nointerpolation uint ClipmapIndex : CLIPMAP_INDEX;
	nointerpolation uint DirectionIndex : DIRECTION_INDEX;
	nointerpolation uint RasterizationZAxis : RASTER_AXIS;
	nointerpolation float SwizzledWorldCardMinZ : CARD_MIN;
	nointerpolation uint NumLayers : NUM_LAYERS;
	float2 SwizzledWorldPositionXY : WORLD_POSITION;
	float4 Position : SV_POSITION;
};

Buffer<uint> QuadAllocator;
Buffer<uint> QuadData;
uint TilesPerInstance;

void CardVoxelizeVS(
	float2 TexCoord : ATTRIBUTE0,
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVoxelizeVSToPS Output
	)
{
	Output = (FCardVoxelizeVSToPS)0;

	// Compute the actual instance id for when multiple tiles are packed into the vertex buffer
	uint EffectiveInstanceId = InstanceId * TilesPerInstance + VertexId / 4;

	if (EffectiveInstanceId < QuadAllocator[0])
	{
		uint QuadInfo = QuadData[EffectiveInstanceId];
		uint ObjectIndex = QuadInfo & 0xFFFFFF;
		uint ClipmapIndex = (QuadInfo >> 24) & 0xF;
		uint DirectionIndex = (QuadInfo >> 28) & 0xF;

		float3 LocalPositionExtent = LoadGlobalObjectLocalPositionExtent(ObjectIndex) * LUMEN_SDF_APPROX_MARGIN;
		float3x3 VolumeToWorld = LoadGlobalObjectVolumeToWorld(ObjectIndex);

		float3 WorldObjectCenter = LoadGlobalObjectPositionAndRadius(ObjectIndex).xyz;
		float3 WorldObjectExtent = mul(LocalPositionExtent, abs(VolumeToWorld));

		// Expand voxelization region by half a voxel on each side
		float3 ConservativeRasterizationExtent = .5f * ClipmapVoxelSizeAndRadius[ClipmapIndex].xyz;
		WorldObjectExtent += ConservativeRasterizationExtent;

		float3 ClippedWorldCardMin = max(WorldObjectCenter - WorldObjectExtent, ClipmapWorldMin[ClipmapIndex].xyz);
		float3 ClippedWorldCardMax = min(WorldObjectCenter + WorldObjectExtent, ClipmapWorldMin[ClipmapIndex].xyz + ClipmapWorldSize[ClipmapIndex].xyz);

		uint RasterizationZAxis = 2;

#if RASTERIZE_MODE == RASTERIZE_ONTO_LARGEST_AXES

		RasterizationZAxis = 0;

		if (WorldObjectExtent.x > WorldObjectExtent.y)
		{
			if (WorldObjectExtent.z > WorldObjectExtent.y)
			{
				RasterizationZAxis = 1;
			}
			else
			{
				RasterizationZAxis = 2;
			}
		}
		else if (WorldObjectExtent.z < WorldObjectExtent.x)
		{
			RasterizationZAxis = 2;
		}

#elif RASTERIZE_MODE == RASTERIZE_ONTO_FACE_DIRECTION
		RasterizationZAxis = DirectionIndex / 2;
#endif

		float3 SwizzledWorldToUVScale = ClipmapWorldToUVScale[ClipmapIndex].xyz;
		float3 SwizzledWorldToUVBias = ClipmapWorldToUVBias[ClipmapIndex].xyz;

		// Transform to swizzled space
		if (RasterizationZAxis == 0)
		{
			ClippedWorldCardMin = ClippedWorldCardMin.yzx;
			ClippedWorldCardMax = ClippedWorldCardMax.yzx;
			SwizzledWorldToUVScale = SwizzledWorldToUVScale.yzx;
			SwizzledWorldToUVBias = SwizzledWorldToUVBias.yzx;
		}
		else if (RasterizationZAxis == 1)
		{
			ClippedWorldCardMin = ClippedWorldCardMin.zxy;
			ClippedWorldCardMax = ClippedWorldCardMax.zxy;
			SwizzledWorldToUVScale = SwizzledWorldToUVScale.zxy;
			SwizzledWorldToUVBias = SwizzledWorldToUVBias.zxy;
		}

		//@todo - not swizzling the clipmap attributes properly
		uint NumLayers = min((ClippedWorldCardMax.z - ClippedWorldCardMin.z) / ClipmapVoxelSizeAndRadius[ClipmapIndex].z + 1, GridResolution.z);

		float3 SwizzledWorldVertexPosition = lerp(ClippedWorldCardMin, ClippedWorldCardMax, float3(TexCoord, 0));
		float3 SwizzledVolumeUV = SwizzledWorldVertexPosition * SwizzledWorldToUVScale + SwizzledWorldToUVBias;

		// Make sure the quad doesn't get depth clipped
		SwizzledVolumeUV.z = .5f;

		Output.ObjectIndex = ObjectIndex;
		Output.ClipmapIndex = ClipmapIndex;
		Output.DirectionIndex = DirectionIndex;
		Output.RasterizationZAxis = RasterizationZAxis;
		Output.SwizzledWorldCardMinZ = ClippedWorldCardMin.z;
		Output.NumLayers = NumLayers;
		Output.SwizzledWorldPositionXY = SwizzledWorldVertexPosition.xy;
		Output.Position = float4(SwizzledVolumeUV * float3(2, -2, 1) + float3(-1, 1, 0), 1);
	}
} 

void CardVoxelizeMaskSetupPS(
	in FCardVoxelizeVSToPS Input)
{
	uint ClipmapIndex = Input.ClipmapIndex;
	uint DirectionIndex = Input.DirectionIndex;
	float3 VoxelSize = ClipmapVoxelSizeAndRadius[ClipmapIndex].xyz;

	uint ObjectIndex = Input.ObjectIndex;
	float3 LocalPositionExtent = LoadGlobalObjectLocalPositionExtent(ObjectIndex) * LUMEN_SDF_APPROX_MARGIN;
	float4x4 WorldToVolume = LoadGlobalObjectWorldToVolume(ObjectIndex);
	bool bGeneratedAsTwoSided;
	float4 UVScaleAndVolumeScale = LoadGlobalObjectUVScale(ObjectIndex, bGeneratedAsTwoSided);
	float4 UVAddAndSelfShadowBias = LoadGlobalObjectUVAddAndSelfShadowBias(ObjectIndex);
	float2 DistanceFieldMAD = LoadGlobalObjectDistanceFieldMAD(ObjectIndex);

	//@todo - track down why this is needed to avoid incorrect culling
	float ExpandTweak = .5f;
	float VoxelRadius = length(ExpandTweak * VoxelSize);
	float3 VolumeSpaceVoxelRadii = mul(float4(VoxelRadius.xxx, 0), WorldToVolume).xyz;
	float VolumeSpaceVoxelRadius = max(VolumeSpaceVoxelRadii.x, max(VolumeSpaceVoxelRadii.y, VolumeSpaceVoxelRadii.z));

	for (uint ZIndex = 0; ZIndex < Input.NumLayers; ZIndex++)
	{
		float SwizzledWorldZ = Input.SwizzledWorldCardMinZ + ZIndex * VoxelSize.z;
		float3 WorldVertexPosition = float3(Input.SwizzledWorldPositionXY, SwizzledWorldZ + .5f * VoxelSize.z);

#if RASTERIZE_MODE != RASTERIZE_ONTO_WORLD_Z
		// Unswizzle back to world space
		if (Input.RasterizationZAxis == 0)
		{
			WorldVertexPosition = WorldVertexPosition.zxy;
		}
		else if (Input.RasterizationZAxis == 1)
		{
			WorldVertexPosition = WorldVertexPosition.yzx;
		}
#endif

		bool bIntersectsVoxel = true;
		if (bIntersectsVoxel)
		{
			float3 VolumeUV = WorldVertexPosition * ClipmapWorldToUVScale[ClipmapIndex].xyz + ClipmapWorldToUVBias[ClipmapIndex].xyz;
			uint3 VoxelCoord = VolumeUV * GridResolution;
			uint3 WriteCoord = uint3(VoxelCoord.x, ClipmapIndex * GridResolution.y + VoxelCoord.y, DirectionIndex * GridResolution.z + VoxelCoord.z);

			RWVoxelMask[WriteCoord] = 1;
		}
	}
}

Texture3D<uint> VoxelMask;
uint VoxelMaskResolutionShift;
RWTexture3D<uint> RWVoxelOITLighting;
RWTexture3D<uint> RWVoxelOITTransparency;
RWTexture3D<uint> RWVoxelVisBuffer;


[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ClearVoxelLightingCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 VoxelCoord = DispatchThreadId;
	uint VoxelUsed = VoxelMask[VoxelCoord >> VoxelMaskResolutionShift];

	if (VoxelUsed > 0)
	{
		RWVoxelOITLighting[uint3(VoxelCoord.x * 4 + 0, VoxelCoord.y, VoxelCoord.z)] = 0;
		RWVoxelOITLighting[uint3(VoxelCoord.x * 4 + 1, VoxelCoord.y, VoxelCoord.z)] = 0;
		RWVoxelOITLighting[uint3(VoxelCoord.x * 4 + 2, VoxelCoord.y, VoxelCoord.z)] = 0;
		RWVoxelOITLighting[uint3(VoxelCoord.x * 4 + 3, VoxelCoord.y, VoxelCoord.z)] = 0;
		RWVoxelOITTransparency[VoxelCoord] = 0xffffffff;
	}
}

void WriteToVoxelLighting(uint3 VoxelCoord, uint ClipmapIndex, uint DirectionIndex, float4 LightingAndOpacity, float Revealage)
{
	if (all(VoxelCoord >= 0) && all(VoxelCoord < GridResolution))
	{
		uint3 WriteCoord = uint3(VoxelCoord.x, ClipmapIndex * GridResolution.y + VoxelCoord.y, DirectionIndex * GridResolution.z + VoxelCoord.z);
		uint4 LightingPayload = LightingAndOpacity * (0xffffffff / (float)0xfffff);

		if (any(LightingPayload != 0))
		{
			InterlockedAdd(RWVoxelOITLighting[uint3(WriteCoord.x * 4 + 0, WriteCoord.y, WriteCoord.z)], LightingPayload.x);
			InterlockedAdd(RWVoxelOITLighting[uint3(WriteCoord.x * 4 + 1, WriteCoord.y, WriteCoord.z)], LightingPayload.y);
			InterlockedAdd(RWVoxelOITLighting[uint3(WriteCoord.x * 4 + 2, WriteCoord.y, WriteCoord.z)], LightingPayload.z);
			InterlockedAdd(RWVoxelOITLighting[uint3(WriteCoord.x * 4 + 3, WriteCoord.y, WriteCoord.z)], LightingPayload.w);
		}

		uint TransparencyPayload = saturate(Revealage) * 0xffffffff;
		// Note: can't emulate float multiply with uint atomics.  Using min for Revealage
		InterlockedMin(RWVoxelOITTransparency[WriteCoord], TransparencyPayload);
	}
}

struct FVoxelVisBuffer
{
	float NormalizedHitDistance;
	uint HitObjectId;
};

#define VIS_BUFFER_INVALID	0
#define VIS_BUFFER_CLEAR	0xFFFFFFFF

uint EncodeVoxelVisBuffer(FVoxelVisBuffer VisBuffer)
{
	uint HitDistanceUInt = uint(saturate(VisBuffer.NormalizedHitDistance) * 0xFF) & 0xFF;
	uint HitObjectUInt = VisBuffer.HitObjectId & 0xFFFFFF;

	uint Payload = (HitDistanceUInt << 24) | HitObjectUInt;

	// Don't collide with VIS_BUFFER_INVALID
	Payload = max(Payload, 1U);

	return Payload;
}

FVoxelVisBuffer DecodeVoxelVisBuffer(uint Payload)
{
	FVoxelVisBuffer VisBuffer;
	VisBuffer.NormalizedHitDistance = ((Payload >> 24) & 0xFF) / float(0xFF);
	VisBuffer.HitObjectId = Payload & 0xFFFFFF;

	return VisBuffer;
}

void CardVoxelizePS(
	in FCardVoxelizeVSToPS Input)
{
	uint ClipmapIndex = Input.ClipmapIndex;
	uint DirectionIndex = Input.DirectionIndex;
	float3 VoxelSize = ClipmapVoxelSizeAndRadius[ClipmapIndex].xyz;

	for (uint ZIndex = 0; ZIndex < Input.NumLayers; ZIndex++)
	{
		float SwizzledWorldZ = Input.SwizzledWorldCardMinZ + ZIndex * VoxelSize.z;
		float3 WorldVertexPosition = float3(Input.SwizzledWorldPositionXY, SwizzledWorldZ + .5f * VoxelSize.z);

#if RASTERIZE_MODE != RASTERIZE_ONTO_WORLD_Z
		// Unswizzle back to world space
		if (Input.RasterizationZAxis == 0)
		{
			WorldVertexPosition = WorldVertexPosition.zxy;
		}
		else if (Input.RasterizationZAxis == 1)
		{
			WorldVertexPosition = WorldVertexPosition.yzx;
		}
#endif

		float3 VolumeUV = WorldVertexPosition * ClipmapWorldToUVScale[ClipmapIndex].xyz + ClipmapWorldToUVBias[ClipmapIndex].xyz;

		uint3 VoxelCoord = VolumeUV * GridResolution;
		uint3 WriteCoord = uint3(VoxelCoord.x, ClipmapIndex * GridResolution.y + VoxelCoord.y, DirectionIndex * GridResolution.z + VoxelCoord.z);

		uint VoxelUsed = 1;
#if !VOXEL_VIS_BUFFER
		VoxelUsed = VoxelMask[WriteCoord >> VoxelMaskResolutionShift];
#endif

		if (VoxelUsed > 0) 
		{
			float3 VoxelMin = ClipmapWorldMin[ClipmapIndex].xyz + VoxelSize * VoxelCoord;
			float3 VoxelExtent = .5f * VoxelSize;
			float3 VoxelCenter = VoxelMin + VoxelExtent;

			float Sign = (DirectionIndex & 1) ? -1.0f : 1.0f;
			uint Axis = DirectionIndex / 2;
			float3 AxisDirection = Sign * float3(Axis == 0 ? 1.0f : 0.0f, Axis == 1 ? 1.0f : 0.0f, Axis == 2 ? 1.0f : 0.0f);
			float3 RayStart = VoxelCenter - AxisDirection * VoxelExtent;
			float3 RayEnd = RayStart + AxisDirection * 2 * VoxelExtent;
			float RayLength = length(RayEnd - RayStart); 

			FConeTraceInput TraceInput;
			TraceInput.Setup(RayStart, AxisDirection, 0, 0, 0, RayLength, 2.0f);
			TraceInput.ConeStartRadius = length(AxisDirection * VoxelExtent);
		
			FCardTraceBlendState TraceBlendState;
			TraceBlendState.Initialize(TraceInput.MaxTraceDistance);
			float3 debug = 0;

			FTraceMeshSDFResult TraceMeshSDFResult;
			TraceMeshSDFResult.HitDistance = TraceInput.MaxTraceDistance;
			TraceMeshSDFResult.HitObject = 0;

			RayTraceSingleMeshSDF(
				TraceInput.ConeOrigin, 
				TraceInput.ConeDirection, 
				TraceInput.TanConeAngle,
				TraceInput.MinTraceDistance,
				TraceInput.MaxTraceDistance, 
				Input.ObjectIndex, 
				true,
				0.0f,
				TraceMeshSDFResult);

			if (TraceMeshSDFResult.HitDistance < TraceInput.MaxTraceDistance)
			{
#if VOXEL_VIS_BUFFER
				FVoxelVisBuffer VisBuffer;
				VisBuffer.NormalizedHitDistance = saturate(TraceMeshSDFResult.HitDistance / TraceInput.MaxTraceDistance);
				VisBuffer.HitObjectId = TraceMeshSDFResult.HitObject;

				uint VisBufferPayload = EncodeVoxelVisBuffer(VisBuffer);

				uint3 WriteCoord = uint3(VoxelCoord.x, ClipmapIndex * GridResolution.y + VoxelCoord.y, DirectionIndex * GridResolution.z + VoxelCoord.z);
				InterlockedMin(RWVoxelVisBuffer[WriteCoord], VisBufferPayload);
#else
				FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(TraceInput.ConeOrigin, TraceInput.ConeDirection, TraceInput.MaxTraceDistance, TraceMeshSDFResult);

				float3 InterpolatePosition = TraceInput.ConeOrigin + TraceInput.ConeDirection * TraceMeshSDFResult.HitDistance;
				float InterpolateRadius = TraceInput.ConeStartRadius;
				float CardInterpolateInfluenceRadius = 20;
				float CardInterpolateDepthVisibilityRadius = VoxelSize.x;

				// #lumen_todo: TEMP hack, remove after atlas mip-map out of bounds bug is fixed
				InterpolateRadius = 0.0f;

				float3 Lighting = SampleLumenCubeMapTree(TraceMeshSDFResult.HitObject, InterpolatePosition, TraceSDFData.HitNormal, InterpolateRadius, TraceSDFData.bAccurateHit, CardInterpolateDepthVisibilityRadius);

				TraceBlendState.AddLighting(Lighting, 1.0f, TraceMeshSDFResult.HitDistance);
				TraceBlendState.RegisterOpaqueHit(TraceMeshSDFResult.HitDistance);

				if (TraceBlendState.GetTransparency() < 1)
				{
					WriteToVoxelLighting(VoxelCoord, ClipmapIndex, DirectionIndex, TraceBlendState.GetLightingAndOpacity(), TraceBlendState.GetTransparency());
				}
#endif // VIS_BUFFER
			}
		}
	}
}

[numthreads(1, 1, 1)]
void SetupComputeScaterIndirectArgsCS()
{
	uint NumElements = QuadAllocator[0];
	uint NumWaves = (NumElements * NUM_VOXEL_DIRECTIONS * SCATTER_BATCH_SIZE + 63) / 64;

	RWObjectIndirectArguments[0] = NumWaves;
	RWObjectIndirectArguments[1] = 1;
	RWObjectIndirectArguments[2] = 1;
}

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ComputeScatterCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{	
	uint QuadIndex = DispatchThreadId.x / (NUM_VOXEL_DIRECTIONS * SCATTER_BATCH_SIZE);
	uint DirectionIndex = DispatchThreadId.x % NUM_VOXEL_DIRECTIONS;
	uint QuadLinearGridIndex = (DispatchThreadId.x / NUM_VOXEL_DIRECTIONS) % SCATTER_BATCH_SIZE;

	if (QuadIndex < QuadAllocator[0])
	{
		uint PackedQuadData0 = QuadData[QuadIndex * 2 + 0];
		uint PackedQuadData1 = QuadData[QuadIndex * 2 + 1];

		uint ObjectIndex = PackedQuadData0;
		uint ObjectSubIndex = PackedQuadData1 & 0xFFFF;
		uint ClipmapIndex = PackedQuadData1 >> 28;

		#if SINGLE_CLIPMAP_TO_UPDATE
			// Fast path for common case when we update only 1 clipmap
			ObjectSubIndex = PackedQuadData1;
			ClipmapIndex = 0;
		#endif

		float3 WorldObjectCenter = LoadGlobalObjectPositionAndRadius(ObjectIndex).xyz;
		float3 WorldObjectExtent = LoadGlobalObjectExtent(ObjectIndex) * LUMEN_SDF_APPROX_MARGIN;

		uint3 ObjectGridMin;
		uint3 ObjectGridMax;
		uint3 ObjectGridSize;
		WorldObjectToGrid(WorldObjectCenter, WorldObjectExtent, ClipmapIndex, ObjectGridMin, ObjectGridMax, ObjectGridSize);

		uint ObjectLinearGridIndex = SCATTER_BATCH_SIZE * ObjectSubIndex + QuadLinearGridIndex;

		uint3 VoxelCoord = ObjectGridMin;
		VoxelCoord.x += ObjectLinearGridIndex % ObjectGridSize.x;
		VoxelCoord.y += ObjectLinearGridIndex / ObjectGridSize.x;
		VoxelCoord.z = 0;

		if (ObjectLinearGridIndex < ObjectGridSize.x * ObjectGridSize.y)
		{
			for (uint LayerIndex = ObjectGridMin.z; LayerIndex < ObjectGridMax.z; ++LayerIndex)
			{
				VoxelCoord.z = LayerIndex;

				float3 VoxelSize = ClipmapVoxelSizeAndRadius[ClipmapIndex].xyz;
				float3 VoxelMin = ClipmapWorldMin[ClipmapIndex].xyz + VoxelSize * VoxelCoord;
				float3 VoxelExtent = .5f * VoxelSize;
				float3 VoxelCenter = VoxelMin + VoxelExtent;

				float Sign = (DirectionIndex & 1) ? -1.0f : 1.0f;
				uint Axis = DirectionIndex / 2;
				float3 AxisDirection = Sign * float3(Axis == 0 ? 1.0f : 0.0f, Axis == 1 ? 1.0f : 0.0f, Axis == 2 ? 1.0f : 0.0f);
				float3 RayStart = VoxelCenter - AxisDirection * VoxelExtent;
				float3 RayEnd = RayStart + AxisDirection * 2 * VoxelExtent;
				float RayLength = length(RayEnd - RayStart);

				FConeTraceInput TraceInput;
				TraceInput.Setup(RayStart, AxisDirection, 0, 0, 0, RayLength, 2.0f);
				TraceInput.ConeStartRadius = length(AxisDirection * VoxelExtent);

				FTraceMeshSDFResult TraceMeshSDFResult;
				TraceMeshSDFResult.HitDistance = TraceInput.MaxTraceDistance;
				TraceMeshSDFResult.HitObject = 0;

				RayTraceSingleMeshSDF(
					TraceInput.ConeOrigin,
					TraceInput.ConeDirection,
					TraceInput.TanConeAngle,
					TraceInput.MinTraceDistance,
					TraceInput.MaxTraceDistance,
					ObjectIndex,
					true,
					0.0f,
					TraceMeshSDFResult);

				if (TraceMeshSDFResult.HitDistance < TraceInput.MaxTraceDistance)
				{
					uint VisBufferPayload = VIS_BUFFER_CLEAR;

					if (TraceMeshSDFResult.bRayStartInsideGeometry)
					{
						VisBufferPayload = VIS_BUFFER_INVALID;
					}
					else
					{
						FVoxelVisBuffer VisBuffer;
						VisBuffer.NormalizedHitDistance = saturate(TraceMeshSDFResult.HitDistance / TraceInput.MaxTraceDistance);
						VisBuffer.HitObjectId = TraceMeshSDFResult.HitObject;
						VisBufferPayload = EncodeVoxelVisBuffer(VisBuffer);
					}

					uint3 WriteCoord = uint3(VoxelCoord.x, ClipmapIndex * GridResolution.y + VoxelCoord.y, DirectionIndex * GridResolution.z + VoxelCoord.z);
					InterlockedMin(RWVoxelVisBuffer[WriteCoord], VisBufferPayload);
				}
			}
		}
	}
}

#define CULL_GRID_TILE_SIZE 4

// Tweaked for the LDS size / occupancy
#define MAX_CULLED_DF_OBJECTS 510
groupshared uint GroupCellObjects[MAX_CULLED_DF_OBJECTS];
groupshared uint GroupCellObjectNum;
groupshared uint GroupCullGridDataInsertIndex;

RWBuffer<uint> RWCullGridAllocator;
RWBuffer<uint> RWCullGridHeader;
RWBuffer<uint> RWCullGridData;

uint CullGridCapacity;
float3 CullTileWorldExtent;
float3 CullGridCoordToWorldCenterScale;
float3 CullGridCoordToWorldCenterBias;

RWBuffer<uint> RWObjectIndexAllocator;
RWBuffer<uint> RWObjectIndexBuffer;

float3 CullClipmapWorldCenter;
float3 CullClipmapWorldExtent;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void GatherVoxelizeClipmapCullCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ObjectIndex = DispatchThreadId.x;

	if (ObjectIndex < NumSceneObjects)
	{
		float3 WorldObjectCenter = SceneObjectBounds[ObjectIndex * OBJECT_BOUNDS_STRIDE + 0].xyz;
		float3 WorldObjectExtent = SceneObjectBounds[ObjectIndex * OBJECT_BOUNDS_STRIDE + 1].xyz * LUMEN_SDF_APPROX_MARGIN;

		float BoundsRadius = length(WorldObjectExtent);

		float DistanceSq = ComputeSquaredDistanceBetweenAABBs(CullClipmapWorldCenter, CullClipmapWorldExtent, WorldObjectCenter, WorldObjectExtent);

		float DistanceToView = length(View.WorldCameraOrigin - WorldObjectCenter);

		if (DistanceSq < 0.01f
			&& BoundsRadius > MeshSDFRadiusThreshold
			&& BoundsRadius / DistanceToView > MeshSDFScreenSizeThreshold)
		{
			uint InsertIndex;
			InterlockedAdd(RWObjectIndexAllocator[0], 1U, InsertIndex);
			RWObjectIndexBuffer[InsertIndex] = ObjectIndex;
		}
	}
}

uint3 CullGridResolution;
Buffer<uint> ObjectIndexAllocator;
Buffer<uint> ObjectIndexBuffer;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void GatherVoxelizeGridCullCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = GroupThreadId.x;
	uint3 CullGridCoord = GroupId;
	uint CullGridLinearIndex = CullGridCoord.x + CullGridCoord.y * CullGridResolution.x + CullGridCoord.z * CullGridResolution.x * CullGridResolution.y;

	if (ThreadIndex == 0)
	{
		GroupCellObjectNum = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint NumObjects = ObjectIndexAllocator[0];

	for (uint ObjectIndexInList = ThreadIndex; ObjectIndexInList < NumObjects; ObjectIndexInList += 64)
	{
		uint ObjectIndex = ObjectIndexBuffer[ObjectIndexInList];

		float3 WorldObjectCenter = SceneObjectBounds[ObjectIndex * OBJECT_BOUNDS_STRIDE + 0].xyz;
		float3 WorldObjectExtent = SceneObjectBounds[ObjectIndex * OBJECT_BOUNDS_STRIDE + 1].xyz * LUMEN_SDF_APPROX_MARGIN;

		float3 CullTileWorldCenter = CullGridCoord * CullGridCoordToWorldCenterScale + CullGridCoordToWorldCenterBias;

		float DistanceSq = ComputeSquaredDistanceBetweenAABBs(CullTileWorldCenter, CullTileWorldExtent, WorldObjectCenter, WorldObjectExtent);

		if (DistanceSq < 0.01f)
		{
			// #lumen_todo: restore
			//float3 LocalPositionExtent = LoadGlobalObjectLocalPositionExtent(ObjectIndex) * LUMEN_SDF_APPROX_MARGIN;
			//if (DoesMeshSDFAffectSphere(CullTileWorldCenter, length(CullTileWorldExtent.xyz), ObjectIndex, LocalPositionExtent))
			{
				uint InsertIndex;
				InterlockedAdd(GroupCellObjectNum, 1, InsertIndex);

				if (InsertIndex < MAX_CULLED_DF_OBJECTS)
				{
					GroupCellObjects[InsertIndex] = ObjectIndex;
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (ThreadIndex == 0)
	{
		uint CellObjectNum = min(GroupCellObjectNum, MAX_CULLED_DF_OBJECTS);

		uint CullGridDataInsertIndex;
		InterlockedAdd(RWCullGridAllocator[0], CellObjectNum, CullGridDataInsertIndex);

		if (CullGridDataInsertIndex > CullGridCapacity)
		{
			CellObjectNum = 0;
		}
		else
		{
			CellObjectNum = min(CellObjectNum, CullGridCapacity - CullGridDataInsertIndex);
		}

		RWCullGridHeader[CullGridLinearIndex * 2 + 0] = CellObjectNum;
		RWCullGridHeader[CullGridLinearIndex * 2 + 1] = CullGridDataInsertIndex;

		GroupCullGridDataInsertIndex = CullGridDataInsertIndex;
		GroupCellObjectNum = CellObjectNum;
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint ObjectInListIndex = ThreadIndex; ObjectInListIndex < GroupCellObjectNum; ObjectInListIndex += 64)
	{
		RWCullGridData[GroupCullGridDataInsertIndex + ObjectInListIndex] = GroupCellObjects[ObjectInListIndex];
	}
}

Buffer<uint> CullGridHeader;
Buffer<uint> CullGridData;
uint3 ClipmapGridResolution;
uint3 OutputGridResolution;
uint CompactedClipmapIndex;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void GatherVoxelizeCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 VoxelCoord = DispatchThreadId;

	if (all(VoxelCoord < OutputGridResolution))
	{
		uint DirectionA = DispatchThreadId.x % 3;
		uint DirectionB = DispatchThreadId.y % 2;
		uint DirectionIndex = DirectionA + DirectionB * 3;
		VoxelCoord.x /= 3;
		VoxelCoord.y /= 2;

		float3 VoxelMin = GridMin + GridVoxelSize * VoxelCoord;
		float3 VoxelExtent = .5f * GridVoxelSize;
		float3 VoxelCenter = VoxelMin + VoxelExtent;

		float DirectionSign = (DirectionIndex & 0x1) ? -1.0f : 1.0f;
		uint AxisIndex = DirectionIndex / 2;
		float3 RayDirection = DirectionSign * float3(AxisIndex == 0 ? 1.0f : 0.0f, AxisIndex == 1 ? 1.0f : 0.0f, AxisIndex == 2 ? 1.0f : 0.0f);
		float3 RayStart = VoxelCenter - RayDirection * VoxelExtent;
		float3 RayEnd = RayStart + RayDirection * 2 * VoxelExtent;
		float RayLength = length(RayEnd - RayStart);

		bool bRayStartInsideGeometry = false;
		uint HitObjectId = 0xFFFFFFFF;
		float HitTime = 1e6;

		uint3 CullGridCoord = VoxelCoord / CULL_GRID_TILE_SIZE;
		uint CullGridLinearIndex = CullGridCoord.x + CullGridCoord.y * CullGridResolution.x + CullGridCoord.z * CullGridResolution.x * CullGridResolution.y;

		uint NumCulledObjects = CullGridHeader[CullGridLinearIndex * 2 + 0];
		uint CullGridOffset = CullGridHeader[CullGridLinearIndex * 2 + 1];

		for (uint ObjectIndexInCell = 0; ObjectIndexInCell < NumCulledObjects; ++ObjectIndexInCell)
		{
			uint ObjectIndex = CullGridData[CullGridOffset + ObjectIndexInCell];

			FConeTraceInput TraceInput;
			TraceInput.Setup(RayStart, RayDirection, 0, 0, 0, RayLength, 2.0f);
			TraceInput.ConeStartRadius = length(RayDirection * VoxelExtent);

			FTraceMeshSDFResult TraceMeshSDFResult;
			TraceMeshSDFResult.HitDistance = TraceInput.MaxTraceDistance;
			TraceMeshSDFResult.HitObject = 0;

			RayTraceSingleMeshSDF(
				TraceInput.ConeOrigin,
				TraceInput.ConeDirection,
				TraceInput.TanConeAngle,
				TraceInput.MinTraceDistance,
				//min(TraceInput.MaxTraceDistance, HitTime), // #lumen_todo: fix flicker and restore
				TraceInput.MaxTraceDistance,
				ObjectIndex,
				true,
				0.0f,
				TraceMeshSDFResult);

			if (TraceMeshSDFResult.HitDistance < TraceInput.MaxTraceDistance && TraceMeshSDFResult.HitDistance < HitTime)
			{
				HitTime = TraceMeshSDFResult.HitDistance;
				HitObjectId = TraceMeshSDFResult.HitObject;
				bRayStartInsideGeometry = TraceMeshSDFResult.bRayStartInsideGeometry;
			}

			if (bRayStartInsideGeometry)
			{
				break;
			}
		}

		uint VisBufferPayload = VIS_BUFFER_CLEAR;

		if (bRayStartInsideGeometry)
		{
			// Skip voxelization for this ray
			VisBufferPayload = VIS_BUFFER_INVALID;
		}
		else if (HitObjectId < 0xFFFFFFFF)
		{
			FVoxelVisBuffer VisBuffer;
			VisBuffer.NormalizedHitDistance = saturate(HitTime / RayLength);
			VisBuffer.HitObjectId = HitObjectId;

			VisBufferPayload = EncodeVoxelVisBuffer(VisBuffer);
		}

		uint3 WriteCoord = uint3(VoxelCoord.x, CompactedClipmapIndex * ClipmapGridResolution.y + VoxelCoord.y, DirectionIndex * ClipmapGridResolution.z + VoxelCoord.z);
		RWVoxelVisBuffer[WriteCoord] = VisBufferPayload;
	}
}

uint3 ClipmapTextureResolution;
Texture3D<uint> VoxelOITLighting;
Texture3D<uint> VoxelOITTransparency;
uint SourceClipmapIndex;
uint DestClipmapIndex;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CompactVoxelLightingCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 VoxelCoord = DispatchThreadId;

	if (all(VoxelCoord < ClipmapTextureResolution))
	{
		uint3 ReadCoord = uint3(VoxelCoord.x, VoxelCoord.y + SourceClipmapIndex * GridResolution.y, VoxelCoord.z);
		uint VoxelUsed = VoxelMask[ReadCoord >> VoxelMaskResolutionShift];

		float3 Lighting = 0;
		float Revealage = 1;

		if (VoxelUsed > 0)
		{
			uint4 LightingPayload;
			LightingPayload.x = VoxelOITLighting.Load(int4(ReadCoord.x * 4 + 0, ReadCoord.y, ReadCoord.z, 0)).x;
			LightingPayload.y = VoxelOITLighting.Load(int4(ReadCoord.x * 4 + 1, ReadCoord.y, ReadCoord.z, 0)).x;
			LightingPayload.z = VoxelOITLighting.Load(int4(ReadCoord.x * 4 + 2, ReadCoord.y, ReadCoord.z, 0)).x;
			LightingPayload.w = VoxelOITLighting.Load(int4(ReadCoord.x * 4 + 3, ReadCoord.y, ReadCoord.z, 0)).x;
			// If the denominator quantized to zero the error will be catastrophic
			LightingPayload.w = max(LightingPayload.w, 1);
			float4 LightingAndWeightedOpacity = LightingPayload * ((float)0xfffff / 0xffffffff);
			Revealage = saturate(VoxelOITTransparency.Load(int4(ReadCoord, 0)).x / (float)0xffffffff);
			float ClampedWeightedOpacity = max(LightingAndWeightedOpacity.a, MIN_flt);
			Lighting = LightingAndWeightedOpacity.rgb / ClampedWeightedOpacity * (1 - Revealage);
		}
	
		uint3 WriteCoord = uint3(VoxelCoord.x, VoxelCoord.y + DestClipmapIndex * GridResolution.y, VoxelCoord.z);
		RWVoxelLighting[WriteCoord] = float4(Lighting, 1.0f - Revealage);
	}
}

Texture3D<uint> VoxelVisBuffer;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void VoxelVisBufferShadingCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 VoxelCoord = DispatchThreadId;

	if (all(VoxelCoord < OutputGridResolution))
	{
		uint DirectionA = DispatchThreadId.x % 3;
		uint DirectionB = DispatchThreadId.y % 2;
		uint DirectionIndex = DirectionA + DirectionB * 3;
		VoxelCoord.x /= 3;
		VoxelCoord.y /= 2;

		float3 VoxelMin = GridMin + GridVoxelSize * VoxelCoord;
		float3 VoxelExtent = .5f * GridVoxelSize;
		float3 VoxelCenter = VoxelMin + VoxelExtent;

		float3 Lighting = 0;
		float Transparency = 1;

		uint3 ReadCoord = uint3(VoxelCoord.x, VoxelCoord.y + SourceClipmapIndex * ClipmapGridResolution.y, DirectionIndex * ClipmapGridResolution.z + VoxelCoord.z);
		uint VisBufferPayload = VoxelVisBuffer.Load(int4(ReadCoord, 0)).x;

		if (VisBufferPayload != VIS_BUFFER_INVALID && VisBufferPayload != VIS_BUFFER_CLEAR)
		{
			float Sign = (DirectionIndex & 1) ? -1.0f : 1.0f;
			uint Axis = DirectionIndex / 2;
			float3 RayDirection = Sign * float3(Axis == 0 ? 1.0f : 0.0f, Axis == 1 ? 1.0f : 0.0f, Axis == 2 ? 1.0f : 0.0f);
			float3 RayStart = VoxelCenter - RayDirection * VoxelExtent;
			float3 RayEnd = RayStart + RayDirection * 2 * VoxelExtent;
			float RayLength = length(RayEnd - RayStart);
			float ConeStartRadius = length(RayDirection * VoxelExtent);

			FVoxelVisBuffer VisBuffer = DecodeVoxelVisBuffer(VisBufferPayload);
			FTraceMeshSDFResult TraceMeshSDFResult;
			TraceMeshSDFResult.HitDistance = RayLength * VisBuffer.NormalizedHitDistance;
			TraceMeshSDFResult.HitObject = VisBuffer.HitObjectId;

			FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(RayStart, RayDirection, RayLength, TraceMeshSDFResult);

			float3 InterpolatePosition = RayStart + RayDirection * TraceMeshSDFResult.HitDistance;

			//@todo - compute based on SDF voxel size, or card texel size
			float CardInterpolateDepthVisibilityRadius = 10.0f;
			float InterpolateRadius = VoxelExtent.x;

			// #lumen_todo: TEMP hack, remove after atlas mip-map out of bounds bug is fixed
			InterpolateRadius = 0.0f;

			float4 LightingAndWeight = SampleLumenCubeMapTreeWithWeight(TraceMeshSDFResult.HitObject, InterpolatePosition, -RayDirection, InterpolateRadius, TraceSDFData.bAccurateHit, CardInterpolateDepthVisibilityRadius);

			Lighting = LightingAndWeight.xyz;
			Transparency = 1.0f - LightingAndWeight.w;
		}

		uint3 WriteCoord = uint3(VoxelCoord.x, TargetClipmapIndex * ClipmapGridResolution.y + VoxelCoord.y, DirectionIndex * ClipmapGridResolution.z + VoxelCoord.z);
		RWVoxelLighting[WriteCoord] = float4(Lighting, 1.0f - Transparency);
	}
}