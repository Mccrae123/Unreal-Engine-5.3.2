// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadianceCache.usf
=============================================================================*/

#define CARD_TRACE_DEPTH_WEIGHTED_OIT 0

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../FastMath.ush"
#include "../DeferredShadingCommon.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "ProbeHierarchy/LumenProbeTracing.ush"
#include "LumenScreenProbeCommon.ush"

RWTexture3D<uint> RWRadianceProbeIndirectionTexture;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void ClearProbeIndirectionCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	RWRadianceProbeIndirectionTexture[DispatchThreadId] = INVALID_PROBE_INDEX;
}

RWBuffer<int> RWProbeFreeListAllocator;
RWBuffer<uint> RWProbeFreeList;
RWBuffer<uint> RWProbeLastUsedFrame;
uint MaxNumProbes;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearProbeFreeListCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = DispatchThreadId.x;

	if (ThreadIndex == 0)
	{
		RWProbeFreeListAllocator[0] = 0;
	}

	if (ThreadIndex < MaxNumProbes)
	{
		RWProbeFreeList[ThreadIndex] = 0;
		RWProbeLastUsedFrame[ThreadIndex] = 0;
	}
}

uint2 DownsampledViewSize;
float DownsampleFactor; 
uint VisualizeLumenScene;

#define USED_PROBE_INDEX 0xFFFFFFFE

void MarkPositionUsedInIndirectionTextureForClipmap(float3 WorldPosition, uint ClipmapIndex)
{
#if RADIANCE_CACHE_USE_INTERPOLATION
	int3 BottomCornerProbeCoord = WorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex] - .5f;
	int3 IndirectionTextureCoord = BottomCornerProbeCoord + int3(ClipmapIndex * RadianceProbeClipmapResolution, 0, 0);

	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(0, 0, 1)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(0, 1, 0)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(0, 1, 1)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 0, 0)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 0, 1)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 1, 0)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 1, 1)] = USED_PROBE_INDEX;
#else
	int3 ProbeCoord = WorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];
	int3 IndirectionTextureCoord = ProbeCoord + int3(ClipmapIndex * RadianceProbeClipmapResolution, 0, 0);
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord] = USED_PROBE_INDEX;
#endif
}

void MarkPositionUsedInIndirectionTexture(float3 WorldPosition, uint ClipmapIndex)
{
#if RADIANCE_CACHE_USE_HIERARCHY
	for (uint i = ClipmapIndex; i < NumRadianceProbeClipmaps; i++)
	{
		MarkPositionUsedInIndirectionTextureForClipmap(WorldPosition, i);
	}
#else
	MarkPositionUsedInIndirectionTextureForClipmap(WorldPosition, ClipmapIndex);
#endif
}

RWBuffer<uint> DispatchParametersOutput;

[numthreads(PROBE_HIERARCHY_MAX_HIERARCHY_DEPTH, 1, 1)]
void SetupMarkRadianceProbesUsedByProbeHierarchyCS(uint GroupThreadIndex : SV_GroupIndex)
{
	if (GroupThreadIndex < PROBE_HIERARCHY_MAX_HIERARCHY_DEPTH)
	{
		uint HierarchyLevelId = GroupThreadIndex;
		FHierarchyLevelParameters HierarchyLevel = GetProbeHierarchyLevelParameters(HierarchyLevelId);

		DispatchParametersOutput[3 * HierarchyLevel.Id + 0] = 1;
		DispatchParametersOutput[3 * HierarchyLevel.Id + 1] = (HierarchyLevel.ProbeCount + (PROBE_TRACING_LANE_COUNT - 1)) / PROBE_TRACING_LANE_COUNT;
		DispatchParametersOutput[3 * HierarchyLevel.Id + 2] = 1;
	}
}

[numthreads(PROBE_TRACING_LANE_COUNT, 1, 1)]
void MarkRadianceProbesUsedByProbeHierarchyCS(
	uint3 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	if (VisualizeLumenScene > 0 && all(GroupId == 0) && GroupThreadIndex == 0)
	{
		// For visualize mode, generate probes around the camera position
		uint ClipmapIndex = GetRadianceProbeClipmap(View.WorldCameraOrigin);
		MarkPositionUsedInIndirectionTexture(View.WorldCameraOrigin, ClipmapIndex);
	}

	FHierarchyLevelParameters HierarchyLevel = GetPassProbeHierarchyLevelParameters();
	uint ProbeIndex = HierarchyLevel.ProbeArrayOffset + GroupId.y * PROBE_TRACING_LANE_COUNT + GroupThreadIndex;

	if (ProbeIndex < HierarchyLevel.ProbeArrayOffset + HierarchyLevel.ProbeCount)
	{
		float3 WorldPosition = ReadProbeInfo(ProbeIndex).TranslatedWorldPosition - View.PreViewTranslation;

		uint ClipmapIndex = GetRadianceProbeClipmap(WorldPosition);

		if (ClipmapIndex < NumRadianceProbeClipmaps)
		{
			MarkPositionUsedInIndirectionTexture(WorldPosition, ClipmapIndex);
		}
	}
} 

[numthreads(PROBE_THREADGROUP_SIZE_2D, PROBE_THREADGROUP_SIZE_2D, 1)]
void MarkRadianceProbesUsedByScreenProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy;
	
	if (VisualizeLumenScene > 0 && all(DispatchThreadId.xy == 0))
	{
		// For visualize mode, generate probes around the camera position
		uint ClipmapIndex = GetRadianceProbeClipmap(View.WorldCameraOrigin);
		MarkPositionUsedInIndirectionTexture(View.WorldCameraOrigin, ClipmapIndex);
	}

	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;
	uint2 ScreenProbeScreenCoord;
	uint ScreenProbeSubsampleIndex;
	GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

		if (SceneDepth > 0 && SceneDepth < 1000000.0f)
		{
			uint ClipmapIndex = GetRadianceProbeClipmap(WorldPosition);

			if (ClipmapIndex < NumRadianceProbeClipmaps)
			{
				//@todo - cull by screen size
				//@todo - cull probes too small for voxel tracing and too large for max trace distance
				MarkPositionUsedInIndirectionTexture(WorldPosition, ClipmapIndex);
			}
		}
	}
}

Texture3D<uint> LastFrameRadianceProbeIndirectionTexture;
float LastFrameRadianceProbeCoordToWorldPositionScale[RADIANCE_PROBE_MAX_CLIPMAPS];
float3 LastFrameRadianceProbeCoordToWorldPositionBias[RADIANCE_PROBE_MAX_CLIPMAPS];
uint FrameNumber;
uint NumFramesToKeepCachedProbes;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void UpdateCacheForUsedProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		uint3 LastFrameProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.y, DispatchThreadId.z);
		uint3 LastFrameProbeIndirectionTextureCoord = uint3(LastFrameProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, LastFrameProbeCoord.yz);
		uint LastFrameProbeIndex = LastFrameRadianceProbeIndirectionTexture.Load(uint4(LastFrameProbeIndirectionTextureCoord, 0));

		if (LastFrameProbeIndex != INVALID_PROBE_INDEX)
		{
			float3 ProbeWorldPosition = LastFrameProbeCoord * LastFrameRadianceProbeCoordToWorldPositionScale[ClipmapIndex] + LastFrameRadianceProbeCoordToWorldPositionBias[ClipmapIndex];
			int3 ProbeCoord = ProbeWorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

			bool bReused = false;

			if (all(ProbeCoord > 0) && all(ProbeCoord < (int3)RadianceProbeClipmapResolution))
			{
				uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, ProbeCoord.yz);
				uint ProbeUsedMarker = RWRadianceProbeIndirectionTexture[ProbeIndirectionTextureCoord];
				uint LastUsedFrameNumber = RWProbeLastUsedFrame[LastFrameProbeIndex];

				if (ProbeUsedMarker == USED_PROBE_INDEX || FrameNumber - LastUsedFrameNumber < NumFramesToKeepCachedProbes)
				{
					bReused = true;

					if (ProbeUsedMarker == USED_PROBE_INDEX)
					{
						RWProbeLastUsedFrame[LastFrameProbeIndex] = FrameNumber;
					}
					RWRadianceProbeIndirectionTexture[ProbeIndirectionTextureCoord] = LastFrameProbeIndex;
				}
			}

			if (!bReused)
			{
				int FreeIndex;
				InterlockedAdd(RWProbeFreeListAllocator[0], 1, FreeIndex);
				RWProbeFreeList[FreeIndex] = LastFrameProbeIndex;
			}
		}
	}
}

RWBuffer<uint> RWProbeAllocator;
RWBuffer<uint> RWProbeTraceAllocator;
RWBuffer<float4> RWProbeTraceData;
Buffer<uint> ProbeFreeList;
uint ProbesUpdateEveryNFrames;
uint NumProbeTracesBudget;

Buffer<uint> NewProbeTraceAllocator;

bool ShouldUpdateProbeThisFrame(uint ProbeIndex, float3 ProbeWorldPosition)
{
	uint EffectiveProbesUpdateEveryNFrames = ProbesUpdateEveryNFrames;

	// If the new probes already exceeded the trace budget, greatly lower the update rate for existing probes
	if (NewProbeTraceAllocator[0] > NumProbeTracesBudget)
	{
		EffectiveProbesUpdateEveryNFrames *= 10;
	}
#define PROBE_UPDATE_BASED_ON_VIEWER_DISTANCE 1
#if PROBE_UPDATE_BASED_ON_VIEWER_DISTANCE
	float DistanceFromViewerSq = dot(View.WorldCameraOrigin - ProbeWorldPosition, View.WorldCameraOrigin - ProbeWorldPosition);
	uint ProbeUpdateFrequency = clamp((uint)pow(DistanceFromViewerSq * .001f, .25f), EffectiveProbesUpdateEveryNFrames, 100);

	return ProbeIndex % ProbeUpdateFrequency == FrameNumber % ProbeUpdateFrequency;
#else
	return ProbeIndex % EffectiveProbesUpdateEveryNFrames == FrameNumber % EffectiveProbesUpdateEveryNFrames;
#endif
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void AllocateUsedProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		uint ProbeUsedMarker = RWRadianceProbeIndirectionTexture[DispatchThreadId];

		uint3 ProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.y, DispatchThreadId.z);
		float3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPositionScale[ClipmapIndex] + RadianceProbeCoordToWorldPositionBias[ClipmapIndex];

		bool bTraceProbe;

		#if UPDATE_NEW_PROBES_PASS
			// Trace cache misses in the first pass
			bTraceProbe = ProbeUsedMarker == USED_PROBE_INDEX;
		#else
			// Retrace cache hits in the second pass
			bTraceProbe = ProbeUsedMarker != INVALID_PROBE_INDEX && ProbeUsedMarker != USED_PROBE_INDEX && ShouldUpdateProbeThisFrame(ProbeUsedMarker, ProbeWorldPosition);;
		#endif

		if (bTraceProbe)
		{
			uint ProbeIndex;

			if (ProbeUsedMarker == USED_PROBE_INDEX)
			{
			#if PERSISTENT_CACHE
				int NumFree;
				InterlockedAdd(RWProbeFreeListAllocator[0], -1, NumFree);

				if (NumFree > 0)
				{
					ProbeIndex = ProbeFreeList[NumFree - 1];
				}
				else
				{
					InterlockedAdd(RWProbeAllocator[0], 1, ProbeIndex);
				}
			#else
				InterlockedAdd(RWProbeAllocator[0], 1, ProbeIndex);
			#endif
				RWProbeLastUsedFrame[ProbeIndex] = FrameNumber;
			}
			else
			{
				ProbeIndex = ProbeUsedMarker;
			}

			if (ProbeIndex < MaxNumProbes)
			{
				RWRadianceProbeIndirectionTexture[DispatchThreadId] = ProbeIndex;

				uint TraceIndex;
				InterlockedAdd(RWProbeTraceAllocator[0], 1, TraceIndex);

				RWProbeTraceData[TraceIndex] = float4(ProbeWorldPosition, asfloat((ClipmapIndex << 24) | ProbeIndex));
			}
			else
			{
				RWRadianceProbeIndirectionTexture[DispatchThreadId] = INVALID_PROBE_INDEX;
			}
		}
	}
}

[numthreads(1, 1, 1)]
void ClampProbeFreeListAllocatorCS()
{
	if (RWProbeFreeListAllocator[0] < 0)
	{
		RWProbeFreeListAllocator[0] = 0;
	}

	if (RWProbeFreeListAllocator[0] > (int)MaxNumProbes)
	{
		RWProbeFreeListAllocator[0] = (int)MaxNumProbes;
	}
}

RWBuffer<uint> RWTraceProbesIndirectArgs;
RWBuffer<uint> RWTraceProbesOverbudgetIndirectArgs;
RWBuffer<uint> RWFixupProbeBordersIndirectArgs;
Buffer<uint> ProbeTraceAllocator;
uint TraceFromProbesGroupSizeXY;
#define OVERBUDGET_DOWNSAMPLE_FACTOR 2

[numthreads(1, 1, 1)]
void SetupTraceFromProbesCS()
{
	uint NumProbesToTrace = ProbeTraceAllocator[0];

	RWTraceProbesIndirectArgs[0] = (RadianceProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWTraceProbesIndirectArgs[1] = (RadianceProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWTraceProbesIndirectArgs[2] = min(NumProbesToTrace, NumProbeTracesBudget);

	RWTraceProbesOverbudgetIndirectArgs[0] = (RadianceProbeResolution / OVERBUDGET_DOWNSAMPLE_FACTOR + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWTraceProbesOverbudgetIndirectArgs[1] = (RadianceProbeResolution / OVERBUDGET_DOWNSAMPLE_FACTOR + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWTraceProbesOverbudgetIndirectArgs[2] = max((int)NumProbesToTrace - (int)NumProbeTracesBudget, 0);

	RWFixupProbeBordersIndirectArgs[0] = (FinalProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWFixupProbeBordersIndirectArgs[1] = (FinalProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY;
	RWFixupProbeBordersIndirectArgs[2] = NumProbesToTrace;
}

Buffer<float4> ProbeTraceData;
RWTexture2D<float4> RWRadianceProbeAtlasTexture;

float StepFactor;
float VoxelStepFactor;
float MinSampleRadius;
float MinTraceDistance;
float MaxTraceDistance;
float MaxCardTraceDistance;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void TraceFromProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ProbeTraceIndex = GroupId.z;

#if OVERBUDGET_TRACING_PASS
	ProbeTraceIndex += NumProbeTracesBudget;
	uint TraceResolution = RadianceProbeResolution / OVERBUDGET_DOWNSAMPLE_FACTOR;
#else
	uint TraceResolution = RadianceProbeResolution;
#endif

	uint2 ProbeTexelCoord = DispatchThreadId.xy;

	float3 ProbeWorldCenter = ProbeTraceData[ProbeTraceIndex].xyz;
	uint PackedW = asuint(ProbeTraceData[ProbeTraceIndex].w);
	uint ClipmapIndex = PackedW >> 24;
	uint ProbeIndex = PackedW & 0xFFFFFF;

	float3 Lighting = 0.0f;

	if (all(ProbeTexelCoord < TraceResolution))
	{
		float2 ProbeTexelCenter = float2(0.5, 0.5);
		float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / float(TraceResolution);
		float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

		float FinalMinTraceDistance = max(MinTraceDistance, GetRadianceProbeTMin(ClipmapIndex));
		float FinalMaxTraceDistance = MaxTraceDistance;
		float EffectiveStepFactor = StepFactor;

		// Evenly distributing the sphere solid angle among all cones instead of based on Octahedron distortion
		float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(TraceResolution * TraceResolution));

		FConeTraceInput TraceInput;
		TraceInput.Setup(
			ProbeWorldCenter, WorldConeDirection,
			ConeHalfAngle, MinSampleRadius,
			FinalMinTraceDistance, FinalMaxTraceDistance,
			EffectiveStepFactor);
		TraceInput.VoxelStepFactor = VoxelStepFactor;

		bool bContinueCardTracing = false;

		TraceInput.VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(FinalMinTraceDistance, FinalMaxTraceDistance, MaxCardTraceDistance, bContinueCardTracing);

		FConeTraceResult TraceResult;
		TraceResult = (FConeTraceResult)0;
		TraceResult.Lighting = 0.0;
		TraceResult.Transparency = 1.0;

		ConeTraceLumenSceneVoxels(TraceInput, TraceResult);

#if TRACE_DISTANT_SCENE
		if (TraceResult.Transparency > .01f)
		{
			FConeTraceResult DistantTraceResult;
			ConeTraceLumenDistantScene(TraceInput, DistantTraceResult);
			TraceResult.Lighting += DistantTraceResult.Lighting * TraceResult.Transparency;
			TraceResult.Transparency *= DistantTraceResult.Transparency;
		}
#endif

		Lighting = TraceResult.Lighting;

#if ENABLE_DYNAMIC_SKY_LIGHT
		if (ReflectionStruct.SkyLightParameters.y > 0)
		{
			float SkyAverageBrightness = 1.0f;
			float Roughness = TanConeAngleToRoughness(tan(ConeHalfAngle));

			Lighting = TraceResult.Lighting + GetSkyLightReflection(WorldConeDirection, Roughness, SkyAverageBrightness) * TraceResult.Transparency;
		}
#endif
		uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
		
#if OVERBUDGET_TRACING_PASS
		uint2 AtlasCoord = ProbeTexelCoord * OVERBUDGET_DOWNSAMPLE_FACTOR + ProbeAtlasBaseCoord;
		RWRadianceProbeAtlasTexture[AtlasCoord] = float4(Lighting, 0);
		RWRadianceProbeAtlasTexture[AtlasCoord + uint2(1, 0)] = float4(Lighting, 0);
		RWRadianceProbeAtlasTexture[AtlasCoord + uint2(0, 1)] = float4(Lighting, 0);
		RWRadianceProbeAtlasTexture[AtlasCoord + uint2(1, 1)] = float4(Lighting, 0);
#else
		RWRadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord] = float4(Lighting, 0);
#endif
	}
}

Texture2D<float4> RadianceProbeAtlasTexture;
RWTexture2D<float3> RWFinalRadianceAtlas;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CopyProbesAndFixupBordersCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId.z;
	uint PackedW = asuint(ProbeTraceData[ProbeTraceIndex].w);
	uint ProbeIndex = PackedW & 0xFFFFFF;

	uint2 FinalProbeTexelCoord = DispatchThreadId.xy;

	if (all(FinalProbeTexelCoord < FinalProbeResolution))
	{
		uint2 ProbeTexelCoord = OctahedralMapWrapBorder(FinalProbeTexelCoord, FinalProbeResolution, 1 << (uint)FinalRadianceAtlasMaxMip);
		uint2 AtlasCoord = ProbeTexelCoord + RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

		float3 Lighting = RadianceProbeAtlasTexture.Load(uint3(AtlasCoord, 0)).xyz;

		uint2 FinalAtlasCoord = FinalProbeTexelCoord + FinalProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

		RWFinalRadianceAtlas[FinalAtlasCoord] = Lighting;
	}
}

RWTexture2D<float3> RWFinalRadianceAtlasMip;
Texture2D<float3> FinalRadianceAtlasParentMip;
uint MipLevel; 

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateMipLevelCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId.z;
	uint PackedW = asuint(ProbeTraceData[ProbeTraceIndex].w);
	uint ProbeIndex = PackedW & 0xFFFFFF;

	uint2 FinalProbeTexelCoord = DispatchThreadId.xy;
	uint ParentMipSize = FinalProbeResolution >> (MipLevel - 1);
	uint MipSize = FinalProbeResolution >> MipLevel;

	if (all(FinalProbeTexelCoord < MipSize))
	{
		uint2 ProbeCoord = uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
		uint2 ParentProbeTexelCoordBase = FinalProbeTexelCoord * 2;
		uint2 ParentFinalAtlasCoord = ParentProbeTexelCoordBase + ParentMipSize * ProbeCoord;
		//@todo - gather area around texel, not aligned to power of 2

		float InvParentMipSize = 1.0f / ParentMipSize;
		float2 ProbeUV00 = (ParentProbeTexelCoordBase + float2(0, 0) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV10 = (ParentProbeTexelCoordBase + float2(1, 0) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV01 = (ParentProbeTexelCoordBase + float2(0, 1) + float2(.5f, .5f)) * InvParentMipSize;
		float2 ProbeUV11 = (ParentProbeTexelCoordBase + float2(1, 1) + float2(.5f, .5f)) * InvParentMipSize;

		float4 Weights;
		Weights.x = OctahedralSolidAngle(ProbeUV00, InvParentMipSize);
		Weights.y = OctahedralSolidAngle(ProbeUV10, InvParentMipSize);
		Weights.z = OctahedralSolidAngle(ProbeUV01, InvParentMipSize);
		Weights.w = OctahedralSolidAngle(ProbeUV11, InvParentMipSize);

		float3 Lighting = 0;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(0, 0), 0)).xyz * Weights.x;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(1, 0), 0)).xyz * Weights.y;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(0, 1), 0)).xyz * Weights.z;
		Lighting += FinalRadianceAtlasParentMip.Load(uint3(ParentFinalAtlasCoord + uint2(1, 1), 0)).xyz * Weights.w;

		uint2 FinalAtlasCoord = FinalProbeTexelCoord + MipSize * ProbeCoord;
		RWFinalRadianceAtlasMip[FinalAtlasCoord] = Lighting / dot(Weights, 1);
	}
}