// Copyright Epic Games, Inc. All Rights Reserved.

#define SUPPORT_CONTACT_SHADOWS 0
#define USE_HAIR_LIGHTING 0

// Additional rewiring to make DeferredShadingCommon happy
#define LTCMatTexture				RaytracingLightsDataPacked.LTCMatTexture
#define LTCMatSampler				GlobalBilinearClampedSampler
#define LTCAmpTexture				RaytracingLightsDataPacked.LTCAmpTexture
#define LTCAmpSampler				GlobalBilinearClampedSampler
#define PreIntegratedGF				ReflectionStruct.PreIntegratedGF
#define PreIntegratedGFSampler		GlobalBilinearClampedSampler

#include "../RayTracing/RayTracingCommon.ush"
#include "../RayTracing/RayTracingDeferredMaterials.ush"
#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingLightingCommon.ush"

#define DEBUG_EVALUATE_LIGHTING 1
#define HIDE_INVALID_SDF 0

// Lighting modes
#define LIGHTING_FROM_SURFACE_CACHE 0
#define EVALUATE_MATERIAL 1
#define EVALUATE_MATERIAL_AND_DIRECT_LIGHTING 2

// Normal modes
#define SDF_NORMAL_TYPE 0
#define GEOMETRIC_NORMAL_TYPE 1

#define INVALID_DF_OBJECT_INDEX -1

uint GetAtlasId(int Mode)
{
	uint AtlasId = FINAL_LIGHTING_ATLAS_ID;
	if (Mode == EVALUATE_MATERIAL)
	{
		AtlasId = IRRADIANCE_ATLAS_ID;
	}
	else if (Mode == EVALUATE_MATERIAL_AND_DIRECT_LIGHTING)
	{
		AtlasId = INDIRECT_IRRADIANCE_ATLAS_ID;
	}
	return AtlasId;
}

struct FRayTracedLightingContext
{
	RaytracingAccelerationStructure TLAS;
	FRayCone RayCone;
	uint2 TraceCoord;
	uint LinearCoord;
};

bool TraceDeferredMaterialRay(
	in RayDesc Ray,
	inout FRayTracedLightingContext Context,
	inout FDeferredMaterialPayload DeferredMaterialPayload
)
{
	DeferredMaterialPayload = (FDeferredMaterialPayload)0;
	DeferredMaterialPayload.SortKey = RAY_TRACING_DEFERRED_MATERIAL_KEY_RAY_MISS;
	DeferredMaterialPayload.PixelCoordinates = (Context.TraceCoord.y << 16) | Context.TraceCoord.x;

	uint RayFlags = RAY_FLAG_FORCE_OPAQUE;
	uint InstanceMask = RAY_TRACING_MASK_OPAQUE;
	FRayIntersectionBookmark Bookmark = (FRayIntersectionBookmark)0;
	TraceDeferredMaterialGatherRay(Context.TLAS, RayFlags, InstanceMask, Ray, Bookmark, DeferredMaterialPayload);

	return DeferredMaterialPayload.IsHit();
}

bool TraceLumenMinimalRay(
	in RayDesc Ray,
	inout FRayTracedLightingContext Context,
	inout FLumenMinimalPayload Payload
)
{
	Payload = (FLumenMinimalPayload)0;

	uint RayFlags = RAY_FLAG_FORCE_OPAQUE;
	uint InstanceMask = RAY_TRACING_MASK_OPAQUE;
	TraceLumenRay(Context.TLAS, RayFlags, InstanceMask, Ray, Payload);

	return Payload.IsHit();
}

float3 CalculateRayHitWorldNormal(
	in RayDesc Ray,
	in float HitDistance,
	in int DFObjectIndex,
	in int NormalMode,
	in float3 PayloadWorldNormal,
	inout bool bAccurateHit
)
{
	float3 RayHitWorldNormal = 0;

	if (NormalMode == SDF_NORMAL_TYPE)
	{
		FTraceMeshSDFResult TraceMeshSDFResult;
		TraceMeshSDFResult.HitDistance = HitDistance;
		TraceMeshSDFResult.HitObject = DFObjectIndex;

		FTraceMeshSDFDerivedData TraceSDFData = CalculateMeshSDFDerivedData(Ray.Origin, Ray.Direction, HitDistance, TraceMeshSDFResult);
		RayHitWorldNormal = TraceSDFData.HitNormal;
		bAccurateHit = TraceSDFData.bAccurateHit;
	}
	else
	{
		RayHitWorldNormal = PayloadWorldNormal;
		RayHitWorldNormal = dot(Ray.Direction, RayHitWorldNormal) < 0 ? RayHitWorldNormal : -RayHitWorldNormal;
		bAccurateHit = true;
	}
	return RayHitWorldNormal;
}

float3 CalculateSurfaceCacheLighting(
	in RayDesc Ray,
	in FRayTracedLightingContext Context,
	float3 RayHitWorldPosition,
	float3 RayHitWorldNormal,
	bool bAccurateHit,
	float HitDistance,
	int DFObjectIndex,
	float3 DiffuseColor,
	int LightingMode
)
{
	float3 Radiance = 0;

	float InterpolateRadius = tan(Context.RayCone.SpreadAngle) * HitDistance;
	//@todo - derive from card texel size
	float CardInterpolateDepthVisibilityRadius = 10;
	// Mode and AtlasId enums are coupled
	uint AtlasId = GetAtlasId(LightingMode);

	float3 ResidualLighting = SampleLumenMeshCards(
		DFObjectIndex,
		RayHitWorldPosition,
		RayHitWorldNormal,
		InterpolateRadius,
		bAccurateHit,
		CardInterpolateDepthVisibilityRadius,
		AtlasId);

	// Apply shading when evaluating the material
	if (LightingMode != LIGHTING_FROM_SURFACE_CACHE)
	{
		ResidualLighting *= Diffuse_Lambert(DiffuseColor);
	}
	Radiance += ResidualLighting;

	return Radiance;
}

float3 CalculateDirectLighting(
	in RayDesc Ray,
	in FRayTracedLightingContext Context,
	inout FPackedMaterialClosestHitPayload Payload,
	float3 RayHitWorldPosition,
	float3 RayHitWorldNormal
)
{
	RandomSequence RandSequence;
	uint SampleOffset = 0;
	RandomSequence_Initialize(RandSequence, Context.LinearCoord, View.StateFrameIndex + SampleOffset * 16);
	float MaxNormalBias = 0.05;
	uint ReflectedShadowsType = 2;
	bool bShouldDoDirectLighting = true;
	bool bShouldDoEmissiveAndIndirectLighting = false;
	bool bTopLayerRayTraceSkyLightContribution = false;
	bool bDecoupleSampleGeneration = false;

	float3 DirectLighting = 0.0f;
	AccumulateResults(
		Payload,
		RayHitWorldPosition,
		Ray.Direction,
		Context.TLAS,
		RandSequence,
		Context.TraceCoord,
		MaxNormalBias,
		ReflectedShadowsType,
		bShouldDoDirectLighting,
		bShouldDoEmissiveAndIndirectLighting,
		bTopLayerRayTraceSkyLightContribution,
		bDecoupleSampleGeneration,
		Context.RayCone,
		DirectLighting);
	return DirectLighting;
}

float3 CalculateRayTracedLightingFromSurfaceCache(
	in RayDesc Ray,
	in FRayTracedLightingContext Context,
	FLumenMinimalPayload Payload,
	float HitDistance,
	int DFObjectIndex,
	int NormalMode
)
{
	float3 Radiance = 0;

	bool bAccurateHit = false;
	float3 RayHitWorldNormal = CalculateRayHitWorldNormal(Ray, HitDistance, DFObjectIndex, NormalMode, Payload.GetWorldNormal(), bAccurateHit);
	float3 RayHitWorldPosition = Ray.Origin + Ray.Direction * HitDistance;
	float3 DiffuseColor = 0;
	Radiance += CalculateSurfaceCacheLighting(Ray, Context, RayHitWorldPosition, RayHitWorldNormal, bAccurateHit, HitDistance, DFObjectIndex, DiffuseColor, LIGHTING_FROM_SURFACE_CACHE);
	return Radiance;
}

float3 CalculateRayTracedLighting(
	in RayDesc Ray,
	in FRayTracedLightingContext Context,
	inout FPackedMaterialClosestHitPayload Payload,
	float HitDistance,
	int DFObjectIndex,
	int NormalMode,
	int LightingMode
)
{
	float3 Radiance = 0;

	bool bAccurateHit = false;
	float3 RayHitWorldNormal = CalculateRayHitWorldNormal(Ray, HitDistance, DFObjectIndex, NormalMode, Payload.GetWorldNormal(), bAccurateHit);

	float3 RayHitWorldPosition = Ray.Origin + Ray.Direction * HitDistance;
	if (LightingMode == EVALUATE_MATERIAL_AND_DIRECT_LIGHTING)
	{
		Radiance = CalculateDirectLighting(Ray, Context, Payload, RayHitWorldPosition, RayHitWorldNormal);
	}

	float3 DiffuseColor = Payload.GetDiffuseColor();
	Radiance += CalculateSurfaceCacheLighting(Ray, Context, RayHitWorldPosition, RayHitWorldNormal, bAccurateHit, HitDistance, DFObjectIndex, DiffuseColor, LightingMode);
	return Radiance;
}

bool TraceAndCalculateRayTracedLighting(
	in RayDesc Ray,
	in FRayTracedLightingContext Context,
	int LightingMode,
	int NormalMode,
	inout float HitDistance,
	inout float3 Radiance
)
{
	HitDistance = Ray.TMax;
	Radiance = 0;
	bool bHit = false;

	uint RayFlags = 0;
	uint InstanceMask = RAY_TRACING_MASK_OPAQUE;
	bool bEnableSkyLightContribution = false;

	FPackedMaterialClosestHitPayload Payload = (FPackedMaterialClosestHitPayload)0;
	Payload.SetLumenPayload();
	if (LightingMode == LIGHTING_FROM_SURFACE_CACHE)
	{
		Payload.SetMinimalPayloadMode();
	}

	// Trace visibility ray
	TraceMaterialRayPacked(
		Payload,
		Context.TLAS,
		RayFlags,
		InstanceMask,
		Ray,
		Context.RayCone,
		Context.TraceCoord,
		bEnableSkyLightContribution);

	bool bIsRTHit = Payload.IsHit();
	if (bIsRTHit)
	{
		int DFObjectIndex = Payload.GetDistanceFieldObjectIndex();

#if HIDE_INVALID_SDF
		while (bIsRTHit && DFObjectIndex != INVALID_DF_OBJECT_INDEX)
		{
			float Epsilon = 0.01;
			Ray.TMin = Payload.HitT + Epsilon;
			// Reset payload flag settings for the new trace
			Payload.SetLumenPayload();
			if (LightingMode == LIGHTING_FROM_SURFACE_CACHE)
			{
				Payload.SetMinimalPayloadMode();
			}

			// Trace visibility ray
			TraceMaterialRayPacked(
				Payload,
				Context.TLAS,
				RayFlags,
				InstanceMask,
				Ray,
				Context.RayCone,
				TraceCoord,
				bEnableSkyLightContribution);
			bIsRTHit = Payload.IsHit();
			DFObjectIndex = Payload.GetDistanceFieldObjectIndex();
		}
#else
		HitDistance = Payload.HitT;
		bHit = true;
#endif

		if (DFObjectIndex != INVALID_DF_OBJECT_INDEX)
		{
			Radiance = CalculateRayTracedLighting(Ray, Context, Payload, HitDistance, DFObjectIndex, NormalMode, LightingMode);
		}
	}

	return bHit;
}

bool TraceAndCalculateRayTracedLightingFromSurfaceCache(
	in RayDesc Ray,
	in FRayTracedLightingContext Context,
	int NormalMode,
	inout float TraceHitDistance,
	inout float3 Radiance
)
{
	Radiance = 0;

	FLumenMinimalPayload Payload = (FLumenMinimalPayload)0;
	bool bHit = TraceLumenMinimalRay(Ray, Context, Payload);
	if (bHit)
	{
		TraceHitDistance = Payload.HitT;
		int DFObjectIndex = Payload.GetDistanceFieldObjectIndex();
		if (DFObjectIndex != INVALID_DF_OBJECT_INDEX)
		{
			Radiance = CalculateRayTracedLightingFromSurfaceCache(Ray, Context, Payload, TraceHitDistance, DFObjectIndex, NormalMode);
		}
	}
	else
	{
		TraceHitDistance = Ray.TMax;
	}

	return bHit;
}