// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadiosity.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "../MonteCarlo.ush"
#include "../FastMath.ush"
#include "LumenRadiosity.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenRadianceCacheMarkCommon.ush"

#ifndef THREADGROUP_SIZE 
#define THREADGROUP_SIZE 0
#endif

StructuredBuffer<uint> QuadAllocator;
StructuredBuffer<uint> QuadData;
RWBuffer<uint> RWIndirectArgs;

[numthreads(1, 1, 1)]
void PlaceProbeIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	RWIndirectArgs[0] = (QuadAllocator[0] + THREADGROUP_SIZE - 1) / THREADGROUP_SIZE;
	RWIndirectArgs[1] = 1;
	RWIndirectArgs[2] = 1;
}

float StepFactor;
float MaxTraceDistance;
float VoxelStepFactor;
float MinTraceDistance;
float MaxMeshSDFTraceDistance;
float TanConeAngle;
float MinSampleRadius;
float SurfaceBias;
float DiffuseConeHalfAngle;
float TanDiffuseConeHalfAngle;

RWBuffer<uint> RWCardTraceBlockAllocator;
RWBuffer<uint4> RWCardTraceBlockData;

#if IRRADIANCE_CACHE
	#define THREADS_PER_RADIOSITY_TEXEL 1
#else
	#define THREADS_PER_RADIOSITY_TEXEL 8
#endif

#if THREADGROUP_SIZE > 0

groupshared uint NumBlocksShared[THREADGROUP_SIZE];
groupshared uint GlobalBlockStartOffset[THREADGROUP_SIZE];

[numthreads(THREADGROUP_SIZE, 1, 1)]
void SetupCardTraceBlocksCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
#define DISTRIBUTE_TRACEBLOCK_WRITES 1
#if DISTRIBUTE_TRACEBLOCK_WRITES

	if (DispatchThreadId.x < QuadAllocator[0])
	{
		uint CardPageId = QuadData[DispatchThreadId.x];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageId);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint NumBlocks = NumBlocksXY.x * NumBlocksXY.y;
		NumBlocksShared[GroupThreadId.x] = NumBlocks;

		uint BlockStartOffset;
		InterlockedAdd(RWCardTraceBlockAllocator[0], NumBlocks, BlockStartOffset);
		GlobalBlockStartOffset[GroupThreadId.x] = BlockStartOffset;
	}
	else
	{
		NumBlocksShared[GroupThreadId.x] = 0;
		GlobalBlockStartOffset[GroupThreadId.x] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint GroupQuadIndex = 0; GroupQuadIndex < THREADGROUP_SIZE; GroupQuadIndex++)
	{
		uint NumBlocks = NumBlocksShared[GroupQuadIndex];
		uint BlockStartOffset = GlobalBlockStartOffset[GroupQuadIndex];
		uint QuadIndex = GroupQuadIndex + DispatchThreadId.x - GroupThreadId.x;
		uint CardPageId = QuadData[QuadIndex];

		for (uint BlockIndex = GroupThreadId.x; BlockIndex < NumBlocks; BlockIndex += THREADGROUP_SIZE)
		{
			uint4 BlockData = uint4(CardPageId, QuadIndex, BlockIndex, 0);
			RWCardTraceBlockData[BlockStartOffset + BlockIndex] = BlockData;
		}
	}

#else

	uint QuadIndex = DispatchThreadId.x;

	if (QuadIndex < QuadAllocator[0])
	{
		uint CardPageId = QuadData[QuadIndex];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageId, CardPageBuffer);

		uint2 CardPageSizeInTexels = GetCardPageSizeInTexels(CardPage, RadiosityAtlasSize);
		uint2 NumBlocksXY = (CardPageSizeInTexels + CARD_TRACE_BLOCK_SIZE - 1) / CARD_TRACE_BLOCK_SIZE;
		uint NumBlocks = NumBlocksXY.x * NumBlocksXY.y;

		uint BlockStartOffset;
		InterlockedAdd(RWCardTraceBlockAllocator[0], NumBlocks, BlockStartOffset);

		for (uint BlockIndex = 0; BlockIndex < NumBlocks; BlockIndex++)
		{
			uint4 BlockData = uint4(CardPageId, QuadIndex, BlockIndex, 0);
			RWCardTraceBlockData[BlockStartOffset + BlockIndex] = BlockData;
		}
	}
#endif
}

#endif

uint ThreadsPerTexel;

[numthreads(1, 1, 1)]
void SetupTraceBlocksIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	RWIndirectArgs[0] = (CardTraceBlockAllocator[0] * CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE * ThreadsPerTexel + THREADGROUP_SIZE - 1) / THREADGROUP_SIZE;
	RWIndirectArgs[1] = 1;
	RWIndirectArgs[2] = 1;
}

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MarkRadianceProbesUsedByRadiosityCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = DispatchThreadId.x;
	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = ThreadIndex % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		FRadiosityTexel RadiosityTexel = GetRadiosityTexel(GlobalBlockIndex, TexelOffsetInBlock);

		if (RadiosityTexel.bValid)
		{
			float3 Lighting = 0;

			if (RadiosityTexel.Opacity > 0)
			{
				uint ClipmapIndex = GetRadianceProbeClipmapForMark(RadiosityTexel.WorldPosition);

				if (IsValidRadianceCacheClipmapForMark(ClipmapIndex))
				{
					MarkPositionUsedInIndirectionTexture(RadiosityTexel.WorldPosition, ClipmapIndex);
				}
			}
		}
	}
}

uint NumCones;
float SampleWeight;
float4 RadiosityConeDirections[32];

float3 RadiosityTraceFromTexel(FRadiosityTexel RadiosityTexel, uint ConeStartIndex, uint ConeEndIndex)
{
	float3 Lighting = 0;

	if (RadiosityTexel.Opacity > 0)
	{
		float3 WorldPosition = RadiosityTexel.WorldPosition;
		float3 WorldNormal = RadiosityTexel.WorldNormal;

		//@todo - derive bias from texel world size
		WorldPosition += WorldNormal * SurfaceBias;

		float VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(MinTraceDistance, MaxTraceDistance, MaxMeshSDFTraceDistance, false);

		for (uint ConeIndex = ConeStartIndex; ConeIndex < ConeEndIndex; ConeIndex++)
		{
			//uint ConeIndex = ConeStartIndex;
			float3x3 TangentBasis = GetTangentBasisFrisvad(WorldNormal);

			#define PRECOMPUTED_SAMPLE_DIRECTIONS 1
			#if PRECOMPUTED_SAMPLE_DIRECTIONS
				float3 LocalConeDirection = RadiosityConeDirections[ConeIndex].xyz;
				float3 WorldConeDirection = mul(LocalConeDirection, TangentBasis);
			#else
				uint2 AtlasCoord = AtlasUV * RadiosityAtlasSize;
				uint2 Seed0 = Rand3DPCG16(int3(AtlasCoord + 17, 0)).xy;
				float2 E = Hammersley16(ConeIndex, NumCones, Seed0);
				float2 DiskE = UniformSampleDiskConcentric(E.xy);
				float TangentZ = sqrt(1 - length2(DiskE));
				float3 WorldConeDirection = mul(float3(DiskE, TangentZ), TangentBasis);
			#endif

			//@todo - derive bias from texel world size
			float3 SamplePosition = WorldPosition + SurfaceBias * WorldConeDirection;

			FConeTraceInput TraceInput;
			TraceInput.Setup(SamplePosition, WorldConeDirection, DiffuseConeHalfAngle, MinSampleRadius, MinTraceDistance, MaxTraceDistance, StepFactor);
			TraceInput.VoxelStepFactor = VoxelStepFactor;
			TraceInput.VoxelTraceStartDistance = VoxelTraceStartDistance;
			TraceInput.SDFStepFactor = 1;

			FConeTraceResult TraceResult;
			ConeTraceVoxels(TraceInput, TraceResult);

			EvaluateSkyRadianceForCone(WorldConeDirection, TraceInput.TanConeAngle, TraceResult);

			Lighting += TraceResult.Lighting;
		}
	}

	Lighting *= PI / (float)NumCones;
	return Lighting;
}

RWTexture2D<float4> RWRadiosityAtlas;

#if THREADGROUP_SIZE > 0

float ProbeOcclusionNormalBias;
groupshared float3 ThreadLighting[THREADGROUP_SIZE];

[numthreads(THREADGROUP_SIZE, 1, 1)]
void LumenCardRadiosityTraceBlocksCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
#if IRRADIANCE_CACHE
	uint ThreadIndex = DispatchThreadId.x;

	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = ThreadIndex % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		FRadiosityTexel RadiosityTexel = GetRadiosityTexel(GlobalBlockIndex, TexelOffsetInBlock);

		if (RadiosityTexel.bValid)
		{
			float3 DiffuseLighting = 0;

			if (RadiosityTexel.Opacity > 0)
			{
				uint ClipmapIndex = GetRadianceProbeClipmap(RadiosityTexel.WorldPosition);

				if (ClipmapIndex < NumRadianceProbeClipmaps)
				{
					float3 BiasOffset = RadiosityTexel.WorldNormal * ProbeOcclusionNormalBias;
					DiffuseLighting = SampleIrradianceCacheInterpolated(RadiosityTexel.WorldPosition, RadiosityTexel.WorldNormal, BiasOffset, ClipmapIndex);
				}
				else
				{
					DiffuseLighting = GetSkySHDiffuse(RadiosityTexel.WorldNormal) * View.SkyLightColor.rgb;
				}
			}

			RWRadiosityAtlas[RadiosityTexel.AtlasCoord] = float4(DiffuseLighting * PI, 0);
		}
	}
#else
	ThreadLighting[GroupThreadId.x] = 0;

	uint ThreadIndex = DispatchThreadId.x;
	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE * THREADS_PER_RADIOSITY_TEXEL);
	int2 AtlasWriteCoord = -1;

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = (ThreadIndex / THREADS_PER_RADIOSITY_TEXEL) % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		FRadiosityTexel RadiosityTexel = GetRadiosityTexel(GlobalBlockIndex, TexelOffsetInBlock);

		if (RadiosityTexel.bValid)
		{
			uint TraceThreadIndex = ThreadIndex % THREADS_PER_RADIOSITY_TEXEL;
			AtlasWriteCoord = RadiosityTexel.AtlasCoord;

			uint NumTracesPerThread = NumCones / THREADS_PER_RADIOSITY_TEXEL;
			uint ConeStartIndex = TraceThreadIndex * NumTracesPerThread;
			float3 Lighting = RadiosityTraceFromTexel(RadiosityTexel, ConeStartIndex, ConeStartIndex + NumTracesPerThread);
			ThreadLighting[GroupThreadId.x] = Lighting;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	uint TraceThreadIndex = ThreadIndex % THREADS_PER_RADIOSITY_TEXEL;

	if (TraceThreadIndex == 0 && all(AtlasWriteCoord >= 0))
	{
		float3 Lighting = 0;

		for (uint OtherThreadIndex = GroupThreadId.x; OtherThreadIndex < GroupThreadId.x + THREADS_PER_RADIOSITY_TEXEL; OtherThreadIndex += 1)
		{
			Lighting += ThreadLighting[OtherThreadIndex];
		}

		RWRadiosityAtlas[AtlasWriteCoord] = float4(Lighting, 0);
	}
#endif
}

#endif

void LumenCardRadiosityPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{
	FRadiosityTexel RadiosityTexel = GetRadiosityTexel(CardInterpolants);

	float3 Lighting = RadiosityTraceFromTexel(RadiosityTexel, 0, NumCones);

	OutColor = float4(Lighting, 0);
}

Texture2D<float3> RayBuffer;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void LumenRadiosityResolveRayBufferCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = DispatchThreadId.x;
	uint GlobalBlockIndex = ThreadIndex / (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);

	if (GlobalBlockIndex < CardTraceBlockAllocator[0])
	{
		uint TexelIndexInBlock = ThreadIndex % (CARD_TRACE_BLOCK_SIZE * CARD_TRACE_BLOCK_SIZE);
		uint2 TexelOffsetInBlock = uint2(TexelIndexInBlock % CARD_TRACE_BLOCK_SIZE, TexelIndexInBlock / CARD_TRACE_BLOCK_SIZE);

		FRadiosityTexel RadiosityTexel = GetRadiosityTexel(GlobalBlockIndex, TexelOffsetInBlock);

		if (RadiosityTexel.bValid)
		{
			float3 Lighting = 0.0f;

			for (uint RayIndex = 0; RayIndex < RayCountPerTexel; ++RayIndex)
			{
				uint2 RayBufferReadCoord = GetRayBufferCoord(GlobalBlockIndex, TexelOffsetInBlock, RayIndex);
				Lighting += RayBuffer[RayBufferReadCoord];
			}

			Lighting *= (PI / (float)RayCountPerTexel);

			RWRadiosityAtlas[RadiosityTexel.AtlasCoord] = float4(Lighting, 0);
		}
	}
}