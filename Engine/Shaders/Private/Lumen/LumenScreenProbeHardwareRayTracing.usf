// Copyright Epic Games, Inc. All Rights Reserved.

// TODO: Remove hair dependency
#include "../HairStrands/HairStrandsVoxelPageCommonStruct.ush"

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../SceneTextureParameters.ush"

#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenScreenProbeCommon.ush"
#include "LumenHardwareRayTracingCommon.ush"

// FIX: integrating with trace compaction is causing cross-talk between hardware tracing and voxel tracing, causing artificial darkening
#define IGNORE_TRACE_COMPACTION 1

RaytracingAccelerationStructure TLAS;
float MaxTraceDistance;
float SurfaceBias;

RAY_TRACING_ENTRY_RAYGEN(LumenScreenProbeGatherHardwareRayTracingRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy;

#if IGNORE_TRACE_COMPACTION
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy / ScreenProbeTracingOctahedronResolution;
	uint2 TraceTexelCoord = DispatchThreadId.xy - ScreenProbeAtlasCoord * ScreenProbeTracingOctahedronResolution;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	uint2 ScreenProbeScreenCoord;
	uint ScreenProbeSubsampleIndex;
	GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

	uint2 ScreenProbeTracingCoord = GetTraceBufferCoord(ScreenProbeAtlasCoord, TraceTexelCoord);
	if (all(ScreenProbeIndex < GetNumScreenProbes() && TraceTexelCoord < ScreenProbeTracingOctahedronResolution))
	{
		float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
		float3 WorldNormal = DecodeNormal(GBufferATexture.Load(int3(ScreenUV * View.BufferSizeAndInvSize.xy, 0)).xyz);

		bool bHit;
		float TraceHitDistance = DecodeProbeRayDistance(TraceHit[ScreenProbeTracingCoord].x, bHit);

		if (SceneDepth > 0 && !bHit)
#else
	if (DispatchThreadId.x < CompactedTraceTexelAllocator[0])
	{
		uint ScreenProbeIndex;
		uint2 TraceTexelCoord;
		float TraceHitDistance;
		DecodeTraceTexel(CompactedTraceTexelData[DispatchThreadId.x], ScreenProbeIndex, TraceTexelCoord, TraceHitDistance);

		uint2 ScreenProbeScreenCoord;
		uint ScreenProbeSubsampleIndex;
		GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

		uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
		uint2 ScreenProbeTracingCoord = GetTraceBufferCoord(ScreenProbeAtlasCoord, TraceTexelCoord);

		float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
		float3 WorldNormal = DecodeNormal(GBufferATexture.Load(int3(ScreenUV * View.BufferSizeAndInvSize.xy, 0)).xyz);

		bool bHit = false;
#endif
		{
			float2 ProbeUV;
			float ConeHalfAngle;
			GetProbeTracingUV(ScreenProbeAtlasCoord, TraceTexelCoord, GetProbeTexelCenter(ScreenProbeScreenCoord), 1, ProbeUV, ConeHalfAngle);
			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

			RayDesc Ray;
			Ray.Origin = WorldPosition;
			Ray.Direction = WorldConeDirection;
			Ray.TMin = TraceHitDistance;
			Ray.TMax = MaxTraceDistance;

			float NormalBias = 0.1;
			ApplyPositionBias(Ray.Origin, Ray.Direction, WorldNormal, max(NormalBias, SurfaceBias * 0.5));
			if (DIM_RADIANCE_CACHE)
			{
				bool bCoveredByRadianceCache = false;
				float ProbeOcclusionDistance = GetRadianceProbeOcclusionDistanceWithInterpolation(WorldPosition, WorldConeDirection, bCoveredByRadianceCache);
				Ray.TMax = min(MaxTraceDistance, ProbeOcclusionDistance);
			}

			FRayCone RayCone = (FRayCone)0;
			RayCone = PropagateRayCone(RayCone, ConeHalfAngle, 0.0);

			FRayTracedLightingContext Context;
			Context.TLAS = TLAS;
			Context.RayCone = RayCone;
			Context.TraceCoord = ScreenProbeScreenCoord;
			Context.LinearCoord = ScreenProbeScreenCoord.y * ScreenProbeViewSize.x + ScreenProbeScreenCoord.x;

			float3 Radiance;
			bHit = CalculateRayTracedLighting(Ray, Context, DIM_LIGHTING_MODE, DIM_NORMAL_MODE, TraceHitDistance, Radiance);
			RWTraceRadiance[ScreenProbeTracingCoord] = Radiance;
		}

		RWTraceHit[ScreenProbeTracingCoord] = EncodeProbeRayDistance(TraceHitDistance, bHit, false);
	}
}
