// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../SceneTextureParameters.ush"

#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenScreenProbeCommon.ush"
#include "LumenHardwareRayTracingCommon.ush"

#ifndef DIM_LIGHTING_MODE
#define DIM_LIGHTING_MODE LIGHTING_FROM_SURFACE_CACHE
#endif

RaytracingAccelerationStructure TLAS;
float MaxTraceDistance;
float PullbackBias;
float NormalBias;
float AvoidSelfIntersectionTraceDistance;
uint CullBackFacingTriangles;
int MaxTranslucentSkipCount; 

StructuredBuffer<FDeferredMaterialPayload> DeferredMaterialBuffer;

RAY_TRACING_ENTRY_RAYGEN(LumenScreenProbeGatherHardwareRayTracingRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy;

	FDeferredMaterialPayload DeferredMaterialPayload;
	#if (DIM_DEFERRED_MATERIAL_MODE)
	{
		DeferredMaterialPayload = DeferredMaterialBuffer[DispatchRaysIndex().x];
		DispatchThreadId = uint2(DeferredMaterialPayload.PixelCoordinates, 0);
	}
	#endif

	if (DispatchThreadId.x >= CompactedTraceTexelAllocator[0])
	{
		return;
	}

	uint ScreenProbeIndex;
	uint2 TraceTexelCoord;
	float TraceHitDistance;
	DecodeTraceTexel(CompactedTraceTexelData[DispatchThreadId.x], ScreenProbeIndex, TraceTexelCoord, TraceHitDistance);

	uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);
	uint2 ScreenTileCoord = GetScreenTileCoord(ScreenProbeScreenPosition);

	uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
	uint2 ScreenProbeTracingCoord = GetTraceBufferCoord(ScreenProbeAtlasCoord, TraceTexelCoord);

	#if DIM_DEFERRED_MATERIAL_MODE
	{
		TraceHitDistance = DeferredMaterialPayload.HitT;

		if (DeferredMaterialPayload.SortKey == RAY_TRACING_DEFERRED_MATERIAL_KEY_INVALID || DeferredMaterialPayload.SortKey == RAY_TRACING_DEFERRED_MATERIAL_KEY_RAY_MISS)
		{
			bool bHit = false;
			RWTraceHit[ScreenProbeTracingCoord] = EncodeProbeRayDistance(MaxTraceDistance, bHit, false);
			return;
		}
	}
	#endif

	float2 ScreenUV = GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition);
	float SceneDepth = GetScreenProbeDepth(ScreenProbeAtlasCoord);
	float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
	float3 WorldNormal = GetScreenProbeNormal(ScreenProbeAtlasCoord);

	float2 ProbeUV;
	float ConeHalfAngle;
	GetProbeTracingUV(ScreenProbeAtlasCoord, TraceTexelCoord, GetProbeTexelCenter(ScreenTileCoord), 1, ProbeUV, ConeHalfAngle);
	float3 WorldConeDirection = OctahedronToUnitVector(ProbeUV * 2.0 - 1.0);

	RayDesc Ray;
	Ray.Origin = WorldPosition;
	Ray.Direction = WorldConeDirection;
	Ray.TMin = max(TraceHitDistance - PullbackBias, 0.0);
	Ray.TMax = AvoidSelfIntersectionTraceDistance;

	ApplyPositionBias(Ray.Origin, Ray.Direction, WorldNormal, NormalBias);

	FRayCone RayCone = (FRayCone)0;
	RayCone = PropagateRayCone(RayCone, ConeHalfAngle, 0.0);

	bool bCullBackfacingTriangles = true;

	FRayTracedLightingContext Context = CreateRayTracedLightingContext(
		TLAS,
		RayCone,
		ScreenTileCoord,
		ScreenTileCoord.y * ScreenProbeViewSize.x + ScreenTileCoord.x,
		bCullBackfacingTriangles,
		MaxTranslucentSkipCount);
	Context.bCalculateHitVelocity = true;

	FRayTracedLightingResult Result = CreateRayTracedLightingResult();

	if (Ray.TMax > Ray.TMin)
	{
		// First trace - short distance with backface culling enabled to avoid self intersecting in cases where the traced geometry doesn't match what's in the GBuffer (Nanite, Ray Tracing LODs, etc)
		#if DIM_LIGHTING_MODE == LIGHTING_FROM_SURFACE_CACHE && (DIM_DEFERRED_MATERIAL_MODE == 0)
		{
			Result = TraceAndCalculateRayTracedLightingFromSurfaceCache(Ray, Context);
		}
		#else
		{
			Result = TraceAndCalculateRayTracedLighting(Ray, Context, DIM_LIGHTING_MODE);
		}
		#endif
	}

	if (!Result.bIsHit)
	{
		// Second trace - trace the rest of the ray with backface culling disabled to reduce leaking from rays that start inside the mesh
		Context.bCullBackFacingTriangles = false;
		Ray.TMin = max(Ray.TMin, AvoidSelfIntersectionTraceDistance);
		Ray.TMax = MaxTraceDistance;

		#if DIM_RADIANCE_CACHE
		{
			FRadianceCacheCoverage Coverage = GetRadianceCacheCoverage(Ray.Origin, Ray.Direction);
				
			if (Coverage.bValid)
			{
				Ray.TMax = min(Ray.TMax, Coverage.MinTraceDistanceBeforeInterpolation);
			}
		}
		#endif

		#if DIM_DEFERRED_MATERIAL_MODE
		{
			float Epsilon = 0.5;
			Ray.TMin = max(0, DeferredMaterialPayload.HitT - Epsilon);
			// Note: adjusting TMax will not properly account for masked materials because of restricted any-hit length
			//Ray.TMax = DeferredMaterialPayload.HitT + Epsilon;
		}
		#endif

		#if DIM_LIGHTING_MODE == LIGHTING_FROM_SURFACE_CACHE && (DIM_DEFERRED_MATERIAL_MODE == 0)
		{
			Result = TraceAndCalculateRayTracedLightingFromSurfaceCache(Ray, Context);
		}
		#else
		{
			Result = TraceAndCalculateRayTracedLighting(Ray, Context, DIM_LIGHTING_MODE);
		}
		#endif
	}

	bool bMoving = false;

	if (Result.bIsHit)
	{
		float3 HitWorldPosition = Ray.Origin + Ray.Direction * Result.TraceHitDistance;
		bMoving = IsTraceMoving(WorldPosition, SceneDepth, ScreenProbeAtlasCoord, HitWorldPosition, Result.WorldVelocity);
	}

	RWTraceRadiance[ScreenProbeTracingCoord] = Result.Radiance * View.PreExposure;
	RWTraceHit[ScreenProbeTracingCoord] = EncodeProbeRayDistance(Result.TraceHitDistance, Result.bIsHit, bMoving);
}

RWStructuredBuffer<FDeferredMaterialPayload> RWDeferredMaterialBuffer;
int2 DeferredMaterialBufferResolution;
uint TileSize;

RAY_TRACING_ENTRY_RAYGEN(LumenScreenProbeGatherHardwareRayTracingDeferredMaterialRGS)
{
	FDeferredMaterialPayload DeferredMaterialPayload = (FDeferredMaterialPayload)0;
	uint DeferredMaterialBufferIndex = DispatchRaysIndex().x;
	if (DispatchRaysIndex().x >= CompactedTraceTexelAllocator[0])
	{
		DeferredMaterialPayload.SortKey = RAY_TRACING_DEFERRED_MATERIAL_KEY_INVALID;
		RWDeferredMaterialBuffer[DeferredMaterialBufferIndex] = DeferredMaterialPayload;
		return;
	}

	uint ScreenProbeIndex;
	uint2 TraceTexelCoord;
	float TraceHitDistance;
	DecodeTraceTexel(CompactedTraceTexelData[DeferredMaterialBufferIndex], ScreenProbeIndex, TraceTexelCoord, TraceHitDistance);

	uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);
	uint2 ScreenTileCoord = GetScreenTileCoord(ScreenProbeScreenPosition);

	uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
	uint2 ScreenProbeTracingCoord = GetTraceBufferCoord(ScreenProbeAtlasCoord, TraceTexelCoord);
	float2 ScreenUV = GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition);

	float SceneDepth = GetScreenProbeDepth(ScreenProbeAtlasCoord);
	float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
	float3 WorldNormal = GetScreenProbeNormal(ScreenProbeAtlasCoord);
	
	float2 ProbeUV;
	float ConeHalfAngle;
	GetProbeTracingUV(ScreenProbeAtlasCoord, TraceTexelCoord, GetProbeTexelCenter(ScreenTileCoord), 1, ProbeUV, ConeHalfAngle);
	float3 WorldConeDirection = OctahedronToUnitVector(ProbeUV * 2.0 - 1.0);

	RayDesc Ray;
	Ray.Origin = WorldPosition;
	Ray.Direction = WorldConeDirection;
	Ray.TMin = max(TraceHitDistance - PullbackBias, 0.0);
	Ray.TMax = MaxTraceDistance;

	ApplyPositionBias(Ray.Origin, Ray.Direction, WorldNormal, NormalBias);

	if (DIM_RADIANCE_CACHE)
	{
		FRadianceCacheCoverage Coverage = GetRadianceCacheCoverage(WorldPosition, WorldConeDirection);
				
		if (Coverage.bValid)
		{
			Ray.TMax = min(Ray.TMax, Coverage.MinTraceDistanceBeforeInterpolation);
		}
	}

	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;
	RayCone = PropagateRayCone(RayCone, ConeHalfAngle, SceneDepth);

	//@todo - implement AvoidSelfIntersectionTraceDistance
	bool bCullBackfacingTriangles = true;
	uint LinearCoord = ScreenTileCoord.y * ScreenProbeViewSize.x + ScreenTileCoord.x;
	FRayTracedLightingContext Context = CreateRayTracedLightingContext(TLAS, RayCone, ScreenTileCoord, LinearCoord, bCullBackfacingTriangles);

	bool bIsHit = TraceDeferredMaterialRay(Ray, Context, DeferredMaterialPayload);

	// Encode max trace distance in the case of an invalid or miss condition
	if (!bIsHit)
	{
		DeferredMaterialPayload.HitT = MaxTraceDistance;
	}

	// Remap the coordinate to that of the initial dispatch index
	DeferredMaterialPayload.PixelCoordinates = DeferredMaterialBufferIndex;

	RWDeferredMaterialBuffer[DeferredMaterialBufferIndex] = DeferredMaterialPayload;
}