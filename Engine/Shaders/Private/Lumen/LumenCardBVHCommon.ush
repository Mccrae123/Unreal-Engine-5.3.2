// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardBVHCommon.ush
=============================================================================*/

// Must match C++
#define INVALID_PROXY_CARD_ID		65535
#define INVALID_BVH_NODE_ID			65535
#define BVH_WIDTH					64

#define BVH_TRAVERSAL_STACK_SIZE	16

struct FLumenCardBVHNodeData
{
	float3 BBoxCenter;
	float3 BBoxExtent;
	uint LumenCardId;
	uint ChildId;
};

// Stride of a single card BVH node's data in float4's, must match C++
#define PROXY_CARD_BVH_NODE_DATA_STRIDE (BVH_WIDTH * 2)

// Fetch from scene card BVH buffer
FLumenCardBVHNodeData GetLumenCardBVHNodeData(uint NodeId, uint ChildId)
{
	// Note: layout must match FLumenCardBVHNodeData in C++
	// Relying on optimizer to remove unused loads

	FLumenCardBVHNodeData NodeData;
	uint BaseOffset = NodeId * PROXY_CARD_BVH_NODE_DATA_STRIDE + ChildId * 2;

	NodeData.BBoxCenter = LumenCardScene.CardBVHData[BaseOffset].xyz;
	NodeData.LumenCardId = asuint(LumenCardScene.CardBVHData[BaseOffset].w);

	NodeData.BBoxExtent = LumenCardScene.CardBVHData[BaseOffset + 1].xyz;
	NodeData.ChildId = asuint(LumenCardScene.CardBVHData[BaseOffset + 1].w);

	return NodeData;
}

struct FBVHTraverseState
{
	uint StackNext;
	uint NodeId;
};

void InitBVHTraverse(out FBVHTraverseState BVH)
{
	BVH.StackNext = 1;
	BVH.NodeId = 0;
}

void SetBVHNodeHit(inout FBVHTraverseState BVH, inout uint BVHStack[BVH_TRAVERSAL_STACK_SIZE], FLumenCardBVHNodeData CurrNode, uint ChildIndex)
{
	if (CurrNode.ChildId != INVALID_BVH_NODE_ID && BVH.StackNext < BVH_TRAVERSAL_STACK_SIZE)
	{
		BVHStack[BVH.StackNext] = CurrNode.ChildId;
		++BVH.StackNext;
	}
}

bool TraverseNextBVHNode(inout FBVHTraverseState BVH, inout uint BVHStack[BVH_TRAVERSAL_STACK_SIZE])
{
	// Pop stack
	--BVH.StackNext;
	BVH.NodeId = BVHStack[BVH.StackNext];

	return BVH.NodeId != INVALID_BVH_NODE_ID;
}