// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenSceneDirectLighting.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenCardCommon.ush"
#define SUPPORT_CONTACT_SHADOWS 0
#include "../DeferredLightingCommon.ush"
#include "../VolumeLightingCommon.ush"
#define FILTER_DIRECTIONAL_LIGHT_SHADOWING 1
#include "../ForwardShadowingCommon.ush"
#include "/Engine/Generated/Material.ush"
#include "../LightFunctionCommon.ush"
#include "../GlobalDistanceFieldUtils.ush"
#include "../DistanceFieldLightingShared.ush"
#define DF_SHADOW_QUALITY 2
#include "../DistanceFieldShadowingShared.ush"

// Must match ELumenLightType in LumenSceneDirectLighting.cpp
#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2
#define LIGHT_TYPE_RECT 3

#ifndef HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE
#define HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE 0
#endif

/** Fade distance in x, disabled brightness in y, output for preview shadows mask in z. */
float3 LightFunctionParameters2;  

float GetLightFunction(float3 WorldPosition) 
{
	float4 LightVector = mul(float4(WorldPosition, 1), LightFunctionWorldToLight);
	float3 LightFunction = GetLightFunctionColor(LightVector.xyz / LightVector.w, WorldPosition);

	float GreyScale = dot(LightFunction, .3333f).x;

	// Calculate radial view distance for stable fading
	float ViewDistance = length(View.WorldCameraOrigin - WorldPosition);

	float DistanceFadeAlpha = saturate((LightFunctionParameters2.x - ViewDistance) / (LightFunctionParameters2.x * .2f));
	// Fade to disabled based on LightFunctionFadeDistance
	GreyScale = lerp(LightFunctionParameters2.y, GreyScale, DistanceFadeAlpha);

	// Fade to disabled based on ShadowFadeFraction
	GreyScale = lerp(LightFunctionParameters2.y, GreyScale, LightFunctionParameters.y);
	return GreyScale;
}

Texture2D OpacityAtlas;
float MaxTraceDistance;
float StepFactor;
float SurfaceBias;
float TanLightSourceAngle;
float SlopeScaledSurfaceBias;
float SDFSurfaceBiasScale;
uint ForceOffscreenShadowing;

#if HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE
Texture2D<float> ShadowMaskAtlas;
#endif

void LumenCardDirectLightingPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{
	float Opacity = Texture2DSampleLevel(OpacityAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasCoord, 0).x;
	float3 Irradiance = 0;

	if (Opacity > 0)
	{
		FDeferredLightData LightData;
		{
			LightData.Position = DeferredLightUniforms.Position;
			LightData.InvRadius = DeferredLightUniforms.InvRadius;
			LightData.Color = DeferredLightUniforms.Color;
			LightData.FalloffExponent = DeferredLightUniforms.FalloffExponent;
			LightData.Direction = DeferredLightUniforms.Direction;  
			LightData.Tangent = DeferredLightUniforms.Tangent;
			LightData.SpotAngles = DeferredLightUniforms.SpotAngles;
			LightData.SourceRadius = DeferredLightUniforms.SourceRadius;
			LightData.SourceLength = DeferredLightUniforms.SourceLength;
			LightData.SoftSourceRadius = DeferredLightUniforms.SoftSourceRadius;
			LightData.SpecularScale = DeferredLightUniforms.SpecularScale;
			LightData.ContactShadowLength = abs(DeferredLightUniforms.ContactShadowLength);
			LightData.ContactShadowLengthInWS = DeferredLightUniforms.ContactShadowLength < 0.0f;
			LightData.DistanceFadeMAD = DeferredLightUniforms.DistanceFadeMAD;
			LightData.ShadowMapChannelMask = DeferredLightUniforms.ShadowMapChannelMask;
			LightData.ShadowedBits = DeferredLightUniforms.ShadowedBits;
			LightData.RectLightBarnCosAngle = DeferredLightUniforms.RectLightBarnCosAngle;
			LightData.RectLightBarnLength = DeferredLightUniforms.RectLightBarnLength;

			LightData.bInverseSquared = LightData.FalloffExponent == 0.0f;
			LightData.bRadialLight = LIGHT_TYPE != LIGHT_TYPE_DIRECTIONAL;
			LightData.bSpotLight = LIGHT_TYPE == LIGHT_TYPE_SPOT;
			LightData.bRectLight = LIGHT_TYPE == LIGHT_TYPE_RECT;
		}

		FLumenCardData LumenCardData = GetLumenCardData(CardInterpolants.CardId);

		float Depth = Texture2DSampleLevel(LumenCardScene.DepthBufferAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasCoord, 0).x;

		float3 LocalPosition;
		LocalPosition.xy = (CardInterpolants.AtlasCoord - LumenCardData.LocalPositionToAtlasUVBias) / LumenCardData.LocalPositionToAtlasUVScale;
		LocalPosition.z = -LumenCardData.LocalExtent.z + Depth * 2 * LumenCardData.LocalExtent.z;

		float3 WorldPosition = mul(LumenCardData.WorldToLocalRotation, LocalPosition) + LumenCardData.Origin;

		float3 LightColor = DeferredLightUniforms.Color;
		float3 L = LightData.Direction;
		float3 ToLight = L;
	
#if LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL
		float CombinedAttenuation = 1;
#else
		float LightMask = 1;
		if (LightData.bRadialLight)
		{
			LightMask = GetLocalLightAttenuation(WorldPosition, LightData, ToLight, L);
		}

		float Attenuation;

		if (LightData.bRectLight)
		{
			FRect Rect = GetRect(ToLight, LightData);
			FRectTexture RectTexture = InitRectTexture(DeferredLightUniforms.SourceTexture);
			Attenuation = IntegrateLight(Rect, RectTexture);
		}
		else
		{
			FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
			Capsule.DistBiasSqr = 0;
			Attenuation = IntegrateLight(Capsule, LightData.bInverseSquared);
		}

		float CombinedAttenuation = Attenuation * LightMask;
#endif

		if (CombinedAttenuation > 0)
		{
			float3 WorldNormal = Texture2DSampleLevel(LumenCardScene.NormalAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasCoord, 0).xyz * 2 - 1;

			if (dot(WorldNormal, L) > 0)
			{
				//@todo DynamicGI - derive from card texel size
				float3 WorldPositionForShadowing = WorldPosition + L * (SurfaceBias + SlopeScaledSurfaceBias * saturate(1 - dot(L, WorldNormal)));

				float ShadowFactor = 1.0f;
				bool bShadowFactorComplete = true;

				#if SHADOWED_LIGHT 
					#if HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE
						float2 AtlasTextureSize = LumenCardScene.AtlasSize;
						uint2 Pos2D = CardInterpolants.AtlasCoord * AtlasTextureSize.xy - float2(0.5, 0.5)/AtlasTextureSize.xy;
						ShadowFactor = ShadowMaskAtlas.Load(uint3(Pos2D,0));
					#else
						#if LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL
							#if DYNAMICALLY_SHADOWED
								float SceneDepth = dot(WorldPositionForShadowing - View.WorldCameraOrigin, View.ViewForward);
								ShadowFactor *= ComputeDirectionalLightDynamicShadowing(WorldPositionForShadowing, SceneDepth, bShadowFactorComplete);
								float4 PostProjectionPosition = mul(float4(WorldPosition, 1.0), View.WorldToClip);
								// CSM's are culled so only query points inside the view are valid
								float2 ValidTexelSize = float2(length(ddx(WorldPosition)), length(ddy(WorldPosition))) * 2;
								bShadowFactorComplete = bShadowFactorComplete && all(PostProjectionPosition.xy - ValidTexelSize < PostProjectionPosition.w && PostProjectionPosition.xy + ValidTexelSize > -PostProjectionPosition.w);
							#else
								bShadowFactorComplete = true;
								ShadowFactor *= ComputeDirectionalLightStaticShadowing(WorldPositionForShadowing);
							#endif
						#else
								ShadowFactor = ComputeVolumeShadowing(WorldPositionForShadowing, LightData.bRadialLight && !LightData.bSpotLight, LightData.bSpotLight, bShadowFactorComplete);
						#endif
			
						bool bOffscreenShadowing = !bShadowFactorComplete;

						if (ForceOffscreenShadowing != 0)
						{
							ShadowFactor = 1.0;
							bOffscreenShadowing = true;
						}

						if (bOffscreenShadowing)
						{
							// Offscreen shadowing, trace to light
							float TraceDistance = MaxTraceDistance;

							#if LIGHT_TYPE != LIGHT_TYPE_DIRECTIONAL
								TraceDistance = min(length(ToLight), MaxTraceDistance);
							#endif

							#define OFFSCREEN_SHADOWING_TRACE_GLOBAL_SDF 1

							#if OFFSCREEN_SHADOWING_TRACE_MESH_SDF && (LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL)
							{
								uint NumIntersectingObjects = GetCulledNumObjects();
								uint CulledDataParameter = 0;
								GetShadowTileCulledData(WorldPositionForShadowing, CulledDataParameter, NumIntersectingObjects);

								float SubsurfaceDensity = 0;
								bool bUseSubsurfaceTransmission = false;

								ShadowFactor *= ShadowRayTraceThroughCulledObjects(
									WorldPositionForShadowing,
									WorldPositionForShadowing + L * TraceDistance,
									TraceDistance,
									0, //@todo - TanLightSourceAngle - causes mismatch with CSM which doesn't support LightSourceAngle
									0,
									100,
									SubsurfaceDensity,
									CulledDataParameter,
									NumIntersectingObjects,
									true,
									true,
									bUseSubsurfaceTransmission,
									/*bExpandSurface*/ true);
							}
							#elif OFFSCREEN_SHADOWING_TRACE_GLOBAL_SDF
							{
								WorldPositionForShadowing = WorldPosition + L * (SurfaceBias + SlopeScaledSurfaceBias * saturate(1 - dot(L, WorldNormal))) * SDFSurfaceBiasScale;

								FGlobalSDFTraceInput TraceInput = SetupGlobalSDFTraceInput(WorldPositionForShadowing, L, 0.0f, TraceDistance, 1.0f, 1.0f);

								FGlobalSDFTraceResult SDFResult = RayTraceGlobalDistanceField(TraceInput);

								//@todo - approximate cone trace from SDF for antialiasing
								ShadowFactor *= GlobalSDFTraceResultIsHit(SDFResult) ? 0.0f : 1.0f;
							}
							#endif
						}
					#endif // End hardware/software shadow selection		
				#endif // End ShadowLight

				#if LIGHT_FUNCTION
					ShadowFactor *= GetLightFunction(WorldPosition);
				#endif

				float NoL = saturate(dot(WorldNormal, L));
				Irradiance = LightColor * (CombinedAttenuation * NoL * ShadowFactor);
				//Irradiance = bShadowFactorValid ? float3(0, 1, 0) : float3(.2f, 0, 0);
			}
		}
	}
		
	OutColor = float4(Irradiance, 0);
}

