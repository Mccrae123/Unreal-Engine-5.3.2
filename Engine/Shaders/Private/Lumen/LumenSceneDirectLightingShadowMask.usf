// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenSceneDirectLightingShadowMask.usf
=============================================================================*/

#ifndef VIRTUAL_SHADOW_MAP
	#define VIRTUAL_SHADOW_MAP 0
#endif
#ifndef DENSE_SHADOW_MAP
	#define DENSE_SHADOW_MAP 0
#endif

#include "../Common.ush"
#include "LumenCardCommon.ush"
#include "LumenCardTile.ush"
#define SUPPORT_CONTACT_SHADOWS 0
#include "../DeferredLightingCommon.ush"
#include "../VolumeLightingCommon.ush"
#include "../ForwardShadowingCommon.ush"
#include "../LightGridCommon.ush"
#if VIRTUAL_SHADOW_MAP
#include "../VirtualShadowMaps/ProjectionCommon.ush"
#endif
#define DISTANCE_FIELD_IN_VIEW_UB 1
#define DF_SHADOW_QUALITY 2
#include "LumenTracingCommon.ush"
#include "../DistanceFieldShadowingShared.ush"
#include "LumenSceneDirectLighting.ush"

// Bias
float SurfaceBias;
float SlopeScaledSurfaceBias;
float VirtualShadowMapSurfaceBias;
int VirtualShadowMapId;

// Debug variables
uint ForceShadowMaps;
uint ForceOffscreenShadowing;

// Workaround for a console shader compiler bug generating incorrect code. Likely can be removed in next SDK.
uint DummyZeroForFixingShaderCompilerBug;

StructuredBuffer<uint2> LightTiles;
StructuredBuffer<uint> LightTileAllocator;
StructuredBuffer<uint> LightTileOffsetsPerLight;
uint LightIndex;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void LumenSceneDirectLightingSampleShadowMapCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	if (GroupThreadId.x < 4 && GroupThreadId.y == 0)
	{
		SharedShadowMask[GroupThreadId.x] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint LocalLightTileIndex = GroupId.x;
	uint LightTileIndex = LocalLightTileIndex + LightTileOffsetsPerLight[LightIndex];
	uint2 CoordInCardTile = GroupThreadId.xy;
	FLightTile LightTile = UnpackLightTile(LightTiles[LightTileIndex]);
	uint2 TexelInCardPageCoord = LightTile.TileCoord * CARD_TILE_SIZE + CoordInCardTile;

	FLumenCardPageData CardPage = GetLumenCardPageData(LightTile.CardPageIndex + DummyZeroForFixingShaderCompilerBug);
	float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale * (TexelInCardPageCoord + 0.5f);
	float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale * (TexelInCardPageCoord + 0.5f);

	float Opacity = Texture2DSampleLevel(LumenCardScene.OpacityAtlas, GlobalPointClampedSampler, AtlasUV, 0).x;

	FShadowMaskRay ShadowMaskRay;
	ShadowMaskRay.ShadowFactor = 0.0f;
	ShadowMaskRay.bShadowFactorComplete = true;

	if (Opacity > 0.0f)
	{
		FDeferredLightData LightData = LoadLightData(LIGHT_TYPE);

		float Depth = 1.0f - Texture2DSampleLevel(LumenCardScene.DepthAtlas, GlobalPointClampedSampler, AtlasUV, 0).x;
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
		float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);

		float3 L = LightData.Direction;
		float3 ToLight = L;

#if LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL
		float CombinedAttenuation = 1;
#else
		float LightMask = 1;
		if (LightData.bRadialLight)
		{
			LightMask = GetLocalLightAttenuation(WorldPosition, LightData, ToLight, L);
		}

		float Attenuation;

		if (LightData.bRectLight)
		{
			FRect Rect = GetRect(ToLight, LightData);
			FRectTexture RectTexture = InitRectTexture(DeferredLightUniforms.SourceTexture);
			Attenuation = IntegrateLight(Rect, RectTexture);
		}
		else
		{
			FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
			Capsule.DistBiasSqr = 0;
			Attenuation = IntegrateLight(Capsule, LightData.bInverseSquared);
		}

		float CombinedAttenuation = Attenuation * LightMask;
#endif

		if (CombinedAttenuation > 0)
		{
			const float3 WorldNormal = DecodeSurfaceCacheNormal(Card, Texture2DSampleLevel(LumenCardScene.NormalAtlas, GlobalPointClampedSampler, AtlasUV, 0).xy);

			if (dot(WorldNormal, L) > 0)
			{
				ShadowMaskRay.ShadowFactor = 1.0f;
				ShadowMaskRay.bShadowFactorComplete = false;
				bool bVSMValid = false;

				const float4 PostProjectionPosition = mul(float4(WorldPosition, 1.0), LWCHackToFloat(PrimaryView.WorldToClip));

				// Shadow maps are culled so only query points inside the view frustum are valid
				if (all(PostProjectionPosition.xy < PostProjectionPosition.w && PostProjectionPosition.xy > -PostProjectionPosition.w))
				{
					#if VIRTUAL_SHADOW_MAP
					{
						// Bias only ray start to maximize chances of hitting an allocated page
						FVirtualShadowMapSampleResult VirtualShadowMapSample = SampleVirtualShadowMap(VirtualShadowMapId, WorldPosition, VirtualShadowMapSurfaceBias, WorldNormal);

						bVSMValid = VirtualShadowMapSample.bValid;
						ShadowMaskRay.ShadowFactor = VirtualShadowMapSample.ShadowFactor;
						
						// If there's also a dense shadow map present we need to sample both (unless the VSM determines we are fully shadowed anyways)
						ShadowMaskRay.bShadowFactorComplete = ShadowMaskRay.ShadowFactor < 0.01f;
						#if !DENSE_SHADOW_MAP
						ShadowMaskRay.bShadowFactorComplete = ShadowMaskRay.bShadowFactorComplete || VirtualShadowMapSample.bValid;
						#endif
					}
					#endif

					#if DENSE_SHADOW_MAP
					if (!ShadowMaskRay.bShadowFactorComplete)
					{
						float3 TranslatedWorldPosition = WorldPosition + LWCHackToFloat(PrimaryView.PreViewTranslation);
						float3 TranslatedWorldPositionForShadowing = GetCardWorldPositionForShadowing(TranslatedWorldPosition, L, WorldNormal, SurfaceBias, SlopeScaledSurfaceBias, 1.0f);

						#if LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL
						{
							#if DYNAMICALLY_SHADOWED
							{
								float SceneDepth = dot(TranslatedWorldPositionForShadowing - PrimaryView.TranslatedWorldCameraOrigin, View.ViewForward);

								bool bShadowingFromValidUVArea = false;
								float NewShadowFactor = ComputeDirectionalLightDynamicShadowing(TranslatedWorldPositionForShadowing, SceneDepth, bShadowingFromValidUVArea);

								if (bShadowingFromValidUVArea)
								{
									ShadowMaskRay.ShadowFactor *= NewShadowFactor;
									ShadowMaskRay.bShadowFactorComplete = VIRTUAL_SHADOW_MAP ? bVSMValid : true;
								}
							}
							#endif
						}
						#else
						{
							bool bShadowingFromValidUVArea = false;
							float NewShadowFactor = ComputeVolumeShadowing(TranslatedWorldPositionForShadowing, LightData.bRadialLight && !LightData.bSpotLight, LightData.bSpotLight, bShadowingFromValidUVArea);

							if (bShadowingFromValidUVArea) 
							{
								ShadowMaskRay.ShadowFactor *= NewShadowFactor;
								ShadowMaskRay.bShadowFactorComplete = VIRTUAL_SHADOW_MAP ? bVSMValid : true;
							}
						}
						#endif
					}
					#endif
				}
			}
		}
	}

	if (ForceShadowMaps != 0)
	{
		ShadowMaskRay.bShadowFactorComplete = true;
	}

	if (ForceOffscreenShadowing == 0)
	{
		WriteSharedShadowMaskRay(ShadowMaskRay, GroupThreadId.xy);
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupThreadId.x < 4 && GroupThreadId.y == 0)
	{
		RWShadowMaskTiles[4 * LightTileIndex + GroupThreadId.x] = SharedShadowMask[GroupThreadId.x];
	}
}

float MaxTraceDistance;
float SDFSurfaceBiasScale;

float TraceOffscreenShadows(float3 WorldPosition, float3 L, float3 ToLight, float3 WorldNormal)
{
	float ShadowFactor = 1.0f;

	// Offscreen shadowing, trace to light
	float TraceDistance = MaxTraceDistance;

	#if LIGHT_TYPE != LIGHT_TYPE_DIRECTIONAL
		TraceDistance = min(length(ToLight), MaxTraceDistance);
	#endif

	#if OFFSCREEN_SHADOWING_TRACE_MESH_SDF && (LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL)
	{
		float3 WorldPositionForShadowing = GetCardWorldPositionForShadowing(WorldPosition, L, WorldNormal, SurfaceBias, SlopeScaledSurfaceBias, 1.0f);

		uint NumIntersectingObjects = GetCulledNumObjects();
		uint CulledDataParameter = 0;
		GetShadowTileCulledData(WorldPositionForShadowing, CulledDataParameter, NumIntersectingObjects);

		float SubsurfaceDensity = 0;
		bool bUseSubsurfaceTransmission = false;

		ShadowFactor = ShadowRayTraceThroughCulledObjects(
			WorldPositionForShadowing,
			WorldPositionForShadowing + L * TraceDistance,
			TraceDistance,
			0, //@todo - TanLightSourceAngle - causes mismatch with CSM which doesn't support LightSourceAngle
			0,
			100,
			SubsurfaceDensity,
			CulledDataParameter,
			NumIntersectingObjects,
			true,
			true,
			bUseSubsurfaceTransmission,
			/*bExpandSurface*/ true);
	}
	#elif OFFSCREEN_SHADOWING_TRACE_GLOBAL_SDF
	{
		float3 WorldPositionForShadowing = GetCardWorldPositionForShadowing(WorldPosition, L, WorldNormal, SurfaceBias, SlopeScaledSurfaceBias, SDFSurfaceBiasScale);

		FGlobalSDFTraceInput TraceInput = SetupGlobalSDFTraceInput(WorldPositionForShadowing, L, 0.0f, TraceDistance, 1.0f, 1.0f);
		FGlobalSDFTraceResult SDFResult = RayTraceGlobalDistanceField(TraceInput);

		//@todo - approximate cone trace from SDF for antialiasing
		ShadowFactor = GlobalSDFTraceResultIsHit(SDFResult) ? 0.0f : 1.0f;
	}
	#endif

#if OFFSCREEN_SHADOWING_TRACE_HEIGHTFIELDS && (LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL)
	float3 WorldPositionForShadowing = GetCardWorldPositionForShadowing(WorldPosition, L, WorldNormal, SurfaceBias, SlopeScaledSurfaceBias, SDFSurfaceBiasScale);

	FGlobalSDFTraceInput TraceInput = SetupGlobalSDFTraceInput(WorldPositionForShadowing, L, 0.0f, TraceDistance, 1.0f, 1.0f);
	FGlobalSDFTraceResult HeightfieldResult = ShadowTraceHeightfield(TraceInput);

	ShadowFactor *= GlobalSDFTraceResultIsHit(HeightfieldResult) ? 0.0f : 1.0f;
#endif

	return ShadowFactor;
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void LumenSceneDirectLightingTraceDistanceFieldShadowsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint LocalLightTileIndex = GroupId.x;
	uint LightTileIndex = LocalLightTileIndex + LightTileOffsetsPerLight[LightIndex];

	if (GroupThreadId.x < 4 && GroupThreadId.y == 0)
	{
		SharedShadowMask[GroupThreadId.x] = RWShadowMaskTiles[4 * LightTileIndex + GroupThreadId.x];
	}

	GroupMemoryBarrierWithGroupSync();

	uint2 CoordInCardTile = GroupThreadId.xy;
	FLightTile LightTile = UnpackLightTile(LightTiles[LightTileIndex]);
	uint2 TexelInCardPageCoord = LightTile.TileCoord * CARD_TILE_SIZE + CoordInCardTile;

	FLumenCardPageData CardPage = GetLumenCardPageData(LightTile.CardPageIndex + DummyZeroForFixingShaderCompilerBug);
	float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale * (TexelInCardPageCoord + 0.5f);
	float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale * (TexelInCardPageCoord + 0.5f);

	FShadowMaskRay ShadowMaskRay;
	ReadSharedShadowMaskRay(GroupThreadId.xy, ShadowMaskRay);

	if (!ShadowMaskRay.bShadowFactorComplete)
	{
		FDeferredLightData LightData = LoadLightData(LIGHT_TYPE);

		float Depth = 1.0f - Texture2DSampleLevel(LumenCardScene.DepthAtlas, GlobalPointClampedSampler, AtlasUV, 0).x;
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
		float3 WorldPosition = GetCardWorldPosition(Card, CardUV, Depth);
		float3 WorldNormal = DecodeSurfaceCacheNormal(Card, Texture2DSampleLevel(LumenCardScene.NormalAtlas, GlobalPointClampedSampler, AtlasUV, 0).xy);

		float3 L = LightData.Direction;
		float3 ToLight = L;

#if LIGHT_TYPE != LIGHT_TYPE_DIRECTIONAL
		if (LightData.bRadialLight)
		{
			float3 TranslatedWorldPosition = WorldPosition + LWCHackToFloat(PrimaryView.PreViewTranslation);
			ToLight = LightData.TranslatedWorldPosition - TranslatedWorldPosition;
			L = normalize(ToLight);
		}
#endif

		ShadowMaskRay.bShadowFactorComplete = true;
		ShadowMaskRay.ShadowFactor = TraceOffscreenShadows(WorldPosition, L, ToLight, WorldNormal);

		WriteSharedShadowMaskRay(ShadowMaskRay, GroupThreadId.xy);
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupThreadId.x < 4 && GroupThreadId.y == 0)
	{
		RWShadowMaskTiles[4 * LightTileIndex + GroupThreadId.x] = SharedShadowMask[GroupThreadId.x];
	}
}