// Copyright Epic Games, Inc. All Rights Reserved.

// TODO: Remove hair dependency
#include "../HairStrands/HairStrandsVoxelPageCommonStruct.ush"

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../SceneTextureParameters.ush"

#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenReflectionCommon.ush"
#include "LumenHardwareRayTracingCommon.ush"

#ifndef DIM_NORMAL_MODE
#define DIM_NORMAL_MODE SDF_NORMAL_TYPE
#endif

#ifndef DIM_LIGHTING_MODE
#define DIM_LIGHTING_MODE LIGHTING_FROM_SURFACE_CACHE
#endif

RWTexture2D<float> RWTraceHit;
RWTexture2D<float3> RWTraceRadiance;

RaytracingAccelerationStructure TLAS;
float MaxTraceDistance;

StructuredBuffer<FDeferredMaterialPayload> DeferredMaterialBuffer;

RAY_TRACING_ENTRY_RAYGEN(LumenReflectionHardwareRayTracingRGS)
{
	uint2 ReflectionTracingCoord;
	float TraceHitDistance = 0;
	FDeferredMaterialPayload DeferredMaterialPayload;

	if (DIM_DEFERRED_MATERIAL_MODE)
	{
		DeferredMaterialPayload = DeferredMaterialBuffer[DispatchRaysIndex().x];
		ReflectionTracingCoord.x = DeferredMaterialPayload.PixelCoordinates & 0xFFFF;
		ReflectionTracingCoord.y = DeferredMaterialPayload.PixelCoordinates >> 16;
		TraceHitDistance = DeferredMaterialPayload.HitT;

		if (DeferredMaterialPayload.SortKey == RAY_TRACING_DEFERRED_MATERIAL_KEY_INVALID)
		{
			bool bHit = false;
			RWTraceHit[ReflectionTracingCoord] = EncodeRayDistance(TraceHitDistance, bHit);
			return;
		}
	}
	else
	{
		if (DispatchRaysIndex().x >= CompactedTraceTexelAllocator[0])
		{
			return;
		}

		DecodeTraceTexel(CompactedTraceTexelData[DispatchRaysIndex().x], ReflectionTracingCoord, TraceHitDistance);
	}

	float2 ScreenUV = GetScreenUVFromReflectionTracingCoord(ReflectionTracingCoord);
	float2 ScreenCoord = ScreenUV * View.BufferSizeAndInvSize.xy;
	uint LinearCoord = ScreenCoord.y * View.BufferSizeAndInvSize.x + ScreenCoord.x;

	float SceneDepth = DownsampledDepth.Load(int3(ReflectionTracingCoord, 0)).x;
	float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
	float3 WorldNormal = DecodeNormal(GBufferATexture.Load(int3(ScreenUV * View.BufferSizeAndInvSize.xy, 0)).xyz);

	FRayData RayData = DecodeRayData(RayBuffer[ReflectionTracingCoord]);

	RayDesc Ray;
	Ray.Origin = WorldPosition;
	Ray.Direction = RayData.Direction;
	float RayBias = 0.05;
	Ray.TMin = max(TraceHitDistance, RayBias);
	Ray.TMax = MaxTraceDistance;

	float NormalBias = 0.05;
	ApplyPositionBias(Ray.Origin, Ray.Direction, WorldNormal, NormalBias);

	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;
	RayCone = PropagateRayCone(RayCone, RayData.ConeHalfAngle, SceneDepth);

	FRayTracedLightingContext Context;
	Context.TLAS = TLAS;
	Context.RayCone = RayCone;
	Context.TraceCoord = ReflectionTracingCoord;
	Context.LinearCoord = LinearCoord;

	bool bTraceRay = true;
	if (DIM_DEFERRED_MATERIAL_MODE)
	{
		bTraceRay = DeferredMaterialPayload.SortKey < RAY_TRACING_DEFERRED_MATERIAL_KEY_RAY_MISS;
		if (bTraceRay)
		{
			float Epsilon = 0.5;
			Ray.TMin = max(0, DeferredMaterialPayload.HitT - Epsilon);
			// Note: adjusting TMax will not properly account for masked materials because of restricted any-hit length
			Ray.TMax = DeferredMaterialPayload.HitT + Epsilon;
		}
	}
	float TOffset = RebaseRay(Ray);

	bool bHit = false;
	float3 Radiance = 0;
	if (bTraceRay)
	{
		float HitDistance = 0.0;
		bool bUseMinimalPayload = (DIM_LIGHTING_MODE == LIGHTING_FROM_SURFACE_CACHE) && (DIM_NORMAL_MODE == SDF_NORMAL_TYPE) && (DIM_DEFERRED_MATERIAL_MODE == 0);
		if (bUseMinimalPayload)
		{
			bHit = TraceAndCalculateRayTracedLightingFromSurfaceCache(Ray, Context, DIM_NORMAL_MODE, HitDistance, Radiance);
		}
		else
		{
			bHit = TraceAndCalculateRayTracedLighting(Ray, Context, DIM_LIGHTING_MODE, DIM_NORMAL_MODE, HitDistance, Radiance);
		}
#if !DIM_DEFERRED_MATERIAL_MODE
		TraceHitDistance = HitDistance;
#endif

		RebaseTraceHitDistance(TraceHitDistance, TOffset);
	}

	Radiance *= View.PreExposure;
	RWTraceRadiance[ReflectionTracingCoord] = Radiance;
	RWTraceHit[ReflectionTracingCoord] = EncodeRayDistance(TraceHitDistance, bHit);
}

RWStructuredBuffer<FDeferredMaterialPayload> RWDeferredMaterialBuffer;
int2 DeferredMaterialBufferResolution;
uint TileSize;

RAY_TRACING_ENTRY_RAYGEN(LumenReflectionHardwareRayTracingDeferredMaterialRGS)
{
	if (DispatchRaysIndex().x >= CompactedTraceTexelAllocator[0])
	{
		return;
	}

	uint2 ReflectionTracingCoord;
	float TraceHitDistance = 0;
	DecodeTraceTexel(CompactedTraceTexelData[DispatchRaysIndex().x], ReflectionTracingCoord, TraceHitDistance);

	float2 ScreenUV = GetScreenUVFromReflectionTracingCoord(ReflectionTracingCoord);
	float2 ScreenCoord = ScreenUV * View.BufferSizeAndInvSize.xy;
	uint LinearCoord = ScreenCoord.y * View.BufferSizeAndInvSize.x + ScreenCoord.x;

	float SceneDepth = DownsampledDepth.Load(int3(ReflectionTracingCoord, 0)).x;
	float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
	float3 WorldNormal = DecodeNormal(GBufferATexture.Load(int3(ScreenUV * View.BufferSizeAndInvSize.xy, 0)).xyz);

	FRayData RayData = DecodeRayData(RayBuffer[ReflectionTracingCoord]);

	RayDesc Ray;
	Ray.Origin = WorldPosition;
	Ray.Direction = RayData.Direction;
	float RayBias = 0.05;
	Ray.TMin = max(TraceHitDistance, RayBias);
	Ray.TMax = MaxTraceDistance;
	float TOffset = RebaseRay(Ray);

	float NormalBias = 0.05;
	ApplyPositionBias(Ray.Origin, Ray.Direction, WorldNormal, NormalBias);

	FRayCone RayCone = (FRayCone)0;
	RayCone.SpreadAngle = View.EyeToPixelSpreadAngle;
	RayCone = PropagateRayCone(RayCone, RayData.ConeHalfAngle, SceneDepth);

	FRayTracedLightingContext Context;
	Context.TLAS = TLAS;
	Context.RayCone = RayCone;
	Context.TraceCoord = ReflectionTracingCoord;
	Context.LinearCoord = LinearCoord;

	FDeferredMaterialPayload DeferredMaterialPayload = (FDeferredMaterialPayload)0;
	bool bIsHit = TraceDeferredMaterialRay(Ray, Context, DeferredMaterialPayload);
	RebaseTraceHitDistance(DeferredMaterialPayload.HitT, TOffset);

	// Encode max trace distance in the case of an invalid or miss condition
	if (!bIsHit)
	{
		DeferredMaterialPayload.HitT = MaxTraceDistance;
	}

#if 0
	// Rearrange in tiled blocks to extract spatial coherence
	uint2 BlockCoord = ReflectionTracingCoord / TileSize;
	uint BlocksPerRow = DeferredMaterialBufferResolution.x / TileSize;
	uint BlockIndex = BlockCoord.y * BlocksPerRow + BlockCoord.x;
	uint2 TileCoord = ReflectionTracingCoord % TileSize;
	uint TileIndex = TileCoord.y * TileSize + TileCoord.x;
	uint BlockSize = TileSize * TileSize;
	uint DeferredMaterialBufferIndex = BlockIndex * BlockSize + TileIndex;
#else
	uint DeferredMaterialBufferIndex = DispatchRaysIndex().x;
#endif

	RWDeferredMaterialBuffer[DeferredMaterialBufferIndex] = DeferredMaterialPayload;
}
