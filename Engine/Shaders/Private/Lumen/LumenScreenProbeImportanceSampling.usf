// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenScreenProbeCommon.ush"
#include "../SHCommon.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

#ifndef LIGHTING_PDF_THREADGROUP_SIZE
#define LIGHTING_PDF_THREADGROUP_SIZE 1
#endif

#ifndef GENERATE_RAYS_THREADGROUP_SIZE
#define GENERATE_RAYS_THREADGROUP_SIZE 1
#endif

RWTexture2D<float> RWBRDFProbabilityDensityFunction;
RWBuffer<float> RWBRDFProbabilityDensityFunctionSH;

groupshared float4 PixelPlanes[PROBE_THREADGROUP_SIZE_2D][PROBE_THREADGROUP_SIZE_2D];
#define NUM_PDF_SH_COEFFICIENTS 9
groupshared float PDF_SphericalHarmonic[PROBE_THREADGROUP_SIZE_2D * PROBE_THREADGROUP_SIZE_2D * 2][NUM_PDF_SH_COEFFICIENTS];
groupshared uint NumSphericalHarmonics;

FThreeBandSHVector GetGroupSharedSH(uint ThreadIndex)
{
	FThreeBandSHVector BRDF;
	BRDF.V0.x = PDF_SphericalHarmonic[ThreadIndex][0];
	BRDF.V0.y = PDF_SphericalHarmonic[ThreadIndex][1];
	BRDF.V0.z = PDF_SphericalHarmonic[ThreadIndex][2];
	BRDF.V0.w = PDF_SphericalHarmonic[ThreadIndex][3];
	BRDF.V1.x = PDF_SphericalHarmonic[ThreadIndex][4];
	BRDF.V1.y = PDF_SphericalHarmonic[ThreadIndex][5];
	BRDF.V1.z = PDF_SphericalHarmonic[ThreadIndex][6];
	BRDF.V1.w = PDF_SphericalHarmonic[ThreadIndex][7];
	BRDF.V2.x = PDF_SphericalHarmonic[ThreadIndex][8];
	return BRDF;
}

void WriteGroupSharedSH(FThreeBandSHVector SH, uint ThreadIndex)
{
	PDF_SphericalHarmonic[ThreadIndex][0] = SH.V0.x;
	PDF_SphericalHarmonic[ThreadIndex][1] = SH.V0.y;
	PDF_SphericalHarmonic[ThreadIndex][2] = SH.V0.z;
	PDF_SphericalHarmonic[ThreadIndex][3] = SH.V0.w;
	PDF_SphericalHarmonic[ThreadIndex][4] = SH.V1.x;
	PDF_SphericalHarmonic[ThreadIndex][5] = SH.V1.y;
	PDF_SphericalHarmonic[ThreadIndex][6] = SH.V1.z;
	PDF_SphericalHarmonic[ThreadIndex][7] = SH.V1.w;
	PDF_SphericalHarmonic[ThreadIndex][8] = SH.V2.x;
}

[numthreads(PROBE_THREADGROUP_SIZE_2D, PROBE_THREADGROUP_SIZE_2D, 1)]
void ScreenProbeComputeBRDFProbabilityDensityFunctionCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	uint2 ScreenProbeScreenCoord;
	uint ScreenProbeSubsampleIndex;
	GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

		if (SceneDepth > 0 && SceneDepth < 1000000.0f)
		{
#define BRDF_PDF_SPHERICAL_HARMONIC 1
#if BRDF_PDF_SPHERICAL_HARMONIC

			uint ThreadIndex = GroupThreadId.y * PROBE_THREADGROUP_SIZE_2D + GroupThreadId.x;

			if (ThreadIndex == 0)
			{
				NumSphericalHarmonics = 0;
			}

			GroupMemoryBarrierWithGroupSync();

			float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

			{
				float2 ThreadOffset = GroupThreadId.xy / (float)PROBE_THREADGROUP_SIZE_2D * ScreenProbeDownsampleFactor * 2.0f - 1.0f;

				if (all(GroupThreadId.xy == PROBE_THREADGROUP_SIZE_2D / 2))
				{
					// Make sure we have at least one pixel that won't be rejected by the depth weight
					ThreadOffset = 0;
				}

				float2 PixelScreenUV = ScreenUV + ThreadOffset * View.BufferSizeAndInvSize.zw;
				PixelScreenUV = clamp(PixelScreenUV, View.ViewRectMin.xy * View.BufferSizeAndInvSize.zw, (View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy - 1) * View.BufferSizeAndInvSize.zw);

				FGBufferData GBufferData = GetGBufferData(PixelScreenUV);

				float3 PixelPosition = GetWorldPositionFromScreenUV(PixelScreenUV, GBufferData.Depth);
				float4 PixelPlane = float4(GBufferData.WorldNormal, dot(GBufferData.WorldNormal, PixelPosition));
				float3 ProbeWorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

				float PlaneDistance = abs(dot(float4(ProbeWorldPosition, -1), PixelPlane));
				float RelativeDepthDifference = PlaneDistance / SceneDepth;
				float DepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));

				if (DepthWeight > .1f)
				{
					uint Index;
					InterlockedAdd(NumSphericalHarmonics, 1, Index);

					FThreeBandSHVector BRDF;

					if (GBufferData.ShadingModelID == SHADINGMODELID_HAIR)
					{
						// Hack to avoid culling directions that hair will sample
						BRDF = (FThreeBandSHVector)0;
						BRDF.V0.x = 1.0f;
					}
					else
					{
						BRDF = CalcDiffuseTransferSH3(GBufferData.WorldNormal, 1.0f);
					}

					WriteGroupSharedSH(BRDF, Index);
				}
			}

			GroupMemoryBarrierWithGroupSync();

			uint NumSHToAccumulate = NumSphericalHarmonics;
			uint Offset = 0;

			while (NumSHToAccumulate > 1)
			{
				uint ThreadBaseIndex = ThreadIndex * 4;

				if (ThreadBaseIndex < NumSHToAccumulate)
				{
					FThreeBandSHVector PDF = GetGroupSharedSH(ThreadBaseIndex + Offset);

					if (ThreadBaseIndex + 1 < NumSHToAccumulate)
					{
						PDF = AddSH(PDF, GetGroupSharedSH(ThreadBaseIndex + 1 + Offset));
					}

					if (ThreadBaseIndex + 2 < NumSHToAccumulate)
					{
						PDF = AddSH(PDF, GetGroupSharedSH(ThreadBaseIndex + 2 + Offset));
					}

					if (ThreadBaseIndex + 3 < NumSHToAccumulate)
					{
						PDF = AddSH(PDF, GetGroupSharedSH(ThreadBaseIndex + 3 + Offset));
					}

					WriteGroupSharedSH(PDF, ThreadIndex + Offset + NumSHToAccumulate);
				}

				Offset += NumSHToAccumulate;
				NumSHToAccumulate = (NumSHToAccumulate + 3) / 4;

				GroupMemoryBarrierWithGroupSync();
			}

			if (ThreadIndex < NUM_PDF_SH_COEFFICIENTS)
			{
				uint WriteIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x) * NUM_PDF_SH_COEFFICIENTS + ThreadIndex;
				float NormalizeWeight = 1.0f / (float)(NumSphericalHarmonics);
				RWBRDFProbabilityDensityFunctionSH[WriteIndex] = PDF_SphericalHarmonic[Offset][ThreadIndex] * NormalizeWeight;
			}

			// 'vis BRDFProbabilityDensityFunction uv1'
			#define VISUALIZE_BRDF_PDF_SPHERICAL_HARMONIC 0
			#if VISUALIZE_BRDF_PDF_SPHERICAL_HARMONIC
				uint2 TexelCoord = GroupThreadId.xy;

				if (all(TexelCoord < ScreenProbeBRDFOctahedronResolution))
				{
					FThreeBandSHVector BRDF;
					float NormalizeWeight = 1.0f / (float)(NumSphericalHarmonics);
					BRDF.V0.x = PDF_SphericalHarmonic[Offset][0] * NormalizeWeight;
					BRDF.V0.y = PDF_SphericalHarmonic[Offset][1] * NormalizeWeight;
					BRDF.V0.z = PDF_SphericalHarmonic[Offset][2] * NormalizeWeight;
					BRDF.V0.w = PDF_SphericalHarmonic[Offset][3] * NormalizeWeight;
					BRDF.V1.x = PDF_SphericalHarmonic[Offset][4] * NormalizeWeight;
					BRDF.V1.y = PDF_SphericalHarmonic[Offset][5] * NormalizeWeight;
					BRDF.V1.z = PDF_SphericalHarmonic[Offset][6] * NormalizeWeight;
					BRDF.V1.w = PDF_SphericalHarmonic[Offset][7] * NormalizeWeight;
					BRDF.V2.x = PDF_SphericalHarmonic[Offset][8] * NormalizeWeight;

					float2 ProbeTexelCenter = float2(0.5, 0.5);
					float2 ProbeUV = (TexelCoord + ProbeTexelCenter) / (float)ScreenProbeBRDFOctahedronResolution;
					float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

					FThreeBandSHVector DirectionSH = SHBasisFunction3(WorldConeDirection);
					float PDF = max(DotSH3(BRDF, DirectionSH), 0);
	
					RWBRDFProbabilityDensityFunction[ScreenProbeAtlasCoord * ScreenProbeBRDFOctahedronResolution + TexelCoord] = PDF;
				}
			#endif
#else
			float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

			{
				float2 ThreadOffset = GroupThreadId.xy / (float)PROBE_THREADGROUP_SIZE_2D * ScreenProbeDownsampleFactor * 2.0f - 1.0f;

				if (all(GroupThreadId.xy == PROBE_THREADGROUP_SIZE_2D / 2))
				{
					// Make sure we have at least one pixel that won't be rejected by the depth weight
					ThreadOffset = 0;
				}

				float2 PixelScreenUV = ScreenUV + ThreadOffset * View.BufferSizeAndInvSize.zw;
				PixelScreenUV = clamp(PixelScreenUV, View.ViewRectMin.xy * View.BufferSizeAndInvSize.zw, (View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy - 1) * View.BufferSizeAndInvSize.zw);

				FGBufferData GBufferData = GetGBufferData(PixelScreenUV);

				float3 PixelPosition = GetWorldPositionFromScreenUV(PixelScreenUV, GBufferData.Depth);
				float4 PixelPlane = float4(GBufferData.WorldNormal, dot(GBufferData.WorldNormal, PixelPosition));
				PixelPlanes[GroupThreadId.x][GroupThreadId.y] = PixelPlane;
			}

			GroupMemoryBarrierWithGroupSync();

			float3 ProbeWorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

			for (uint TexelCoordY = GroupThreadId.y; TexelCoordY < ScreenProbeBRDFOctahedronResolution; TexelCoordY += PROBE_THREADGROUP_SIZE_2D)
			{
				for (uint TexelCoordX = GroupThreadId.x; TexelCoordX < ScreenProbeBRDFOctahedronResolution; TexelCoordX += PROBE_THREADGROUP_SIZE_2D)
				{
					float2 PDFTexelCoord = float2(TexelCoordX, TexelCoordY);
					float2 ProbeTexelCenter = float2(0.5, 0.5);
					float2 ProbeUV = (PDFTexelCoord + ProbeTexelCenter) / (float)ScreenProbeBRDFOctahedronResolution;
					float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

					float PDF = 0.0f;

					for (uint Y = 0; Y < PROBE_THREADGROUP_SIZE_2D; Y++)
					{
						for (uint X = 0; X < PROBE_THREADGROUP_SIZE_2D; X++)
						{
							float4 PixelPlane = PixelPlanes[X][Y];
						
							float PlaneDistance = abs(dot(float4(ProbeWorldPosition, -1), PixelPlane));
							float RelativeDepthDifference = PlaneDistance / SceneDepth;
							float DepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));

							if (DepthWeight > .1f)
							{
								float Bias = 0.0f;
								float NdotL = max((1.0f - Bias) * dot(WorldConeDirection, PixelPlane.xyz) + Bias, 0.0f);
								//@todo - integrate over texel.  BRDF is evaluated at lower resolution than final integral.
								PDF = max(PDF, NdotL);
							}
						}
					}

					RWBRDFProbabilityDensityFunction[ScreenProbeAtlasCoord * ScreenProbeBRDFOctahedronResolution + uint2(TexelCoordX, TexelCoordY)] = PDF;
				}
			}
#endif
		}
	}
}

RWTexture2D<float> RWLightingProbabilityDensityFunction;

float4 ImportanceSamplingHistoryScreenPositionScaleBias;
float4 ImportanceSamplingHistoryUVMinMax;
float ImportanceSamplingHistoryDistanceThreshold;
float PrevInvPreExposure;
Texture2D HistoryDownsampledDepth;
Texture2D<float3> HistoryScreenProbeRadiance;
Texture2D VelocityTexture;

groupshared float SharedPDF[LIGHTING_PDF_THREADGROUP_SIZE * LIGHTING_PDF_THREADGROUP_SIZE * 4];

float ComputeHistoryWeightBasedOnPosition(float2 ScreenPosition, float SceneDepth, float2 OldScreenPosition, float HistoryCameraDepth, float Noise)
{
	float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;

	float3 PrevPositionTranslatedWorld = mul(float4(OldScreenPosition * HistoryCameraDepth, HistoryCameraDepth, 1), View.PrevScreenToTranslatedWorld).xyz;
	float3 PrevWorldPosition = PrevPositionTranslatedWorld - View.PrevPreViewTranslation;

	float DistanceToHistoryValue = length(PrevWorldPosition - WorldPosition);
	float RelativeHistoryDistanceThreshold = ImportanceSamplingHistoryDistanceThreshold * lerp(.5f, 1.5f, Noise) / 1000.0f;

	return DistanceToHistoryValue / SceneDepth > RelativeHistoryDistanceThreshold ? 0.0f : 1.0f;
}

[numthreads(LIGHTING_PDF_THREADGROUP_SIZE, LIGHTING_PDF_THREADGROUP_SIZE, 1)]
void ScreenProbeComputeLightingProbabilityDensityFunctionCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	uint2 ProbeTexelCoord = GroupThreadId.xy;

	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	uint2 ScreenProbeScreenCoord;
	uint ScreenProbeSubsampleIndex;
	GetScreenProbeScreenCoord(ScreenProbeIndex, ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);

	float PDF = 0.0f;

	float2 ScreenUV = GetScreenUVFromScreenProbeCoord(ScreenProbeScreenCoord, ScreenProbeSubsampleIndex);
	float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

	if (ScreenProbeIndex < GetNumScreenProbes() && SceneDepth > 0 && SceneDepth < 1000000.0f)
	{
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
		
		float3 Lighting = 0;
		float Transparency = 1;

#if PROBE_RADIANCE_HISTORY
		// Reproject into last frame's probe depth buffer
		// Interpolate from neighboring probes last frame lighting, with position error weight

		float2 ScreenPosition = (ScreenUV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
		float3 HistoryScreenPosition = float3(ScreenPosition, ConvertToDeviceZ(SceneDepth));
		bool bIsDynamicPixel = false;

		{
			float4 ThisClip = float4(HistoryScreenPosition, 1);
			float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
			float3 PrevScreen = PrevClip.xyz / PrevClip.w;
			float3 Velocity = HistoryScreenPosition - PrevScreen;
			float3 EncodedVelocity = VelocityTexture.SampleLevel(GlobalPointClampedSampler, ScreenUV, 0).xyz;
			bIsDynamicPixel = EncodedVelocity.x > 0.0;

			if (bIsDynamicPixel)
			{
				Velocity = DecodeVelocityFromTexture(EncodedVelocity);
			}

			HistoryScreenPosition -= Velocity;
		}

		float2 HistoryScreenUV = HistoryScreenPosition.xy * ImportanceSamplingHistoryScreenPositionScaleBias.xy + ImportanceSamplingHistoryScreenPositionScaleBias.wz;

		float EffectiveHistoryWeight = 1.0f;

		FLATTEN
		if (any(HistoryScreenUV > ImportanceSamplingHistoryUVMinMax.zw + .5f * View.BufferSizeAndInvSize.zw) || any(HistoryScreenUV < ImportanceSamplingHistoryUVMinMax.xy - .5f * View.BufferSizeAndInvSize.zw))
		{ 
			EffectiveHistoryWeight = 0.0f;
		}

		if (EffectiveHistoryWeight > 0.0f)
		{
			float2 HistoryScreenProbeCoord = GetScreenProbeCoordFromScreenUV(HistoryScreenUV, SCREEN_HISTORY_TEMPORAL_INDEX, 0);

			//@todo - interpolate from 4 neighbors
			float HistoryDepth = HistoryDownsampledDepth.Load(int3(HistoryScreenProbeCoord, 0)).x;
			float PositionWeight = ComputeHistoryWeightBasedOnPosition(ScreenPosition, SceneDepth, HistoryScreenPosition.xy, HistoryDepth, 1.0f);

			EffectiveHistoryWeight *= PositionWeight;

			uint2 HistoryRadianceCoord = ((uint2)HistoryScreenProbeCoord) * ScreenProbeGatherOctahedronResolution + ProbeTexelCoord;
			float3 HistoryRadiance = HistoryScreenProbeRadiance.Load(int3(HistoryRadianceCoord, 0)).xyz * PrevInvPreExposure * View.PreExposure;

			Lighting = HistoryRadiance * EffectiveHistoryWeight;
			Transparency = 1.0f - EffectiveHistoryWeight;
		}
#endif
		float2 ProbeTexelCenter = GetProbeTexelCenter(ScreenProbeAtlasCoord);
		float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / float(ScreenProbeTracingOctahedronResolution);

		if (Transparency > 0.0f)
		{
#if RADIANCE_CACHE
			float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);
			float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(ScreenProbeTracingOctahedronResolution * ScreenProbeTracingOctahedronResolution));

			bool bCoveredByRadianceCache = false;
			float ProbeOcclusionDistance = GetRadianceProbeOcclusionDistanceWithInterpolation(WorldPosition, WorldConeDirection, bCoveredByRadianceCache);

			if (bCoveredByRadianceCache)
			{
				Lighting += SampleRadianceCacheInterpolated(WorldPosition, WorldConeDirection, ConeHalfAngle, float3(0, 0, 0)) * Transparency;
			}
			else
#endif
			{
				//@todo - skylight
				Lighting = 1;
			}
		}


		const float InvScreenProbeResolution = 1.0f / ScreenProbeTracingOctahedronResolution;
		float SolidAngle = OctahedralSolidAngleLUT(ProbeUV, ScreenProbeTracingOctahedronResolution);

		PDF = Luminance(Lighting) * SolidAngle;

		SharedPDF[GroupThreadId.y * LIGHTING_PDF_THREADGROUP_SIZE + GroupThreadId.x] = PDF;

		GroupMemoryBarrierWithGroupSync();

		uint ThreadIndex = GroupThreadId.y * LIGHTING_PDF_THREADGROUP_SIZE + GroupThreadId.x;
		uint NumValuesToAccumulate = LIGHTING_PDF_THREADGROUP_SIZE * LIGHTING_PDF_THREADGROUP_SIZE;
		uint Offset = 0;

		while (NumValuesToAccumulate > 1)
		{
			uint ThreadBaseIndex = ThreadIndex * 4;

			if (ThreadBaseIndex < NumValuesToAccumulate)
			{
				float PDF = SharedPDF[ThreadBaseIndex + Offset];

				if (ThreadBaseIndex + 1 < NumValuesToAccumulate)
				{
					PDF += SharedPDF[ThreadBaseIndex + 1 + Offset];
				}

				if (ThreadBaseIndex + 2 < NumValuesToAccumulate)
				{
					PDF += SharedPDF[ThreadBaseIndex + 2 + Offset];
				}

				if (ThreadBaseIndex + 3 < NumValuesToAccumulate)
				{
					PDF += SharedPDF[ThreadBaseIndex + 3 + Offset];
				}

				SharedPDF[ThreadIndex + Offset + NumValuesToAccumulate] = PDF;
			}

			Offset += NumValuesToAccumulate;
			NumValuesToAccumulate = (NumValuesToAccumulate + 3) / 4;

			GroupMemoryBarrierWithGroupSync();
		}

		float PDFSum = SharedPDF[Offset];
		RWLightingProbabilityDensityFunction[DispatchThreadId.xy] = Luminance(Lighting) * SolidAngle / max(PDFSum, 0.0001f);
	}
}

// Stores a RayInfo indirection entry for each ray to trace of a Screen Probe, used by tracing passes 
RWTexture2D<uint> RWStructuredImportanceSampledRayInfosForTracing;
// Stores a RayCoord (relative offset into RWStructuredImportanceSampledRayInfosForTracing) for each texel so that the composite can gather the lighting of the rays that were traced
RWTexture2D<UNORM float2> RWStructuredImportanceSampledRayCoordForComposite;

Texture2D<float> BRDFProbabilityDensityFunction;
Buffer<float> BRDFProbabilityDensityFunctionSH;
Texture2D<float> LightingProbabilityDensityFunction;
float MinPDFToTrace;

#define GENERATE_RAYS_NUM_TOTAL_THREADS (GENERATE_RAYS_THREADGROUP_SIZE * GENERATE_RAYS_THREADGROUP_SIZE)
groupshared uint2 RaysToRefine[GENERATE_RAYS_NUM_TOTAL_THREADS];
groupshared uint2 RaysToRefineSorted[GENERATE_RAYS_NUM_TOTAL_THREADS];
groupshared uint NumRaysToSubdivide;

uint2 PackRaySortInfo(uint2 TexelCoord, uint Level, float PDF)
{
	return uint2((TexelCoord.x & 0xFF) | ((TexelCoord.y & 0xFF) << 8) | ((Level & 0xFF) << 16), asuint(PDF));
}

void UnpackRaySortInfo(uint2 RaySortInfo, out uint2 TexelCoord, out uint Level, out float PDF)
{
	TexelCoord.x = RaySortInfo.x & 0xFF;
	TexelCoord.y = (RaySortInfo.x >> 8) & 0xFF;
	Level = (RaySortInfo.x >> 16) & 0xFF;
	PDF = asfloat(RaySortInfo.y);
}

uint Compute1dIndex(uint2 Coord, uint2 Size)
{
	return Coord.y * Size.x + Coord.x;
}

void WriteRay(uint2 ScreenProbeCoord, uint2 TracingRayCoord, uint2 SourceTexelCoord, uint SourceLevel)
{
	if (TracingRayCoord.x != INVALID_TRACING_COORD)
	{
		uint2 TraceCoord = GetTraceBufferCoord(ScreenProbeCoord, TracingRayCoord);
		RWStructuredImportanceSampledRayInfosForTracing[TraceCoord] = PackRayInfo(SourceTexelCoord, SourceLevel);
	}

#if GENERATE_RAYS_FOR_GATHER_COMPOSITE
	{
		uint MipSize = MaxImportanceSamplingOctahedronResolution >> SourceLevel;
		uint UpsampleKernelSize = MaxImportanceSamplingOctahedronResolution / MipSize;
		uint2 BaseCoord = ScreenProbeCoord * MaxImportanceSamplingOctahedronResolution + SourceTexelCoord * UpsampleKernelSize;

		for (uint Y = 0; Y < UpsampleKernelSize; Y++)
		{
			for (uint X = 0; X < UpsampleKernelSize; X++)
			{
				RWStructuredImportanceSampledRayCoordForComposite[BaseCoord + uint2(X, Y)] = TracingRayCoord / 255.0f;
			}
		}
	}
#endif
}

[numthreads(GENERATE_RAYS_THREADGROUP_SIZE, GENERATE_RAYS_THREADGROUP_SIZE, 1)]
void ScreenProbeGenerateRaysCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint UniformLevel = firstbithigh(MaxImportanceSamplingOctahedronResolution / ScreenProbeTracingOctahedronResolution);
	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;

	float SceneDepth = DownsampledDepth.Load(int3(ScreenProbeAtlasCoord, 0)).x;

	if (ScreenProbeIndex < GetNumScreenProbes() && SceneDepth > 0 && SceneDepth < 1000000.0f)
	{
#define UNIFORM_RAY_DISTRIBUTION_DEBUG 0
#if UNIFORM_RAY_DISTRIBUTION_DEBUG

		uint MipSize = MaxImportanceSamplingOctahedronResolution >> UniformLevel;
		uint2 TexelCoord = GroupThreadId.xy;

		if (all(TexelCoord < MipSize))
		{
			WriteRay(ScreenProbeAtlasCoord, TexelCoord, TexelCoord, UniformLevel);
		}

#else
		{
			uint2 TexelCoord = GroupThreadId.xy;
			uint MipSize = MaxImportanceSamplingOctahedronResolution >> UniformLevel;

			if (all(TexelCoord < MipSize))
			{
#if BRDF_PDF_SPHERICAL_HARMONIC
				uint SHBaseIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x) * NUM_PDF_SH_COEFFICIENTS;
				FThreeBandSHVector BRDF;
				BRDF.V0.x = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 0];
				BRDF.V0.y = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 1];
				BRDF.V0.z = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 2];
				BRDF.V0.w = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 3];
				BRDF.V1.x = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 4];
				BRDF.V1.y = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 5];
				BRDF.V1.z = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 6];
				BRDF.V1.w = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 7];
				BRDF.V2.x = BRDFProbabilityDensityFunctionSH[SHBaseIndex + 8];

				float2 ProbeUV = (TexelCoord + float2(.5f, .5f)) / float(MipSize);
				float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);
				FThreeBandSHVector DirectionSH = SHBasisFunction3(WorldConeDirection);
				float PDF = max(DotSH3(BRDF, DirectionSH), 0);
#else
				uint PDFUpsampleFactor = MipSize / ScreenProbeBRDFOctahedronResolution;
				float PDF = BRDFProbabilityDensityFunction.Load(int3(ScreenProbeAtlasCoord * ScreenProbeBRDFOctahedronResolution + TexelCoord / PDFUpsampleFactor, 0));
#endif

#if IMPORTANCE_SAMPLE_LIGHTING
				float LightingPDF = LightingProbabilityDensityFunction.Load(int3(ScreenProbeAtlasCoord * MipSize + TexelCoord, 0));

				if (PDF > MinPDFToTrace)
				{
					float LightingPDFScale = LightingPDF * (MipSize * MipSize);
					PDF = max(PDF * LightingPDFScale, MinPDFToTrace);
				}
#endif
				RaysToRefine[TexelCoord.y * MipSize + TexelCoord.x] = PackRaySortInfo(TexelCoord, UniformLevel, PDF);
			}
		}

		GroupMemoryBarrierWithGroupSync();

		uint NumRaysToTrace = ScreenProbeTracingOctahedronResolution * ScreenProbeTracingOctahedronResolution;
		uint ThreadIndex = GroupThreadId.y * GENERATE_RAYS_THREADGROUP_SIZE + GroupThreadId.x;

		// Sort the rays by ascending PDF
		// O(N^2) simple parallel sort
		for (uint RayIndex = ThreadIndex; RayIndex < NumRaysToTrace; RayIndex += GENERATE_RAYS_NUM_TOTAL_THREADS)
		{
			uint2 RayTexelCoord;
			uint RayLevel;
			float SortKey;
			UnpackRaySortInfo(RaysToRefine[RayIndex], RayTexelCoord, RayLevel, SortKey);

			uint NumSmaller = 0;

			// Count how many items have a smaller key, so we can insert ourselves into the correct position, without requiring interaction between threads
			for (uint OtherRayIndex = 0; OtherRayIndex < NumRaysToTrace; OtherRayIndex++)
			{
				uint2 OtherRayTexelCoord;
				uint OtherRayLevel;
				float OtherSortKey;
				UnpackRaySortInfo(RaysToRefine[OtherRayIndex], OtherRayTexelCoord, OtherRayLevel, OtherSortKey);

				if (OtherSortKey < SortKey
					// Provide sort stability and resolve collisions based on unsorted array index
					|| OtherSortKey == SortKey && OtherRayIndex > RayIndex)
				{
					NumSmaller++;
				}
			}

			// Move this entry into it's sorted position
			RaysToRefineSorted[NumSmaller] = RaysToRefine[RayIndex];
		}

		NumRaysToSubdivide = 0;

		GroupMemoryBarrierWithGroupSync();

		if (UniformLevel > 0)
		{
			// For each 3 rays with PDF < threshold, refine matching high PDF ray

#define SUBDIVIDE_WITH_THREE_THREADS 1
#if SUBDIVIDE_WITH_THREE_THREADS
			uint MergeThreadIndex = ThreadIndex % 3;
			uint MergeIndex = ThreadIndex / 3;
			uint RayIndexToRefine = max((int)NumRaysToTrace - (int)MergeIndex - 1, 0);
			uint RayIndexToMerge2 = MergeIndex * 3 + 2;

			// Only continue for threads which have a valid matching ray to refine
			if (RayIndexToMerge2 < RayIndexToRefine)
			{
				uint2 RayTexelCoord2;
				uint RayLevel2;
				float PDF2;
				UnpackRaySortInfo(RaysToRefineSorted[RayIndexToMerge2], RayTexelCoord2, RayLevel2, PDF2);

				// Only continue if our thread is part of a packet of 3 which are all below the threshold to be traced
				if (PDF2 < MinPDFToTrace)
				{
					// Fetch the properties of the ray we will subdivide
					uint2 OriginalRayTexelCoord;
					uint OriginalRayLevel;
					float OriginalPDF;
					UnpackRaySortInfo(RaysToRefineSorted[RayIndexToRefine], OriginalRayTexelCoord, OriginalRayLevel, OriginalPDF);

					// Write INVALID_TRACING_COORD for this ray into RWStructuredImportanceSampledRayCoordForComposite so the composite knows not to lookup its trace lighting
					{
						uint2 RayTexelCoord;
						uint RayLevel;
						float PDF;
						UnpackRaySortInfo(RaysToRefineSorted[ThreadIndex], RayTexelCoord, RayLevel, PDF);

						#if GENERATE_RAYS_FOR_GATHER_COMPOSITE
							WriteRay(ScreenProbeAtlasCoord, uint2(INVALID_TRACING_COORD, INVALID_TRACING_COORD), RayTexelCoord, RayLevel);
						#endif
					}

					// Reassign this ray to the new subdivided texel
					RaysToRefineSorted[ThreadIndex] = PackRaySortInfo(OriginalRayTexelCoord * 2 + uint2((MergeThreadIndex + 1) % 2, (MergeThreadIndex + 1) / 2), OriginalRayLevel - 1, 0.0f);

					if (MergeThreadIndex == 0)
					{
						// Queue overwriting the ray we chose to subdivide after a group sync
						InterlockedAdd(NumRaysToSubdivide, 1);
					}
				}
			}

			GroupMemoryBarrierWithGroupSync();

			if (ThreadIndex < NumRaysToSubdivide)
			{
				uint RayIndexToSubdivide = NumRaysToTrace - ThreadIndex - 1;

				uint2 OriginalRayTexelCoord;
				uint OriginalRayLevel;
				float OriginalPDF;
				UnpackRaySortInfo(RaysToRefineSorted[RayIndexToSubdivide], OriginalRayTexelCoord, OriginalRayLevel, OriginalPDF);

				RaysToRefineSorted[RayIndexToSubdivide] = PackRaySortInfo(OriginalRayTexelCoord * 2, OriginalRayLevel - 1, 0.0f);
			}

#else
			// Subdivide with one thread 
			uint RayIndexToRefine = max((int)NumRaysToTrace - (int)ThreadIndex - 1, 0);
			uint RayIndexToMerge2 = ThreadIndex * 3 + 2;

			if (RayIndexToMerge2 < RayIndexToRefine)
			{
				uint2 RayTexelCoord2;
				uint RayLevel2;
				float PDF2;
				UnpackRaySortInfo(RaysToRefineSorted[RayIndexToMerge2], RayTexelCoord2, RayLevel2, PDF2);

				if (PDF2 < MinPDFToTrace)
				{
					uint RayIndexToMerge0 = ThreadIndex * 3 + 0;
					uint RayIndexToMerge1 = ThreadIndex * 3 + 1;

					uint2 RayTexelCoord0;
					uint RayLevel0;
					float PDF0;
					UnpackRaySortInfo(RaysToRefineSorted[RayIndexToMerge0], RayTexelCoord0, RayLevel0, PDF0);

					uint2 RayTexelCoord1;
					uint RayLevel1;
					float PDF1;
					UnpackRaySortInfo(RaysToRefineSorted[RayIndexToMerge1], RayTexelCoord1, RayLevel1, PDF1);


					WriteRay(ScreenProbeAtlasCoord, uint2(INVALID_TRACING_COORD, INVALID_TRACING_COORD), RayTexelCoord0, RayLevel0);
					WriteRay(ScreenProbeAtlasCoord, uint2(INVALID_TRACING_COORD, INVALID_TRACING_COORD), RayTexelCoord1, RayLevel1);
					WriteRay(ScreenProbeAtlasCoord, uint2(INVALID_TRACING_COORD, INVALID_TRACING_COORD), RayTexelCoord2, RayLevel2);

					uint2 OriginalRayTexelCoord;
					uint OriginalRayLevel;
					float OriginalPDF;
					UnpackRaySortInfo(RaysToRefineSorted[RayIndexToRefine], OriginalRayTexelCoord, OriginalRayLevel, OriginalPDF);
					RaysToRefineSorted[RayIndexToRefine] = PackRaySortInfo(OriginalRayTexelCoord * 2, OriginalRayLevel - 1, 0.0f);

					RaysToRefineSorted[RayIndexToMerge0] = PackRaySortInfo(OriginalRayTexelCoord * 2 + uint2(1, 0), OriginalRayLevel - 1, 0.0f);
					RaysToRefineSorted[RayIndexToMerge1] = PackRaySortInfo(OriginalRayTexelCoord * 2 + uint2(0, 1), OriginalRayLevel - 1, 0.0f);
					RaysToRefineSorted[RayIndexToMerge2] = PackRaySortInfo(OriginalRayTexelCoord * 2 + uint2(1, 1), OriginalRayLevel - 1, 0.0f);
				}
			}
#endif
		}

		GroupMemoryBarrierWithGroupSync();

		if (ThreadIndex < NumRaysToTrace)
		{
			uint2 RayTexelCoord;
			uint RayLevel;
			float RayPDF;
			UnpackRaySortInfo(RaysToRefineSorted[ThreadIndex], RayTexelCoord, RayLevel, RayPDF);

			uint2 RayCoord = uint2(ThreadIndex % ScreenProbeTracingOctahedronResolution, ThreadIndex / ScreenProbeTracingOctahedronResolution);
			WriteRay(ScreenProbeAtlasCoord, RayCoord, RayTexelCoord, RayLevel);
		}
#endif
	}
}
