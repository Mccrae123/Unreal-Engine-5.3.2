// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardCulling.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenCardCommon.ush"
#define CARD_BVH 0
#include "LumenTracingCommon.ush"
#include "../SceneTexturesCommon.ush"

uint3 CullGridSize;
float3 CardGridZParams;
uint MaxCulledCardsPerCell;
uint CardGridPixelSizeShift;

float ComputeCellNearViewDepthFromZSlice(uint ZSlice)
{
	float SliceDepth = (exp2(ZSlice / CardGridZParams.z) - CardGridZParams.y) / CardGridZParams.x;

	if (ZSlice == 0)
	{
		// The exponential distribution of z slices contains an offset, but some screen pixels
		// may be nearer to the camera than this offset. To avoid false card rejection, we set the
		// first depth slice to zero to ensure that the AABB includes the [0, offset] depth range.
		SliceDepth = 0.0f;
	}

	return SliceDepth;
}

void ComputeCellViewAABB(uint3 GridCoordinate, out float3 ViewTileMin, out float3 ViewTileMax)
{
	// Compute extent of tiles in clip-space. Note that the last tile may extend a bit outside of view if view size is not evenly divisible tile size.
	const float2 InvCulledGridSizeF = (1 << CardGridPixelSizeShift) * View.ViewSizeAndInvSize.zw;
	const float2 TileSize = float2(2.0f, -2.0f) * InvCulledGridSizeF.xy;
	const float2 UnitPlaneMin = float2(-1.0f, 1.0f);

	float2 UnitPlaneTileMin = GridCoordinate.xy * TileSize + UnitPlaneMin;
	float2 UnitPlaneTileMax = (GridCoordinate.xy + 1) * TileSize + UnitPlaneMin;

	float MinTileZ = ComputeCellNearViewDepthFromZSlice(GridCoordinate.z);
	float MaxTileZ = ComputeCellNearViewDepthFromZSlice(GridCoordinate.z + 1);

	float MinTileDeviceZ = ConvertToDeviceZ(MinTileZ);
	float4 MinDepthCorner0 = mul(float4(UnitPlaneTileMin.x, UnitPlaneTileMin.y, MinTileDeviceZ, 1), View.ClipToView);
	float4 MinDepthCorner1 = mul(float4(UnitPlaneTileMax.x, UnitPlaneTileMax.y, MinTileDeviceZ, 1), View.ClipToView);
	float4 MinDepthCorner2 = mul(float4(UnitPlaneTileMin.x, UnitPlaneTileMax.y, MinTileDeviceZ, 1), View.ClipToView);
	float4 MinDepthCorner3 = mul(float4(UnitPlaneTileMax.x, UnitPlaneTileMin.y, MinTileDeviceZ, 1), View.ClipToView);

	float MaxTileDeviceZ = ConvertToDeviceZ(MaxTileZ);
	float4 MaxDepthCorner0 = mul(float4(UnitPlaneTileMin.x, UnitPlaneTileMin.y, MaxTileDeviceZ, 1), View.ClipToView);
	float4 MaxDepthCorner1 = mul(float4(UnitPlaneTileMax.x, UnitPlaneTileMax.y, MaxTileDeviceZ, 1), View.ClipToView);
	float4 MaxDepthCorner2 = mul(float4(UnitPlaneTileMin.x, UnitPlaneTileMax.y, MaxTileDeviceZ, 1), View.ClipToView);
	float4 MaxDepthCorner3 = mul(float4(UnitPlaneTileMax.x, UnitPlaneTileMin.y, MaxTileDeviceZ, 1), View.ClipToView);

	float2 ViewMinDepthCorner0 = MinDepthCorner0.xy / MinDepthCorner0.w;
	float2 ViewMinDepthCorner1 = MinDepthCorner1.xy / MinDepthCorner1.w;
	float2 ViewMinDepthCorner2 = MinDepthCorner2.xy / MinDepthCorner2.w;
	float2 ViewMinDepthCorner3 = MinDepthCorner3.xy / MinDepthCorner3.w;
	float2 ViewMaxDepthCorner0 = MaxDepthCorner0.xy / MaxDepthCorner0.w;
	float2 ViewMaxDepthCorner1 = MaxDepthCorner1.xy / MaxDepthCorner1.w;
	float2 ViewMaxDepthCorner2 = MaxDepthCorner2.xy / MaxDepthCorner2.w;
	float2 ViewMaxDepthCorner3 = MaxDepthCorner3.xy / MaxDepthCorner3.w;

	//@todo - derive min and max from quadrant
	ViewTileMin.xy = min(ViewMinDepthCorner0, ViewMinDepthCorner1);
	ViewTileMin.xy = min(ViewTileMin.xy, ViewMinDepthCorner2);
	ViewTileMin.xy = min(ViewTileMin.xy, ViewMinDepthCorner3);
	ViewTileMin.xy = min(ViewTileMin.xy, ViewMaxDepthCorner0);
	ViewTileMin.xy = min(ViewTileMin.xy, ViewMaxDepthCorner1);
	ViewTileMin.xy = min(ViewTileMin.xy, ViewMaxDepthCorner2);
	ViewTileMin.xy = min(ViewTileMin.xy, ViewMaxDepthCorner3);

	ViewTileMax.xy = max(ViewMinDepthCorner0, ViewMinDepthCorner1);
	ViewTileMax.xy = max(ViewTileMax.xy, ViewMinDepthCorner2);
	ViewTileMax.xy = max(ViewTileMax.xy, ViewMinDepthCorner3);
	ViewTileMax.xy = max(ViewTileMax.xy, ViewMaxDepthCorner0);
	ViewTileMax.xy = max(ViewTileMax.xy, ViewMaxDepthCorner1);
	ViewTileMax.xy = max(ViewTileMax.xy, ViewMaxDepthCorner2);
	ViewTileMax.xy = max(ViewTileMax.xy, ViewMaxDepthCorner3);

	ViewTileMin.z = MinTileZ;
	ViewTileMax.z = MaxTileZ; 
}

bool DoesCardIntersectFroxel(FLumenCardData CardData, uint3 GridCoordinate, float3 ViewTileCenter, float3 ViewTileExtent, float CardTraceEndDistance)
{
	float CardRadius = length(CardData.LocalExtent);
	float3 ViewSpaceCardPosition = mul(float4(CardData.Origin.xyz + View.PreViewTranslation.xyz, 1), View.TranslatedWorldToView).xyz;
	float BoxDistance = sqrt(ComputeSquaredDistanceFromBoxToPoint(ViewTileCenter, ViewTileExtent, ViewSpaceCardPosition));

	bool bIntersects = BoxDistance < CardRadius + CardTraceEndDistance && CardData.bVisible;

#define INTERSECT_OBB 1
#if INTERSECT_OBB

	if (bIntersects)
	{
		const float2 InvCulledGridSizeF = (1 << CardGridPixelSizeShift) * View.ViewSizeAndInvSize.zw;
		const float2 TileSize = float2(2.0f, -2.0f) * InvCulledGridSizeF.xy;
		const float2 UnitPlaneMin = float2(-1.0f, 1.0f);

		float3 MinCardProjections = 100000.0f;
		float3 MaxCardProjections = -100000.0f;
		float3 MinFroxelProjections = 100000.0f;
		float3 MaxFroxelProjections = -100000.0f;

		for (uint z = 0; z < 2; z++)
		{
			float TileZ = ComputeCellNearViewDepthFromZSlice(GridCoordinate.z + z);
			float TileDeviceZ = ConvertToDeviceZ(TileZ);

			for (uint y = 0; y < 2; y++)
			{
				for (uint x = 0; x < 2; x++)
				{
					float3 VertexSigns = float3(x == 0 ? -1 : 1, y == 0 ? -1 : 1, z == 0 ? -1 : 1);
					float3 WorldSpaceVertex = CardData.Origin + mul(CardData.WorldToLocalRotation, VertexSigns * CardData.LocalExtent);
					float3 ViewSpaceVertex = mul(float4(WorldSpaceVertex + View.PreViewTranslation.xyz, 1), View.TranslatedWorldToView).xyz;

					// Project OBB verts onto axes of view space AABB of froxel
					MinCardProjections = min(MinCardProjections, ViewSpaceVertex - ViewTileCenter);
					MaxCardProjections = max(MaxCardProjections, ViewSpaceVertex - ViewTileCenter);

					float2 UnitPlaneTileXY = (GridCoordinate.xy + float2(x, y)) * TileSize + UnitPlaneMin;
					float4 ProjectedVertex = mul(float4(UnitPlaneTileXY, TileDeviceZ, 1), View.ClipToWorld);
					float3 WorldSpaceFroxelVertex = ProjectedVertex.xyz / ProjectedVertex.w;
					float3 CardSpaceFroxelVertex = mul(WorldSpaceFroxelVertex - CardData.Origin, CardData.WorldToLocalRotation);

					// Project froxel onto OBB axes
					MinFroxelProjections = min(MinFroxelProjections, CardSpaceFroxelVertex);
					MaxFroxelProjections = max(MaxFroxelProjections, CardSpaceFroxelVertex);
				}
			}
		}

		float3 ExpandedViewTileExtent = ViewTileExtent + CardTraceEndDistance;
		float3 MaxCardInfluenceLocalExtent = CardData.LocalExtent + CardTraceEndDistance;
		// Traces from behind the card do not see it, don't extend the influence in that direction
		float3 MinCardInfluenceLocalExtent = -CardData.LocalExtent - float3(CardTraceEndDistance.xx, 0);

		if (any(MaxCardProjections < -ExpandedViewTileExtent) || any(MinCardProjections > ExpandedViewTileExtent)
			|| any(MaxFroxelProjections < MinCardInfluenceLocalExtent) || any(MinFroxelProjections > MaxCardInfluenceLocalExtent))
		{
			bIntersects = false;
		}
	}

#endif

	return bIntersects;
}

RWBuffer<uint> RWCulledCardGridHeader;
RWBuffer<uint> RWCulledCardGridData;

float TanConeAngle;
float MinTraceDistance;
float MaxTraceDistance;
float MaxCardTraceDistance;
float CardTraceEndDistanceFromCamera; 

bool BVHCullingNodeTest(FLumenCardBVHNodeData BVHNode, uint3 CullGridPos)
{
	float3 ViewTileMin;
	float3 ViewTileMax;
	ComputeCellViewAABB(CullGridPos, ViewTileMin, ViewTileMax);

	float3 ViewTileCenter = .5f * (ViewTileMin + ViewTileMax);
	float3 ViewTileExtent = ViewTileMax - ViewTileCenter;
	float3 WorldTileCenter = mul(float4(ViewTileCenter, 1), View.ViewToTranslatedWorld).xyz - View.PreViewTranslation;
	float4 WorldTileBoundingSphere = float4(WorldTileCenter, length(ViewTileExtent));

	float DistanceSq = ComputeSquaredDistanceBetweenAABBs(BVHNode.BBoxCenter, BVHNode.BBoxExtent, WorldTileBoundingSphere.xyz, WorldTileBoundingSphere.www);
	if (DistanceSq < MaxCardTraceDistance * MaxCardTraceDistance)
	{
		if (BVHNode.LumenCardId != INVALID_PROXY_CARD_ID)
		{
			FLumenCardData CardData = GetLumenCardData(BVHNode.LumenCardId);
			return DoesCardIntersectFroxel(CardData, CullGridPos, ViewTileCenter, ViewTileExtent, MaxCardTraceDistance);
		}

		return true;
	}

	return false;
}
#include "LumenCardBVHCulling.ush"

uint ComputeCardGridCellIndex(uint2 PixelPos, float SceneDepth)
{
	uint ZSlice = (uint)(max(0, log2(SceneDepth * CardGridZParams.x + CardGridZParams.y) * CardGridZParams.z));
	ZSlice = min(ZSlice, (uint)(CullGridSize.z - 1));
	uint3 GridCoordinate = uint3(PixelPos >> CardGridPixelSizeShift, ZSlice);
	uint GridIndex = (GridCoordinate.z * CullGridSize.y + GridCoordinate.y) * CullGridSize.x + GridCoordinate.x;
	return GridIndex;
}

bool DoesCardAffectPoint(uint CardIndex, float3 WorldPosition, float CardTraceEndDistance)
{
	FLumenCardData CardData = GetLumenCardData(CardIndex);
	
	float3 CardSpacePosition = mul(WorldPosition - CardData.Origin, CardData.WorldToLocalRotation);
	float DistanceSq = ComputeSquaredDistanceFromBoxToPoint(0, CardData.LocalExtent, CardSpacePosition);

	return (DistanceSq < CardTraceEndDistance * CardTraceEndDistance) && CardData.bVisible;
	/*
	if (DistanceSq < CardTraceEndDistance * CardTraceEndDistance)
	{
		float3 LocalPosition = mul(WorldPosition - CardData.Origin, CardData.WorldToLocalRotation);
		LocalPosition.xy = clamp(LocalPosition.xy, -CardData.LocalExtent.xy, CardData.LocalExtent.xy);

		float MipIndex = 0;
		float2 DepthValidRegionScale = CalculateValidRegionScale(MipIndex, CardData.CardUVToAtlasScale);
		float2 DepthUV = CalculateAtlasUV(LocalPosition.xy, DepthValidRegionScale, CardData);
		float Depth = Texture2DSampleLevel(DilatedDepthAtlas, GlobalBilinearClampedSampler, DepthUV, MipIndex).x;
		float FrontHeightfieldZ = CardData.LocalExtent.z - Depth * 2 * CardData.LocalExtent.z;

		return LocalPosition.z < FrontHeightfieldZ + CardTraceEndDistance && (LocalPosition.z > FrontHeightfieldZ || CardData.bTwoSided);
	}

	return false;*/
}

Texture2D DownsampledDepth;
uint2 DownsampledViewSize;
float DownsampleFactor; 
Buffer<uint> CulledCardGridHeader;
RWBuffer<uint> RWUsedCardData;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CardGridMarkUsedByGBufferCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenCoord = DispatchThreadId.xy;

	if (all(ScreenCoord < DownsampledViewSize))
	{
		float SceneDepth = DownsampledDepth.Load(int3(ScreenCoord, 0)).x;
		if (SceneDepth < CardTraceEndDistanceFromCamera)
		{
			float2 ScreenUV = float2((ScreenCoord * DownsampleFactor + View.ViewRectMin.xy + .5f) * View.BufferSizeAndInvSize.zw);
			float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
			float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;

			uint CardGridCellIndex = ComputeCardGridCellIndex(ScreenCoord * DownsampleFactor, SceneDepth);

			uint NumOverlappingCards = CulledCardGridHeader[CardGridCellIndex * CULLED_CARD_GRID_HEADER_STRIDE + 0];
			uint OverlappingCardsStartIndex = CulledCardGridHeader[CardGridCellIndex * CULLED_CARD_GRID_HEADER_STRIDE + 1];

			for (uint ListIndex = 0; ListIndex < NumOverlappingCards; ListIndex++)
			{
				uint CardIndex = CulledCardGridData[OverlappingCardsStartIndex + ListIndex];

				if (DoesCardAffectPoint(CardIndex, WorldPosition, MaxCardTraceDistance))
				{
					RWUsedCardData[OverlappingCardsStartIndex + ListIndex] = 1;
				}
			}
		}
	}
}

Buffer<uint> UsedCardData;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void CardGridCompactUsedByGBufferCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 GridCoordinate = DispatchThreadId;

	if (all(GridCoordinate < CullGridSize))
	{  
		uint GridIndex = (GridCoordinate.z * CullGridSize.y + GridCoordinate.y) * CullGridSize.x + GridCoordinate.x;

		uint NumOverlappingCards = RWCulledCardGridHeader[GridIndex * CULLED_CARD_GRID_HEADER_STRIDE + 0];
		uint OverlappingCardsStartIndex = RWCulledCardGridHeader[GridIndex * CULLED_CARD_GRID_HEADER_STRIDE + 1];
		uint NumUsedCards = 0;

		for (uint ListIndex = 0; ListIndex < NumOverlappingCards; ListIndex++)
		{
			uint CardReadIndex = OverlappingCardsStartIndex + ListIndex;

			if (UsedCardData[CardReadIndex] > 0)
			{
				uint CardIndex = RWCulledCardGridData[OverlappingCardsStartIndex + ListIndex];
				RWCulledCardGridData[OverlappingCardsStartIndex + NumUsedCards] = CardIndex;
				NumUsedCards++;
			}
		}

		RWCulledCardGridHeader[GridIndex * CULLED_CARD_GRID_HEADER_STRIDE + 0] = NumUsedCards;
	}
}