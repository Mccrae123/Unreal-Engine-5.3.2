// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardSceneLighting.usf
=============================================================================*/

#include "../Common.ush"
#include "../BRDF.ush"
#include "LumenCardCommon.ush"
#include "LumenCardUpdate.ush"
#include "LumenCardTile.ush"

RWStructuredBuffer<uint> RWQuadAllocator;
RWStructuredBuffer<uint> RWQuadData;

float4 InfluenceSphere;
float3 LightPosition;
float3 LightDirection;
float LightRadius;
float CosConeAngle;
float SinConeAngle;

void GetCardAABB(FLumenCardData LumenCardData, out float3 WorldCardCenter, out float3 WorldCardExtent)
{
	WorldCardCenter = LumenCardData.Origin;
	WorldCardExtent = mul(abs(LumenCardData.WorldToLocalRotation), LumenCardData.LocalExtent);
}

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 0
#endif

#ifndef SHAPE_TYPE
#define SHAPE_TYPE 0
#endif

uint MaxQuadsPerScatterInstance;
uint MaxCardTilesPerScatterInstance;
uint CardScatterInstanceIndex;

// Resources for LumenCardUpdate
uint NumCardPagesToRenderIndices;
Buffer<uint> CardPagesToRenderIndices;
Buffer<uint> CardPagesToRenderHashMap;

uint FrameId;
float CardLightingUpdateFrequencyScale;
uint CardLightingUpdateMinFrequency;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void CullCardPagesToShapeCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint IndexInIndexBuffer = DispatchThreadId.x;

#if OPERATE_ON_CARD_TILES_MODE != OPERATE_ON_EMPTY_LIST
#if OPERATE_ON_CARD_TILES_MODE == OPERATE_ON_CARD_TILES_TO_RENDER
	if (IndexInIndexBuffer < NumCardPagesToRenderIndices)
	{
		uint CardPageIndex = CardPagesToRenderIndices[IndexInIndexBuffer];
#else
	if (IndexInIndexBuffer < LumenCardScene.NumCardPages)
	{
		uint CardPageIndex = IndexInIndexBuffer;
#endif
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLightCullingParameters LightCullingParameters = CreateLightCullingParameters(
				InfluenceSphere, LightPosition, LightDirection, LightRadius, CosConeAngle, SinConeAngle);

			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			FLumenCardUpdateResources CardUpdateResources = CreateLumenCardUpdateResources(
				NumCardPagesToRenderIndices, CardPagesToRenderIndices, CardPagesToRenderHashMap);

			FLumenCardUpdateOptions CardUpdateOptions = CreateLumenCardUpdateOptions(
				CardLightingUpdateMinFrequency, CardLightingUpdateFrequencyScale, FrameId);

			if (Card.bVisible
				&& DoesLightAffectCardPage(SHAPE_TYPE, LightCullingParameters, CardPage, Card)
				&& ShouldUpdateCardPage(CardPageIndex, Card, CardUpdateResources, CardUpdateOptions))
			{
				uint QuadDataInsertIndex;
				InterlockedAdd(RWQuadAllocator[CardScatterInstanceIndex], 1, QuadDataInsertIndex);

				if (QuadDataInsertIndex < MaxQuadsPerScatterInstance)
				{
					RWQuadData[CardScatterInstanceIndex * MaxQuadsPerScatterInstance + QuadDataInsertIndex] = CardPageIndex;
				}
			}
		}
	}
#endif
}

StructuredBuffer<uint> QuadAllocator;
StructuredBuffer<uint> QuadData;
RWStructuredBuffer<uint> RWCardTileAllocator;
RWStructuredBuffer<uint> RWCardTileData;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void BuildCardTilesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint QuadIndex = GroupId.x;
	uint2 TileInQuadBaseCoord = 2 * GroupThreadId.xy;
	uint NumQuads = QuadAllocator[CardScatterInstanceIndex];

	if (QuadIndex < NumQuads)
	{
		uint CardPageIndex = QuadData[CardScatterInstanceIndex * MaxQuadsPerScatterInstance + QuadIndex];

		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			FLightCullingParameters LightCullingParameters = CreateLightCullingParameters(
				InfluenceSphere, LightPosition, LightDirection, LightRadius, CosConeAngle, SinConeAngle);

			const uint2 SizeInTiles = CardPage.SizeInTexels / CARD_TILE_SIZE;

			for (uint TileCoordOffsetY = 0; TileCoordOffsetY < 2; ++TileCoordOffsetY)
			{
				for (uint TileCoordOffsetX = 0; TileCoordOffsetX < 2; ++TileCoordOffsetX)
				{
					const uint TileCoordX = TileCoordOffsetX + TileInQuadBaseCoord.x;
					const uint TileCoordY = TileCoordOffsetY + TileInQuadBaseCoord.y;

					if (TileCoordX < SizeInTiles.x && TileCoordY < SizeInTiles.y)
					{
						FCardTileData CardTile;
						CardTile.CardPageIndex = CardPageIndex;
						CardTile.TileCoord.x = TileCoordX;
						CardTile.TileCoord.y = TileCoordY;

						float2 UVMin = float2(CardTile.TileCoord) / SizeInTiles;
						float2 UVMax = float2(CardTile.TileCoord + 1) / SizeInTiles;

						float SwapY = UVMin.y;
						UVMin.y = 1.0f - UVMax.y;
						UVMax.y = 1.0f - SwapY;

						bool bLightAffectsCard = DoesLightAffectCardPageUVRange(SHAPE_TYPE, LightCullingParameters, CardPage, Card, UVMin, UVMax);
						if (bLightAffectsCard)
						{
							uint NextTileOffset = 0;
							InterlockedAdd(RWCardTileAllocator[CardScatterInstanceIndex], 1, NextTileOffset);

							if (NextTileOffset < MaxCardTilesPerScatterInstance)
							{
								RWCardTileData[CardScatterInstanceIndex * MaxCardTilesPerScatterInstance + NextTileOffset] = PackCardTileData(CardTile);
							}
						}
					}
				}
			}
		}
	}
}

RWBuffer<uint> RWDrawCardPagesIndirectArgs;
RWBuffer<uint> RWBuildTilesIndirectArgs;

uint MaxScatterInstanceCount;
uint VertexCountPerInstanceIndirect;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void InitializeCardPageIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ScatterInstanceIndex = DispatchThreadId.x;

	if (ScatterInstanceIndex < MaxScatterInstanceCount)
	{
		uint NumQuads = QuadAllocator[ScatterInstanceIndex];

		// FRHIDrawIndirectParameters
		uint ArgOffset = 4 * ScatterInstanceIndex;
		RWDrawCardPagesIndirectArgs[ArgOffset + 0] = VertexCountPerInstanceIndirect;
		RWDrawCardPagesIndirectArgs[ArgOffset + 1] = NumQuads;
		RWDrawCardPagesIndirectArgs[ArgOffset + 2] = 0;
		RWDrawCardPagesIndirectArgs[ArgOffset + 3] = 0;

		// FRHIDispatchIndirectParameters
		ArgOffset = 3 * ScatterInstanceIndex;
		RWBuildTilesIndirectArgs[ArgOffset + 0] = NumQuads;
		RWBuildTilesIndirectArgs[ArgOffset + 1] = 1;
		RWBuildTilesIndirectArgs[ArgOffset + 2] = 1;
	}
}

RWBuffer<uint> RWDrawCardTilesIndirectArgs;
RWBuffer<uint> RWDispatchCardTilesIndirectArgs;

StructuredBuffer<uint> CardTileAllocator;
StructuredBuffer<uint> CardTileData;

Buffer<uint4> RectMinMaxBuffer;
float2 InvRectMinMaxResolution;
float2 IndirectLightingAtlasSize;

void RasterizeToCardsVS(
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	float2 TexCoord = float2(0.0f, 0.0f);
	TexCoord.x += VertexId == 1 || VertexId == 2 || VertexId == 4 ? 1.0f : 0.0f;
	TexCoord.y += VertexId == 2 || VertexId == 4 || VertexId == 5 ? 1.0f : 0.0f;

	uint QuadIndex = InstanceId.x;
	uint NumQuads = QuadAllocator[CardScatterInstanceIndex];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (QuadIndex < NumQuads)
	{
		uint CardPageIndex = QuadData[CardScatterInstanceIndex * MaxQuadsPerScatterInstance + QuadIndex];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

		#if CLAMP_TO_INFLUENCE_SPHERE
		{
			float3 LocalSphereOrigin = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);

			float2 InvCardPageUVSize = 1.0f / (CardPage.CardUVRect.zw - CardPage.CardUVRect.xy);

			float2 SphereOriginCardUV = SamplePositonToCardUV(Card, LocalSphereOrigin.xy);
			float2 SphereOriginCardPageUV = (SphereOriginCardUV - CardPage.CardUVRect.xy) * InvCardPageUVSize;

			float2 SphereRadius = 0.5f * (InfluenceSphere.ww / Card.LocalExtent.xy) * InvCardPageUVSize;

			TexCoord = clamp(TexCoord, SphereOriginCardPageUV - SphereRadius, SphereOriginCardPageUV + SphereRadius);
		}
		#endif

		float2 ScreenUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, TexCoord);
		float2 AtlasUV = ScreenUV;

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[CardPageIndex].xyzw * InvRectMinMaxResolution.xyxy;
			AtlasUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[QuadIndex].xyzw * InvRectMinMaxResolution.xyxy;
			ScreenUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		// When sampling from a downsampled Indirect Lighting atlas we need to appropriately clamp input UVs to prevent bilinear reading outside of the valid area
		float2 CardWidthInTexels = (CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy) * IndirectLightingAtlasSize;
		float2 ClampBorder = 0.5f / CardWidthInTexels;
		float2 IndirectLightingTexCoord = clamp(TexCoord, ClampBorder, 1.0f - ClampBorder);
		float2 IndirectLightingAtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, IndirectLightingTexCoord);

		float2 ScreenPosition = float2(2.0f, -2.0f) * ScreenUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		float2 QuadCorner = -2.0f * TexCoord + 1.0f;
		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.IndirectLightingAtlasUV = IndirectLightingAtlasUV;
		CardInterpolants.CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, TexCoord);
		CardInterpolants.CardTileIndex = 0;
		CardInterpolants.CardPageIndex = CardPageIndex;
	}
}

void RasterizeToCardTilesVS(
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	float2 TexCoord = float2(0.0f, 0.0f);
	TexCoord.x += VertexId == 1 || VertexId == 2 || VertexId == 4 ? 1.0f : 0.0f;
	TexCoord.y += VertexId == 2 || VertexId == 4 || VertexId == 5 ? 1.0f : 0.0f;

	uint CardTileIndex = InstanceId.x;
	uint NumCardTiles = CardTileAllocator[CardScatterInstanceIndex];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (CardTileIndex < NumCardTiles)
	{
		FCardTileData CardTile = UnpackCardTileData(CardTileData[CardScatterInstanceIndex * MaxCardTilesPerScatterInstance + CardTileIndex]);
		FLumenCardPageData CardPage = GetLumenCardPageData(CardTile.CardPageIndex);

		float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale * CARD_TILE_SIZE * (CardTile.TileCoord + TexCoord);
		float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale * CARD_TILE_SIZE * (CardTile.TileCoord + TexCoord);

		float2 ScreenPosition = float2(2.0f, -2.0f) * AtlasUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.IndirectLightingAtlasUV = float2(0.0f, 0.0f);
		CardInterpolants.CardUV = CardUV;
		CardInterpolants.CardTileIndex = CardTileIndex;
		CardInterpolants.CardPageIndex = CardTile.CardPageIndex;
	}
}

Texture2D AlbedoAtlas;
Texture2D EmissiveAtlas;
Texture2D DirectLightingAtlas;
Texture2D IndirectLightingAtlas;
Texture2D OpacityAtlas;

float DiffuseReflectivityOverride;

void CombineLumenSceneLighting(
	FCardVSToPS CardInterpolants,
	out float4 OutFinalLighting : SV_Target0)
{
	float3 Albedo = DecodeSurfaceCacheAlbedo(Texture2DSampleLevel(AlbedoAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz);
	float3 Emissive = Texture2DSampleLevel(EmissiveAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	float3 DirectLighting = Texture2DSampleLevel(DirectLightingAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	float3 IndirectLighting = Texture2DSampleLevel(IndirectLightingAtlas, GlobalBilinearClampedSampler, CardInterpolants.IndirectLightingAtlasUV, 0).xyz;

	if (DiffuseReflectivityOverride > 0.0f)
	{
		float AlbedoMaxComponent = max(Albedo.x, max(Albedo.y, Albedo.z));
		Albedo = saturate(Albedo * max(AlbedoMaxComponent / max(AlbedoMaxComponent, .0001f), 1.0f));
	}

	float3 FinalLighting = (DirectLighting + IndirectLighting) * Diffuse_Lambert(Albedo) + Emissive;

	// Secure again strange values, as we are writing it to a persistent atlas with a feedback loop
	FinalLighting = max(MakeFinite(FinalLighting), float3(0.0f, 0.0f, 0.0f));

	OutFinalLighting = float4(FinalLighting, 0);
}

void ClearLumenCardsPS(
	out float4 OutTarget : SV_Target)
{
	OutTarget = float4(0.0f, 0.0f, 0.0f, 0.0f);
}

void ClearLumenCardCapturePS(
	out float4 OutAlbedo : SV_Target0,
	out float4 OutNormals : SV_Target1,
	out float4 OutEmissive : SV_Target2
)
{
	OutAlbedo = float4(0.0f, 0.0f, 0.0f, 0.0f);
	OutNormals = float4(0.5f, 0.5f, 0.0f, 0.0f);
	OutEmissive = float4(0.0f, 0.0f, 0.0f, 0.0f);
}
