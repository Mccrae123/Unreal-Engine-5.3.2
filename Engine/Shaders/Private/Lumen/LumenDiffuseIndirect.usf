// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenDiffuseIndirect.usf
=============================================================================*/

#ifndef PROBE_HIERARCHY_ID
#define PROBE_HIERARCHY_ID 0
#endif

#include "../Common.ush"
#include "LumenCardCommon.ush"
#define CARD_BVH 0
#if CULLED_CARDS_GRID
	#define CARD_CULLED_LIST 1
#else
	#define CARD_CULLED_LIST 0
#endif
// Depth weighted OIT doesn't cover enough depth range for ConeTraceLumenDistantScene
// This has the side effect that card tracing for detail traces in this file don't get blended
#define CARD_TRACE_DEPTH_WEIGHTED_OIT 0
#define VOXEL_TRACE_BLEND_BETWEEN_AXES 1
#include "LumenTracingCommon.ush"
#include "LumenBufferEncoding.ush"
#include "ProbeHierarchy/LumenProbeTracing.ush"
#include "LumenRadianceCacheCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "../MonteCarlo.ush"
#include "../HybridIndirectLighting.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 0
#endif

RWTexture2D<float4> RWDiffuseIndirect0;
RWTexture2D<UNORM float4> RWDiffuseIndirect1;
#define DownsampleFactor DownscaleFactor // TODO(Guillaume)
float StepFactor;
float VoxelStepFactor;
float CardTraceEndDistanceFromCamera; 
float SampleWeight;
float DiffuseConeHalfAngle;
float TanDiffuseConeHalfAngle;
float MinSampleRadius;
float MinTraceDistance;
float MaxTraceDistance;
float MaxCardTraceDistance;
float SurfaceBias;
float CardInterpolateInfluenceRadius;
static const uint SampleTileSize = INDIRECT_LIGHTING_INTERLEAVING_TILE_SIZE;
static const uint SampleTileBitMask = INDIRECT_LIGHTING_INTERLEAVING_TILE_SIZE * INDIRECT_LIGHTING_INTERLEAVING_TILE_SIZE - 1;

Buffer<uint> CulledCardGridHeader;
uint CardGridPixelSizeShift;
float3 CardGridZParams;
uint3 CullGridSize;

uint ComputeCardGridCellIndex(uint2 PixelPos, float SceneDepth)
{
	uint ZSlice = (uint)(max(0, log2(SceneDepth * CardGridZParams.x + CardGridZParams.y) * CardGridZParams.z));
	ZSlice = min(ZSlice, (uint)(CullGridSize.z - 1));
	uint3 GridCoordinate = uint3(PixelPos >> CardGridPixelSizeShift, ZSlice);
	uint GridIndex = (GridCoordinate.z * CullGridSize.y + GridCoordinate.y) * CullGridSize.x + GridCoordinate.x;
	return GridIndex;
}

struct FDiffuseGatherLighting
{
#if LUMEN_DIFFUSE_DIRECTIONAL_ENCODING
	FTwoBandSHVectorRGB SH;

	void Initialize()
	{
		SH.R = (FTwoBandSHVector)0;
		SH.G = (FTwoBandSHVector)0;
		SH.B = (FTwoBandSHVector)0;
	}

	void AddLighting(float3 WorldDirection, float3 Normal, float3 Lighting)
	{
		SH = AddSH(MulSH(SHBasisFunction(WorldDirection), Lighting), SH);
	}

	void Multiply(float Multiplier)
	{
		SH.R = MulSH(SH.R, Multiplier);
		SH.G = MulSH(SH.G, Multiplier);
		SH.B = MulSH(SH.B, Multiplier);
	}

	void AddGatheredLighting(FDiffuseGatherLighting OtherLighting)
	{
		SH = AddSH(OtherLighting.SH, SH);
	}

	void Encode(out float4 Vector0, out float4 Vector1)
	{
		EncodeLumenDiffuseLighting(SH, /* out */ Vector0, /* out */ Vector1);
	}

	void Decode(float4 Vector0, float4 Vector1)
	{
		DecodeLumenDiffuseLighting(Vector0, Vector1, /* out */ SH);
	}

#else
	float3 LightingAlongNormal;

	void Initialize()
	{
		LightingAlongNormal = 0;
	}

	void AddLighting(float3 WorldDirection, float3 Normal, float3 InLighting)
	{
		LightingAlongNormal += saturate(dot(WorldDirection, Normal)) * InLighting;
	}

	void Multiply(float Multiplier)
	{
		LightingAlongNormal *= Multiplier;
	}

	void AddGatheredLighting(FDiffuseGatherLighting OtherLighting)
	{
		LightingAlongNormal += OtherLighting.LightingAlongNormal;
	}

	void Encode(out float4 Vector0, out float4 Vector1)
	{
		Vector0 = 0;
		Vector0.rgb = LightingAlongNormal;
		Vector1 = 0;
	}

	void Decode(float4 Vector0, float4 Vector1)
	{
		LightingAlongNormal = Vector0.xyz;
	}
#endif
};

uint2 SourceViewMax;

void DownsampleDepthAndNormalPS(
	float4 SVPosition : SV_POSITION,
	out float OutDownsampledDepth : SV_Target0,
	out float4 OutDownsampledNormal : SV_Target1)
{
	int2 ScreenPos = SVPosition.xy;
	int2 SourcePos = ScreenPos * DownsampleFactor;

	float SceneDepth = ConvertFromDeviceZ(SceneTexturesStruct.SceneDepthTexture.Load(int3(SourcePos, 0)).x);
	float3 SceneNormal = DecodeNormal(SceneTexturesStruct.GBufferATexture.Load(int3(SourcePos, 0)).xyz);

#if DOWNSAMPLE_FILTER
	// Blur normal.
	const float3x3 GaussianWeights = 
	{
		{ 0.077847, 0.123317, 0.077847 },
		{ 0.123317, 0.195346, 0.123317 },
		{ 0.077847, 0.123317, 0.077847 },
	};

	float TotalWeight = 0.0f;
	float3 TotalNormal = float3(0.0f, 0.0f, 0.0f);
	UNROLL
	for (int y = -1; y <= 1; ++y)
	{
		UNROLL
		for (int x = -1; x <= 1; ++x)
		{
			int3 SamplePos = int3(SourcePos + int2(x, y), 0);
			SamplePos.xy = max(SamplePos.xy, int2(0, 0));
			SamplePos.xy = min(SamplePos.xy, (int2)SourceViewMax);

			float SampleDepth = ConvertFromDeviceZ(SceneTexturesStruct.SceneDepthTexture.Load(SamplePos).x);
			float DepthWeight = exp2(-1000.0 * abs(SceneDepth - SampleDepth) / SceneDepth);
			float SampleWeight = DepthWeight * GaussianWeights[x + 1][y + 1];
			float3 SampleNormal = DecodeNormal(SceneTexturesStruct.GBufferATexture.Load(SamplePos).xyz);

			TotalNormal += SampleNormal * SampleWeight;
			TotalWeight += SampleWeight;
		}
	}

	SceneNormal = normalize(TotalNormal / TotalWeight);
#endif

	OutDownsampledDepth = SceneDepth;
	OutDownsampledNormal = float4(EncodeNormal(SceneNormal), 1.0f);
}

#define DIFFUSE_DEBUG_PASSTHROUGH 0

#define DownsampledViewSize TracingViewportSize // TODO(Guillaume): bulk renaming
Texture2D DownsampledDepth;
Texture2D DownsampledNormal;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void DiffuseIndirectTraceCardsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenCoord;
	float3 Debug = float3(0, 0, 0);

	#undef DEINTERLEAVED_TRACING
	#define DEINTERLEAVED_TRACING 0
	#if DEINTERLEAVED_TRACING
		// Compute viewport size split into SampleTileSize pieces
		uint2 InterleavedSampleSetSize = (DownsampledViewSize + SampleTileSize - 1) / (SampleTileSize);
		uint2 InterleavedCoord = DispatchThreadId.xy;
		ScreenCoord = (DispatchThreadId.xy % InterleavedSampleSetSize) * SampleTileSize + DispatchThreadId.xy / InterleavedSampleSetSize;
	#else
		ScreenCoord = DispatchThreadId.xy;
	#endif

	if (all(ScreenCoord < DownsampledViewSize))
	{
		float2 ScreenUV = TracingPixelCoordToSceneBufferUV(ScreenCoord);
		const float SceneDepth = DownsampledDepth.Load(int3(ScreenCoord, 0)).x;

		if (SceneDepth < CardTraceEndDistanceFromCamera)
		{
			float3 SceneNormal = DecodeNormal(DownsampledNormal.Load(int3(ScreenCoord, 0)).xyz);

			uint CardGridCellIndex = ComputeCardGridCellIndex(ScreenCoord * DownsampleFactor, SceneDepth); 

			#if CULLED_CARDS_GRID
				uint NumOverlappingCards = CulledCardGridHeader[CardGridCellIndex * CULLED_CARD_GRID_HEADER_STRIDE + 0];
				uint OverlappingCardsStartIndex = CulledCardGridHeader[CardGridCellIndex * CULLED_CARD_GRID_HEADER_STRIDE + 1];
			#endif

			#if CARD_TRACE_MESH_SDF
				uint NumMeshSDFs = NumGridCulledMeshSDFObjects[CardGridCellIndex];
				uint MeshSDFStartOffset = GridCulledMeshSDFObjectStartOffsetArray[CardGridCellIndex];
				Debug = NumMeshSDFs / 10.0f;
			#endif

			float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
			float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;

			//float Noise = InterleavedGradientNoise(ScreenCoord, View.StateFrameIndexMod8);
			float EffectiveSurfaceBias = SurfaceBias;// *lerp(.5f, 1.5f, Noise);
			float EffectiveStepFactor = StepFactor;// *= lerp(.8f, 1.2f, Noise);

			//@todo - derive bias from texel world size
			WorldPosition += SceneNormal * EffectiveSurfaceBias;

			LOOP
			for (uint PixelRayIndex = 0; PixelRayIndex < RayCountPerPixel; PixelRayIndex++)
			{
				uint2 RayStorageCoord = GetRayStorageCoords(ScreenCoord, PixelRayIndex);

				float3 WorldConeDirection = GetDiffuseWorldRayDirection(SceneNormal, ScreenCoord, PixelRayIndex);

				//@todo - derive bias from texel world size
				float3 SamplePosition = WorldPosition + EffectiveSurfaceBias * WorldConeDirection;

				FConeTraceInput TraceInput;
				TraceInput.Setup(SamplePosition, WorldConeDirection, DiffuseConeHalfAngle, MinSampleRadius, MinTraceDistance, MaxTraceDistance, EffectiveStepFactor);
				TraceInput.VoxelStepFactor = VoxelStepFactor;
				TraceInput.VoxelTraceStartDistance = MaxCardTraceDistance;

				#if CARD_CULLED_LIST
					TraceInput.NumOverlappingCards = NumOverlappingCards;
					TraceInput.OverlappingCardsStartIndex = OverlappingCardsStartIndex;
				#endif

					#if CARD_TRACE_MESH_SDF
						TraceInput.NumMeshSDFs = NumMeshSDFs;
						TraceInput.MeshSDFStartOffset = MeshSDFStartOffset;
						TraceInput.CardInterpolateInfluenceRadius = CardInterpolateInfluenceRadius;
						//@todo - derive from card texel size
						TraceInput.CardInterpolateDepthVisibilityRadius = 10;
					#endif

				FConeTraceResult TraceResult;
				ConeTraceLumenSceneCards(TraceInput, TraceResult);

				{
					float DistanceFromViewpoint = length(View.WorldCameraOrigin - WorldPosition);
					float DistanceFade = saturate(4 * DistanceFromViewpoint / CardTraceEndDistanceFromCamera - 3);

					TraceResult.Lighting *= 1 - DistanceFade;
					TraceResult.Transparency = lerp(TraceResult.Transparency, 1, DistanceFade);
				}

				#if RESUME_RAYS
				{
					float4 PreviousRadiance = HitRadianceOutput[RayStorageCoord];
					
					#if USE_PREEXPOSURE
						PreviousRadiance.rgb *= View.OneOverPreExposure;
					#endif

					TraceResult.Lighting = TraceResult.Lighting * PreviousRadiance.a + PreviousRadiance.rgb;
					TraceResult.Transparency *= PreviousRadiance.a;
				}
				#endif
				
				#if USE_PREEXPOSURE
					TraceResult.Lighting *= View.PreExposure;
				#endif

				HitRadianceOutput[RayStorageCoord] = float4(TraceResult.Lighting, TraceResult.Transparency);

				#if DIFFUSE_DEBUG_PASSTHROUGH
					HitRadianceOutput[RayStorageCoord] = float4(Debug, 0);
				#endif
			}
		}
		#if !RESUME_RAYS
		else
		{
			LOOP
			for (uint PixelRayIndex = 0; PixelRayIndex < RayCountPerPixel; PixelRayIndex++)
			{
				uint2 RayStorageCoord = GetRayStorageCoords(ScreenCoord, PixelRayIndex);
				HitRadianceOutput[RayStorageCoord] = float4(0.0f, 0.0f, 0.0f, 1.0f);
			}
		}
		#endif
	}
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void DiffuseIndirectTraceVoxelsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenCoord;

	#undef DEINTERLEAVED_TRACING
	#define DEINTERLEAVED_TRACING 1
	#if DEINTERLEAVED_TRACING
		// Compute viewport size split into SampleTileSize pieces
		uint2 InterleavedSampleSetSize = (DownsampledViewSize + SampleTileSize - 1) / (SampleTileSize);
		uint2 InterleavedCoord = DispatchThreadId.xy;
		ScreenCoord = (DispatchThreadId.xy % InterleavedSampleSetSize) * SampleTileSize + DispatchThreadId.xy / InterleavedSampleSetSize;
	#else
		ScreenCoord = DispatchThreadId.xy;
	#endif

	if (all(ScreenCoord < DownsampledViewSize))
	{
		float3 Debug = 0;

		float2 ScreenUV = TracingPixelCoordToSceneBufferUV(ScreenCoord);
		const float SceneDepth = DownsampledDepth.Load(int3(ScreenCoord, 0)).x;

		FDiffuseGatherLighting DiffuseLighting;
		DiffuseLighting.Initialize();

		if (SceneDepth < 1000000.0f)
		{
			float3 SceneNormal = DecodeNormal(DownsampledNormal.Load(int3(ScreenCoord, 0)).xyz);

			float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
			float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;

			float Noise = InterleavedGradientNoise(ScreenCoord, View.StateFrameIndexMod8);
			float EffectiveSurfaceBias = SurfaceBias;// *lerp(.5f, 1.5f, Noise);
			float EffectiveStepFactor = StepFactor;// *= lerp(.8f, 1.2f, Noise);

			//@todo - derive bias from texel world size
			float3 BiasedWorldPosition = WorldPosition + SceneNormal * EffectiveSurfaceBias;

			bool bContinueCardTracing = (DIFFUSE_TRACE_CARDS != 0);

			float VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(
				BiasedWorldPosition, DiffuseConeHalfAngle, MinTraceDistance, MaxTraceDistance, MaxCardTraceDistance, bContinueCardTracing);


			float3 ProbeNoise = float3(
				InterleavedGradientNoise(ScreenCoord, View.StateFrameIndexMod8),
				InterleavedGradientNoise(ScreenCoord + uint2(127, 1347), View.StateFrameIndexMod8 + 1),
				InterleavedGradientNoise(ScreenCoord + uint2(597, 285), View.StateFrameIndexMod8 + 2));

			LOOP
			for (uint PixelRayIndex = 0; PixelRayIndex < RayCountPerPixel; PixelRayIndex++)
			{
				uint2 RayStorageCoord = GetRayStorageCoords(ScreenCoord, PixelRayIndex);
				
				float3 WorldConeDirection = GetDiffuseWorldRayDirection(SceneNormal, ScreenCoord, PixelRayIndex);

				//@todo - derive bias from texel world size
				float3 SamplePosition = BiasedWorldPosition + EffectiveSurfaceBias * WorldConeDirection;

				float TraceDistance = MaxTraceDistance;
				bool bCoveredByRadianceCache = false;
#if RADIANCE_CACHE
				float ProbeOcclusionDistance = GetRadianceProbeOcclusionDistanceWithInterpolation(WorldPosition, WorldConeDirection, bCoveredByRadianceCache);
				TraceDistance = min(TraceDistance, ProbeOcclusionDistance);
#endif

				FConeTraceInput TraceInput;
				TraceInput.Setup(SamplePosition, WorldConeDirection, DiffuseConeHalfAngle, MinSampleRadius, MinTraceDistance, TraceDistance, EffectiveStepFactor);
				TraceInput.VoxelStepFactor = VoxelStepFactor;
				TraceInput.VoxelTraceStartDistance = VoxelTraceStartDistance;

				FConeTraceResult TraceResult;

				{
					float4 TraceRadianceValue = float4(0, 0, 0, 1);
						
					#if DIFFUSE_TRACE_CARDS
					{
						#if OUTPUT_INDIVIDUAL_RAYS
						{
							TraceRadianceValue = HitRadianceOutput[RayStorageCoord];
						}
						#else
						{
							TraceRadianceValue = HitRadiance.Load(int3(RayStorageCoord, 0));
						}
						#endif
					
						#if USE_PREEXPOSURE
							TraceRadianceValue.rgb *= View.OneOverPreExposure;
						#endif
					}
					#endif

					Debug = TraceRadianceValue.xyz;
					TraceResult = (FConeTraceResult)0;

					TraceResult.Lighting = TraceRadianceValue.xyz;
					TraceResult.Transparency = TraceRadianceValue.w;

					if (TraceResult.Transparency > .01f)
					{
						ConeTraceLumenSceneVoxels(TraceInput, TraceResult);
					}
				}

#if RADIANCE_CACHE
				if (bCoveredByRadianceCache)
				{
					SampleRadianceCacheAndApply(WorldPosition, WorldConeDirection, ProbeNoise, TraceResult.Lighting, TraceResult.Transparency);
				}
				else
#endif
				{
#if OLD_DENOISER_TRACE_DISTANT_SCENE
					if (TraceResult.Transparency > .01f)
					{
						FConeTraceResult DistantTraceResult;
						ConeTraceLumenDistantScene(TraceInput, DistantTraceResult);
						TraceResult.Lighting += DistantTraceResult.Lighting * TraceResult.Transparency;
						TraceResult.Transparency *= DistantTraceResult.Transparency;
					}
#endif
					EvaluateSkyRadianceForCone(WorldConeDirection, TanDiffuseConeHalfAngle, TraceResult);
				}

				#if USE_PREEXPOSURE
					TraceResult.Lighting *= View.PreExposure;
				#endif
			
				#if OUTPUT_INDIVIDUAL_RAYS
				{
					// Lumen equation:
					//		SceneColor += Diffuse_Lambert(DiffuseColor) * Sum(TraceResult.Lighting * SampleWeight) * AO
					//		SampleWeight = LumenDiffuseIntensity * 2.0f * PI / RayCountPerPixel
					
					float Weight = SampleWeight;

					// Because DiffuseIndirectMergeSamples.usf does /= RayCountPerPixel
					Weight *= RayCountPerPixel;
					
					// Because DiffuseIndirectComposite.usf doesn't do Diffuse_Lambert(DiffuseColor)
					//Weight *= rcp(PI);

					HitRadianceOutput[RayStorageCoord] = float4(TraceResult.Lighting * Weight, /* Transparency = */ 0.0);
				}
				#else
				{
					DiffuseLighting.AddLighting(WorldConeDirection, SceneNormal, TraceResult.Lighting * SampleWeight);
				}
				#endif
			}
		}
	 
		#if !OUTPUT_INDIVIDUAL_RAYS
			DiffuseLighting.Encode(RWDiffuseIndirect0[ScreenCoord], RWDiffuseIndirect1[ScreenCoord]);
		#endif

		#if DIFFUSE_DEBUG_PASSTHROUGH
			RWDiffuseIndirect0[ScreenCoord] = float4(Debug, 0);
		#endif
	}
}

Texture2D DiffuseIndirect0;
Texture2D DiffuseIndirect1;
SamplerState DiffuseIndirectSampler;
float2 DiffuseIndirectTexelSize;
float2 MaxDiffuseIndirectBufferUV;

void DiffuseIndirectFilterPS(
	float4 SVPosition : SV_POSITION,
	out float4 OutColor0 : SV_Target0,
	out float4 OutColor1 : SV_Target1)
{
#define FILTER 1
#if FILTER
	float2 BufferUV = min(SVPosition.xy * DiffuseIndirectTexelSize, MaxDiffuseIndirectBufferUV);
	float SceneDepth = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, BufferUV, 0).x;
	FDiffuseGatherLighting TotalLighting;
	TotalLighting.Initialize();
	float TotalWeight = .00001f;

	if (SceneDepth < 1000000.0f)
	{
		float4 ScenePlane;
		float3 CameraVector;
		{
			// Note: hardcoded for DownsampleFactor = 2 
			float DownsampledHalfTexelToFullResHalfTexelOffset = .25f;
			// Correct the downsampled half texel offset in SVPos with ViewRectMin removed to full res half texel offset for sampling Scene buffers
			float2 ScreenUV = (SVPosition.xy - DownsampledHalfTexelToFullResHalfTexelOffset + View.ViewRectMin.xy) * View.BufferSizeAndInvSize.zw * DownsampleFactor;
			float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
			float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;
			CameraVector = normalize(WorldPosition - View.WorldCameraOrigin);

			float3 WorldNormal = GetGBufferData(ScreenUV).WorldNormal;
			ScenePlane = float4(WorldNormal, dot(WorldPosition, WorldNormal));
		}

		float Start = -(float)SampleTileSize / 2.0f;
		float End = Start + SampleTileSize;

		for (float Y = Start; Y < End; Y++)
		{
			for (float X = Start; X < End; X++)
			{
				float2 UV = (SVPosition.xy + float2(X, Y)) * DiffuseIndirectTexelSize;
				UV = min(UV, MaxDiffuseIndirectBufferUV);
				float SampleDepth = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, UV, 0).x;

				float PlaneWeight;
				
				{
					// Note: hardcoded for DownsampleFactor = 2
					float DownsampledHalfTexelToFullResHalfTexelOffset = .25f;
					// Correct the downsampled half texel offset in SVPos with ViewRectMin removed to full res half texel offset for sampling Scene buffers
					float2 ScreenUV = (SVPosition.xy + float2(X, Y) - DownsampledHalfTexelToFullResHalfTexelOffset + View.ViewRectMin.xy) * View.BufferSizeAndInvSize.zw * DownsampleFactor;
					float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
					float3 WorldPosition = mul(float4(ScreenPosition * SampleDepth, SampleDepth, 1), View.ScreenToWorld).xyz;
					float PlaneDistance = abs(dot(float4(WorldPosition, -1), ScenePlane));

					PlaneWeight = .1f * exp2(-.1f * (PlaneDistance * PlaneDistance));
				}

				#if LUMEN_DIFFUSE_DIRECTIONAL_ENCODING
					float NormalWeight = 1;
				#else
					float3 SampleNormal = GetGBufferData(UV).WorldNormal;
					float NormalWeight = saturate(dot(SampleNormal, ScenePlane.xyz));
				#endif
				/*
				float Epsilon = .0001f;
				float DepthDifference = abs(SampleDepth - SceneDepth);
				float RelativeDepthDifference = DepthDifference / SceneDepth;
				//float DepthWeight = 1.0f / (DepthDifference + Epsilon);
				float DepthWeight = .1f * exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference));
				*/
				/*
				float GrazingAngleOverride = saturate(dot(SampleNormal, CameraVector));
				DepthWeight = lerp(1, DepthWeight, pow(GrazingAngleOverride, 1.0f / 8.0f));
				*/
				//float Weight = DepthWeight;

				float Weight = NormalWeight * PlaneWeight;
				
				if (Weight > 0)
				{
					float4 Vector0 = Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, UV, 0);
					float4 Vector1 = Texture2DSampleLevel(DiffuseIndirect1, DiffuseIndirectSampler, UV, 0);
					FDiffuseGatherLighting SampleLighting;
					SampleLighting.Decode(Vector0, Vector1);
					SampleLighting.Multiply(Weight);
					TotalLighting.AddGatheredLighting(SampleLighting);
				}
				TotalWeight += Weight;
			}
		}
	}

	TotalLighting.Multiply(1.0f / TotalWeight);
	TotalLighting.Encode(OutColor0, OutColor1);
#else
	OutColor0 = Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, SVPosition.xy * DiffuseIndirectTexelSize, 0);
	OutColor1 = Texture2DSampleLevel(DiffuseIndirect1, DiffuseIndirectSampler, SVPosition.xy * DiffuseIndirectTexelSize, 0);
#endif
}

float HistoryDistanceThreshold;

float ComputeHistoryWeightBasedOnPosition(float2 ScreenPosition, float SceneDepth, float2 OldScreenPosition, float HistoryCameraDepth)
{
	float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;

	float3 PrevPositionTranslatedWorld = mul(float4(OldScreenPosition * HistoryCameraDepth, HistoryCameraDepth, 1), View.PrevScreenToTranslatedWorld).xyz;
	float3 PrevWorldPosition = PrevPositionTranslatedWorld - View.PrevPreViewTranslation;

	float DistanceToHistoryValue = length(PrevWorldPosition - WorldPosition);
	float RelativeHistoryDistanceThreshold = HistoryDistanceThreshold / 1000.0f;

	return DistanceToHistoryValue / SceneDepth > RelativeHistoryDistanceThreshold ? 0.0f : 1.0f;
}

Texture2D DiffuseIndirectHistory0;
Texture2D DiffuseIndirectHistory1;
Texture2D DiffuseIndirectDepthHistory;
Texture2D HistoryConvergence;

float HistoryWeight;
float HistoryConvergenceWeight;

float4 HistoryScreenPositionScaleBias;
float4 HistoryUVMinMax;

Texture2D VelocityTexture;
SamplerState VelocityTextureSampler;

float2 InvDiffuseIndirectBufferSize;
float PrevInvPreExposure;

void UpdateHistoryDepthRejectionPS(
	float4 SVPosition : SV_POSITION,
	out float4 OutDiffuseIndirect0 : SV_Target0,
	out float4 OutDiffuseIndirect1 : SV_Target1,
	out float4 OutDownsampledDepth : SV_Target2,
	out float4 OutConvergence : SV_Target3)
{
	float2 DiffuseIndirectUVs = SVPosition.xy * InvDiffuseIndirectBufferSize;
	// Note: hardcoded for DownsampleFactor = 2
	float DownsampledHalfTexelToFullResHalfTexelOffset = .25f;
	// Correct the downsampled half texel offset in SVPos with ViewRectMin removed to full res half texel offset for sampling Scene buffers
	float2 ScreenUV = (SVPosition.xy - DownsampledHalfTexelToFullResHalfTexelOffset + View.ViewRectMin.xy) * View.BufferSizeAndInvSize.zw * DownsampleFactor;
	float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;

	FDiffuseGatherLighting NewValue;
	NewValue.Decode(
		Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, DiffuseIndirectUVs, 0),
		Texture2DSampleLevel(DiffuseIndirect1, DiffuseIndirectSampler, DiffuseIndirectUVs, 0));

	float SceneDepth = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, DiffuseIndirectUVs, 0).x;

	float4 ThisClip = float4(ScreenPosition, ConvertToDeviceZ(SceneDepth), 1);
	float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
	float2 PrevScreen = PrevClip.xy / PrevClip.w;
	float2 ScreenVelocity = ScreenPosition - PrevScreen;
		
	float2 VelocityN = Texture2DSampleLevel(VelocityTexture, VelocityTextureSampler, ScreenUV, 0).xy;
		
	if (VelocityN.x > 0.0)
	{
		ScreenVelocity = DecodeVelocityFromTexture(float3(VelocityN, 0.0)).xy;
	}
		
	float2 OldScreenPosition = (ScreenPosition - ScreenVelocity);
	float2 OldScreenUVs = OldScreenPosition * HistoryScreenPositionScaleBias.xy + HistoryScreenPositionScaleBias.wz;
	// Undo the correction 
	float2 OldDiffuseIndirectUVs = OldScreenUVs + (DownsampledHalfTexelToFullResHalfTexelOffset - View.ViewRectMin.xy) * View.BufferSizeAndInvSize.zw * DownsampleFactor;

	float EffectiveHistoryWeight = HistoryWeight;
	float EffectiveConvergenceWeight = HistoryConvergenceWeight;
	float NewConvergence = 1;

	FLATTEN
	if (any(OldDiffuseIndirectUVs > HistoryUVMinMax.zw + .5f * InvDiffuseIndirectBufferSize) || any(OldDiffuseIndirectUVs < HistoryUVMinMax.xy - .5f * InvDiffuseIndirectBufferSize))
	{
		EffectiveHistoryWeight = 0;
		EffectiveConvergenceWeight = 0;
		NewConvergence = 0;
	}

	// It's not enough just to set EffectiveHistoryWeight to 0, as sampling from invalid history region may result in a NaN
	OldDiffuseIndirectUVs = clamp(OldDiffuseIndirectUVs, HistoryUVMinMax.xy, HistoryUVMinMax.zw);

	FDiffuseGatherLighting HistoryValue;
	HistoryValue.Decode(
		Texture2DSampleLevel(DiffuseIndirectHistory0, DiffuseIndirectSampler, OldDiffuseIndirectUVs, 0),
		Texture2DSampleLevel(DiffuseIndirectHistory1, DiffuseIndirectSampler, OldDiffuseIndirectUVs, 0));

	float HistoryDepth = Texture2DSampleLevel(DiffuseIndirectDepthHistory, DiffuseIndirectSampler, OldDiffuseIndirectUVs, 0).x;
	float PositionWeight = ComputeHistoryWeightBasedOnPosition(ScreenPosition, SceneDepth, OldScreenPosition, HistoryDepth);

	EffectiveConvergenceWeight *= PositionWeight;
	NewConvergence *= PositionWeight;

	float ConvergenceHistory = Texture2DSampleLevel(HistoryConvergence, DiffuseIndirectSampler, OldDiffuseIndirectUVs, 0).r;
	float UpdatedConvergence = lerp(NewConvergence, ConvergenceHistory, EffectiveConvergenceWeight);

	EffectiveHistoryWeight *= PositionWeight * UpdatedConvergence;

	//OutDiffuseIndirect.rgb = lerp(NewValue.rgb, HistoryValue.rgb, EffectiveHistoryWeight);
	HistoryValue.Multiply(EffectiveHistoryWeight * PrevInvPreExposure * View.PreExposure);
	NewValue.Multiply(1 - EffectiveHistoryWeight);
	NewValue.AddGatheredLighting(HistoryValue);
	NewValue.Encode(OutDiffuseIndirect0, OutDiffuseIndirect1);

	OutDownsampledDepth = SceneDepth;

	OutConvergence.r = UpdatedConvergence;
	OutConvergence.gba = 0;
}

Texture2D ConvergenceTexture;
float LowConvergenceSpatialFilterSpread;

#define HALF_HISTORY_FILL_KERNEL_SIZE 4

/** Seeds newly rejected history values (which are sources of temporal instability) with the results of a spatial search from stable history values */
void LowConvergenceSpatialFilterPS(
	float4 SVPosition : SV_POSITION,
	out float4 OutColor0 : SV_Target0,
	out float4 OutColor1 : SV_Target1)
{
	float2 BufferUV = SVPosition.xy * DiffuseIndirectTexelSize;
	BufferUV = min(BufferUV, MaxDiffuseIndirectBufferUV);

	FDiffuseGatherLighting CurrentLighting;
	{
		float4 Vector0 = Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, BufferUV, 0);
		float4 Vector1 = Texture2DSampleLevel(DiffuseIndirect1, DiffuseIndirectSampler, BufferUV, 0);
		CurrentLighting.Decode(Vector0, Vector1);
	}

	float Convergence = Texture2DSampleLevel(ConvergenceTexture, DiffuseIndirectSampler, BufferUV, 0).x;
	
	// Only do the spatial search for pixels who discarded their history value
	if (Convergence < .99f)
	{
		float SceneDepth = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, BufferUV, 0).x;

		FDiffuseGatherLighting AccumulatedLighting;
		AccumulatedLighting.Initialize();
		float TotalWeight = 0;

		for (float y = -HALF_HISTORY_FILL_KERNEL_SIZE; y <= HALF_HISTORY_FILL_KERNEL_SIZE; y++)
		{
			for (float x = -HALF_HISTORY_FILL_KERNEL_SIZE; x <= HALF_HISTORY_FILL_KERNEL_SIZE; x++)
			{
				float2 SampleBufferUV = BufferUV + DiffuseIndirectTexelSize * LowConvergenceSpatialFilterSpread * float2(x, y);

				// Diffuse Indirect was computed at 0,0 regardless of viewrect min.
				SampleBufferUV = min(SampleBufferUV, MaxDiffuseIndirectBufferUV);

				float SampleSceneDepth = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, SampleBufferUV, 0).x;
				float SampleConvergence = Texture2DSampleLevel(ConvergenceTexture, DiffuseIndirectSampler, SampleBufferUV, 0).x;
				//float ValidWeight = SampleConvergence > .99f;

				// Weight by depth to avoid pulling in values of a foreground object
				// This is a careful tradeoff between ghosting behind panning foreground objects and successful spatial searches to reduce flickering
				float DepthWeight = exp2(-1000 * abs(SceneDepth - SampleSceneDepth) / SceneDepth);

				//float2 Weight2D = exp2(-abs(float2(x, y) * 10.0f / (float)HALF_HISTORY_FILL_KERNEL_SIZE));
				//float ScreenSpaceSpatialWeight = max(Weight2D.x, Weight2D.y);

				float ExcludeSourceWeight = saturate(dot(float2(x, y), float2(x, y)));
				float Weight = DepthWeight * ExcludeSourceWeight;

				if (Weight > 0)
				{
					float4 Vector0 = Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, SampleBufferUV, 0);
					float4 Vector1 = Texture2DSampleLevel(DiffuseIndirect1, DiffuseIndirectSampler, SampleBufferUV, 0);
					FDiffuseGatherLighting SampleLighting;
					SampleLighting.Decode(Vector0, Vector1);
					SampleLighting.Multiply(Weight);
					AccumulatedLighting.AddGatheredLighting(SampleLighting);
				}

				TotalWeight += Weight;
			}
		}

		if (TotalWeight > 0)
		{
			float InvTotalWeight = 1.0f / TotalWeight;
			// Construct the output value as if the spatial search result was the previous history, 
			// And the GI we just computed this frame was the new value
			//NewValue.xyz = lerp(HistoryValue.xyz, Accumulation.xyz * InvWeight, HistoryWeight);
			//CurrentLighting.Multiply(1 - HistoryWeight);
			//AccumulatedLighting.Multiply(HistoryWeight * InvTotalWeight);
			//CurrentLighting.AddGatheredLighting(AccumulatedLighting);

			//AccumulatedLighting.SH.R.V.x = 2 * TotalWeight;
#define CONVERGENCE_LERP 1
#if CONVERGENCE_LERP
			// Out = lerp(AccumulatedLighting * InvTotalWeight, CurrentLighting, Convergence);
			AccumulatedLighting.Multiply(InvTotalWeight * (1 - Convergence));
			CurrentLighting.Multiply(Convergence);
			CurrentLighting.AddGatheredLighting(AccumulatedLighting);

#else
			AccumulatedLighting.Multiply(InvTotalWeight);
			CurrentLighting = AccumulatedLighting;
#endif
			//CurrentLighting.SH.R.V.x = 2;
		}
	}

	CurrentLighting.Encode(OutColor0, OutColor1);
}

FDiffuseGatherLighting SampleDiffuseIndirect(float2 UV)
{
	float4 Vector0 = Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, UV, 0);
	float4 Vector1 = Texture2DSampleLevel(DiffuseIndirect1, DiffuseIndirectSampler, UV, 0);

	FDiffuseGatherLighting Result;
	Result.Decode(Vector0, Vector1);

	return Result;
}

int bVisualizeDiffuseIndirect;

void UpsampleDiffuseIndirectPS(
	float4 SVPosition : SV_POSITION,
	out float4 OutColor : SV_Target0,
	out float4 OutRoughSpecularIndirect : SV_Target1)
{
	// DiffuseIndirect was computed at 0,0 regardless of viewrect min
	float2 DiffuseIndirectUVs = SvPositionToBufferUV(SVPosition) - View.ViewRectMin.xy * View.BufferSizeAndInvSize.zw;
	float2 ScreenUV = SvPositionToBufferUV(SVPosition);
	float SceneDepth = CalcSceneDepth(ScreenUV);

	OutColor = 0;

	if (SceneDepth < 1000000.0f)
	{
#define BILATERAL_UPSAMPLE 1
#if BILATERAL_UPSAMPLE && UPSAMPLE_REQUIRED
		float2 LowResBufferSize = floor(View.BufferSizeAndInvSize.xy / DOWNSAMPLE_FACTOR);
		float2 LowResTexelSize = 1.0f / LowResBufferSize;
		float2 Corner00UV = floor(DiffuseIndirectUVs * LowResBufferSize - .5f) / LowResBufferSize + .5f * LowResTexelSize;
		float2 BilinearWeights = (DiffuseIndirectUVs - Corner00UV) * LowResBufferSize;

		float4 CornerDepths;
		CornerDepths.x = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, Corner00UV, 0).x;
		CornerDepths.y = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, Corner00UV + float2(LowResTexelSize.x, 0), 0).x;
		CornerDepths.z = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, Corner00UV + float2(0, LowResTexelSize.y), 0).x;
		CornerDepths.w = Texture2DSampleLevel(DownsampledDepth, DiffuseIndirectSampler, Corner00UV + LowResTexelSize, 0).x;

		float4 CornerWeights = float4(
			(1 - BilinearWeights.y) * (1 - BilinearWeights.x),
			(1 - BilinearWeights.y) * BilinearWeights.x,
			BilinearWeights.y * (1 - BilinearWeights.x),
			BilinearWeights.y * BilinearWeights.x);

		float Epsilon = .0001f;

		float4 DepthDifference = abs(CornerDepths - SceneDepth.xxxx);
		float4 RelativeDepthDifference = DepthDifference / SceneDepth;
		float4 DepthWeights = .1f * exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference));
		//float4 DepthWeights = 1.0f / (abs(CornerDepths - SceneDepth.xxxx) + Epsilon);

		float4 FinalWeights = CornerWeights * DepthWeights;
		FinalWeights /= dot(FinalWeights, 1);

		FDiffuseGatherLighting InterpolatedResult;
		InterpolatedResult.Initialize();

		if (FinalWeights.x > 0)
		{
			FDiffuseGatherLighting TextureValues00 = SampleDiffuseIndirect(Corner00UV);
			TextureValues00.Multiply(FinalWeights.x);
			InterpolatedResult.AddGatheredLighting(TextureValues00);
		}

		if (FinalWeights.y > 0)
		{
			FDiffuseGatherLighting TextureValues10 = SampleDiffuseIndirect(Corner00UV + float2(LowResTexelSize.x, 0));
			TextureValues10.Multiply(FinalWeights.y);
			InterpolatedResult.AddGatheredLighting(TextureValues10);
		}

		if (FinalWeights.z > 0)
		{
			FDiffuseGatherLighting TextureValues01 = SampleDiffuseIndirect(Corner00UV + float2(0, LowResTexelSize.y));
			TextureValues01.Multiply(FinalWeights.z);
			InterpolatedResult.AddGatheredLighting(TextureValues01);
		}

		if (FinalWeights.w > 0)
		{
			FDiffuseGatherLighting TextureValues11 = SampleDiffuseIndirect(Corner00UV + LowResTexelSize);
			TextureValues11.Multiply(FinalWeights.w);
			InterpolatedResult.AddGatheredLighting(TextureValues11);
		}

#else
		FDiffuseGatherLighting InterpolatedResult = SampleDiffuseIndirect(DiffuseIndirectUVs);
#endif

		FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(ScreenUV);
		FGBufferData GBufferData = ScreenSpaceData.GBuffer;

		if (GBufferData.ShadingModelID != SHADINGMODELID_UNLIT)
		{
			float3 DiffuseColor = bVisualizeDiffuseIndirect ? float3(1, 1, 1) : GBufferData.DiffuseColor;

			float3 DiffuseLighting;
#if LUMEN_DIFFUSE_DIRECTIONAL_ENCODING
			FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(GBufferData.WorldNormal, 1);
			DiffuseLighting = max(DotSH(InterpolatedResult.SH, DiffuseTransferSH), float3(0, 0, 0));
#else
			DiffuseLighting = InterpolatedResult.LightingAlongNormal;
#endif

			{
				//@todo - interpolate ViewVector from VS
				float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
				float3 WorldPosition = mul(float4(ScreenPosition * GBufferData.Depth, GBufferData.Depth, 1), View.ScreenToWorld).xyz;
				float3 V = normalize(WorldPosition - View.WorldCameraOrigin);
				float3 ReflectionVector = reflect(V, GBufferData.WorldNormal);
				FTwoBandSHVector ReflectionHemisphereTransferSH = CalcDiffuseTransferSH(ReflectionVector, 1);
				float3 ReflectionLighting = max(DotSH(InterpolatedResult.SH, ReflectionHemisphereTransferSH), float3(0, 0, 0));
				OutRoughSpecularIndirect = float4(ReflectionLighting, 0) * View.OneOverPreExposure;
			}

			FLightAccumulator LightAccumulator = (FLightAccumulator)0;

			float3 DiffuseTerm = DiffuseLighting * Diffuse_Lambert(DiffuseColor); // * GBufferData.GBufferAO * ScreenSpaceData.AmbientOcclusion;

			const bool bNeedsSeparateSubsurfaceLightAccumulation = UseSubsurfaceProfile(GBufferData.ShadingModelID);

			LightAccumulator_Add(LightAccumulator, DiffuseTerm, DiffuseTerm, float3(1, 1, 1), bNeedsSeparateSubsurfaceLightAccumulation);

			OutColor = LightAccumulator_GetResult(LightAccumulator);

#if DIFFUSE_DEBUG_PASSTHROUGH
			OutColor.rgb = Texture2DSampleLevel(DiffuseIndirect0, DiffuseIndirectSampler, DiffuseIndirectUVs, 0).xyz;
			OutColor.a = 0;
#endif
		}
	}
}