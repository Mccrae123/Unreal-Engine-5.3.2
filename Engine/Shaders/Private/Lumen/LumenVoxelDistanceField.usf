// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenVoxelDistanceField.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenVoxelDistanceFieldCommon.ush"

Texture3D VoxelLighting;
uint3 ClipmapResolution;
uint ClipmapIndex;
uint MaxDistanceFieldValue;
RWTexture3D<uint4> RWNearestVoxelAtlas;

[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, THREADGROUP_SIZE_Z)]
void VoxelLightingToDistanceFieldCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 VoxelCoord = DispatchThreadId;

	if (all(VoxelCoord < ClipmapResolution))
	{
		uint FaceMask = 0;

		for (uint FaceIndex = 0; FaceIndex < 6; ++FaceIndex)
		{
			uint3 VoxelLightingCoord;
			VoxelLightingCoord.x = VoxelCoord.x;
			VoxelLightingCoord.y = VoxelCoord.y + ClipmapIndex * ClipmapResolution.y;
			VoxelLightingCoord.z = VoxelCoord.z + FaceIndex * ClipmapResolution.z;

			float FaceTranslucency = VoxelLighting.Load(uint4(VoxelLightingCoord, 0)).w;
			FaceMask |= FaceTranslucency < 1.0f ? (1 << FaceIndex) : 0;
		}

		FVoxelDistanceField VDF;
		VDF.Distance = FaceMask ? 0 : MaxDistanceFieldValue;
		VDF.FaceMask = FaceMask;

		uint3 OutputVoxelCoord = VoxelCoord + uint3(0, ClipmapIndex * ClipmapResolution.y, 0);
		RWNearestVoxelAtlas[OutputVoxelCoord] = VDF.Pack();
	}
}


Texture3D<uint4> PrevNearestVoxelAtlas;

[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, THREADGROUP_SIZE_Z)]
void PropagateDistanceFieldCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 VoxelCoordInClipmap = DispatchThreadId;

	if (all(VoxelCoordInClipmap < ClipmapResolution))
	{
		uint3 VoxelCoordInAtlas = VoxelCoordInClipmap + uint3(0, ClipmapIndex * ClipmapResolution.y, 0);

		FVoxelDistanceField CenterVoxel;
		CenterVoxel.Unpack(PrevNearestVoxelAtlas.Load(uint4(VoxelCoordInAtlas, 0)));

		UNROLL
		for (int OffsetZ = -1; OffsetZ <= 1; ++OffsetZ)
		{
			UNROLL
			for (int OffsetY = -1; OffsetY <= 1; ++OffsetY)
			{
				UNROLL
				for (int OffsetX = -1; OffsetX <= 1; ++OffsetX)
				{
					int3 OffsetCmp = abs(int3(OffsetX, OffsetY, OffsetZ));

					if (!all(OffsetCmp == 0))
					{
						uint SampleOffset = 1;
						int3 SampleVoxelCoord = VoxelCoordInClipmap;
						SampleVoxelCoord.x += OffsetX * SampleOffset;
						SampleVoxelCoord.y += OffsetY * SampleOffset;
						SampleVoxelCoord.z += OffsetZ * SampleOffset;
						SampleVoxelCoord = clamp(SampleVoxelCoord, 0, (int3)ClipmapResolution - 1);

						SampleVoxelCoord.y += ClipmapIndex * ClipmapResolution.y;

						FVoxelDistanceField SampleVoxel;
						SampleVoxel.Unpack(PrevNearestVoxelAtlas.Load(uint4(SampleVoxelCoord, 0)));

						CenterVoxel.Distance = min(CenterVoxel.Distance, SampleVoxel.Distance + 1);
					}
				}
			}
		}

		RWNearestVoxelAtlas[VoxelCoordInAtlas] = CenterVoxel.Pack();
	}
}
