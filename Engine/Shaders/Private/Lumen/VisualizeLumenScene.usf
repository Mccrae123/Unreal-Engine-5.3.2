// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	VisualizeLumenCardScene.usf
=============================================================================*/

#if CULLED_CARDS_GRID
	#define CARD_CULLED_LIST 1
#else
	#define CARD_CULLED_LIST 0
#endif
#define CARD_BVH 0

#include "../Common.ush"
#include "LumenCardCommon.ush"
#define VOXEL_TRACE_BLEND_BETWEEN_AXES 1
// Depth weighted OIT doesn't cover enough depth range for ConeTraceLumenDistantScene
// This has the side effect that card tracing for detail traces in this file don't get blended
#define CARD_TRACE_DEPTH_WEIGHTED_OIT 0
#include "LumenTracingCommon.ush"
#include "LumenRadianceCacheCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../PrintValue.ush"
#include "../SHCommon.ush"

uint3 CullGridSize;
uint CardGridPixelSizeShift;
uint4 ViewDimensions;
float PreviewConeAngle;
float TanPreviewConeAngle;
float VisualizeStepFactor;
float VoxelStepFactor;
float MinTraceDistance;
float MaxTraceDistance;
float MaxCardTraceDistanceForVoxelTracing;
float MaxCardTraceDistance;
int VisualizeClipmapIndex;
int VisualizeVoxelFaceIndex;
float CardInterpolateInfluenceRadius;

bool BVHCullingNodeTest(FLumenCardBVHNodeData BVHNode, uint3 CullGridPos)
{
	float MinTileZ = 0.0f;
	float MaxTileZ = MaxCardTraceDistance;

	// Setup tile frustum planes
	float2 TileScale = -float2(View.ViewSizeAndInvSize.zw - View.ViewSizeAndInvSize.xy) * rcp(2 * (1 << CardGridPixelSizeShift));
	float2 TileBias = TileScale - CullGridPos.xy - 0.5;

	float4 C1 = float4(View.ViewToClip._11 * TileScale.x, 0.0f, View.ViewToClip._31 * TileScale.x + TileBias.x, 0.0f);
	float4 C2 = float4(0.0f, -View.ViewToClip._22 * TileScale.y, View.ViewToClip._32 * TileScale.y + TileBias.y, 0.0f);
	float4 C4 = float4(0.0f, 0.0f, 1.0f, 0.0f);

	float4 frustumPlanes[6];
	frustumPlanes[0] = C4 - C1;
	frustumPlanes[1] = C4 + C1;
	frustumPlanes[2] = C4 - C2;
	frustumPlanes[3] = C4 + C2;
	frustumPlanes[4] = float4(0.0f, 0.0f, 1.0f, -MinTileZ);
	frustumPlanes[5] = float4(0.0f, 0.0f, -1.0f, MaxTileZ);

	// Normalize tile frustum planes
	for (uint i = 0; i < 4; ++i)
	{
		frustumPlanes[i] *= rcp(length(frustumPlanes[i].xyz));
	}

	float4x4 AbsTranslatedWorldToView = float4x4(	abs(View.TranslatedWorldToView[0]),
													abs(View.TranslatedWorldToView[1]),
													abs(View.TranslatedWorldToView[2]),
													abs(View.TranslatedWorldToView[3]));

	float3 ViewSpaceNodeCenter = mul(float4(BVHNode.BBoxCenter + View.PreViewTranslation.xyz, 1.0f), View.TranslatedWorldToView).xyz;
	float3 ViewSpaceNodeInfluenceExtent = mul(float4(BVHNode.BBoxExtent, 0.0f), AbsTranslatedWorldToView).xyz + CardInterpolateInfluenceRadius;

	// Tile frustum plane vs node AABB test
	bool bInTile = true;
	{
		for (uint i = 0; i < 6; ++i)
		{
			float DistanceFromNodeCenterToPlane = dot(frustumPlanes[i], float4(ViewSpaceNodeCenter, 1.0f));
			float Radius = dot(ViewSpaceNodeInfluenceExtent, abs(frustumPlanes[i].xyz));
			bInTile = bInTile && (DistanceFromNodeCenterToPlane >= -Radius);
		}
	}

	return bInTile;
}
#include "LumenCardBVHCulling.ush"

RWTexture2D<float4> RWSceneColor;
Buffer<uint> CulledCardGridHeader;

#define DEBUG_CULLED_CARDS_GRID 0

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void VisualizeQuadsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelPos = DispatchThreadId.xy + ViewDimensions.xy;
	float2 ViewportUV = (float2(DispatchThreadId.xy) + .5f) / (ViewDimensions.zw - ViewDimensions.xy);
	float2 ScreenPosition = float2(2.0f, -2.0f) * ViewportUV + float2(-1.0f, 1.0f);
	float3 ScreenVector = mul(float4(ScreenPosition, 1, 0), View.ScreenToTranslatedWorld).xyz;
	float3 CameraVector = normalize(ScreenVector);
	float Noise = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8);

	float TanConeAngle = tan(PreviewConeAngle);
	float TraceDistance = MaxTraceDistance;
	bool bCoveredByRadianceCache = false;

#if RADIANCE_CACHE
	float Noise2 = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8 + 1);
	float Noise3 = InterleavedGradientNoise(PixelPos, View.StateFrameIndexMod8 + 2);
	float3 ProbeNoise = float3(Noise, Noise2, Noise3);
	float ProbeOcclusionDistance = GetRadianceProbeOcclusionDistanceWithInterpolation(View.WorldCameraOrigin, CameraVector, bCoveredByRadianceCache);
	TraceDistance = min(TraceDistance, ProbeOcclusionDistance);
#endif

	FConeTraceInput TraceInput;
	TraceInput.Setup(View.WorldCameraOrigin, CameraVector, PreviewConeAngle, .01f, MinTraceDistance, TraceDistance, VisualizeStepFactor);
	TraceInput.VoxelStepFactor = VoxelStepFactor;
	TraceInput.SDFStepFactor = lerp(.8f, 1.0f, Noise);

	float3 Debug = -1;

	bool bContinueCardTracing = false;
#if TRACE_CARDS
	bContinueCardTracing = true;
#endif

	TraceInput.VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(View.WorldCameraOrigin, PreviewConeAngle, MinTraceDistance, TraceDistance, MaxCardTraceDistance, bContinueCardTracing);

#if RADIANCE_CACHE
	TraceInput.VoxelTraceStartDistance = min(TraceInput.VoxelTraceStartDistance, TraceDistance);
#endif

	int2 CellCoord = clamp((int2)PixelPos >> CardGridPixelSizeShift, int2(0, 0), (int2)CullGridSize.xy - 1);
	uint CardGridCellIndex = CellCoord.x + CellCoord.y * CullGridSize.x;

#if CARD_CULLED_LIST
	uint NumOverlappingCards = CulledCardGridHeader[CardGridCellIndex * CULLED_CARD_GRID_HEADER_STRIDE + 0];
	uint OverlappingCardsStartIndex = CulledCardGridHeader[CardGridCellIndex * CULLED_CARD_GRID_HEADER_STRIDE + 1];

	TraceInput.NumOverlappingCards = NumOverlappingCards;
	TraceInput.OverlappingCardsStartIndex = OverlappingCardsStartIndex;
#endif

#if CARD_TRACE_MESH_SDF
	TraceInput.NumMeshSDFs = NumGridCulledMeshSDFObjects[CardGridCellIndex];
	TraceInput.MeshSDFStartOffset = GridCulledMeshSDFObjectStartOffsetArray[CardGridCellIndex];
	TraceInput.CardInterpolateInfluenceRadius = CardInterpolateInfluenceRadius;
	//@todo - compute based on SDF voxel size, or card texel size
	TraceInput.CardInterpolateDepthVisibilityRadius = 10.0f;
	//Debug = TraceInput.NumMeshSDFs / 20.0f;
#endif

	FConeTraceResult TraceResult;

#if TRACE_CARDS
#define TRACE_MODE 2
#else
#define TRACE_MODE 1
#endif

#if TRACE_MODE == 0
	ConeTraceLumenCards(TraceInput, TraceResult);
#elif TRACE_MODE == 1
	ConeTraceVoxels(TraceInput, TraceResult);
#elif TRACE_MODE == 2

	TraceResult = (FConeTraceResult)0;
	TraceResult.Transparency = 1;

	ConeTraceLumenScene(TraceInput, TraceResult);
#endif

#if RADIANCE_CACHE
	TraceResult.Lighting += SampleRadianceCacheInterpolated(View.WorldCameraOrigin, CameraVector, ProbeNoise) * TraceResult.Transparency;
	TraceResult.Transparency = 0.0f;
#else

	#define VISUALIZE_TRACE_DISTANT_SCENE 1
	#if VISUALIZE_TRACE_DISTANT_SCENE

		FConeTraceResult DistantTraceResult;
		ConeTraceLumenDistantScene(TraceInput, DistantTraceResult);
		TraceResult.Lighting += DistantTraceResult.Lighting * TraceResult.Transparency;
		TraceResult.Transparency *= DistantTraceResult.Transparency;
	#endif

	EvaluateSkyRadianceForCone(CameraVector, TanConeAngle, TraceResult);
#endif

	#if USE_PREEXPOSURE
		TraceResult.Lighting *= View.PreExposure;
	#endif

	#define VISUALIZE_MODE 0
	#if VISUALIZE_MODE == 0
		RWSceneColor[PixelPos] = float4(TraceResult.Lighting + float3(0 * (saturate(TraceResult.NumOverlaps / 20.0f)), 0, 0), 0);
	#elif VISUALIZE_MODE == 1
		RWSceneColor[PixelPos] = float4(frac(TraceResult.OpaqueHitDistance.xxx / 100.0f), 0);
	#elif VISUALIZE_MODE == 2
		RWSceneColor[PixelPos] = float4(TraceResult.Lighting + TraceResult.Debug, 0);
	#else 
		RWSceneColor[PixelPos] = float4(TraceResult.NumSteps.xxx / 100.0f, 0);
	#endif

	if (any(Debug >= 0))
	{
		RWSceneColor[PixelPos] = float4(Debug, 0);
	}

	#if DEBUG_CULLED_CARDS_GRID && CARD_CULLED_LIST
		RWSceneColor[PixelPos] = float4(TraceInput.NumOverlappingCards.xxx / 10.0f, 0);
	#endif
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void VisualizeLumenCardBVHCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelPos = DispatchThreadId.xy + ViewDimensions.xy;
	float2 ViewportUV = (float2(DispatchThreadId.xy) + .5f) / (ViewDimensions.zw - ViewDimensions.xy);
	float2 ScreenPosition = float2(2.0f, -2.0f) * ViewportUV + float2(-1.0f, 1.0f);
	float3 ScreenVector = mul(float4(ScreenPosition, 1, 0), View.ScreenToTranslatedWorld).xyz;
	float3 ConeDirection = normalize(ScreenVector);
	float3 ConeOrigin = View.WorldCameraOrigin;
	float TanConeAngle = tan(PreviewConeAngle);

	uint PrintLumenCardId = INVALID_PROXY_CARD_ID;
	float ClosestHit = 1e9;
	float3 VisColor = 0;

	uint BVHStack[BVH_TRAVERSAL_STACK_SIZE];
	BVHStack[0] = INVALID_BVH_NODE_ID;
	FBVHTraverseState BVH;
	InitBVHTraverse(BVH);

	LOOP
	while (true)
	{
		for (uint i = 0; i < BVH_WIDTH; i++)
		{
			FLumenCardBVHNodeData BVHNode = GetLumenCardBVHNodeData(BVH.NodeId, i);
			float3 BBoxCenter = BVHNode.BBoxCenter;
			float3 BBoxExtent = BVHNode.BBoxExtent;
			float3 BBoxMin = BBoxCenter - BBoxExtent;
			float3 BBoxMax = BBoxCenter + BBoxExtent;

			float BBoxCenterDistanceAlongRay = dot(ConeDirection, BBoxCenter - ConeOrigin);
			float ConeRadiusExtent = TanConeAngle * max(BBoxCenterDistanceAlongRay, 0.1f);
			float2 IntersectionT = LineBoxIntersect(ConeOrigin, ConeOrigin + ConeDirection * MaxTraceDistance, BBoxMin - ConeRadiusExtent, BBoxMax + ConeRadiusExtent);

			if (IntersectionT.x < IntersectionT.y)
			{
				SetBVHNodeHit(BVH, BVHStack, BVHNode, i);

				VisColor.xyz += BVHNode.LumenCardId == INVALID_PROXY_CARD_ID ? 0.02f : float3(0.0f, 0.0f, 0.1f);

				if (IntersectionT.x <= ClosestHit && BVHNode.LumenCardId != INVALID_PROXY_CARD_ID)
				{
					PrintLumenCardId = BVHNode.LumenCardId;
					ClosestHit = IntersectionT.x;
					VisColor += .02f;
				}
			}
		}

		if (!TraverseNextBVHNode(BVH, BVHStack))
		{
			break;
		}
	}

	if (PrintLumenCardId != INVALID_PROXY_CARD_ID)
	{
		float2 TextPos = 4.0f * frac(PixelPos / float2(32.0f, 40.0f));
		VisColor = lerp(VisColor, float3(1.0f, 1.0f, 1.0f), PrintFixed(TextPos, 0, PrintLumenCardId));
	}

	RWSceneColor[PixelPos] = float4(VisColor, 1.0f);
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void VisualizeLumenVoxelsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelPos = DispatchThreadId.xy + ViewDimensions.xy;
	float2 ViewportUV = (float2(DispatchThreadId.xy) + .5f) / (ViewDimensions.zw - ViewDimensions.xy);
	float2 ScreenPosition = float2(2.0f, -2.0f) * ViewportUV + float2(-1.0f, 1.0f);
	float3 ScreenVector = mul(float4(ScreenPosition, 1, 0), View.ScreenToTranslatedWorld).xyz;


	float4 LightingAndAlpha = float4(0, 0, 0, 1);
	uint TotalNumSteps = 0;

	float RayTime = 0.0f;
	float3 RayDirection = normalize(ScreenVector);
	float3 RayOrigin = View.WorldCameraOrigin + MinTraceDistance * RayDirection;
	int3 VoxelStep = (RayDirection < 0) ? int3(-1, -1, -1) : int3(1, 1, 1);

	uint VoxelClipmapIndex = VisualizeClipmapIndex >= 0 ? VisualizeClipmapIndex : 0;
	for (uint ClipmapIndex = 0; ClipmapIndex < NumClipmapLevels; ++ClipmapIndex)
	{
		bool bOutOfRange = any(abs(RayOrigin - ClipmapWorldCenter[ClipmapIndex].xyz) > ClipmapWorldExtent[ClipmapIndex].xyz);
		VoxelClipmapIndex = bOutOfRange ? ClipmapIndex + 1 : VoxelClipmapIndex;
	}

	float VoxelSize = ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].x;
	float3 ClipmapMin = ClipmapWorldCenter[VoxelClipmapIndex].xyz - ClipmapWorldExtent[VoxelClipmapIndex].xyz;
	float3 ClipmapMax = ClipmapWorldCenter[VoxelClipmapIndex].xyz + ClipmapWorldExtent[VoxelClipmapIndex].xyz;
	int3 VoxelCoord = 64.0f * (RayOrigin - ClipmapMin) / (ClipmapMax - ClipmapMin);

	float3 VoxelMin = (VoxelCoord + 0.0f) * VoxelSize + ClipmapMin;
	float3 VoxelMax = (VoxelCoord + 1.0f) * VoxelSize + ClipmapMin;
	float3 MaxNegT = (VoxelMin - RayOrigin) / RayDirection;
	float3 MaxPosT = (VoxelMax - RayOrigin) / RayDirection;
	float3 NextVoxelFaceT = (RayDirection < 0) ? MaxNegT : MaxPosT;
	float3 VoxelFaceStepT = abs(VoxelSize / RayDirection);

	uint RayVoxelEntryFace = 6;
	uint StepIndex = 0;

	while (StepIndex < 512 && LightingAndAlpha.a > MIN_VOXEL_TRACE_TRANSPARENCY && VoxelClipmapIndex < NumClipmapLevels)
	{
		if (VoxelClipmapIndex >= NumClipmapLevels || (VisualizeClipmapIndex >= 0 && (uint)VisualizeClipmapIndex != VoxelClipmapIndex))
		{
			break;
		}

		if (RayTime > MaxTraceDistance)
		{
			break;
		}


		if (RayVoxelEntryFace < 6)
		{
			int3 LightingVolumeCoord = VoxelCoord;
			LightingVolumeCoord.y += 64 * VoxelClipmapIndex;
			LightingVolumeCoord.z += 64 * RayVoxelEntryFace;

			float4 StepLighting = VoxelLighting.Load(int4(LightingVolumeCoord, 0));
			StepLighting.w = 1.0f - StepLighting.w;

			if (StepLighting.w > 0.0f)
			{
				LightingAndAlpha.xyz = StepLighting.xyz;
				LightingAndAlpha.w = 0.0f;
				break;
			}
		}


		// Next step
		float VoxelFaceT = min3(NextVoxelFaceT.x, NextVoxelFaceT.y, NextVoxelFaceT.z);
		uint3 StepInc = int3(NextVoxelFaceT == VoxelFaceT.xxx);
		RayVoxelEntryFace = VoxelFaceFromStep(StepInc, VoxelStep);
		RayTime = VoxelFaceT;
		NextVoxelFaceT += StepInc * VoxelFaceStepT;
		VoxelCoord += StepInc * VoxelStep;


		// Next clipmap if we are out of bounds
		if (any(VoxelCoord < 0) || any(VoxelCoord >= 64))
		{
			++VoxelClipmapIndex;

			// #lumen_todo: it schould just go back to the last face of the higher climap level
			float3 SamplePosition = RayOrigin + (RayTime - 2.0f * ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].w) * RayDirection;

			VoxelSize = ClipmapVoxelSizeAndRadius[VoxelClipmapIndex].x;
			ClipmapMin = ClipmapWorldCenter[VoxelClipmapIndex].xyz - ClipmapWorldExtent[VoxelClipmapIndex].xyz;
			ClipmapMax = ClipmapWorldCenter[VoxelClipmapIndex].xyz + ClipmapWorldExtent[VoxelClipmapIndex].xyz;
			VoxelCoord = 64.0f * (SamplePosition - ClipmapMin) / (ClipmapMax - ClipmapMin);

			VoxelMin = (VoxelCoord + 0.0f) * VoxelSize + ClipmapMin;
			VoxelMax = (VoxelCoord + 1.0f) * VoxelSize + ClipmapMin;
			MaxNegT = (VoxelMin - RayOrigin) / RayDirection;
			MaxPosT = (VoxelMax - RayOrigin) / RayDirection;
			NextVoxelFaceT = (RayDirection < 0) ? MaxNegT : MaxPosT;
			VoxelFaceStepT = abs(VoxelSize / RayDirection);
		}

		++StepIndex;
	}

	FConeTraceResult TraceResult = (FConeTraceResult)0;
	TraceResult.Lighting = LightingAndAlpha.xyz;
	TraceResult.Transparency = LightingAndAlpha.w;

	EvaluateSkyRadianceForCone(RayDirection, .01f, TraceResult);

	RWSceneColor[PixelPos] = float4(TraceResult.Lighting, 1.0f);
}