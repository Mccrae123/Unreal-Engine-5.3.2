// Copyright Epic Games, Inc. All Rights Reserved.

#include "Common.ush"
#include "SceneTextureParameters.ush"
#include "LightGridCommon.ush"
#include "DeferredLightingCommon.ush"

void Main(float4 SvPosition : SV_POSITION, out float3 OutColorA : SV_Target0, out float4 OutColorB : SV_Target1)
{
	const uint2 PixelPos = SvPosition.xy;
	const float2 ScreenPosition = SvPositionToScreenPosition(SvPosition).xy;
	const uint EyeIndex = 0;

	float2 ScreenUV = ScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
	float SceneDepth = CalcSceneDepth(ScreenUV);

	float3 TranslatedWorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), PrimaryView.ScreenToTranslatedWorld).xyz;

	uint GridIndex = ComputeLightGridCellIndex(uint2(PixelPos.x, PixelPos.y), SceneDepth);
	const FCulledLightsGridData CulledLightGridData = GetCulledLightsGrid(GridIndex, EyeIndex);

	const uint NumLocalLights = min(CulledLightGridData.NumLocalLights, GetNumLocalLights(EyeIndex));

	float3 Color = uint3(0.f, 0.f , 0.f);
	float3 SavedL = float3(0,0,0);
	float TotalWeight = 0;

	LOOP
	for (uint LocalLightListIndex = 0; LocalLightListIndex < NumLocalLights; LocalLightListIndex++)
	{
		const FLocalLightData LocalLight = GetLocalLightData(CulledLightGridData.DataStartIndex + LocalLightListIndex, EyeIndex);

		// extra-early out since we know light grid is sloppy and all lights in list are radial (have a range)
		// appears useless
		float InvLightRadiusSq = LocalLight.LightPositionAndInvRadius.w * LocalLight.LightPositionAndInvRadius.w;
		float DistLight = length2(TranslatedWorldPosition - LocalLight.LightPositionAndInvRadius.xyz) * InvLightRadiusSq;
		if (DistLight > 1.0f)
		{
			continue;
		}
		FDeferredLightData LightData = ConvertToDeferredLight_Mobile(LocalLight);

		float3 L = LightData.Direction;	// Already normalized
		float3 ToLight = L;
		float3 MaskedLightColor = LightData.Color;
		float LightMask = 1;
		if (LightData.bRadialLight)
		{
			LightMask = GetLocalLightAttenuation( TranslatedWorldPosition, LightData, ToLight, L );
			MaskedLightColor *= LightMask;
		}

		float WeightLight = 1 - DistLight;
		
		if( LightMask > 0)
		{
			TotalWeight += WeightLight;
			Color += MaskedLightColor;
			SavedL += L *  WeightLight;
		}
	}

	if (TotalWeight > 0)
	{
		SavedL = (SavedL / TotalWeight);
		OutColorA = float3(Color.x, Color.y, Color.z);
		OutColorB = 0.5f * float4(SavedL.x, SavedL.y, SavedL.z, 0)  + float4(0.5f, 0.5f, 0.5f, 0.5f);
	}
	else
	{
		OutColorA = float3(0, 0, 0);
		OutColorB = float4(0.5,0.5,0.5, 0.5);
	}
}
