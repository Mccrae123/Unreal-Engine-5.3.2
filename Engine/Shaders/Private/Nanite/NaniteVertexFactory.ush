// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../VertexFactoryCommon.ush"
#include "NaniteDataDecode.ush"
#include "NaniteAttributeDecode.ush"

struct FVertexFactoryInterpolantsVSToPS
{
#if NEEDS_LIGHTMAP_COORDINATE
	nointerpolation float4 LightMapCoordinate : TEXCOORD3;
#endif
#if VF_USE_PRIMITIVE_SCENE_DATA && NEEDS_LIGHTMAP_COORDINATE
	nointerpolation uint LightmapDataIndex : LIGHTMAP_ID;
#endif
};

#if NEEDS_LIGHTMAP_COORDINATE
void GetLightMapCoordinates(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 LightmapUV0, out float2 LightmapUV1, out uint LightmapDataIndex)
{
	LightmapUV0 = Interpolants.LightMapCoordinate.xy * float2(1.0, 0.5);
	LightmapUV1 = LightmapUV0 + float2(0.0, 0.5);

#if VF_USE_PRIMITIVE_SCENE_DATA && NEEDS_LIGHTMAP_COORDINATE
	LightmapDataIndex = Interpolants.LightmapDataIndex;
#else
	LightmapDataIndex = 0;
#endif
}

void GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 ShadowMapCoordinate, out uint LightmapDataIndex)
{
#if VF_USE_PRIMITIVE_SCENE_DATA && NEEDS_LIGHTMAP_COORDINATE
	LightmapDataIndex = Interpolants.LightmapDataIndex;
#else
	LightmapDataIndex = 0;
#endif
	ShadowMapCoordinate = Interpolants.LightMapCoordinate.zw;
}

void SetLightMapCoordinate(inout FVertexFactoryInterpolantsVSToPS Interpolants, float2 InLightMapCoordinate, float2 InShadowMapCoordinate)
{
	Interpolants.LightMapCoordinate.xy = InLightMapCoordinate;
	Interpolants.LightMapCoordinate.zw = InShadowMapCoordinate;
}
#endif

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(inout FVertexFactoryInterpolantsVSToPS Interpolants, inout float4 SvPosition)
{
	FMaterialPixelParameters Result = (FMaterialPixelParameters)0;

	const uint2 PixelPos = SvPosition.xy - float2(0.5f, 0.5f);
	const UlongType Pixel = Nanite.VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(Pixel, DepthInt, VisibleClusterIndex, TriIndex);

	const FNaniteView NaniteView = GetNaniteView(0);
	
	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster           = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData          = GetInstanceData(VisibleCluster);
		FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);
		FPrimitiveSceneData PrimitiveData        = GetPrimitiveData(InstanceData.PrimitiveId);
		FCluster Cluster                         = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

		const uint3 TriIndices = ReadTriangleIndices(Cluster, TriIndex);

		const float3 PointLocal0 = DecodePosition(TriIndices.x, Cluster);
		const float3 PointLocal1 = DecodePosition(TriIndices.y, Cluster);
		const float3 PointLocal2 = DecodePosition(TriIndices.z, Cluster);

		const float4 PointClip0 = mul(float4(PointLocal0, 1), InstanceDynamicData.LocalToClip);
		const float4 PointClip1 = mul(float4(PointLocal1, 1), InstanceDynamicData.LocalToClip);
		const float4 PointClip2 = mul(float4(PointLocal2, 1), InstanceDynamicData.LocalToClip);

		const float2 PixelClip = (SvPosition.xy - View.ViewRectMin.xy) * View.ViewSizeAndInvSize.zw * float2(2, -2) + float2(-1, 1);

		// Calculate perspective correct barycentric coordinates with screen derivatives
		const FBarycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2);

		const FNaniteAttributeData AttributeData = GetAttributeData(
			Cluster,
			TriIndices,
			PointLocal0,
			PointLocal1,
			PointLocal2,
			Barycentrics,
			ClusterPageData,
			InstanceData,
			NUM_TEX_COORD_INTERPOLATORS
		);

	#if INTERPOLATE_VERTEX_COLOR
		Result.VertexColor = AttributeData.VertexColor;
	#else
		// Coerce compiler into DCE as much code as possible.
		Result.VertexColor = float4(1, 1, 1, 1);
	#endif

		Result.TangentToWorld = AttributeData.TangentToWorld;
		Result.UnMirrored = AttributeData.UnMirrored;

	#if NUM_TEX_COORD_INTERPOLATORS > 0
		UNROLL_N(NUM_TEX_COORD_INTERPOLATORS)
		for (uint TexCoordIndex = 0; TexCoordIndex < NUM_TEX_COORD_INTERPOLATORS; TexCoordIndex++)
		{
			// Protect against case where Nanite max UV count is lower than what the material may define.
			Result.TexCoords[TexCoordIndex] = (TexCoordIndex < MAX_NANITE_UVS) ? AttributeData.TexCoords[TexCoordIndex] : float2(0.0f, 0.0f);
		}
	#endif

		const float3 PointLocal = Barycentrics.UVW.x * PointLocal0 + Barycentrics.UVW.y * PointLocal1 + Barycentrics.UVW.z * PointLocal2;

		Result.PrevScreenPosition = mul( float4(PointLocal, 1), InstanceDynamicData.PrevLocalToClip );
		//Result.PrevScreenPosition = float4( Result.PrevScreenPosition.xyz / Result.PrevScreenPosition.w, 1 );

		// Update to real depth from VisBuffer
		SvPosition.z = asfloat(DepthInt);

	#if USE_PARTICLE_SUBUVS && NUM_TEX_COORD_INTERPOLATORS > 0
		// Output TexCoord0 for when previewing materials that use ParticleSubUV.
		Result.Particle.SubUVCoords[0] = Result.TexCoords[0]
		Result.Particle.SubUVCoords[1] = Result.TexCoords[0]
	#endif

		// Required for previewing materials that use ParticleColor
		Result.Particle.Color = half4(1, 1, 1, 1);

	#if NEEDS_LIGHTMAP_COORDINATE && NUM_TEX_COORD_INTERPOLATORS > 0
		const uint LightmapDataIndex = PrimitiveData.LightmapDataIndex;
		const uint LightmapUVIndex   = PrimitiveData.LightmapUVIndex;
		//UnpackLightmapDataAndUVIndex(PrimitiveData.LightmapDataAndUVIndex, LightmapDataIndex, LightmapUVIndex);

		const float2 ShadowmapUV = float2(0, 0); // TODO: Need to support going forward?
		const float2 LightmapUV  = Result.TexCoords[LightmapUVIndex];

		Interpolants.LightmapDataIndex = LightmapDataIndex;

		SetLightMapCoordinate(Interpolants, LightmapUV, ShadowmapUV);
	#else
		const float2 LightmapUV = float2(0, 0);
	#endif

	#if LIGHTMAP_UV_ACCESS
		Result.LightmapUVs = LightmapUV;
	#endif

		Result.TwoSidedSign = 1;
		Result.PrimitiveId = InstanceData.PrimitiveId;
	}

	return Result;
}

struct FVertexFactoryInterpolantsVSToDS
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
};

float2 VertexFactoryGetTextureCoordinateDS( FVertexFactoryInterpolantsVSToDS Interpolants )
{
	return float2(0,0);
}

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
{
	return Input.InterpolantsVSToPS;
}

FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
{
	return a;
}
