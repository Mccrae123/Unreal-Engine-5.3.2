// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../DeferredShadingCommon.ush"

#include "NaniteDataDecode.ush"
#include "NaniteAttributeDecode.ush"

Texture2D<UlongType> VisBuffer64;
Texture2D<float> SceneDepth;
Texture2D<uint> MaterialResolve;
ByteAddressBuffer MaterialSlotTable;
ByteAddressBuffer MaterialDepthTable;
ByteAddressBuffer MaterialEditorTable;
RWTexture2D<uint> MaterialComplexity;

// .xy = min, .zw = max
uint4 ViewRect;

float InvShaderBudget;

groupshared uint2 TileMaterialIDs[64];

[numthreads(8, 8, 1)]
void CalculateMaterialComplexity(uint3 GTID : SV_GroupThreadID, uint3 GID : SV_GroupID, uint3 DTID : SV_DispatchThreadID)
{
	//const uint2 PixelPos = min(DTID.xy + ViewRect.xy, ViewRect.zw - 1);
	const uint2 PixelPos = DTID.xy;

	uint PixelMaterialID = 0;

	const bool bInsideViewport = all(PixelPos.xy < ViewRect.zw);
	//BRANCH
	//if (bInsideViewport)
	//{
		UlongType VisPixel = VisBuffer64[PixelPos];

		uint DepthInt = 0;
		uint VisibleClusterIndex = 0;
		uint TriIndex = 0;
		UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

		const bool ValidClusterIndex = (VisibleClusterIndex != 0xFFFFFFFF);
		if (ValidClusterIndex)
		{
			FVisibleCluster VisibleCluster = GetVisibleCluster(VisibleClusterIndex);
			FInstanceSceneData InstanceData = GetInstanceSceneData(VisibleCluster, false);
			FCluster ClusterData = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
			const uint MaterialSlot = GetMaterialSlot(ClusterData, InstanceData.PrimitiveId, TriIndex, MaterialSlotTable);
			PixelMaterialID = GetMaterialDepthId(MaterialSlot, MaterialDepthTable);
		}
	//}

	const uint FlattenedIndex = GTID.x + (GTID.y * 8);
	TileMaterialIDs[FlattenedIndex] = uint2(PixelMaterialID, FlattenedIndex);

	GroupMemoryBarrierWithGroupSync();

	for (uint MergeSize = 2u; MergeSize <= 64u; MergeSize *= 2u)
	{
		for (uint MergeSubSize = MergeSize >> 1u; MergeSubSize > 0; MergeSubSize >>= 1)
		{
			uint IndexTemp = FlattenedIndex;
			uint IndexLow = IndexTemp & (MergeSubSize - 1u);
			uint IndexHigh = 2u * (IndexTemp - IndexLow);
			uint Index = IndexHigh + IndexLow;

			uint Swap = MergeSubSize == MergeSize >> 1u ? IndexHigh + (2u * MergeSubSize - 1u) - IndexLow : IndexHigh + MergeSubSize + IndexLow;
			if (Swap < 64 && Index < 64)
			{
				const uint2 A = TileMaterialIDs[Index];
				const uint2 B = TileMaterialIDs[Swap];
				if (A.x > B.x)
				{
					TileMaterialIDs[Index] = B;
					TileMaterialIDs[Swap]  = A;
				}
			}

			GroupMemoryBarrierWithGroupSync();
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(GTID.xy == 0u))
	{
		uint TileMaterialCount = 0;
		uint LastMaterialID = 0xFFFFFFFFu;
		LOOP
		for (uint Iter = 0; Iter < 64; ++Iter)
		{
			const uint IterMaterialID = TileMaterialIDs[Iter].x;
			BRANCH
			if (IterMaterialID != LastMaterialID && IterMaterialID != 0)
			{
				LastMaterialID = IterMaterialID;
				++TileMaterialCount;
			}
		}

		MaterialComplexity[GID.xy] = TileMaterialCount;
	}

	GroupMemoryBarrierWithGroupSync();
}

void ExportDebugViewPS(
	in float4 SvPosition : SV_Position,
	out float4 OutColor  : SV_Target0
)
{
	const uint2 PixelPos = (uint2)SvPosition.xy;
	const UlongType VisPixel = VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(VisPixel, DepthInt, VisibleClusterIndex, TriIndex);

	bool bValidExport = false;

	if (VisibleClusterIndex != 0xFFFFFFFFu)
	{
		const float NaniteDepth = asfloat(DepthInt);
		float SceneDepthValue = SceneDepth[PixelPos.xy];
		if (NaniteDepth >= SceneDepthValue)
		{
			FNaniteView NaniteView = GetNaniteView(0);

			bool IsNanitePixel = false;
			bool IsDecalReceiver = false;
			uint MaterialSlot = 0;
			UnpackMaterialResolve(MaterialResolve[PixelPos], IsNanitePixel, IsDecalReceiver, MaterialSlot);
			const uint MaterialEditorData = GetMaterialDepthId(MaterialSlot, MaterialEditorTable);

			const uint NumPSInstructions = (MaterialEditorData & 0xFFFF0000u) >> 16u;
			const uint NumVSInstructions = (MaterialEditorData & 0x0000FFFFu);

			// If mode is DVSM_QuadComplexity, different calculations used
			// See: FComplexityAccumulateInterface::GetDebugViewModeShaderBindings()

			// float3(PS/ShaderBudget, VS/ShaderBudget, overdraw)
			float3 NormalizedComplexity = float3(
				NumPSInstructions * InvShaderBudget,
				NumVSInstructions * InvShaderBudget,
				1.0 / 32.0f
			);

			float3 FinalComplexity = NormalizedComplexity.xyz;

			//BRANCH
			//if (bShowQuadOverdraw && NormalizedComplexity.x > 0.0f)
			//{
			//	uint Coverage = ComputeQuadCoverage(Input.SvPosition.xy, Input.PrimitiveID, 24, false, false, 0);
			//	// The extra cost from quad overdraw is assumed to be linear.
			//	FinalComplexity.x *= 4.f / (float)(Coverage);
			//}

			// use the maximum range allowed for scene color
			// alpha channel needs to be 1 to have decals working where the framebuffer blend is setup to multiply with alpha
			OutColor = float4(FinalComplexity.xyz, 1.0f);

			bValidExport = true;
		}
	}
	
	if (!bValidExport)
	{
		discard;
	}
}

