// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NaniteDataDecode.ush"

#define MAX_NANITE_UVS								4		// must match define in NaniteResources.h
#define MAX_TEXCOORD_QUANTIZATION_BITS				15		// must match define in NaniteResources.h
#define MAX_COLOR_QUANTIZATION_BITS					8		// must match define in NaniteResources.h

#define NORMAL_QUANTIZATION_BITS					9

#define VERTEX_COLOR_MODE_WHITE						0
#define VERTEX_COLOR_MODE_CONSTANT					1
#define VERTEX_COLOR_MODE_VARIABLE					2

#define SIZEOF_UV_RANGE	32
struct FUVRange
{
	float2	Min;
	float2	Scale;
	uint2	GapStart;
	uint2	GapLength;
};

FUVRange GetUVRange(ByteAddressBuffer InputBuffer, uint StartOffset, uint Index)
{
	uint Offset = StartOffset + Index * SIZEOF_UV_RANGE;
	uint4 Data[2];
	Data[0] = InputBuffer.Load4(Offset);
	Data[1] = InputBuffer.Load4(Offset + 16);

	FUVRange Range;
	Range.Min =			asfloat(Data[0].xy);
	Range.Scale =		asfloat(Data[0].zw);
	Range.GapStart =	Data[1].xy;
	Range.GapLength =	Data[1].zw;
	return Range;
}

float2 UnpackTexCoord(uint2 Packed, FUVRange UVRange)
{
	uint2 T = Packed + ((Packed >= UVRange.GapStart) ? UVRange.GapLength : 0u);
	return float2(T) * UVRange.Scale + UVRange.Min;
}

float3 UnpackNormal(uint Packed, uint Bits)
{
	uint Mask = BitFieldMaskU32(Bits, 0);
	float2 F = uint2(BitFieldExtractU32(Packed, Bits, 0), BitFieldExtractU32(Packed, Bits, Bits)) * (2.0f / Mask) - 1.0f;
	float3 N = float3(F.xy, 1.0 - abs(F.x) - abs(F.y));
	float T = saturate(-N.z);
	N.xy += N.xy >= 0.0 ? -T : T;
	return N;
}

struct FBarycentrics
{
	float3 UVW;
	float3 UVW_dx;
	float3 UVW_dy;
};

/** Calculates perspective correct barycentric coordinates and partial derivatives using screen derivatives. */
FBarycentrics CalculateTriangleBarycentrics(float2 PixelClip, float4 PointClip0, float4 PointClip1, float4 PointClip2)
{
	FBarycentrics Result;

	float3 Pos0 = PointClip0.xyz / PointClip0.w;
	float3 Pos1 = PointClip1.xyz / PointClip1.w;
	float3 Pos2 = PointClip2.xyz / PointClip2.w;

	float3 RcpW = rcp(float3(PointClip0.w, PointClip1.w, PointClip2.w));

	float3 Pos120X = float3(Pos1.x, Pos2.x, Pos0.x);
	float3 Pos120Y = float3(Pos1.y, Pos2.y, Pos0.y);
	float3 Pos201X = float3(Pos2.x, Pos0.x, Pos1.x);
	float3 Pos201Y = float3(Pos2.y, Pos0.y, Pos1.y);

	float3 C_dx = Pos201Y - Pos120Y;
	float3 C_dy = Pos120X - Pos201X;

	float3 C = C_dx * (PixelClip.x - Pos120X) + C_dy * (PixelClip.y - Pos120Y);	// Evaluate the 3 edge functions
	float3 G = C * RcpW;

	float H = dot(C, RcpW);
	float RcpH = rcp(H);

	// UVW = C * RcpW / dot(C, RcpW)
	Result.UVW = G * RcpH;

	// Texture coordinate derivatives:
	// UVW = G / H where G = C * RcpW and H = dot(C, RcpW)
	// UVW' = (G' * H - G * H') / H^2
	// float2 TexCoordDX = UVW_dx.y * TexCoord10 + UVW_dx.z * TexCoord20;
	// float2 TexCoordDY = UVW_dy.y * TexCoord10 + UVW_dy.z * TexCoord20;
	float3 G_dx = C_dx * RcpW;
	float3 G_dy = C_dy * RcpW;

	float H_dx = dot(C_dx, RcpW);
	float H_dy = dot(C_dy, RcpW);

	Result.UVW_dx = (G_dx * H - G * H_dx) * (RcpH * RcpH);
	Result.UVW_dy = (G_dy * H - G * H_dy) * (RcpH * RcpH);

	return Result;
}

uint CalculateMaxAttributeBits(uint NumTexCoordInterpolators)
{
	return (2 * NORMAL_QUANTIZATION_BITS + 4 * MAX_COLOR_QUANTIZATION_BITS + NumTexCoordInterpolators * (2 * MAX_TEXCOORD_QUANTIZATION_BITS));
}

bool IsMaterialFastPath(FCluster InCluster)
{
	return (InCluster.Material0Length > 0);
}

uint GetRelativeMaterialIndex(FCluster InCluster, uint InTriIndex)
{
	uint MaterialIndex = 0xFFFFFFFF;

	BRANCH
	if (IsMaterialFastPath(InCluster))
	{
		if (InTriIndex < InCluster.Material0Length)
		{
			MaterialIndex = InCluster.Material0Index;
		}
		else if (InTriIndex < (InCluster.Material0Length + InCluster.Material1Length))
		{
			MaterialIndex = InCluster.Material1Index;
		}
		else
		{
			MaterialIndex = InCluster.Material2Index;
		}
	}
	else
	{
		uint TableOffset = InCluster.PageBaseAddress + InCluster.MaterialTableOffset * 4;
		for (uint TableEntry = 0; TableEntry < InCluster.MaterialTableLength; ++TableEntry)
		{
			uint EncodedRange = ClusterPageData.Load(TableOffset);
			TableOffset += 4;

			// uint32 TriStart      :  8; // max 128 triangles
			// uint32 TriLength     :  8; // max 128 triangles
			// uint32 MaterialIndex :  6; // max  64 materials
			// uint32 Padding       : 10;

			const uint TriStart = (EncodedRange & 0x000000FF);
			const uint TriLength = (EncodedRange & 0x0000FF00) >> 8;
			if (InTriIndex >= TriStart && InTriIndex < (TriStart + TriLength))
			{
				MaterialIndex = (EncodedRange & 0x003F0000) >> 16;
				break;
			}
		}
	}

	return MaterialIndex;
}

uint RemapMaterialIndexToId(uint InPrimitiveIndex, uint InMaterialIndex, ByteAddressBuffer InMaterialTable)
{
	// Remap local primitive material indices (i.e. 0...8) to global indices of all primitives in current scene
	const uint MaxMaterials = 64;
	const uint RemapOffset = (InPrimitiveIndex * MaxMaterials * 4) + (InMaterialIndex * 4);
	const uint MaterialId = InMaterialTable.Load(RemapOffset);
	return MaterialId;
}

uint GetMaterialDepthId(
	FCluster InCluster,
	uint InPrimitiveIndex,
	uint InTriIndex,
	ByteAddressBuffer InMaterialDepthTable)
{
	const uint RelativeMaterialIndex = GetRelativeMaterialIndex(InCluster, InTriIndex);
	const uint MaterialDepthId = RemapMaterialIndexToId(InPrimitiveIndex, RelativeMaterialIndex, InMaterialDepthTable);
	return MaterialDepthId;
}

uint GetMaterialHitProxyId(
	FCluster InCluster,
	uint InPrimitiveIndex,
	uint InTriIndex,
	ByteAddressBuffer InMaterialHitProxyTable)
{
	const uint RelativeMaterialIndex = GetRelativeMaterialIndex(InCluster, InTriIndex);
	const uint MaterialHitProxyId = RemapMaterialIndexToId(InPrimitiveIndex, RelativeMaterialIndex, InMaterialHitProxyTable);
	return MaterialHitProxyId;
}

uint GetMaterialBucketIdFromDepth(float Depth)
{
	return (uint)(Depth * MAX_STATE_BUCKET_ID);
}