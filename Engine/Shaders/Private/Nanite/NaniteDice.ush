// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NaniteRasterizationCommon.ush"
#include "NaniteTessellation.ush"

#if NANITE_TESSELLATION

struct FDiceBase
{
	FRaster			Raster;
	FMaterialShader	Shader;
	uint			PixelValue;
	uint2			VisualizeValues;

	// Vertex cache
	//uint	FirstVert;
	//uint&	NumCached;

	template< typename FTransformBarycentrics >
	void	RasterizeDicedTriangle( uint PatchIndex, uint TriIndex, uint TessellationPattern, FTransformBarycentrics TransformBarycentrics );
};

//groupshared float3			VertexCache[ THREADGROUP_SIZE ];
//#define VertCache(x)		VertexCache[ QueueOffset + ( (x) & ( LaneCount - 1 ) ) ]

template< typename FTransformBarycentrics >
void FDiceBase::RasterizeDicedTriangle( uint PatchIndex, uint TriIndex, uint TessellationPattern, FTransformBarycentrics TransformBarycentrics )
{
	FTessellatedPatch TessellatedPatch = GetTessellatedPatch( TessellationPattern );
	
	uint3 VertIndexes = TessellatedPatch.GetIndexes( TriIndex );

	// TODO
	bool bReverseWindingOrder = false;
	if( bReverseWindingOrder )
		VertIndexes.yz = VertIndexes.zy;
	
	float4 Verts[3];
	
#if 0
	// Grab what's there for this triangle before updating cache. Otherwise cache would need to be double size.
	bool3 VertRead = false;

	UNROLL
	for( uint k = 0; k < 3; k++ )
	{
		if( FirstVert + VertIndexes[k] < NumCached )
		{
			Verts[k] = VertCache( FirstVert + VertIndexes[k] );
			VertRead[k] = true;
		}
	}

	GroupMemoryBarrier();
			
	bool bNewVertex = PackedIndexes & (1 << 30);
	if( bNewVertex )
	{
		uint MaxVertIndex = max3( VertIndexes.x, VertIndexes.y, VertIndexes.z );

		float3 UVW = TessellatedPatch.GetVert( MaxVertIndex );
		UVW = TransformBarycentrics( UVW );

		FBarycentrics Barycentrics;
		Barycentrics.UVW 	= UVW;
		Barycentrics.UVW_dx	= 0;
		Barycentrics.UVW_dy	= 0;

		VertCache( FirstVert + MaxVertIndex ) = CalculateSubpixelCoordinates( Raster, Shader.EvaluateDomain( Barycentrics ) );
	}
			
	GroupMemoryBarrier();

	NumCached += WaveActiveCountBits( bNewVertex );		//FIXME this increments LocalTask.NumCached which goes no where. Need persistent scalar. Need references!

	UNROLL
	for( uint k = 0; k < 3; k++ )
	{
		if( !VertRead[k] )
			Verts[k] = VertCache( FirstVert + VertIndexes[k] );
	}
#else
	float3 TessFactors = TessellatedPatch.GetTessFactors();

	UNROLL
	for( uint i = 0; i < 3; i++ )
	{
		FBarycentrics Barycentrics;
		Barycentrics.UVW	= TessellatedPatch.GetVert( VertIndexes[i] );
		Barycentrics.UVW_dx	= 0;
		Barycentrics.UVW_dy	= 0;
		Barycentrics.UVW	= TransformBarycentrics( Barycentrics.UVW );

		//Barycentrics.UVW_dx	= float3( -1, 1, 0 ) / TessFactors.x;
		//Barycentrics.UVW_dy	= float3( 0, -1, 1 ) / TessFactors.y;
		//Barycentrics.UVW_dx	= TransformBarycentrics( Barycentrics.UVW_dx );
		//Barycentrics.UVW_dy	= TransformBarycentrics( Barycentrics.UVW_dy );

		Verts[i] = CalculateSubpixelCoordinates( Raster, Shader.EvaluateDomain( Barycentrics ) );
	}
#endif

	FRasterTri Tri = SetupTriangle< NANITE_SUBPIXEL_SAMPLES, !NANITE_TWO_SIDED >( Raster.ScissorRect, Verts );

	if( Tri.bIsValid )
	{
	#if VIRTUAL_TEXTURE_TARGET && NANITE_LATE_VSM_PAGE_TRANSLATION
		if (!Raster.bSinglePage)
		{
			TNaniteWritePixel< FMaterialShader, FCachedPageTable > NaniteWritePixel = { Raster, Shader, PixelValue | PatchIndex, VisualizeValues };
			RasterizeTri_Rect( Tri, NaniteWritePixel );
		}
		else
	#elif VIRTUAL_TEXTURE_TARGET
		if (!Raster.bSinglePage)
		{
			TNaniteWritePixel< FMaterialShader, FFetchPageTable > NaniteWritePixel =
			{
				Raster,
				Shader,
				PixelValue | PatchIndex,
				VisualizeValues,
				Shader.NaniteView.TargetMipLevel,
				CalcPageTableLevelOffset( Shader.NaniteView.TargetLayerIndex, Shader.NaniteView.TargetMipLevel ).LevelOffset
			};
			
			RasterizeTri_Rect( Tri, NaniteWritePixel );
		}
		else
	#endif
		{
			TNaniteWritePixel< FMaterialShader > NaniteWritePixel = { Raster, Shader, PixelValue | PatchIndex, VisualizeValues };
		#if VISUALIZE
			NaniteWritePixel.VisualizeValues.x = TriIndex;
		#endif
			//Shader.TransformedTri = TransformedTri;	// FIXME this should be the diced tri not the patch
				
			RasterizeTri_Rect( Tri, NaniteWritePixel );
		}
	}
}


struct FClusterDiceTask
{
	FDiceBase				Base;
	FNaniteTransformedVert	Vert;

	uint	PatchData;
	uint	TessellationPattern;

	// Vertex cache
	//uint	FirstVert;
	//uint	NumCached;

	void				Create( float3 TessFactors, uint3 VertIndexes, uint TriIndex, inout uint NumVerts, inout uint NumTris );
	FClusterDiceTask	CreateChild( uint ParentIndex );
	void				RunChild( uint LocalItemIndex );
};

void FClusterDiceTask::Create( float3 TessFactors, uint3 VertIndexes, uint TriIndex, inout uint NumVerts, inout uint NumTris )
{
	TessellationPattern = GetTessellationTablePattern( TessFactors, VertIndexes, NumVerts, NumTris );
	
	PatchData  = VertIndexes.x << 0;
	PatchData |= VertIndexes.y << 8;
	PatchData |= VertIndexes.z << 16;
	PatchData |= TriIndex << 24;
}

FClusterDiceTask FClusterDiceTask::CreateChild( uint ParentIndex )
{
	// "this" is broken: https://github.com/microsoft/DirectXShaderCompiler/issues/4914
	FClusterDiceTask ChildTask;// = this;
	ChildTask.Base = Base;
	ChildTask.PatchData				= WaveReadLaneAt( PatchData, ParentIndex );
	ChildTask.TessellationPattern	= WaveReadLaneAt( TessellationPattern, ParentIndex );
	//ChildTask.FirstVert				= WaveReadLaneAt( FirstVert, ParentIndex );

	uint3 PatchVertIndexes;
	PatchVertIndexes.x = ( ChildTask.PatchData >>  0 ) & 0xff;
	PatchVertIndexes.y = ( ChildTask.PatchData >>  8 ) & 0xff;
	PatchVertIndexes.z = ( ChildTask.PatchData >> 16 ) & 0xff;

	FNaniteTransformedTri TransformedTri = MakeTransformedNaniteTriangle( Vert, PatchVertIndexes );
	ChildTask.Base.Shader.TransformedTri = TransformedTri;	// TODO mutable. This is weird

	return ChildTask;
}

void FClusterDiceTask::RunChild( uint LocalItemIndex )
{
	struct
	{
		float3 operator()( float3 Barycentrics )
		{
			return Barycentrics;
		}
	} TransformBarycentrics;

	Base.RasterizeDicedTriangle( PatchData >> 24, LocalItemIndex, TessellationPattern, TransformBarycentrics );
}


struct FPatchDiceTask
{
	FDiceBase	Base;
	uint4		Encoded;
	uint		TessellationPattern;

	void			Create( float3 TessFactors, inout uint NumVerts, inout uint NumTris );
	FPatchDiceTask	CreateChild( uint ParentIndex );
	void			RunChild( uint LocalItemIndex );
};

void FPatchDiceTask::Create( float3 TessFactors, inout uint NumVerts, inout uint NumTris )
{
	TessellationPattern = GetTessellationTablePattern( TessFactors, Encoded.yzw, NumVerts, NumTris );
}

FPatchDiceTask FPatchDiceTask::CreateChild( uint ParentIndex )
{
	// "this" is broken: https://github.com/microsoft/DirectXShaderCompiler/issues/4914
	FPatchDiceTask ChildTask;// = this;
	ChildTask.Base = Base;
	ChildTask.Encoded				= WaveReadLaneAt( Encoded, ParentIndex );
	ChildTask.TessellationPattern	= WaveReadLaneAt( TessellationPattern, ParentIndex );

	for( uint k = 0; k < 3; k++ )
		ChildTask.Base.Shader.TransformedTri.Verts[k] = WaveReadLaneAt( Base.Shader.TransformedTri.Verts[k], ParentIndex );

	return ChildTask;
}

void FPatchDiceTask::RunChild( uint LocalItemIndex )
{
	FSplitPatch Patch;
	Patch.Decode( Encoded );

	struct
	{
		FSplitPatch Patch;

		float3 operator()( float3 Barycentrics )
		{
			return
				Patch.Barycentrics[0] * Barycentrics.x +
				Patch.Barycentrics[1] * Barycentrics.y +
				Patch.Barycentrics[2] * Barycentrics.z;
		}
	} TransformBarycentrics;
	TransformBarycentrics.Patch = Patch;

	Base.RasterizeDicedTriangle( Patch.TriIndex, LocalItemIndex, TessellationPattern, TransformBarycentrics );
}


struct FClusterSplitTask
{
	uint4	Encoded;
	uint	TessellationPattern;

	void				Init( uint VisibleClusterIndex, uint TriIndex );

	FClusterSplitTask	CreateChild( uint ParentLaneIndex );
	void				RunChild( uint LocalItemIndex );
};

void FClusterSplitTask::Init( uint VisibleClusterIndex, uint TriIndex )
{
	Encoded.x = ( VisibleClusterIndex << 7 ) | TriIndex;
	Encoded.y = BarycentricMax;
	Encoded.z = BarycentricMax << 16;
	Encoded.w = 0;
}

FClusterSplitTask FClusterSplitTask::CreateChild( uint ParentLaneIndex )
{
	FClusterSplitTask ChildTask;//= this;
	ChildTask.Encoded				= WaveReadLaneAt( Encoded, ParentLaneIndex );
	ChildTask.TessellationPattern	= WaveReadLaneAt( TessellationPattern, ParentLaneIndex );

	return ChildTask;
}

void FClusterSplitTask::RunChild( uint LocalItemIndex )
{
	FTessellatedPatch TessellatedPatch = GetTessellatedPatch( TessellationPattern );

#if 0
	Encoded.yzw = TessellatedPatch.GetTriangleEncoded( LocalItemIndex );
#else
	FSplitPatch Patch;
	Patch.Decode( Encoded );
		
	uint3 VertIndexes = TessellatedPatch.GetIndexes( LocalItemIndex );

	for( int i = 0; i < 3; i++ )
	{
		float3 Barycentrics = TessellatedPatch.GetVert( VertIndexes[i] );

		Barycentrics = 
			Patch.Barycentrics[0] * Barycentrics.x +
			Patch.Barycentrics[1] * Barycentrics.y +
			Patch.Barycentrics[2] * Barycentrics.z;
		
		Encoded[ i + 1 ] = EncodeBarycentrics( Barycentrics );
	}
#endif

	uint WriteOffset = SplitWorkQueue.Add();
	if( WriteOffset < SplitWorkQueue.Size )
	{
		checkSlow(
			Encoded.x != ~0u &&
			Encoded.y != ~0u &&
			Encoded.z != ~0u &&
			Encoded.w != ~0u );

		SplitWorkQueue.DataBuffer.Store4( WriteOffset * 16, Encoded );
	}
}

#endif