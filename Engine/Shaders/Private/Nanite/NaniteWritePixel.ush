// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "/Engine/Shared/NaniteDefinitions.h"
#if VIRTUAL_TEXTURE_TARGET
#include "../VirtualShadowMaps/VirtualShadowMapPageAccessCommon.ush"
#endif

RWTexture2D<uint>		OutDepthBuffer;
RWTexture2DArray<uint>	OutDepthBufferArray;
RWTexture2D<UlongType>	OutVisBuffer64;

#if VISUALIZE
RWTexture2D<UlongType>	OutDbgBuffer64;
RWTexture2D<uint>		OutDbgBuffer32;
#endif

bool ShouldWritePixel(
	RWTexture2D<UlongType> OutBuffer,
	uint2 PixelPos,
	float DeviceZ
)
{
	// When near clipping is disabled we need to move the geometry
	DeviceZ = saturate(DeviceZ);

	const uint DepthInt = asuint(DeviceZ);

#if DEPTH_ONLY
	return OutDepthBuffer[PixelPos] < DepthInt;
#elif COMPILER_SUPPORTS_UINT64_IMAGE_ATOMICS
	return UnpackUlongType(OutBuffer[PixelPos]).y < DepthInt;
#else
	#error UNKNOWN_ATOMIC_PLATFORM
	return false;
#endif
}

void WritePixel(
	RWTexture2D<UlongType> OutBuffer,
	uint PixelValue,
	uint2 PixelPos,
	float DeviceZ
)
{
	// When near clipping is disabled we need to move the geometry 
	DeviceZ = saturate(DeviceZ);

	const uint DepthInt = asuint(DeviceZ);

#if DEPTH_ONLY
	InterlockedMax( OutDepthBuffer[ PixelPos ], DepthInt );
#elif COMPILER_SUPPORTS_UINT64_IMAGE_ATOMICS
	const UlongType Pixel = PackUlongType(uint2(PixelValue, DepthInt));
	ImageInterlockedMaxUInt64(OutBuffer, PixelPos, Pixel);
#else
	#error UNKNOWN_ATOMIC_PLATFORM
#endif
}

// Optional per-pixel page translation parameters
struct WritePixelPageTranslation
{
	// TODO: We could optimize this slightly be precomputing the base layer/level offset
	int TargetLayerIndex;
	int TargetMipLevel;
	uint ArrayIndex;
};

WritePixelPageTranslation InitializeWritePixelPageTranslation()
{
	WritePixelPageTranslation Result;
	Result.TargetLayerIndex = INDEX_NONE;
	Result.TargetMipLevel = 0;
	Result.ArrayIndex = 0;
	return Result;
}

WritePixelPageTranslation InitializeWritePixelPageTranslation( FNaniteView NaniteView, bool bStaticPage )
{
	WritePixelPageTranslation Result;
	Result.TargetLayerIndex = NaniteView.TargetLayerIndex;
	Result.TargetMipLevel = NaniteView.TargetMipLevel;
	Result.ArrayIndex = bStaticPage ? GetVirtualShadowMapStaticArrayIndex() : 0;
	return Result;
}

#if DEPTH_ONLY

// Determines final write position with an optional per-pixel page translation
bool VirtualToPhysicalTexel(uint2 VirtualPixelPos, WritePixelPageTranslation PageTranslation, out uint3 PhysicalPixelPos)
{
	PhysicalPixelPos = uint3(VirtualPixelPos, PageTranslation.ArrayIndex);

#if VIRTUAL_TEXTURE_TARGET
	if( PageTranslation.TargetLayerIndex != INDEX_NONE )
	{
		if( !VirtualToPhysicalTexel(PageTranslation.TargetLayerIndex, PageTranslation.TargetMipLevel, VirtualPixelPos, PhysicalPixelPos.xy) )
		{
			// mapped to non-commited space.
			return false;
		}
	}
#endif

	return true;
}

// Allows you to pre-translate the virtual pixel position to physical and perform an early depth test before calling WriteDepthTextureArray
bool ShouldWriteDepthTextureArray(
	uint2 VirtualPixelPos,
	WritePixelPageTranslation PageTranslation,
	float DeviceZ,
	out uint3 PhysicalPixelPos
)
{
	if (!VirtualToPhysicalTexel(VirtualPixelPos, PageTranslation, PhysicalPixelPos))
	{
		// mapped to non-commited space.
		return false;
	}

	// When near clipping is disabled we need to move the geometry 
	DeviceZ = saturate(DeviceZ);

	const uint DepthInt = asuint(DeviceZ);
	return OutDepthBufferArray[PhysicalPixelPos] < DepthInt;
}

// Write depth pixel. Supports array texture targets (third coordinate of PhysicalPixelPos)
void WriteDepthTextureArray(uint3 PhysicalPixelPos, float DeviceZ)
{
	// When near clipping is disabled we need to move the geometry 
	DeviceZ = saturate(DeviceZ);

	const uint DepthInt = asuint(DeviceZ);
	InterlockedMax( OutDepthBufferArray[ PhysicalPixelPos ], DepthInt );
}

// Write depth pixel with optional per-pixel page translation
void WriteDepthTextureArray(
	uint2 VirtualPixelPos,
	WritePixelPageTranslation PageTranslation,
	float DeviceZ
)
{
	uint3 PhysicalPixelPos;
	if (!VirtualToPhysicalTexel(VirtualPixelPos, PageTranslation, PhysicalPixelPos))
	{
		// mapped to non-commited space.
		return;
	}

	WriteDepthTextureArray(PhysicalPixelPos, DeviceZ);
}

#endif
