// Copyright Epic Games, Inc. All Rights Reserved.

#include "NaniteShadeCommon.ush"

uint4 ViewRect;
uint ShadingBinCount;

#if (SHADING_BIN_PASS == NANITE_SHADING_BIN_CLASSIFY)
	#define SHADING_BIN_CLASSIFY	1
	#define SHADING_BIN_RESERVE		0
	#define SHADING_BIN_SCATTER		0
#elif (SHADING_BIN_PASS == NANITE_RASTER_BIN_SCATTER)
	#define SHADING_BIN_CLASSIFY	0
	#define SHADING_BIN_RESERVE		0
	#define SHADING_BIN_SCATTER		1
#else
	#define SHADING_BIN_CLASSIFY	0
	#define SHADING_BIN_RESERVE		1
	#define SHADING_BIN_SCATTER		0
#endif

#define GATHER4_OPTIMIZATION 0
#define STATS_SAMPLE_COUNT 0

#if SHADING_BIN_SCATTER && VARIABLE_SHADING_RATE
uint ShadingRateTileSize;
Texture2D<uint> ShadingRateImage;
#endif

#if SHADING_BIN_CLASSIFY || SHADING_BIN_SCATTER
Texture2D<uint> ShadingMask;
SamplerState ShadingMaskSampler;
#endif

// .x = Quad count shaded by bin
// .y = Pixel count shaded by bin
// .z = Quad coord range start
// .w = Reserved
RWStructuredBuffer<uint4> OutShadingBinMeta;

#if SHADING_BIN_RESERVE
RWStructuredBuffer<uint> OutShadingBinAllocator;
RWBuffer<uint> OutShadingBinArgs;
#endif

#if SHADING_BIN_SCATTER
RWStructuredBuffer<uint> OutShadingBinQuads;
#endif

#if SHADING_BIN_CLASSIFY || SHADING_BIN_SCATTER

[numthreads(8, 8, 1)]
void ShadingBinBuildCS(uint2 ThreadGlobalId : SV_DispatchThreadID, uint2 GroupId : SV_GroupID, uint ThreadId : SV_GroupIndex)
{
	const uint ViewWidth  = ViewRect.z - ViewRect.x;
	const uint ViewHeight = ViewRect.w - ViewRect.y;

	const uint2 QuadTLCoord = uint2(ThreadGlobalId.xy << 1u) + uint2(ViewRect.xy);
	const uint2 QuadTRCoord = QuadTLCoord + uint2(1, 0);
	const uint2 QuadBLCoord = QuadTLCoord + uint2(0, 1);
	const uint2 QuadBRCoord = QuadTLCoord + uint2(1, 1);

#if GATHER4_OPTIMIZATION
	uint4 QuadShadingMask = ShadingMask.GatherRed(ShadingMaskSampler, float2(QuadTLCoord + 0.5f) / float2(ViewRect.z, ViewRect.w)).wzxy;
#else
	uint4 QuadShadingMask;
	QuadShadingMask.x = ShadingMask[QuadTLCoord];
	QuadShadingMask.y = ShadingMask[QuadTRCoord];
	QuadShadingMask.z = ShadingMask[QuadBLCoord];
	QuadShadingMask.w = ShadingMask[QuadBRCoord];
#endif

	FShadingMask ShadingMaskTL = UnpackShadingMask(QuadShadingMask.x);
	FShadingMask ShadingMaskTR = UnpackShadingMask(QuadShadingMask.y);
	FShadingMask ShadingMaskBL = UnpackShadingMask(QuadShadingMask.z);
	FShadingMask ShadingMaskBR = UnpackShadingMask(QuadShadingMask.w);

	const bool4 ValidMask = bool4(
		QuadTLCoord.x < ViewWidth,
		QuadTLCoord.y < ViewHeight,
		QuadTLCoord.x < ViewWidth  - 1u,
		QuadTLCoord.y < ViewHeight - 1u
	);

	const bool4 ValidPixels = bool4(
		all(ValidMask.xy) && ShadingMaskTL.bIsNanitePixel,
		all(ValidMask.zy) && ShadingMaskTR.bIsNanitePixel,
		all(ValidMask.xw) && ShadingMaskBL.bIsNanitePixel,
		all(ValidMask.zw) && ShadingMaskBR.bIsNanitePixel
	);

	if (!any(ValidPixels))
	{
		// Quad is entirely non-Nanite
		return;
	}

#if SHADING_BIN_SCATTER && VARIABLE_SHADING_RATE
	uint WaveShadingRate = D3D12_SHADING_RATE_1X1;
	if (WaveIsFirstLane() && ShadingRateTileSize != 0)
	{
		// Retrieve the variable shading rate that governs the 2x2 quads within the VRS tile boundary (8x8, 16x16, or 32x32)
		WaveShadingRate = ShadingRateImage[QuadTLCoord.xy / ShadingRateTileSize.xx] & 0xFu;
	}

	// Propagate the shading rate to all lanes in wave
	WaveShadingRate = WaveReadLaneFirst(WaveShadingRate);
#endif

	uint4 SampleBins = uint4(
		ShadingMaskTL.ShadingBin,
		ShadingMaskTR.ShadingBin,
		ShadingMaskBL.ShadingBin,
		ShadingMaskBR.ShadingBin
	);

	const uint LaneIndex = WaveGetLaneIndex();

	uint SampleMask = PackQuadCoverage(ValidPixels);
	while (WaveActiveAnyTrue(SampleMask != 0u))
	{
		// Activate all quad lanes that have not fully counted all samples yet
		if (SampleMask != 0u)
		{
			// Determine current shading bin to count
			const uint CurrentBinIndex = firstbitlow(SampleMask);
			const uint CurrentBin = WaveReadLaneFirst(SampleBins[CurrentBinIndex]);

			uint Coverage = 0u;

			UNROLL
			for (uint SampleIndex = 0u; SampleIndex < 4u; ++SampleIndex)
			{
				const uint CoverageMask = (1u << SampleIndex);
				const bool bSampleActive = (SampleMask & CoverageMask) != 0u;
				if (bSampleActive && SampleBins[SampleIndex] == CurrentBin)
				{
					SampleMask &= ~CoverageMask;
					Coverage   |=  CoverageMask;
				}
			}

			const uint BinQuadCount = WaveActiveCountBits(Coverage != 0u);

	#if SHADING_BIN_CLASSIFY
		#if STATS_SAMPLE_COUNT
			const uint SampleCount  = countbits(Coverage);
			const uint BinSampleCount = WaveActiveSum(SampleCount);
		#endif
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[CurrentBin].x, BinQuadCount);
			#if STATS_SAMPLE_COUNT
				InterlockedAdd(OutShadingBinMeta[CurrentBin].y, BinSampleCount);
			#endif
			}
	#elif SHADING_BIN_SCATTER
			uint WaveWriteOffset;
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[CurrentBin].x, BinQuadCount, WaveWriteOffset);
				WaveWriteOffset += OutShadingBinMeta[CurrentBin].z;
			}
			WaveWriteOffset = WaveReadLaneFirst(WaveWriteOffset);

			const uint QuadWriteOffset = WavePrefixCountBits(Coverage != 0u);
			if (Coverage != 0u)
			{
				OutShadingBinQuads[WaveWriteOffset + QuadWriteOffset] = PackShadingQuad(QuadTLCoord, Coverage);
			}
	#endif
		}
	}
}

#elif SHADING_BIN_RESERVE

[numthreads(64, 1, 1)]
void ShadingBinReserveCS(uint ShadingBin : SV_DispatchThreadID)
{
	if (ShadingBin < ShadingBinCount)
	{
		const uint BinQuadCount = OutShadingBinMeta[ShadingBin].x;

		if (BinQuadCount > 0)
		{
			uint RangeStart;
			InterlockedAdd(OutShadingBinAllocator[0], BinQuadCount, RangeStart);
			OutShadingBinMeta[ShadingBin].x = 0;
			OutShadingBinMeta[ShadingBin].z = RangeStart;
		}

		const uint ArgsOffset = ShadingBin * 4u;

		// Includes helper lanes
		const uint BinPixelCount = BinQuadCount * 4u;

		OutShadingBinArgs[ArgsOffset + 0] = (BinPixelCount + 63u) / 64u;	// ThreadGroupCountX
		OutShadingBinArgs[ArgsOffset + 1] = 1;								// ThreadGroupCountY
		OutShadingBinArgs[ArgsOffset + 2] = 1;								// ThreadGroupCountZ
		OutShadingBinArgs[ArgsOffset + 3] = 0;								// padding
	}
}

#endif
