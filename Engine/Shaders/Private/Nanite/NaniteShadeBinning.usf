// Copyright Epic Games, Inc. All Rights Reserved.

#include "NaniteShadeCommon.ush"

uint4 ViewRect;
uint ShadingBinCount;

#if (SHADING_BIN_PASS == NANITE_SHADING_BIN_COUNT)
	#define SHADING_BIN_COUNT		1
	#define SHADING_BIN_RESERVE		0
	#define SHADING_BIN_SCATTER		0
#elif (SHADING_BIN_PASS == NANITE_RASTER_BIN_SCATTER)
	#define SHADING_BIN_COUNT		0
	#define SHADING_BIN_RESERVE		0
	#define SHADING_BIN_SCATTER		1
#else
	#define SHADING_BIN_COUNT		0
	#define SHADING_BIN_RESERVE		1
	#define SHADING_BIN_SCATTER		0
#endif

#define GATHER4_OPTIMIZATION 0

#if SHADING_BIN_SCATTER && VARIABLE_SHADING_RATE
uint ShadingRateTileSize;
Texture2D<uint> ShadingRateImage;
#endif

#if SHADING_BIN_COUNT || SHADING_BIN_SCATTER
Texture2D<uint> ShadingMask;
SamplerState ShadingMaskSampler;
#endif

// .x = Quad count shaded by bin
// .y = Pixel count shaded by bin
// .z = Quad coord range start
// .w = Reserved
RWStructuredBuffer<uint4> OutShadingBinMeta;

#if SHADING_BIN_RESERVE
RWStructuredBuffer<uint> OutShadingBinAllocator;
RWBuffer<uint> OutShadingBinArgs;
#endif

#if SHADING_BIN_SCATTER
RWStructuredBuffer<uint> OutShadingBinData;
#endif

#if SHADING_BIN_COUNT || SHADING_BIN_SCATTER

[numthreads(8, 8, 1)]
void ShadingBinBuildCS(uint2 ThreadGlobalId : SV_DispatchThreadID, uint2 GroupId : SV_GroupID, uint ThreadId : SV_GroupIndex)
{
	const uint ViewWidth  = ViewRect.z - ViewRect.x;
	const uint ViewHeight = ViewRect.w - ViewRect.y;

	const uint2 QuadTLCoord = uint2(ThreadGlobalId.xy << 1u) + uint2(ViewRect.xy);

	// .x = TL, .y = TR, .z = BL, .w = BR
	const uint2 QuadCoords[4] =
	{
		QuadTLCoord,
		QuadTLCoord + uint2(1, 0),
		QuadTLCoord + uint2(0, 1),
		QuadTLCoord + uint2(1, 1)
	};

#if GATHER4_OPTIMIZATION
	uint4 QuadShadingMask = ShadingMask.GatherRed(ShadingMaskSampler, float2(QuadTLCoord + 0.5f) / float2(ViewRect.z, ViewRect.w)).wzxy;
#else
	uint4 QuadShadingMask;
	QuadShadingMask.x = ShadingMask[QuadCoords[0]];
	QuadShadingMask.y = ShadingMask[QuadCoords[1]];
	QuadShadingMask.z = ShadingMask[QuadCoords[2]];
	QuadShadingMask.w = ShadingMask[QuadCoords[3]];
#endif

	FShadingMask ShadingMaskTL = UnpackShadingMask(QuadShadingMask.x);
	FShadingMask ShadingMaskTR = UnpackShadingMask(QuadShadingMask.y);
	FShadingMask ShadingMaskBL = UnpackShadingMask(QuadShadingMask.z);
	FShadingMask ShadingMaskBR = UnpackShadingMask(QuadShadingMask.w);

	const bool4 ValidMask = bool4(
		QuadTLCoord.x < ViewWidth,
		QuadTLCoord.y < ViewHeight,
		QuadTLCoord.x < ViewWidth  - 1u,
		QuadTLCoord.y < ViewHeight - 1u
	);

	const bool4 ValidPixels = bool4(
		all(ValidMask.xy) && ShadingMaskTL.bIsNanitePixel,
		all(ValidMask.zy) && ShadingMaskTR.bIsNanitePixel,
		all(ValidMask.xw) && ShadingMaskBL.bIsNanitePixel,
		all(ValidMask.zw) && ShadingMaskBR.bIsNanitePixel
	);

	if (!any(ValidPixels))
	{
		// Quad is entirely non-Nanite
		return;
	}

	uint4 CopyMasks = uint4(0, 0, 0, 0);

#if SHADING_BIN_SCATTER && VARIABLE_SHADING_RATE
	uint WaveShadingRate = D3D12_SHADING_RATE_1X1;
	if (WaveIsFirstLane() && ShadingRateTileSize != 0)
	{
		// Retrieve the variable shading rate that governs the 2x2 quads within the VRS tile boundary (8x8, 16x16, or 32x32)
		WaveShadingRate = ShadingRateImage[QuadTLCoord.xy / ShadingRateTileSize.xx] & 0xFu;
	}

	// Propagate the shading rate to all lanes in wave
	WaveShadingRate = WaveReadLaneFirst(WaveShadingRate);
#endif

	uint4 SampleBins = uint4(
		ShadingMaskTL.ShadingBin,
		ShadingMaskTR.ShadingBin,
		ShadingMaskBL.ShadingBin,
		ShadingMaskBR.ShadingBin
	);

	const uint LaneIndex = WaveGetLaneIndex();

	uint SampleMask = PackQuadCoverage(ValidPixels);
	while (WaveActiveAnyTrue(SampleMask != 0u))
	{
		// Activate all quad lanes that have not fully counted all samples yet
		if (SampleMask != 0u)
		{
			// Determine current shading bin to count
			const uint CurrentBinIndex = firstbitlow(SampleMask);
			const uint CurrentBin = WaveReadLaneFirst(SampleBins[CurrentBinIndex]);

			uint Coverage = 0u;

			UNROLL
			for (uint SampleIndex = 0u; SampleIndex < 4u; ++SampleIndex)
			{
				const uint CoverageMask = (1u << SampleIndex);
				const bool bSampleActive = (SampleMask & CoverageMask) != 0u;
				if (bSampleActive && SampleBins[SampleIndex] == CurrentBin)
				{
					SampleMask &= ~CoverageMask;
					Coverage   |=  CoverageMask;
				}
			}

		#if !QUAD_BINNING || GATHER_STATS
			const uint SampleCount  = countbits(Coverage);
			const uint BinSampleCount = WaveActiveSum(SampleCount);
		#endif

	#if QUAD_BINNING
			const uint BinQuadCount = WaveActiveCountBits(Coverage != 0u);
		#if SHADING_BIN_COUNT
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[CurrentBin].x, BinQuadCount);
			#if GATHER_STATS
				InterlockedAdd(OutShadingBinMeta[CurrentBin].y, BinSampleCount);
			#endif
			}
		#elif SHADING_BIN_SCATTER
			uint WaveWriteOffset;
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[CurrentBin].x, BinQuadCount, WaveWriteOffset);
				WaveWriteOffset += OutShadingBinMeta[CurrentBin].z;
			}
			WaveWriteOffset = WaveReadLaneFirst(WaveWriteOffset);

			const uint QuadWriteOffset = WavePrefixCountBits(Coverage != 0u);
			if (Coverage != 0u)
			{
				OutShadingBinData[WaveWriteOffset + QuadWriteOffset] = PackShadingQuad(QuadTLCoord, Coverage);
			}
		#endif
	#else // QUAD_BINNING
		#if SHADING_BIN_COUNT
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[CurrentBin].y, BinSampleCount);
			}
		#elif SHADING_BIN_SCATTER
			uint WaveWriteOffset;
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[CurrentBin].y, BinSampleCount, WaveWriteOffset);
				WaveWriteOffset += OutShadingBinMeta[CurrentBin].z;
			}
			WaveWriteOffset = WaveReadLaneFirst(WaveWriteOffset);

			const uint LaneWriteOffset = WavePrefixSum(SampleCount);

			UNROLL
			for (uint SampleIndex = 0u; SampleIndex < 4u; ++SampleIndex)
			{
				if ((Coverage & (1u << SampleIndex)) != 0u)
				{
					OutShadingBinData[WaveWriteOffset + LaneWriteOffset + SampleIndex] = PackShadingPixel(QuadCoords[SampleIndex], CopyMasks[SampleIndex]);
				}
			}
		#endif
	#endif // QUAD_BINNING
		}
	}
}

#elif SHADING_BIN_RESERVE

#if GATHER_STATS
// .x = total quad count
// .y = total pixel count
// .z = total helper count
// .w = unused
RWStructuredBuffer<uint4> OutShadingBinStats;
#endif

[numthreads(64, 1, 1)]
void ShadingBinReserveCS(uint ShadingBin : SV_DispatchThreadID)
{
	if (ShadingBin < ShadingBinCount)
	{
#if QUAD_BINNING
		const uint BinQuadCount = OutShadingBinMeta[ShadingBin].x;

		if (BinQuadCount > 0)
		{
			uint RangeStart;
			InterlockedAdd(OutShadingBinAllocator[0], BinQuadCount, RangeStart);
			OutShadingBinMeta[ShadingBin].x = 0;
			OutShadingBinMeta[ShadingBin].z = RangeStart;
		}

		const uint ArgsOffset = ShadingBin * 4u;

		// Includes helper lanes
		const uint BinPixelCount = BinQuadCount * 4u;

	#if GATHER_STATS
		const uint BinSampleCount		= OutShadingBinMeta[ShadingBin].y;
		const uint BinHelperCount		= BinPixelCount - BinSampleCount;
		const uint WaveBinQuadCount		= WaveActiveSum(BinQuadCount);
		const uint WaveBinPixelCount	= WaveActiveSum(BinPixelCount);
		const uint WaveBinHelperCount	= WaveActiveSum(BinHelperCount);
		if (WaveIsFirstLane())
		{
			InterlockedAdd(OutShadingBinStats[0].x, WaveBinQuadCount);
			InterlockedAdd(OutShadingBinStats[0].y, WaveBinPixelCount);
			InterlockedAdd(OutShadingBinStats[0].z, WaveBinHelperCount);
		}
	#endif
#else // QUAD_BINNING
		const uint BinPixelCount = OutShadingBinMeta[ShadingBin].y;

		if (BinPixelCount > 0)
		{
			uint RangeStart;
			InterlockedAdd(OutShadingBinAllocator[0], BinPixelCount, RangeStart);
			OutShadingBinMeta[ShadingBin].y = 0;
			OutShadingBinMeta[ShadingBin].z = RangeStart;
		}

		const uint ArgsOffset = ShadingBin * 4u;

	#if GATHER_STATS
		const uint WaveBinPixelCount = WaveActiveSum(BinPixelCount);
		if (WaveIsFirstLane())
		{
			InterlockedAdd(OutShadingBinStats[0].y, WaveBinPixelCount);
		}
	#endif
#endif // QUAD_BINNING

		OutShadingBinArgs[ArgsOffset + 0] = (BinPixelCount + 63u) / 64u;	// ThreadGroupCountX
		OutShadingBinArgs[ArgsOffset + 1] = 1;								// ThreadGroupCountY
		OutShadingBinArgs[ArgsOffset + 2] = 1;								// ThreadGroupCountZ
		OutShadingBinArgs[ArgsOffset + 3] = 0;								// padding
	}
}

#endif
