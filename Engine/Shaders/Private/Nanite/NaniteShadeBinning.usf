// Copyright Epic Games, Inc. All Rights Reserved.

#include "NaniteShadeCommon.ush"

uint4 ViewRect;
uint2 QuadDispatchDim;
uint  ShadingBinCount;

#if (SHADING_BIN_PASS == NANITE_SHADING_BIN_COUNT)
	#define SHADING_BIN_COUNT		1
	#define SHADING_BIN_RESERVE		0
	#define SHADING_BIN_SCATTER		0
#elif (SHADING_BIN_PASS == NANITE_RASTER_BIN_SCATTER)
	#define SHADING_BIN_COUNT		0
	#define SHADING_BIN_RESERVE		0
	#define SHADING_BIN_SCATTER		1
#else
	#define SHADING_BIN_COUNT		0
	#define SHADING_BIN_RESERVE		1
	#define SHADING_BIN_SCATTER		0
#endif

#define GATHER4_OPTIMIZATION 0

#if VARIABLE_SHADING_RATE
uint ShadingRateTileSize;
Texture2D<uint> ShadingRateImage;
#endif

#if SHADING_BIN_COUNT || SHADING_BIN_SCATTER
Texture2D<uint> ShadingMask;
SamplerState ShadingMaskSampler;
#endif

// .x = Quad count shaded by bin
// .y = Pixel count shaded by bin
// .z = Quad coord range start
// .w = Material bit flags
RWStructuredBuffer<uint4> OutShadingBinMeta;

#if SHADING_BIN_RESERVE
RWStructuredBuffer<uint> OutShadingBinAllocator;
RWBuffer<uint> OutShadingBinArgs;
#endif

#if SHADING_BIN_SCATTER
RWStructuredBuffer<uint> OutShadingBinData;
#endif

FNaniteMaterialFlags GetShadingBinMaterialFlags(uint BinIndex)
{
	return UnpackNaniteMaterialFlags(OutShadingBinMeta[BinIndex].w);
}

#if SHADING_BIN_COUNT || SHADING_BIN_SCATTER

[numthreads(8, 8, 1)]
void ShadingBinBuildCS(uint ThreadIndex : SV_GroupIndex, uint2 GroupId : SV_GroupID, uint ThreadId : SV_GroupIndex)
{
	const uint ViewWidth  = ViewRect.z - ViewRect.x;
	const uint ViewHeight = ViewRect.w - ViewRect.y;

	uint2 Coord = GroupId.xy * 8u;

#if 1
	// [0 1][2 3] -> [0 1][4 5]
	// [4 5][6 7] -> [2 3][6 7]
	Coord.x += BitFieldInsertU32(BitFieldMaskU32(1u, 0u), ThreadIndex, BitFieldExtractU32(ThreadIndex, 3u, 2u));
	Coord.y += BitFieldInsertU32(BitFieldMaskU32(2u, 0u), BitFieldExtractU32(ThreadIndex, 2u, 1u), BitFieldExtractU32(ThreadIndex, 3u, 3u));
#else
	Coord += Unflatten2D(ThreadIndex, uint2(8u, 8u));
#endif

	const uint2 QuadTLCoord = uint2(Coord.xy << 1u) + uint2(ViewRect.xy);

	// .x = TL, .y = TR, .z = BL, .w = BR
	const uint2 QuadCoords[4] =
	{
		QuadTLCoord,
		QuadTLCoord + uint2(1, 0),
		QuadTLCoord + uint2(0, 1),
		QuadTLCoord + uint2(1, 1)
	};

#if GATHER4_OPTIMIZATION
	uint4 QuadShadingMask = ShadingMask.GatherRed(ShadingMaskSampler, float2(QuadTLCoord + 0.5f) / float2(ViewRect.z, ViewRect.w)).wzxy;
#else
	uint4 QuadShadingMask;
	QuadShadingMask.x = ShadingMask[QuadCoords[0]];
	QuadShadingMask.y = ShadingMask[QuadCoords[1]];
	QuadShadingMask.z = ShadingMask[QuadCoords[2]];
	QuadShadingMask.w = ShadingMask[QuadCoords[3]];
#endif

	FShadingMask ShadingMaskTL = UnpackShadingMask(QuadShadingMask.x);
	FShadingMask ShadingMaskTR = UnpackShadingMask(QuadShadingMask.y);
	FShadingMask ShadingMaskBL = UnpackShadingMask(QuadShadingMask.z);
	FShadingMask ShadingMaskBR = UnpackShadingMask(QuadShadingMask.w);

	const bool4 ValidMask = bool4(
		QuadTLCoord.x < ViewWidth,
		QuadTLCoord.y < ViewHeight,
		QuadTLCoord.x < ViewWidth  - 1u,
		QuadTLCoord.y < ViewHeight - 1u
	);

	bool4 ValidPixels = bool4(
		all(ValidMask.xy) && ShadingMaskTL.bIsNanitePixel,
		all(ValidMask.zy) && ShadingMaskTR.bIsNanitePixel,
		all(ValidMask.xw) && ShadingMaskBL.bIsNanitePixel,
		all(ValidMask.zw) && ShadingMaskBR.bIsNanitePixel
	);

	if (!any(ValidPixels))
	{
		// Quad is entirely non-Nanite or out of bounds.
		return;
	}

	uint4 CopyMasks = uint4(0, 0, 0, 0);

#if VARIABLE_SHADING_RATE
	uint WaveShadingRate = D3D12_SHADING_RATE_1X1;
	if (WaveIsFirstLane() && ShadingRateTileSize != 0)
	{
		// Retrieve the variable shading rate that governs the 2x2 quads within the VRS tile boundary (8x8, 16x16, or 32x32)
		WaveShadingRate = ShadingRateImage[QuadTLCoord.xy / ShadingRateTileSize.xx] & 0xFu;
	}

	// Propagate the shading rate to all lanes in wave
	WaveShadingRate = WaveReadLaneFirst(WaveShadingRate);
#endif

	uint4 VotingBins = uint4(
		ShadingMaskTL.ShadingBin,
		ShadingMaskTR.ShadingBin,
		ShadingMaskBL.ShadingBin,
		ShadingMaskBR.ShadingBin
	);

#if VARIABLE_SHADING_RATE
	// TODO: Optimize - proof of concept
	if (all(ValidPixels))
	{
		// For now we don't want to worry about VRS for quads that contain non-Nanite or out of bound pixels
		if (WaveShadingRate == D3D12_SHADING_RATE_1X2)
		{
			// [A]
			// [B]

			const uint CopyHMask = PackPixelCopy(bool3(true, false, false));

			if (VotingBins[0] == VotingBins[1])
			{
				ValidPixels[1] = false;
				CopyMasks[0] = CopyHMask;
			}

			if (VotingBins[2] == VotingBins[3])
			{
				ValidPixels[3] = false;
				CopyMasks[2] = CopyHMask;
			}
		}
		else if (WaveShadingRate == D3D12_SHADING_RATE_2X1)
		{
			// [A][B]

			const uint CopyVMask = PackPixelCopy(bool3(false, true, false));

			if (VotingBins[0] == VotingBins[2])
			{
				ValidPixels[2] = false;
				CopyMasks[0] = CopyVMask;
			}

			if (VotingBins[1] == VotingBins[3])
			{
				ValidPixels[3] = false;
				CopyMasks[1] = CopyVMask;
			}
		}
		else if (WaveShadingRate == D3D12_SHADING_RATE_2X2)
		{
			// [A][B]
			// [C][D]

			const uint CopyAMask = PackPixelCopy(bool3(true, true, true));

			if (VotingBins[0] == VotingBins[1] &&
				VotingBins[0] == VotingBins[2] &&
				VotingBins[0] == VotingBins[3])
			{
				ValidPixels[1] = false;
				ValidPixels[2] = false;
				ValidPixels[3] = false;

				CopyMasks[0] = CopyAMask;
			}
		}
	}
#endif

	const uint LaneIndex = WaveGetLaneIndex();

	// Create quad-lane mask of valid pixels to vote with (exclude non-Nanite or out of bounds).
	uint VotingMask = PackQuadCoverage(ValidPixels);

	// All quad-lanes process until every pixel has been binned.
	while (WaveActiveAnyTrue(VotingMask != 0u))
	{
		// Activate all quad lanes that have not fully binned all pixels yet.
		if (VotingMask != 0u)
		{
			// Determine current shading bin for all quad-lanes to classify.
			const uint VotedBinIndex = firstbitlow(VotingMask);
			const uint VotedBin = WaveReadLaneFirst(VotingBins[VotedBinIndex]);

			uint BinCoverage = 0u;

			// Determine mask of which pixels (if any) in this quad-lane shade 
			// using the currently voted shading bin.
			UNROLL
			for (uint PixelIndex = 0u; PixelIndex < 4u; ++PixelIndex)
			{
				const uint PixelMask = (1u << PixelIndex);
				const bool bPixelActive = (VotingMask & PixelMask) != 0u;
				if (bPixelActive && VotingBins[PixelIndex] == VotedBin)
				{
					// Remove pixel from voting mask.
					VotingMask  &= ~PixelMask;

					// Include pixel in shading bin coverage mask.
					BinCoverage |=  PixelMask;
				}
			}

		#if !QUAD_BINNING || GATHER_STATS
			const uint PixelCount  = countbits(BinCoverage);
			const uint WavePixelCount = WaveActiveSum(PixelCount);
		#endif

	#if QUAD_BINNING
			const uint WaveQuadCount = WaveActiveCountBits(BinCoverage != 0u);
		#if SHADING_BIN_COUNT
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[VotedBin].x, WaveQuadCount);
			#if GATHER_STATS
				InterlockedAdd(OutShadingBinMeta[VotedBin].y, WavePixelCount);
			#endif
			}
		#elif SHADING_BIN_SCATTER
			uint WaveWriteOffset = 0u;
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[VotedBin].x, WaveQuadCount, WaveWriteOffset);
				WaveWriteOffset += OutShadingBinMeta[VotedBin].z;
			}

			const uint DataWriteOffset = WaveReadLaneFirst(WaveWriteOffset) + WavePrefixCountBits(BinCoverage != 0u);
			if (BinCoverage != 0u)
			{
				OutShadingBinData[DataWriteOffset] = PackShadingQuad(QuadTLCoord, BinCoverage);
			}
		#endif
	#else // QUAD_BINNING
		#if SHADING_BIN_COUNT
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[VotedBin].y, WavePixelCount);
			}
		#elif SHADING_BIN_SCATTER
			uint WaveWriteOffset = 0u;
			if (WaveIsFirstLane())
			{
				InterlockedAdd(OutShadingBinMeta[VotedBin].y, WavePixelCount, WaveWriteOffset);
				WaveWriteOffset += OutShadingBinMeta[VotedBin].z;
			}

			const uint DataWriteOffset = WaveReadLaneFirst(WaveWriteOffset) + WavePrefixSum(PixelCount);

			uint PackedIndex = 0;

			UNROLL
			for (uint PixelIndex = 0u; PixelIndex < 4u; ++PixelIndex)
			{
				if ((BinCoverage & (1u << PixelIndex)) != 0u)
				{
					OutShadingBinData[DataWriteOffset + PackedIndex] = PackShadingPixel(QuadCoords[PixelIndex], CopyMasks[PixelIndex]);
					++PackedIndex;
				}
			}
		#endif
	#endif // QUAD_BINNING
		}
	}
}

#elif SHADING_BIN_RESERVE

#if GATHER_STATS
// .x = total quad count
// .y = total pixel count
// .z = total helper count
// .w = unused
RWStructuredBuffer<uint4> OutShadingBinStats;
#endif

[numthreads(64, 1, 1)]
void ShadingBinReserveCS(uint ShadingBin : SV_DispatchThreadID)
{
	if (ShadingBin < ShadingBinCount)
	{
#if QUAD_BINNING
		const uint BinQuadCount = OutShadingBinMeta[ShadingBin].x;

		if (BinQuadCount > 0)
		{
			uint RangeStart;
			InterlockedAdd(OutShadingBinAllocator[0], BinQuadCount, RangeStart);
			OutShadingBinMeta[ShadingBin].x = 0;
			OutShadingBinMeta[ShadingBin].z = RangeStart;
		}

		const uint ArgsOffset = ShadingBin * 4u;

		// Includes helper lanes
		const uint BinPixelCount = BinQuadCount * 4u;

	#if GATHER_STATS
		const uint BinSampleCount		= OutShadingBinMeta[ShadingBin].y;
		const uint BinHelperCount		= BinPixelCount - BinSampleCount;
		const uint WaveBinQuadCount		= WaveActiveSum(BinQuadCount);
		const uint WaveBinPixelCount	= WaveActiveSum(BinPixelCount);
		const uint WaveBinHelperCount	= WaveActiveSum(BinHelperCount);
		if (WaveIsFirstLane())
		{
			InterlockedAdd(OutShadingBinStats[0].x, WaveBinQuadCount);
			InterlockedAdd(OutShadingBinStats[0].y, WaveBinPixelCount);
			InterlockedAdd(OutShadingBinStats[0].z, WaveBinHelperCount);
		}
	#endif
#else // QUAD_BINNING
		const uint BinPixelCount = OutShadingBinMeta[ShadingBin].y;

		if (BinPixelCount > 0)
		{
			uint RangeStart;
			InterlockedAdd(OutShadingBinAllocator[0], BinPixelCount, RangeStart);
			OutShadingBinMeta[ShadingBin].y = 0;
			OutShadingBinMeta[ShadingBin].z = RangeStart;
		}

		const uint ArgsOffset = ShadingBin * 4u;

	#if GATHER_STATS
		const uint WaveBinPixelCount = WaveActiveSum(BinPixelCount);
		if (WaveIsFirstLane())
		{
			InterlockedAdd(OutShadingBinStats[0].y, WaveBinPixelCount);
		}
	#endif
#endif // QUAD_BINNING

		OutShadingBinArgs[ArgsOffset + 0] = (BinPixelCount + 63u) / 64u;	// ThreadGroupCountX
		OutShadingBinArgs[ArgsOffset + 1] = 1;								// ThreadGroupCountY
		OutShadingBinArgs[ArgsOffset + 2] = 1;								// ThreadGroupCountZ
		OutShadingBinArgs[ArgsOffset + 3] = 0;								// padding
	}
}

#endif
