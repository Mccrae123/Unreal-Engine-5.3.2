// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	GlobalDistanceField.usf
=============================================================================*/

#include "Common.ush"
#include "DeferredShadingCommon.ush"
#include "DistanceFieldLightingShared.ush"
#include "DistanceFieldAOShared.ush"
#include "GlobalDistanceFieldShared.ush"
#include "HeightfieldLightingShared.ush"

#ifndef CULLOBJECTS_THREADGROUP_SIZE
	#define CULLOBJECTS_THREADGROUP_SIZE 1
#endif

#ifndef THREADGROUP_SIZE
	#define THREADGROUP_SIZE 1
#endif

float ComputeSquaredDistanceBetweenAABBs(float3 CenterA, float3 ExtentA, float3 CenterB, float3 ExtentB)
{
	float3 AxisDistances = max(abs(CenterB - CenterA) - (ExtentA + ExtentB), 0);
	return dot(AxisDistances, AxisDistances);
}

float InfluenceRadius;
uint ClipmapIndex;
float3 VolumeTexelSize;
float3 UpdateRegionVolumeMin;
float UpdateRegionVolumeStep;
float HeightfieldThickness;
uint3 CullGridDimension;

RWBuffer<uint> RWCullGridAllocator;
RWBuffer<uint> RWCullGridObjectHeader;
RWBuffer<uint> RWCullGridObjectArray;

#ifndef MAX_GRID_CULLED_DF_OBJECTS
#define MAX_GRID_CULLED_DF_OBJECTS 1
#endif

#ifndef CULL_GRID_TILE_SIZE
#define CULL_GRID_TILE_SIZE 1
#endif

#define GRID_CULL_THREADGORUP_TOTALSIZE 256

uint3 UpdateRegionSize;
Buffer<uint> CullGridObjectHeader;
Buffer<uint> CullGridObjectArray;
Texture3D<float> ParentGlobalDistanceFieldTexture;
RWTexture3D<float> RWGlobalDistanceFieldTexture;

#ifndef COMPOSITE_THREADGROUP_SIZEX
#define COMPOSITE_THREADGROUP_SIZEX 1
#endif

#ifndef COMPOSITE_THREADGROUP_SIZEY
#define COMPOSITE_THREADGROUP_SIZEY 1
#endif

#ifndef COMPOSITE_THREADGROUP_SIZEZ
#define COMPOSITE_THREADGROUP_SIZEZ 1
#endif

#define COMPOSITE_THREADGORUP_TOTALSIZE (COMPOSITE_THREADGROUP_SIZEX * COMPOSITE_THREADGROUP_SIZEY * COMPOSITE_THREADGROUP_SIZEZ)

float DistanceToNearestSurfaceForObject(uint ObjectIndex, float3 WorldPosition, float MaxDistance)
{
	float3 LocalPositionExtent = LoadGlobalObjectLocalPositionExtent(ObjectIndex);
	float4x4 WorldToVolume = LoadGlobalObjectWorldToVolume(ObjectIndex);
	bool bGeneratedAsTwoSided;
	float4 UVScaleAndVolumeScale = LoadGlobalObjectUVScale(ObjectIndex, bGeneratedAsTwoSided);
	float3 VolumePosition = mul(float4(WorldPosition, 1), WorldToVolume).xyz;
	float BoxDistance = ComputeDistanceFromBoxToPoint(-LocalPositionExtent, LocalPositionExtent, VolumePosition) * UVScaleAndVolumeScale.w;

	float DistanceToOccluder = MaxDistance;

	BRANCH
	if (BoxDistance < InfluenceRadius)
	{
		float3 UVAdd = LoadGlobalObjectUVAddAndSelfShadowBias(ObjectIndex).xyz;
		float2 DistanceFieldMAD = LoadGlobalObjectDistanceFieldMAD(ObjectIndex);

		float3 ClampedSamplePosition = clamp(VolumePosition, -LocalPositionExtent, LocalPositionExtent);
		float DistanceToClamped = length(VolumePosition - ClampedSamplePosition);

		float3 StepVolumeUV = DistanceFieldVolumePositionToUV(ClampedSamplePosition, UVScaleAndVolumeScale.xyz, UVAdd);
		DistanceToOccluder = (SampleMeshDistanceField(StepVolumeUV, DistanceFieldMAD).x + DistanceToClamped) * UVScaleAndVolumeScale.w;
	}

	return DistanceToOccluder;
}

RWBuffer<uint> RWObjectIndexBuffer;
RWBuffer<uint> RWObjectIndexNumBuffer;
float3 ClipmapWorldCenter;
float3 ClipmapWorldExtent;
float InfluenceRadiusSq;
// 0: accept only mostly static objects, 1: accept only often moving objects, 2: accept all objects
uint AcceptOftenMovingObjectsOnly;
float MeshSDFRadiusThreshold;

[numthreads(CULLOBJECTS_THREADGROUP_SIZE, 1, 1)]
void CullObjectsToClipmapCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ObjectIndex = DispatchThreadId.x;

	if (ObjectIndex < NumSceneObjects)
	{
		float4 ObjectBoundingSphere = LoadGlobalObjectPositionAndRadius(ObjectIndex);
		uint OftenMoving = LoadGlobalObjectOftenMoving(ObjectIndex);

		BRANCH
		if (ObjectBoundingSphere.w > MeshSDFRadiusThreshold
			&& (AcceptOftenMovingObjectsOnly == 2 || OftenMoving == AcceptOftenMovingObjectsOnly))
		{
			float3 ObjectCenter = ObjectBoundingSphere.xyz;
			float3 ObjectExtent = LoadGlobalObjectExtent(ObjectIndex) * MESH_SDF_APPROX_MARGIN;

			float DistanceSq = ComputeSquaredDistanceBetweenAABBs(ClipmapWorldCenter, ClipmapWorldExtent, ObjectCenter, ObjectExtent);
			if (DistanceSq < InfluenceRadiusSq)
			{
				uint DestIndex;
				InterlockedAdd(RWObjectIndexNumBuffer[0], 1U, DestIndex);
				RWObjectIndexBuffer[DestIndex] = ObjectIndex;
			}
		}
	}
}

RWBuffer<uint> RWComposeIndirectArgBuffer;
RWBuffer<uint> RWCullGridIndirectArgBuffer;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearIndirectArgBufferCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	if (DispatchThreadId.x == 0)
	{
		RWComposeIndirectArgBuffer[0] = 0;
		RWComposeIndirectArgBuffer[1] = 1;
		RWComposeIndirectArgBuffer[2] = 1;

		RWCullGridIndirectArgBuffer[0] = 0;
		RWCullGridIndirectArgBuffer[1] = 1;
		RWCullGridIndirectArgBuffer[2] = 1;
	}
}

RWBuffer<uint> RWGridTileBuffer;
RWBuffer<uint> RWGridIndirectArgBuffer;

Buffer<float4> UpdateBoundsBuffer;
uint NumUpdateBounds;

uint3 GridResolution;
float3 GridCoordToWorldCenterScale;
float3 GridCoordToWorldCenterBias;
float3 TileWorldExtent;

groupshared uint GroupInsideBounds;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void BuildGridTilesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint3 GridCoord = GroupId.xyz;
	uint ThreadId = GroupThreadId.x;
	float3 GridWorldCenter = GridCoord * GridCoordToWorldCenterScale + GridCoordToWorldCenterBias;

	if (ThreadId == 0)
	{
		GroupInsideBounds = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	LOOP
	for (uint UpdateBoundsIndex = ThreadId; UpdateBoundsIndex < NumUpdateBounds; UpdateBoundsIndex += THREADGROUP_SIZE)
	{
		float3 UpdateBoundsCenter = UpdateBoundsBuffer[UpdateBoundsIndex * 2 + 0].xyz;
		float3 UpdateBoundsExtent = UpdateBoundsBuffer[UpdateBoundsIndex * 2 + 1].xyz;

		bool bExtendByInflueceRadius = UpdateBoundsBuffer[UpdateBoundsIndex * 2 + 0].w > 0.0f;
		float UpdateBoundsInfluenceRadiusSq = bExtendByInflueceRadius ? InfluenceRadiusSq : 0.0f;

		float DistanceSq = ComputeSquaredDistanceBetweenAABBs(UpdateBoundsCenter, UpdateBoundsExtent, GridWorldCenter, TileWorldExtent);
		if (DistanceSq <= UpdateBoundsInfluenceRadiusSq)
		{
			GroupInsideBounds = 1;
			break;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(GridCoord < GridResolution) && ThreadId == 0)
	{
		if (GroupInsideBounds)
		{
			uint DestIndex;
			InterlockedAdd(RWGridIndirectArgBuffer[0], 1U, DestIndex);
			RWGridTileBuffer[DestIndex] = GridCoord.x | (GridCoord.y << 8) | (GridCoord.z << 16);
		}
	}
}

groupshared uint NumObjectsGridCell;
groupshared uint GridCellStartOffset;

Buffer<uint> ObjectIndexBuffer;
Buffer<uint> ObjectIndexNumBuffer;
Buffer<uint> CullGridTileBuffer;
uint3 CullGridResolution;
float3 CullGridCoordToWorldCenterScale;
float3 CullGridCoordToWorldCenterBias;
float3 CullTileWorldExtent;

[numthreads(GRID_CULL_THREADGORUP_TOTALSIZE, 1, 1)]
void CullObjectsToGridCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID) 
{
	uint ThreadIndex = GroupThreadId.x;

	uint PackedCullGridTile = CullGridTileBuffer[GroupId.x];

	uint3 CullGridCoord;
	CullGridCoord.x = PackedCullGridTile & 0xFF;
	CullGridCoord.y = (PackedCullGridTile >> 8) & 0xFF;
	CullGridCoord.z = (PackedCullGridTile >> 16) & 0xFF;

	uint CullGridLinearIndex = (CullGridCoord.z * CullGridResolution.y + CullGridCoord.y) * CullGridResolution.x + CullGridCoord.x;

	if (ThreadIndex == 0)
	{
		NumObjectsGridCell = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	float3 CullTileWorldCenter = CullGridCoord * CullGridCoordToWorldCenterScale + CullGridCoordToWorldCenterBias;

	if (all(CullGridCoord < CullGridResolution))
	{
		for (uint IndexInObjectIndexBuffer = ThreadIndex; IndexInObjectIndexBuffer < ObjectIndexNumBuffer[0]; IndexInObjectIndexBuffer += GRID_CULL_THREADGORUP_TOTALSIZE)
		{
			uint ObjectIndex = ObjectIndexBuffer[IndexInObjectIndexBuffer];

			float3 ObjectCenter = LoadGlobalObjectPositionAndRadius(ObjectIndex).xyz;
			float3 ObjectExtent = LoadGlobalObjectExtent(ObjectIndex) * MESH_SDF_APPROX_MARGIN;

			float DistanceSq = ComputeSquaredDistanceBetweenAABBs(CullTileWorldCenter, CullTileWorldExtent, ObjectCenter, ObjectExtent);

			if (DistanceSq < InfluenceRadiusSq)
			{
				InterlockedAdd(NumObjectsGridCell, 1U);
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (ThreadIndex == 0)
	{
		// Allocate space in the array for our objects
		InterlockedAdd(RWCullGridAllocator[0], NumObjectsGridCell, GridCellStartOffset);
		RWCullGridObjectHeader[CullGridLinearIndex * 2 + 0] = NumObjectsGridCell;
		RWCullGridObjectHeader[CullGridLinearIndex * 2 + 1] = GridCellStartOffset;
		NumObjectsGridCell = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(CullGridCoord < CullGridResolution))
	{
		for (uint IndexInObjectIndexBuffer = ThreadIndex; IndexInObjectIndexBuffer < ObjectIndexNumBuffer[0]; IndexInObjectIndexBuffer += GRID_CULL_THREADGORUP_TOTALSIZE)
		{
			uint ObjectIndex = ObjectIndexBuffer[IndexInObjectIndexBuffer];

			float3 ObjectCenter = LoadGlobalObjectPositionAndRadius(ObjectIndex).xyz;
			float3 ObjectExtent = LoadGlobalObjectExtent(ObjectIndex) * MESH_SDF_APPROX_MARGIN;

			float DistanceSq = ComputeSquaredDistanceBetweenAABBs(CullTileWorldCenter, CullTileWorldExtent, ObjectCenter, ObjectExtent);

			if (DistanceSq < InfluenceRadiusSq)
			{
				uint DestIndex;
				InterlockedAdd(NumObjectsGridCell, 1U, DestIndex);

				// Write the intersecting object index into the array
				RWCullGridObjectArray[GridCellStartOffset + DestIndex] = ObjectIndex;
			}
		}
	}
}

// Tweaked for the LDS size / occupancy
#define MAX_CULLED_DF_OBJECTS 511
groupshared uint SharedCulledObjectList[MAX_CULLED_DF_OBJECTS];
groupshared uint NumTileCulledObjects;

#define USE_CULL_GRID 1

Buffer<uint> ComposeTileBuffer;
uint3 GlobalDistanceFieldScrollOffset;
uint3 ClipmapResolution;
float3 VoxelCoordToWorldVoxelCenterScale;
float3 VoxelCoordToWorldVoxelCenterBias;
float3 ComposeGridCoordToWorldCenterScale;
float3 ComposeGridCoordToWorldCenterBias;
float3 ComposeTileWorldExtent;

[numthreads(COMPOSITE_THREADGROUP_SIZEX, COMPOSITE_THREADGROUP_SIZEY, COMPOSITE_THREADGROUP_SIZEZ)]
void ComposeObjectDistanceFieldsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID) 
{
	uint ThreadIndex = (GroupThreadId.z * COMPOSITE_THREADGROUP_SIZEY + GroupThreadId.y) * COMPOSITE_THREADGROUP_SIZEX + GroupThreadId.x;

	uint PackedComposeTile = ComposeTileBuffer[GroupId.x];

	uint3 ComposeGridCoord;
	ComposeGridCoord.x = PackedComposeTile & 0xFF;
	ComposeGridCoord.y = (PackedComposeTile >> 8) & 0xFF;
	ComposeGridCoord.z = (PackedComposeTile >> 16) & 0xFF;

	uint3 VoxelCoord = ComposeGridCoord * COMPOSITE_THREADGROUP_SIZEX + GroupThreadId;
	uint3 CullGridCoord = (ComposeGridCoord * COMPOSITE_THREADGROUP_SIZEX) / CULL_GRID_TILE_SIZE;

	uint CullGridLinearIndex = (CullGridCoord.z * CullGridResolution.y + CullGridCoord.y) * CullGridResolution.x + CullGridCoord.x;
	uint CullGridObjectNum = CullGridObjectHeader[CullGridLinearIndex * 2 + 0];
	uint CullGridObjectOffset = CullGridObjectHeader[CullGridLinearIndex * 2 + 1];

	float3 VoxelWorldCenter = VoxelCoord * VoxelCoordToWorldVoxelCenterScale + VoxelCoordToWorldVoxelCenterBias;
	float3 ComposeTileWorldCenter = ComposeGridCoord * ComposeGridCoordToWorldCenterScale + ComposeGridCoordToWorldCenterBias;

	float MinDistance = InfluenceRadius;

#undef USE_OBJECT_COMPOSITING_TILE_CULLING
#define USE_OBJECT_COMPOSITING_TILE_CULLING 1
#if USE_OBJECT_COMPOSITING_TILE_CULLING

	uint NumPasses = (CullGridObjectNum + MAX_CULLED_DF_OBJECTS - 1) / MAX_CULLED_DF_OBJECTS;

	for (uint PassIndex = 0; PassIndex < NumPasses; PassIndex++)
	{
		uint PassStartObject = PassIndex * MAX_CULLED_DF_OBJECTS;
		uint PassNumObjects = PassStartObject + min(CullGridObjectNum - PassStartObject, MAX_CULLED_DF_OBJECTS);

		if (all(GroupThreadId == 0))
		{
			NumTileCulledObjects = 0;
		}

		GroupMemoryBarrierWithGroupSync();

		for (uint CulledGridObjectIndex = PassStartObject + ThreadIndex; CulledGridObjectIndex < PassNumObjects; CulledGridObjectIndex += COMPOSITE_THREADGORUP_TOTALSIZE)
		{
			uint ObjectIndex = CullGridObjectArray[CullGridObjectOffset + CulledGridObjectIndex];

			float3 ObjectCenter = LoadGlobalObjectPositionAndRadius(ObjectIndex).xyz;
			float3 ObjectExtent = LoadGlobalObjectExtent(ObjectIndex) * MESH_SDF_APPROX_MARGIN;

			float DistanceSq = ComputeSquaredDistanceBetweenAABBs(ComposeTileWorldCenter, ComposeTileWorldExtent, ObjectCenter, ObjectExtent);

			if (DistanceSq < InfluenceRadiusSq)
			{
				uint DestIndex;
				InterlockedAdd(NumTileCulledObjects, 1U, DestIndex);
				SharedCulledObjectList[DestIndex] = ObjectIndex;
			}
		}

		GroupMemoryBarrierWithGroupSync();

		uint LocalNumTileCulledObjects = NumTileCulledObjects;

		LOOP 
		for (uint ListObjectIndex = 0; ListObjectIndex < LocalNumTileCulledObjects; ListObjectIndex++)
		{
			uint ObjectIndex = SharedCulledObjectList[ListObjectIndex];

			float DistanceToOccluder = DistanceToNearestSurfaceForObject(ObjectIndex, VoxelWorldCenter, InfluenceRadius);
			MinDistance = min(MinDistance, DistanceToOccluder);
		}
	}

#else

	for (uint IndexInCullGrid = 0; IndexInCullGrid < CullGridObjectNum; ++IndexInCullGrid)
	{
		uint ObjectIndex = CullGridObjectArray[CullGridObjectOffset + IndexInCullGrid];

		float DistanceToOccluder = DistanceToNearestSurfaceForObject(ObjectIndex, VoxelWorldCenter, InfluenceRadius);
		MinDistance = min(MinDistance, DistanceToOccluder);
	}

#endif

	if (all(VoxelCoord < ClipmapResolution))
	{
		uint3 GlobalSDFClipmapCoord = (VoxelCoord + GlobalDistanceFieldScrollOffset) % ClipmapResolution;

		#if COMPOSE_PARENT_DISTANCE_FIELD
			MinDistance = min(MinDistance, ParentGlobalDistanceFieldTexture[GlobalSDFClipmapCoord].x);
		#endif

		RWGlobalDistanceFieldTexture[GlobalSDFClipmapCoord] = MinDistance;
	}
}

#ifndef COMPOSITE_HEIGHTFIELDS_THREADGROUP_SIZE
	#define COMPOSITE_HEIGHTFIELDS_THREADGROUP_SIZE 1
#endif

[numthreads(COMPOSITE_HEIGHTFIELDS_THREADGROUP_SIZE, COMPOSITE_HEIGHTFIELDS_THREADGROUP_SIZE, 1)]
void ComposeHeightfieldsIntoGlobalDistanceFieldCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	// We only dispatch one depth layer, so the z value is incorrect
	float3 LookupWorldPosition = UpdateRegionVolumeMin + float3(DispatchThreadId.xy, 0.0f) * UpdateRegionVolumeStep;

	uint ValidHeightfieldIndex = 0;

	LOOP
		for (uint HeightfieldIndex = 0; HeightfieldIndex < NumHeightfields; HeightfieldIndex++)
		{
			float3 LocalPosition = mul(float4(LookupWorldPosition, 1), GetWorldToLocal(HeightfieldIndex)).xyz;
			float4 MinMaxHeightfieldUV;
			float2 HeightfieldUV = GetHeightfieldUV(HeightfieldIndex, LocalPosition.xy, MinMaxHeightfieldUV);

			if (all(HeightfieldUV > MinMaxHeightfieldUV.xy) && all(HeightfieldUV < MinMaxHeightfieldUV.zw))
			{
				ValidHeightfieldIndex = HeightfieldIndex;
				break;
			}
		}


	float3 LocalPosition = mul(float4(LookupWorldPosition, 1), GetWorldToLocal(ValidHeightfieldIndex)).xyz;
	float4 MinMaxHeightfieldUV;
	float2 HeightfieldUV = GetHeightfieldUV(ValidHeightfieldIndex, LocalPosition.xy, MinMaxHeightfieldUV);

	if (all(HeightfieldUV > MinMaxHeightfieldUV.xy) && all(HeightfieldUV < MinMaxHeightfieldUV.zw))
	{
		if (all(DispatchThreadId.xy < UpdateRegionSize.xy))
		{
			float3 WorldHeightfieldNormal;
			float HeightfieldVisibility;
			float3 WorldHeightfieldShadingPosition = GetHeightfieldWorldPositionAndNormal(ValidHeightfieldIndex, LocalPosition.xy, HeightfieldUV, WorldHeightfieldNormal, HeightfieldVisibility);

			if (HeightfieldVisibility > 0.5f) // Skip holes in the heightfield
			{
				// Compute distance for all Z values of the update region
				LOOP
					for (uint ZIndex = 0; ZIndex < UpdateRegionSize.z; ZIndex++)
					{
						float3 WorldPosition;
						WorldPosition.xy = LookupWorldPosition.xy;
						WorldPosition.z = UpdateRegionVolumeMin.z + ZIndex * UpdateRegionVolumeStep;

						// Project the vertical height vector onto the normal of the heightfield directly below the point we are computing the distance field for, use the perpendicular distance
						float DistanceToHeightfieldPlane = dot(WorldHeightfieldNormal, WorldPosition - WorldHeightfieldShadingPosition);

						// Limit negative region of a heighfield to a user defined thickness  
						const float MinInteriorDistance = -HeightfieldThickness;
						if (DistanceToHeightfieldPlane < MinInteriorDistance)
						{
							DistanceToHeightfieldPlane = MinInteriorDistance - DistanceToHeightfieldPlane;
						}

						float MinDistance = clamp(DistanceToHeightfieldPlane, -InfluenceRadius, InfluenceRadius);

						float3 GlobalUV = ComputeGlobalUV(WorldPosition, ClipmapIndex);
						uint3 WriteCoordinate = (uint3)(frac(GlobalUV) * GlobalVolumeDimension);
						RWGlobalDistanceFieldTexture[WriteCoordinate] = min(MinDistance, RWGlobalDistanceFieldTexture[WriteCoordinate]);
					}
			}
		}
	}
}