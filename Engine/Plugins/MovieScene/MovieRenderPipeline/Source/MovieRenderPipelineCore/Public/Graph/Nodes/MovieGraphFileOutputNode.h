// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once
#include "Graph/MovieGraphNode.h"
#include "Graph/MovieGraphDataTypes.h"
#include "MovieGraphFileOutputNode.generated.h"

/**
* The UMovieGraphFileOutputNode node defines a output file format that MRQ may place produced render data into.
* At runtime, the individual pieces of render data will be generated by the Movie Graph Renderer, and then 
* all data will be collected into a single datastructure by the FMovieGraphOutputMerger before being passed back
* into the main Movie Graph Pipeline. Once this happens, the CDOs deriving from UMovieGraphFileOutputNode will be
* given a pointer to the information for the whole frame, so they can decide what to do with it. There are potentially
* multiple output formats at once (such as exr and jpeg).
*/
UCLASS(Abstract)
class UMovieGraphFileOutputNode : public UMovieGraphNode
{
	GENERATED_BODY()
public:
	UMovieGraphFileOutputNode() = default;
	
	// UMovieGraphFileOutputNode Interface
	/** 
	* This is called by the Game Thread containing the final output data for a given output frame. If you need to hold 
	* onto this data for longer than the duration of the single function call (such as async/task graph operations) then
	* you need to increment the reference count on the data in the UMovieGraphPipeline, and decrement when you are done.
	* Failing to increment will lead to the data being deleted out from underneath you, and failing to decrement will leak 
	* memory until the end of a render.
	*/
	void OnReceiveImageData(UMovieGraphPipeline* InPipeline, UE::MovieGraph::FMovieGraphOutputMergerFrame* InRawFrameData) { OnReceiveImageDataImpl(InPipeline, InRawFrameData); }
	void OnAllFramesSubmitted() { OnAllFramesSubmittedImpl(); }
	bool IsFinishedWritingToDisk() const { return IsFinishedWritingToDiskImpl(); }
	// ~UMovieGraphFileOutputNode Interface

	virtual TArray<FMovieGraphPinProperties> GetInputPinProperties() const override
	{
		TArray<FMovieGraphPinProperties> Properties;
		Properties.Add(FMovieGraphPinProperties(NAME_None, EMovieGraphMemberType::Branch, false));
		return Properties;
	}

	virtual TArray<FMovieGraphPinProperties> GetOutputPinProperties() const override
	{
		TArray<FMovieGraphPinProperties> Properties;
		Properties.Add(FMovieGraphPinProperties(NAME_None, EMovieGraphMemberType::Branch, false));
		return Properties;
	}

#if WITH_EDITOR
	virtual FText GetMenuCategory() const override
	{
		return NSLOCTEXT("MovieGraphNodes", "FileOutputGraphNode_Category", "Output Type");
	}
#endif

protected:
	virtual void OnReceiveImageDataImpl(UMovieGraphPipeline* InPipeline, UE::MovieGraph::FMovieGraphOutputMergerFrame* InRawFrameData) {}
	virtual void OnAllFramesSubmittedImpl() {}
	virtual bool IsFinishedWritingToDiskImpl() const { return true; }
};