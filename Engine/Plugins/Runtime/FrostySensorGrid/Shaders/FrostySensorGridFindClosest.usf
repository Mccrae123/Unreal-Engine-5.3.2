// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "/Engine/Public/Platform.ush"
#include "FrostySensorGridCommon.ush"

#if !defined(MAX_HIERARCHY_LEVEL_COUNT)
	#error MAX_HIERARCHY_LEVEL_COUNT is not defined
#endif

#if !defined(NETWORK_COUNT_PER_GROUP)
	#error NETWORK_COUNT_PER_GROUP is not defined
#endif

#define SUBGRID_SIZE 2
#define STACK_STRIDE (((MAX_HIERARCHY_LEVEL_COUNT - 1) * 3) + 1)

////////////////////////////////////////////////////////////////////////////////
///// Searches through the bounds hierarchy to find the closest valid sensor
////////////////////////////////////////////////////////////////////////////////

ByteAddressBuffer SensorHierarchy;
RWStructuredBuffer<FSensorInfo> NearestSensors;
int3 SensorGridDimensions;
int HierarchyLevelOffsets[MAX_HIERARCHY_LEVEL_COUNT];
float2 DistanceBounds;
int HierarchyLevelCount;

// CellIndex -> GridX, GridY, GridZ
// Level (0 is largest 'mip', 1 is half the size, ...)
float4 RetrieveBounds(uint3 CellIndex, uint HierarchyLevel)
{
	const uint CellCount = 1 << (HierarchyLevelCount - HierarchyLevel - 1);
	const uint BoundsAddress = HierarchyLevelOffsets[HierarchyLevel] + 16 * TiledToLinear(CellIndex, int3(CellCount, CellCount, 0));

	return asfloat(SensorHierarchy.Load4(BoundsAddress));
}

float DistanceBetweenBounds(float4 A, float4 B)
{
	return length(B.xyz - A.xyz) - A.w - B.w;
}

groupshared int3 ThreadBestSensorIndex[SUBGRID_SIZE * SUBGRID_SIZE * NETWORK_COUNT_PER_GROUP];
groupshared float ThreadBestSensorDistance[SUBGRID_SIZE * SUBGRID_SIZE * NETWORK_COUNT_PER_GROUP];

groupshared float4 ThreadLeaves[SUBGRID_SIZE][SUBGRID_SIZE];
groupshared float4 ThreadBounds;

[numthreads(1, 1, NETWORK_COUNT_PER_GROUP)]
void FindClosestSensors(uint3 GroupThreadId : SV_GroupThreadID, uint GroupIndex : SV_GroupIndex, uint3 GroupId : SV_GroupID)
{
	if (GroupId.z >= uint(SensorGridDimensions.z))
	{
		return;
	}

	// collect the bounds of the leaves and their immmediate parent
	if (GroupIndex == 0)
	{
		ThreadBounds = RetrieveBounds(GroupId, log2(SUBGRID_SIZE));
		for (int i = 0; i < SUBGRID_SIZE; ++i)
		{
			for (int j = 0; j < SUBGRID_SIZE; ++j)
			{
				ThreadLeaves[i][j] = RetrieveBounds(GroupId * uint3(2, 2, 1) + uint3(i, j, 0), 0);

				for (int o = 0; o < NETWORK_COUNT_PER_GROUP; ++o)
				{
					ThreadBestSensorDistance[o + NETWORK_COUNT_PER_GROUP * (j + SUBGRID_SIZE * i)] = DistanceBounds.y;
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	const float MinDistance = DistanceBounds.x;
	float WorstLocalDistance = DistanceBounds.y;

	for (int OwnerOffset = 1; OwnerOffset <= SensorGridDimensions.z; OwnerOffset += NETWORK_COUNT_PER_GROUP)
	{
		const uint OwnerIndex = (GroupId.z + GroupIndex + OwnerOffset) % SensorGridDimensions.z;

		if (OwnerIndex == GroupId.z || WorstLocalDistance < MinDistance)
		{
			continue;
		}

		int4 DepthFirstStack[STACK_STRIDE];
		int StackDepth = 0;

		DepthFirstStack[StackDepth++] = int4(0, 0, OwnerIndex, HierarchyLevelCount - 1);

		while (StackDepth > 0 && WorstLocalDistance > MinDistance)
		{
			const int4 ParentIndex = DepthFirstStack[--StackDepth];
			const float4 ParentBounds = RetrieveBounds(ParentIndex.xyz, ParentIndex.w);

			float Delta = DistanceBetweenBounds(ParentBounds, ThreadBounds);

			// if no part of this cell is closer than our current best case sensor, then we can skip it
			if (Delta < WorstLocalDistance)
			{
				// if the bounds of the parent are smaller than our min distance we'll just use the first
				// leaf node underneath us (all others are within our specified error tolerance)
				if (ParentBounds.w <= MinDistance)
				{
					int3 LeafIndex = int3(ParentIndex.xy * (1 << ParentIndex.w), ParentIndex.z);
					float MaxLocalDistances = 0.0f;

					for (int ThreadI = 0; ThreadI < SUBGRID_SIZE; ++ThreadI)
					{
						for (int ThreadJ = 0; ThreadJ < SUBGRID_SIZE; ++ThreadJ)
						{
							const int ThreadRecordIndex = GroupThreadId.z + NETWORK_COUNT_PER_GROUP * (ThreadJ + SUBGRID_SIZE * ThreadI);
							const float4 ThreadLeafBounds = ThreadLeaves[ThreadI][ThreadJ];

							const float LeafDistance = DistanceBetweenBounds(ParentBounds, ThreadLeafBounds);

							if (LeafDistance < ThreadBestSensorDistance[ThreadRecordIndex])
							{
								ThreadBestSensorDistance[ThreadRecordIndex] = LeafDistance;
								ThreadBestSensorIndex[ThreadRecordIndex] = LeafIndex;
							}

							MaxLocalDistances = max(MaxLocalDistances, ThreadBestSensorDistance[ThreadRecordIndex]);
						}
					}

					WorstLocalDistance = min(MaxLocalDistances, DistanceBounds.y);
				}
				// see if we have more intermediary nodes to get through
				else if (ParentIndex.w > 1)
				{
					// queue up potential candidates
					DepthFirstStack[StackDepth++] = ParentIndex * int4(2, 2, 1, 1) + int4(1, 1, 0, -1); // BR
					DepthFirstStack[StackDepth++] = ParentIndex * int4(2, 2, 1, 1) + int4(0, 1, 0, -1); // BL
					DepthFirstStack[StackDepth++] = ParentIndex * int4(2, 2, 1, 1) + int4(1, 0, 0, -1); // TR
					DepthFirstStack[StackDepth++] = ParentIndex * int4(2, 2, 1, 1) + int4(0, 0, 0, -1); // TL
				}
				else
				{
					float MaxLocalDistances = 0.0f;

					// perform the actual comparison between leaves
					for (int ThreadI = 0; ThreadI < SUBGRID_SIZE; ++ThreadI)
					{
						for (int ThreadJ = 0; ThreadJ < SUBGRID_SIZE; ++ThreadJ)
						{
							const int ThreadRecordIndex = GroupThreadId.z + NETWORK_COUNT_PER_GROUP * (ThreadJ + SUBGRID_SIZE * ThreadI);
							const float4 ThreadLeafBounds = ThreadLeaves[ThreadI][ThreadJ];

							if (DistanceBetweenBounds(ParentBounds, ThreadLeafBounds) < WorstLocalDistance)
							{
								for (int LeafI = 0; LeafI < SUBGRID_SIZE; ++LeafI)
								{
									for (int LeafJ = 0; LeafJ < SUBGRID_SIZE; ++LeafJ)
									{
										const int3 LeafIndex = ParentIndex.xyz * int3(2, 2, 1) + int3(LeafI, LeafJ, 0);
										const float4 LeafBounds = RetrieveBounds(LeafIndex, 0);
										const float LeafDistance = DistanceBetweenBounds(ThreadLeafBounds, LeafBounds);

										if (LeafDistance < ThreadBestSensorDistance[ThreadRecordIndex])
										{
											ThreadBestSensorDistance[ThreadRecordIndex] = LeafDistance;
											ThreadBestSensorIndex[ThreadRecordIndex] = LeafIndex;
										}
									}
								}
							}

							MaxLocalDistances = max(MaxLocalDistances, ThreadBestSensorDistance[ThreadRecordIndex]);
						}
					}

					WorstLocalDistance = min(MaxLocalDistances, DistanceBounds.y);
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (GroupIndex == 0)
	{
		for (int i = 0; i < SUBGRID_SIZE; ++i)
		{
			for (int j = 0; j < SUBGRID_SIZE; ++j)
			{
				FSensorInfo BestSensor;
				BestSensor.HitIndex = int3(-1, -1, -1);
				BestSensor._Pad0 = 0;
				BestSensor.LocationAndDistance = float4(0.0f, 0.0f, 0.0f, DistanceBounds.y);

				const int StartThreadIndex = NETWORK_COUNT_PER_GROUP * (j + SUBGRID_SIZE * i);
				for (int OwnerIndex = 0; OwnerIndex < NETWORK_COUNT_PER_GROUP; ++OwnerIndex)
				{
					if (ThreadBestSensorDistance[StartThreadIndex + OwnerIndex] < BestSensor.LocationAndDistance.w)
					{
						BestSensor.HitIndex = ThreadBestSensorIndex[StartThreadIndex + OwnerIndex];
						BestSensor.LocationAndDistance = float4(RetrieveBounds(BestSensor.HitIndex, 0).xyz, ThreadBestSensorDistance[StartThreadIndex + OwnerIndex]);
					}
				}

				// write the results
				const uint ResultIndex = TiledToLinear(GroupId * uint3(2, 2, 1) + uint3(i, j, 0), SensorGridDimensions);
				NearestSensors[ResultIndex] = BestSensor;
			}
		}
	}
}


