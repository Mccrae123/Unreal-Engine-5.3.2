// Copyright Epic Games, Inc. All Rights Reserved.

#include "MassSpawner.h"
#include "Engine/World.h"
#include "UObject/ConstructorHelpers.h"
#include "Components/SceneComponent.h"
#include "Components/BillboardComponent.h"
#include "MassSpawnerTypes.h"
#include "MassSpawnerSubsystem.h"
#include "MassSimulationSubsystem.h"
#include "EnvironmentQuery/EnvQuery.h"
#include "VisualLogger/VisualLogger.h"
#include "MassEntityConfigAsset.h"
#include "EngineUtils.h"

namespace UE::MassSpawner
{
	float ScalabilitySpawnDensityMultiplier = 1.f;
	FAutoConsoleVariableRef CVarScalabilitySpawnDensityMultiplier(TEXT("ai.mass.scalability.SpawnDensityMultiplier"), ScalabilitySpawnDensityMultiplier, TEXT("Spawn Density Multiplier, must be set before Mass Spawn Init"), ECVF_Scalability);

#if WITH_EDITOR
	static FAutoConsoleCommandWithWorld ForceSpawningCommand(
	TEXT("ai.mass.ForceSpawn"),
	TEXT("Command to Force Spawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoSpawning();
			}
		}
	}));

	static FAutoConsoleCommandWithWorld ForceDespawningCommand(
	TEXT("ai.mass.ForceDespawn"),
	TEXT("Command to Force Despawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoDespawning();
			}
		}
	}));

	static FAutoConsoleCommandWithWorld ResetSpawningCommand(
	TEXT("ai.mass.ResetSpawning"),
	TEXT("Command to Force Despawn and Respawn all mass entities generated by MassSpawners"),
	FConsoleCommandWithWorldDelegate::CreateLambda([](UWorld* World)
	{
		for (TActorIterator<AActor> It(World, AMassSpawner::StaticClass()); It; ++It)
		{
			if (AMassSpawner* Spawner = Cast<AMassSpawner>(*It))
			{
				Spawner->DoDespawning();
				Spawner->DoSpawning();
			}
		}
	}));
#endif // WITH_EDITOR
}

AMassSpawner::AMassSpawner()
{
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("SceneComp"));
	RootComponent->Mobility = EComponentMobility::Static;

#if WITH_EDITOR
	SpriteComponent = CreateEditorOnlyDefaultSubobject<UBillboardComponent>(TEXT("Sprite"));

	// SpriteComponent can be null for editor builds running "-game|server"
	if (!IsRunningCommandlet() && SpriteComponent != nullptr)
	{
		// Structure to hold one-time initialization
		struct FConstructorStatics
		{
			ConstructorHelpers::FObjectFinderOptional<UTexture2D> IconTextureObject;
			FName MassSpawnerID;
			FText MassSpawnerName;
			FConstructorStatics()
				: IconTextureObject(TEXT("/MassGameplay/S_MassCrowd"))
				, MassSpawnerID(TEXT("MassSpawner"))
				, MassSpawnerName(NSLOCTEXT("SpriteCategory", "MassSpawner", "MassSpawner"))
			{
			}
		};
		static FConstructorStatics ConstructorStatics;
		
		SpriteComponent->Sprite = ConstructorStatics.IconTextureObject.Get();
		SpriteComponent->SetRelativeScale3D(FVector(0.5f, 0.5f, 0.5f));
		SpriteComponent->SpriteInfo.Category = ConstructorStatics.MassSpawnerID;
		SpriteComponent->SpriteInfo.DisplayName = ConstructorStatics.MassSpawnerName;
		SpriteComponent->SetupAttachment(RootComponent);
		SpriteComponent->Mobility = EComponentMobility::Static;
	}
#endif // WITH_EDITOR

	SetCanBeDamaged(false);
	SetActorHiddenInGame(true);

	bAutoSpawnOnBeginPlay = true;
	bOverrideSchematics = false;
}

void AMassSpawner::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		TickSchematicsAdjustHandle = UMassSimulationSubsystem::GetOnAdjustTickSchematics().AddUObject(this, &AMassSpawner::OnAdjustTickSchematics);
	}
}

void AMassSpawner::PostLoad()
{
	Super::PostLoad();

	for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
	{
		if (SpawnPointsGenerator.GeneratorClass)
		{
			SpawnPointsGenerator.GeneratorInstance = NewObject<UMassEntitySpawnPointsGeneratorBase>(this, SpawnPointsGenerator.GeneratorClass);
			SpawnPointsGenerator.GeneratorClass = nullptr;
			MarkPackageDirty();
		}
	}
}

void AMassSpawner::PostRegisterAllComponents()
{
	Super::PostRegisterAllComponents();

	// This is a temp fix for streaming levels async loading MassSpawners after UMassSpawnerSubsystem::OnPostWorldInit, in the long run we are going to need a better system
	// for making sure all the spawnsets are registered on the clients before replication of Agents occurs. This is only required to be done for clients
	if (HasAnyFlags(RF_ClassDefaultObject) == false)
	{
		UWorld* World = GetWorld();
		check(World);

		if (GEngine->GetNetMode(GetWorld()) == NM_Client)
		{
			UMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
			if (MassSpawnerSubsystem)
			{
				if (bUseEntityConfig)
				{
					RegisterEntityTemplates();
				}
				else
				{
					MassSpawnerSubsystem->RegisterCollection(GetSpawnSets());
				}
			}
			else
			{
				FWorldDelegates::OnPostWorldInitialization.AddUObject(this, &AMassSpawner::OnPostWorldInit);
			}
		}
	}
}

void AMassSpawner::OnPostWorldInit(UWorld* World, const UWorld::InitializationValues)
{
	if (World == GetWorld())
	{
		UMassSpawnerSubsystem* MassSpawnerSubsystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(World);
		check(MassSpawnerSubsystem);

		if (bUseEntityConfig)
		{
			RegisterEntityTemplates();
		}
		else
		{
			MassSpawnerSubsystem->RegisterCollection(GetSpawnSets());
		}

		FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);
	}
}

void AMassSpawner::BeginDestroy()
{
	FWorldDelegates::OnPostWorldInitialization.Remove(OnPostWorldInitDelegateHandle);
	UMassSimulationSubsystem::GetOnAdjustTickSchematics().Remove(TickSchematicsAdjustHandle);

	DoDespawning();

	Super::BeginDestroy();
}

void AMassSpawner::BeginPlay()
{
	check(GEngine);

	Super::BeginPlay();

	const ENetMode NetMode = GEngine->GetNetMode(GetWorld());

	if (bAutoSpawnOnBeginPlay && NetMode != NM_Client)
	{
		const UMassSimulationSubsystem* MassSimulationSubsystem = UWorld::GetSubsystem<UMassSimulationSubsystem>(GetWorld());
		if (MassSimulationSubsystem == nullptr || MassSimulationSubsystem->IsSimulationStarted())
		{
			DoSpawning();
		}
		else
		{
			
			SimulationStartedHandle = UMassSimulationSubsystem::GetOnSimulationStarted().AddLambda([this](UWorld* InWorld)
				{
					UWorld* World = GetWorld();

					if (World == InWorld)
					{
						DoSpawning();
					}
				});
		}
	}
}

void AMassSpawner::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	UMassSimulationSubsystem::GetOnSimulationStarted().Remove(SimulationStartedHandle);

	Super::EndPlay(EndPlayReason);
}

#if WITH_EDITOR
void AMassSpawner::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	static const FName SpawnSetsName = GET_MEMBER_NAME_CHECKED(AMassSpawner, SpawnSets);
	static const FName EntityTypesName = GET_MEMBER_NAME_CHECKED(AMassSpawner, EntityTypes);

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property)
	{
		const FName PropName = PropertyChangedEvent.Property->GetFName();
		if (PropName == SpawnSetsName)
		{
			ValidateSpawnSets();
		}
		else if (PropName == EntityTypesName)
		{
			// TODO: Should optimize this, i.e. set a dirty flag and update only when needed.
			RegisterEntityTemplates();
		}
	}
}

void AMassSpawner::ValidateSpawnSets()
{
	// @todo shortly
}

void AMassSpawner::DEBUG_Spawn()
{
	DoSpawning();
}

void AMassSpawner::DEBUG_Clear()
{
	DoDespawning();
}

#endif // WITH_EDITOR

void AMassSpawner::RegisterEntityTemplates()
{
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			EntityConfig->GetConfig().GetOrCreateEntityTemplate(*this, *EntityConfig);
		}
	}
}

void AMassSpawner::DoSpawning()
{
		const int32 SpawnCount = GetSpawnCount();
		if (SpawnCount > 0)
		{
			float TotalProportion = 0.0f;
			for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
			{
			if (SpawnPointsGenerator.GeneratorInstance)
				{
					SpawnPointsGenerator.bPointsGenerated = false;
					TotalProportion += SpawnPointsGenerator.Proportion;
				}
			}

			if (TotalProportion <= 0.0f)
			{
				UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("The total combined porportion of all the generator needs to be greater than 0.0f."));
				return;
			}

			int32 SpawnPointCountRemaining = SpawnCount;
			float ProportionRemaining = TotalProportion;
			for(FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
			{
				// Still needs to call the OnSpawnPointGenerationFinished for Generator we don't want to output Spawn Points for as the system will wait
				// for the bPointsGenerated == true on every Generators before proceeding to the next steps.
				if (SpawnPointsGenerator.Proportion == 0.0f || ProportionRemaining <= 0.0f || SpawnPointCountRemaining <= 0)
				{
					const TArray<FVector> EmptyLoc;
					OnSpawnPointGenerationFinished(EmptyLoc, &SpawnPointsGenerator);
					continue;
				}

			if (SpawnPointsGenerator.GeneratorInstance)
				{
					const float ProportionRatio = FMath::Min(SpawnPointsGenerator.Proportion / ProportionRemaining, 1.0f);
					const int32 SpawnPointCount = FMath::CeilToInt(SpawnPointCountRemaining * ProportionRatio);
					if(SpawnPointCount > 0)
					{
						FFinishedGeneratingSpawnPointsSignature Delegate = FFinishedGeneratingSpawnPointsSignature::CreateUObject(this, &AMassSpawner::OnSpawnPointGenerationFinished, &SpawnPointsGenerator);
					SpawnPointsGenerator.GeneratorInstance->GenerateSpawnPoints(*this, SpawnPointCount, Delegate);
						SpawnPointCountRemaining -= SpawnPointCount;
						ProportionRemaining -= SpawnPointsGenerator.Proportion;
					}
				}
			}
		}
	}

void AMassSpawner::OnSpawnPointGenerationFinished(const TArray<FVector>& Locations, FMassSpawnPointGenerator* FinishedGenerator)
{
	AllGeneratedLocations.Append(Locations);

	bool bAllSpawnPointsGenerated = true;
	bool bFoundFinishedGenerator = false;
	for (FMassSpawnPointGenerator& SpawnPointsGenerator : SpawnPointsGenerators)
	{
		if (&SpawnPointsGenerator == FinishedGenerator)
		{
			SpawnPointsGenerator.bPointsGenerated = true;
			bFoundFinishedGenerator = true;
		}

		bAllSpawnPointsGenerated &= SpawnPointsGenerator.bPointsGenerated;
	}

	checkf(bFoundFinishedGenerator, TEXT("Something went wrong, we are receiving a callback on an unknow spawn point generator"))
	
	if(bAllSpawnPointsGenerated)
	{
		SpawnAtLocations(AllGeneratedLocations);
	}
}

int32 AMassSpawner::GetSpawnCount() const
{
	const float FinalSpawningCountScale = SpawningCountScale * UE::MassSpawner::ScalabilitySpawnDensityMultiplier;
	
	if (bUseEntityConfig)
	{
		return int32(FinalSpawningCountScale * Count);
	}
	else
	{
		int32 OldCount = 0;
		for (const FInstancedStruct& Entry : SpawnSets)
		{
			const FMassSpawnConfigBase& Config = Entry.Get<FMassSpawnConfigBase>();
			OldCount += Config.MaxNumber;
		}
		return int32(FinalSpawningCountScale * OldCount);
	}
}

void AMassSpawner::SpawnAtLocations(const TArray<FVector>& Locations)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to spawn entities"));
		return;
	}

	FMassSpawnAuxData MassSpawnAuxData;
	MassSpawnAuxData.Transforms.Reserve(Locations.Num());
	for (const FVector& Location : Locations)
	{
		FTransform& Transform = MassSpawnAuxData.Transforms.AddDefaulted_GetRef();

		Transform.SetLocation(Location);
	}

	if (bUseEntityConfig)
	{
		const int32 SpawnCount = GetSpawnCount();
		if(SpawnCount > 0)
		{
			float TotalProportion = 0.0f;
			for (const FMassSpawnedEntityType& EntityType : EntityTypes)
			{
				TotalProportion += EntityType.Proportion;
			}

			if (TotalProportion <= 0)
			{
				UE_VLOG_UELOG(this, LogMassSpawner, Error, TEXT("The total combined porportion of all the entity types needs to be greater than 0.0f."));
				return;
			}

			AllSpawnedEntities.Reserve(AllSpawnedEntities.Num() + EntityTypes.Num());

			for (const FMassSpawnedEntityType& EntityType : EntityTypes)
			{
				if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
				{
					const int32 EntityCount = int32(SpawnCount * EntityType.Proportion / TotalProportion);
					if(EntityCount > 0)
					{
						FMassSpawnConfigBase SpawnConfig;
						SpawnConfig.MinNumber = EntityCount;
						SpawnConfig.MaxNumber = EntityCount;
						const FMassEntityTemplate* EntityTemplate = EntityConfig->GetConfig().GetOrCreateEntityTemplate(*this, *EntityConfig);
						if (EntityTemplate && EntityTemplate->IsValid())
						{
							FSpawnedEntities& SpawnedEntities = AllSpawnedEntities.AddDefaulted_GetRef();
							SpawnedEntities.TemplateID = EntityTemplate->GetTemplateID();
							SpawnerSystem->SpawnEntities(EntityTemplate->GetTemplateID(), SpawnConfig, FStructView::Make(MassSpawnAuxData), SpawnedEntities.Entities);
						}
					}
				}
			}
		}
	}
	else
	{
		SpawnerSystem->SpawnCollection(MakeArrayView(SpawnSets), /*Count=*/-1, FStructView::Make(MassSpawnAuxData));
	}
}

void AMassSpawner::DoDespawning()
{
	if (AllSpawnedEntities.IsEmpty())
	{
		return;
	}
	
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to despawn entities"));
		return;
	}

	for (const FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		SpawnerSystem->DestroyEntities(SpawnedEntities.TemplateID, SpawnedEntities.Entities);
	}
	AllSpawnedEntities.Reset();
}

bool AMassSpawner::DespawnEntity(const FMassEntityHandle Entity)
{
	UMassSpawnerSubsystem* SpawnerSystem = UWorld::GetSubsystem<UMassSpawnerSubsystem>(GetWorld());
	if (SpawnerSystem == nullptr)
	{
		UE_LOG(LogMassSpawner, Error, TEXT("UMassSpawnerSubsystem missing while trying to despawn a single entity"));
		return false;
	}

	for (FSpawnedEntities& SpawnedEntities : AllSpawnedEntities)
	{
		const int32 Index = SpawnedEntities.Entities.Find(Entity);
		if (Index != INDEX_NONE)
		{
			SpawnerSystem->DestroyEntities(SpawnedEntities.TemplateID, MakeArrayView(&Entity, 1));
			// not using "RemoveAtSwap" on purpose to retain the order which will help creation of sparse chunks if need be
			SpawnedEntities.Entities.RemoveAt(Index, 1, /*bAllowShrinking=*/false);
			return true;
		}
	}
	return false;
}

void AMassSpawner::ClearTemplates()
{
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		if (const UMassEntityConfigAsset* EntityConfig = EntityType.GetEntityConfig())
		{
			EntityConfig->GetConfig().DestroyEntityTemplate(*this, *EntityConfig);
		}
	}
}

void AMassSpawner::UnloadConfig()
{
	// Clear all templates that were created by the config
	ClearTemplates();
	for (FMassSpawnedEntityType& EntityType : EntityTypes)
	{
		EntityType.UnloadEntityConfig();
	}
}

void AMassSpawner::OnAdjustTickSchematics(UWorld* World,TArray<TSoftObjectPtr<UMassSchematic>>& InOutTickSchematics)
{
	// this function gets called from a static multicast delegate, so we need to differentiate based on the World it's being called for.
	if (World != GetWorld())
	{
		return;
	}

	if (bOverrideSchematics)
	{
		UE_VLOG_UELOG(World, LogMassSpawner, Log, TEXT("Overriding TickSchematics with %s"), *GetName());
		InOutTickSchematics = TickSchematics;
	}
	else
	{
		UE_VLOG_UELOG(World, LogMassSpawner, Log, TEXT("Appending to TickSchematics with %s"), *GetName());
		InOutTickSchematics.Append(TickSchematics);
	}
}

