// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#pragma once
#include "NetworkPredictionTypes.h"
#include "NetworkSimulationModelBuffer.h"
#include "NetworkSimulationModelTypes.h"
#include "NetworkSimulationModelReplicators.h"
#include "NetworkSimulationModelDebugger.h"

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//	TNetworkedSimulationModel
//	
//	* Has all logic for "ticking, advancing buffers, calling Update, calling ServerRPC etc
//	* Doesn't have anything about update component, movesweep, etc
//	* Concept of "IDriver" which is the owning object that is driving the network sim. This is the interface to the outside UE4 world.
//	* Has 4 buffers:
//		-Input: Generated by a client / not the authority.
//		-Sync: What we are trying to keep in sync. The state that evolves frame to frame with an Update function.
//		-Aux: State that is also an input into the simulation but does not intrinsically evolve from to frame. Changes to this state can be trapped/tracked/predicted.
//		-Debug: Replicated buffer from server->client with server-frame centered debug information. Compiled out of shipping builds.
//
//	* How other code interacts with this:
//		-Network updates will come in through UE4 networking -> FReplicationProxy (on actor/component) -> TNetworkedSimulationModel::RepProxy_* -> Buffers.*
//		-UNetworkSimulationGlobalManager: responsible for ticking simulation (after recv net traffic, prior to UE4 actor ticking)
//		-External game code can interact with the system:
//			-The TNetworkedSimulationModel is mostly public and exposed. It is not recommend to publicly expose to your "user" code (high level scripting, designers, etc).
//			-TNetworkSimStateAccessor is a helper for safely reading/writing to state within the system.
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

template <
	typename InTSimulation,								// Final Simulation class
	typename TUserBufferTypes,							// The user types (input, sync, aux, debug). Note this gets wrapped in TInternalBufferTypes internally.
	typename InTTickSettings=TNetworkSimTickSettings<>, // Defines global rules about time keeping and ticking

	// Core proxies that dictate how data replicates and how the simulation evolves for the three main roles
	typename TRepProxyServerRPC =	TReplicator_Server		<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings >,
	typename TRepProxyAutonomous =	TReplicator_Autonomous	<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings>,
	typename TRepProxySimulated =	TReplicator_Simulated	<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings>,

	// Defines how replication happens on these special channels, but doesn't dictate how simulation evolves
	typename TRepProxyReplay =		TReplicator_Sequence	<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings, ENetworkSimBufferTypeId::Sync,  3>,
	typename TRepProxyDebug =		TReplicator_Debug		<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings>
>
class TNetworkedSimulationModel : public INetworkSimulationModel
{
public:

	using TSimulation = InTSimulation;
	using TDriver = TNetworkedSimulationModelDriver<TUserBufferTypes>;

	using TBufferTypes = TInternalBufferTypes<TUserBufferTypes, InTTickSettings>;
	using TTickSettings = InTTickSettings;

	using TInputCmd = typename TBufferTypes::TInputCmd;
	using TSyncState = typename TBufferTypes::TSyncState;
	using TAuxState = typename TBufferTypes::TAuxState;
	using TDebugState = typename TBufferTypes::TDebugState;

	using TSimTime = FNetworkSimTime;
	using TRealTime = FNetworkSimTime::FRealTime;
	
	TNetworkedSimulationModel(TSimulation* InSimulation, TDriver* InDriver, const TSyncState& InitialSyncState = TSyncState(), const TAuxState& InitialAuxState = TAuxState())
	{
		check(InSimulation && InDriver);
		Simulation = InSimulation;
		Driver = InDriver;
		*Buffers.Sync.WriteKeyframe(0) = InitialSyncState;
		*Buffers.Aux.WriteKeyframe(0) = InitialAuxState;
		Ticker.SetTotalProcessedSimulationTime(FNetworkSimTime(), 0);
		DO_NETSIM_MODEL_DEBUG(FNetworkSimulationModelDebuggerManager::Get().RegisterNetworkSimulationModel(this, Driver->GetVLogOwner()));
	}

	virtual ~TNetworkedSimulationModel()
	{
		SetParentSimulation(nullptr);
		ClearAllDependentSimulations();
	}

	void Tick(const FNetSimTickParameters& Parameters) final override
	{
		// Update previous DebugState based on what we (might) have sent *after* our last Tick 
		// (property replication and ServerRPC get sent after the tick, rather than forcing awkward callback into the NetSim post replication, we can check it here)
		if (auto* DebugBuffer = GetLocalDebugBuffer())
		{
			if (TDebugState* const PrevDebugState = DebugBuffer->Get(DebugBuffer->HeadKeyframe()))
			{
				if (Parameters.Role == ROLE_AutonomousProxy)
				{
					PrevDebugState->LastSentInputKeyframe = RepProxy_ServerRPC.GetLastSerializedKeyframe();
				}
				else if (Parameters.Role == ROLE_Authority)
				{
					PrevDebugState->LastSentInputKeyframe = RepProxy_Autonomous.GetLastSerializedKeyframe();
				}
			}
		}

		// Current frame debug state
		TDebugState* const DebugState = GetNextLocalDebugStateWrite();
		if (DebugState)
		{
			*DebugState = TDebugState();
			DebugState->LocalDeltaTimeSeconds = Parameters.LocalDeltaTimeSeconds;
			DebugState->LocalGFrameNumber = GFrameNumber;
			DebugState->ProcessedKeyframes.Reset();
			
			if (Parameters.Role == ROLE_AutonomousProxy)
			{
				DebugState->LastReceivedInputKeyframe = RepProxy_Autonomous.GetLastSerializedKeyframe();
			}
			else if (Parameters.Role == ROLE_Authority)
			{
				DebugState->LastReceivedInputKeyframe = RepProxy_ServerRPC.GetLastSerializedKeyframe();
			}
		}

		// ----------------------------------------------------------------------------------------------------------------
		//	PreSimTick
		//	This is the beginning of a new frame. PreSimTick will decide if we should take Parameters.LocalDeltaTimeSeconds
		//	and advance the simulation or not. It will also generate new local input if necessary.
		// ----------------------------------------------------------------------------------------------------------------
		switch (Parameters.Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.template PreSimTick<TDriver>(Driver, Buffers, Ticker, Parameters);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.template PreSimTick<TDriver>(Driver, Buffers, Ticker, Parameters);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.template PreSimTick<TDriver>(Driver, Buffers, Ticker, Parameters);
			break;
		}

		// -------------------------------------------------------------------------------------------------------------------------------------------------
		//												Input Processing & Simulation Update
		// -------------------------------------------------------------------------------------------------------------------------------------------------
		while (Ticker.PendingKeyframe <= Ticker.MaxAllowedKeyframe)
		{
			const int32 InputKeyframe = Ticker.PendingKeyframe;
			const int32 OutputKeyframe = Ticker.PendingKeyframe + 1;

			const TInputCmd* InputCmd = Buffers.Input[InputKeyframe];
			if (!ensureMsgf(InputCmd, TEXT("No InputCmd available for Keyframe %d. PendingKeyframe: %d. MaxAllowedKeyframe: %d."), InputKeyframe, Ticker.PendingKeyframe, Ticker.MaxAllowedKeyframe))
			{
				break;
			}

			// We have an unprocessed command, do we have enough allotted simulation time to process it?
			if (Ticker.GetRemainingAllowedSimulationTime() >= InputCmd->GetFrameDeltaTime())
			{
				TSyncState* InSyncState = Buffers.Sync[InputKeyframe];
				if (InSyncState == nullptr)
				{
					// We don't have valid sync state for this frame. This could mean we skipped ahead somehow, such as heavy packet loss where the server doesn't receive all input cmds
					// We will use the last known sync state, but first write it out to the current InputKeyframe
					UE_LOG(LogNetworkSim, Log, TEXT("%s: No sync state found @ keyframe %d. Using previous head element @ keyframe %d."), *Driver->GetDebugName(), InputKeyframe, Buffers.Sync.HeadKeyframe());
					InSyncState = Buffers.Sync.WriteKeyframeInitializedFromHead(InputKeyframe);
				}

				const TAuxState* InAuxState = Buffers.Aux[InputKeyframe];
				checkf(InAuxState, TEXT("No AuxState available for Keyframe %d. PendingKeyframe: %d. MaxAllowedKeyframe: %d."), InputKeyframe, Ticker.PendingKeyframe, Ticker.MaxAllowedKeyframe);

				TSyncState* OutSyncState = Buffers.Sync.WriteKeyframe(OutputKeyframe);
				check(OutSyncState);

				{
					TScopedSimulationTick UpdateScope(Ticker, OutputKeyframe, InputCmd->GetFrameDeltaTime());
					
					Simulation->SimulationTick( 
						{ InputCmd->GetFrameDeltaTime(), Ticker },
						{ *InputCmd, *InSyncState, *InAuxState },
						{ *OutSyncState, Buffers.Aux.LazyWriter(OutputKeyframe) } );
													
				}

				if (DebugState)
				{
					DebugState->ProcessedKeyframes.Add(InputKeyframe);
				}
			}
			else
			{
				break;
			}
		}

		// -------------------------------------------------------------------------------------------------------------------------------------------------
		//												Post Sim Tick: finalize the frame
		// -------------------------------------------------------------------------------------------------------------------------------------------------

		switch (Parameters.Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.template PostSimTick<TDriver>(Driver, Buffers, Ticker, Parameters);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.template PostSimTick<TDriver>(Driver, Buffers, Ticker, Parameters);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.template PostSimTick<TDriver>(Driver, Buffers, Ticker, Parameters);
			break;
		}

		// -------------------------------------------------------------------------------------------------------------------------------------------------
		//														Debug
		// -------------------------------------------------------------------------------------------------------------------------------------------------

		// Finish debug state buffer recording (what the server processed each frame)
		if (DebugState)
		{
			DebugState->PendingKeyframe = Ticker.PendingKeyframe;
			DebugState->HeadKeyframe = Buffers.Input.HeadKeyframe();
			DebugState->RemainingAllowedSimulationTimeSeconds = (float)Ticker.GetRemainingAllowedSimulationTime().ToRealTimeSeconds();
		}

		// Historical data recording (longer buffers for historical reference)
		if (auto* HistoricData = GetHistoricBuffers())
		{
			HistoricData->Input.CopyAndMerge(Buffers.Input);
			HistoricData->Sync.CopyAndMerge(Buffers.Sync);
			HistoricData->Aux.CopyAndMerge(Buffers.Aux);
		}
	}

	virtual void Reconcile(const ENetRole Role) final override
	{
		// --------------------------------------------------------------------------------------------------------------------------
		//	Reconcile
		//	This will eventually be called outside the Tick loop, only after processing a network bunch
		//	Reconcile is about "making things right" after a network update. We are not processing "more" simulation yet.
		// --------------------------------------------------------------------------------------------------------------------------
		switch (Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.template Reconcile<TSimulation, TDriver>(Simulation, Driver, Buffers, Ticker);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.template Reconcile<TSimulation, TDriver>(Simulation, Driver, Buffers, Ticker);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.template Reconcile<TSimulation, TDriver>(Simulation, Driver, Buffers, Ticker);
			break;
		}
	}
	
	void InitializeForNetworkRole(const ENetRole Role, const FNetworkSimulationModelInitParameters& Parameters) final override
	{
		// FIXME: buffer sizes are now inlined allocated but we want to support role based buffer sizes

		//Buffers.Input.SetBufferSize(Parameters.InputBufferSize);
		//Buffers.Sync.SetBufferSize(Parameters.SyncedBufferSize);
		//Buffers.Aux.SetBufferSize(Parameters.AuxBufferSize); AUXFIXME

		if (GetLocalDebugBuffer())
		{
			//GetLocalDebugBuffer()->SetBufferSize(Parameters.DebugBufferSize);
		}

		if (auto* MyHistoricBuffers = GetHistoricBuffers(true))
		{
			//MyHistoricBuffers->Input.SetBufferSize(Parameters.HistoricBufferSize);
			//MyHistoricBuffers->Sync.SetBufferSize(Parameters.HistoricBufferSize);
			//MyHistoricBuffers->Aux.SetBufferSize(Parameters.HistoricBufferSize); AUXFIXME
		}

		//Ticker.InitSimulationTimeBuffer(Parameters.SyncedBufferSize);
	}

	void NetSerializeProxy(EReplicationProxyTarget Target, const FNetSerializeParams& Params) final override
	{
		switch(Target)
		{
		case EReplicationProxyTarget::ServerRPC:
			RepProxy_ServerRPC.NetSerialize(Params, Buffers, Ticker);
			break;
		case EReplicationProxyTarget::AutonomousProxy:
			RepProxy_Autonomous.NetSerialize(Params, Buffers, Ticker);
			break;
		case EReplicationProxyTarget::SimulatedProxy:
			RepProxy_Simulated.NetSerialize(Params, Buffers, Ticker);
			break;
		case EReplicationProxyTarget::Replay:
			RepProxy_Replay.NetSerialize(Params, Buffers, Ticker);
			break;
		case EReplicationProxyTarget::Debug:
#if NETSIM_MODEL_DEBUG
			RepProxy_Debug.NetSerialize(Params, Buffers, Ticker);
			break;
#endif
		default:
			checkf(false, TEXT("Unknown: %d"), (int32)Target);
		};
	}

	int32 GetProxyDirtyCount(EReplicationProxyTarget Target) final override
	{
		switch(Target)
		{
		case EReplicationProxyTarget::ServerRPC:
			return RepProxy_ServerRPC.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::AutonomousProxy:
			return RepProxy_Autonomous.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::SimulatedProxy:
			return RepProxy_Simulated.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::Replay:
			return RepProxy_Replay.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::Debug:
#if NETSIM_MODEL_DEBUG
			return RepProxy_Debug.GetProxyDirtyCount(Buffers);
#endif
		default:
			checkf(false, TEXT("Unknown: %d"), (int32)Target);
			return 0;
		};
	}

	ESimulatedUpdateMode GetSimulatedUpdateMode() const
	{
		return RepProxy_Simulated.GetSimulatedUpdateMode();
	}

	// ------------------------------------------------------------------------------------------------------

	void SetParentSimulation(INetworkSimulationModel* ParentSimulation) final override
	{
		if (RepProxy_Simulated.ParentSimulation)
		{
			RepProxy_Simulated.ParentSimulation->RemoveDependentSimulation(this);
		}
		
		RepProxy_Simulated.ParentSimulation = ParentSimulation;
		if (ParentSimulation)
		{
			ParentSimulation->AddDependentSimulation(this);
		}
	}

	INetworkSimulationModel* GetParentSimulation() const final override
	{
		return RepProxy_Simulated.ParentSimulation;
	}

	void AddDependentSimulation(INetworkSimulationModel* DependentSimulation) final override
	{
		check(RepProxy_Autonomous.DependentSimulations.Contains(DependentSimulation) == false);
		RepProxy_Autonomous.DependentSimulations.Add(DependentSimulation);
		NotifyDependentSimNeedsReconcile(); // force reconcile on purpose
	}

	void RemoveDependentSimulation(INetworkSimulationModel* DependentSimulation) final override
	{
		RepProxy_Autonomous.DependentSimulations.Remove(DependentSimulation);
	}

	void NotifyDependentSimNeedsReconcile()
	{
		RepProxy_Autonomous.bDependentSimulationNeedsReconcile = true;
	}

	void BeginRollback(const FNetworkSimTime& RollbackDeltaTime, const int32 ParentKeyframe) final override
	{
		RepProxy_Simulated.template DependentRollbackBegin<TSimulation, TDriver>(Simulation, Driver, Buffers, Ticker, RollbackDeltaTime, ParentKeyframe);
	}

	void StepRollback(const FNetworkSimTime& Step, const int32 ParentKeyframe, const bool bFinalStep) final override
	{
		RepProxy_Simulated.template DependentRollbackStep<TSimulation, TDriver>(Simulation, Driver, Buffers, Ticker, Step, ParentKeyframe, bFinalStep);
	}

	void ClearAllDependentSimulations()
	{
		TArray<INetworkSimulationModel*> LocalList = MoveTemp(RepProxy_Autonomous.DependentSimulations);
		for (INetworkSimulationModel* DependentSim : LocalList)
		{
			DependentSim->SetParentSimulation(nullptr);
		}
	}

	// -------------------------------------------------------------------------------------------------------

	TSimulation* Simulation = nullptr;
	TDriver* Driver = nullptr;

	TSimulationTicker<TTickSettings> Ticker;

	TNetworkSimBufferContainer<TBufferTypes> Buffers;

	TRepProxyServerRPC RepProxy_ServerRPC;
	TRepProxyAutonomous RepProxy_Autonomous;
	TRepProxySimulated RepProxy_Simulated;
	TRepProxyReplay RepProxy_Replay;

	using TInputBuffer = typename TNetworkSimBufferContainer<TBufferTypes>::TInputBuffer;
	using TSyncBuffer = typename TNetworkSimBufferContainer<TBufferTypes>::TSyncBuffer;
	using TAuxBuffer = typename TNetworkSimBufferContainer<TBufferTypes>::TAuxBuffer;
	using TDebugBuffer = typename TNetworkSimBufferContainer<TBufferTypes>::TDebugBuffer;

	// ------------------------------------------------------------------
	// RPC Sending helper: provides basic send frequency settings for tracking when the Server RPC can be invoked.
	// Note that the Driver is the one that must call the RPC, that cannot be rolled into this templated structure.
	// More flexbile/dynamic send rates may be desireable. There is not reason this *has* to be done here, it could
	// completely be tracked at the driver level, but that will also push more boilerplate to that layer for users.
	// ------------------------------------------------------------------

	void SetDesiredServerRPCSendFrequency(float DesiredHz) final override { ServerRPCThresholdTimeSeconds = 1.f / DesiredHz; }
	bool ShouldSendServerRPC(float DeltaTimeSeconds) final override
	{
		// Don't allow a large delta time to pollute the accumulator
		const float CappedDeltaTimeSeconds = FMath::Min<float>(DeltaTimeSeconds, ServerRPCThresholdTimeSeconds);
		ServerRPCAccumulatedTimeSeconds += DeltaTimeSeconds;
		if (ServerRPCAccumulatedTimeSeconds >= ServerRPCThresholdTimeSeconds)
		{
			ServerRPCAccumulatedTimeSeconds -= ServerRPCThresholdTimeSeconds;
			return true;
		}

		return false;
	}

	// Simulation class should have a static const FName GroupName member
	FName GetSimulationGroupName() const final override { return TSimulation::GroupName; }

private:
	float ServerRPCAccumulatedTimeSeconds = 0.f;
	float ServerRPCThresholdTimeSeconds = 1.f / 999.f; // Default is to send at a max of 999hz. This part of the system needs to be build out more (better handling of super high FPS clients and fixed rate servers)

	// ------------------------------------------------------------------
	//	Debugging
	// ------------------------------------------------------------------
public:

#if NETSIM_MODEL_DEBUG
	TDebugBuffer* GetLocalDebugBuffer() {	return &Buffers.Debug; }
	TDebugState* GetNextLocalDebugStateWrite() { return Buffers.Debug.WriteKeyframe( Buffers.Debug.HeadKeyframe() + 1 ); }
	TNetworkSimBufferContainer<TBufferTypes>* GetHistoricBuffers(bool bCreate=false)
	{
		if (HistoricBuffers.IsValid() == false && bCreate) { HistoricBuffers.Reset(new TNetworkSimBufferContainer<TBufferTypes>()); }
		return HistoricBuffers.Get();
	}

	TDebugBuffer* GetRemoteDebugBuffer() {	return &RepProxy_Debug.ReceivedBuffer; }
#else
	TDebugBuffer* GetLocalDebugBuffer() {	return nullptr; }
	TDebugState* GetNextLocalDebugStateWrite() { return nullptr; }
	TNetworkSimBufferContainer<TBufferTypes>* GetHistoricBuffers(bool bCreate=false) { return nullptr; }
	TDebugBuffer* GetRemoteDebugBuffer() {	return nullptr; }
#endif

private:

#if NETSIM_MODEL_DEBUG
	TRepProxyDebug RepProxy_Debug;
	TUniquePtr<TNetworkSimBufferContainer<TBufferTypes>> HistoricBuffers;
#endif

};