// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#pragma once
#include "NetworkPredictionTypes.h"
#include "NetworkSimulationModelBuffer.h"
#include "NetworkSimulationModelTypes.h"
#include "NetworkSimulationModelReplicators.h"

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//	TNetworkedSimulationModel
//	
//	* Has all logic for "ticking, advancing buffers, calling Update, calling ServerRPC etc
//	* Doesn't have anything about update component, movesweep, etc
//	* Concept of "IDriver" which is the owning object that is driving the network sim. This is the interface to the outside UE4 world.
//	* Has 4 buffers:
//		-Input: Generated by a client / not the authority.
//		-Sync: What we are trying to keep in sync. The state that evolves frame to frame with an Update function.
//		-Aux: State that is also an input into the simulation but does not intrinsically evolve from to frame. Changes to this state can be trapped/tracked/predicted.
//		-Debug: Replicated buffer from server->client with server-frame centered debug information. Compiled out of shipping builds.
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

template <
	typename T,
	typename TUserBufferTypes,
	typename InTTickSettings=TNetworkSimTickSettings<>,
	typename TRepProxyServerRPC =	TReplicator_DynamicSequence	<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings, ENetworkSimBufferTypeId::Input>,
	typename TRepProxyAutonomous =	TReplicator_BasicReconciliar <TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings>,
	typename TRepProxySimulated =	TReplicator_SimulatedExtrapolatedReconciliar <TInternalBufferTypes<TUserBufferTypes, InTTickSettings>, InTTickSettings>,
	typename TRepProxyReplay =		TReplicator_DynamicSequence	<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings, ENetworkSimBufferTypeId::Sync>,
	typename TRepProxyDebug =		TReplicator_DynamicSequence	<TInternalBufferTypes<TUserBufferTypes, InTTickSettings>,	InTTickSettings, ENetworkSimBufferTypeId::Debug>
>
class TNetworkedSimulationModel : public IReplicationProxy
{
public:

	using TBufferTypes = TInternalBufferTypes<TUserBufferTypes, InTTickSettings>;
	using TTickSettings = InTTickSettings;

	using TInputCmd = typename TBufferTypes::TInputCmd;
	using TSyncState = typename TBufferTypes::TSyncState;
	using TAuxState = typename TBufferTypes::TAuxState;
	using TDebugState = typename TBufferTypes::TDebugState;

	using TSimTime = TNetworkSimTime<TTickSettings>;
	using TRealTime = typename TTickSettings::TRealTime;

	class IDriver
	{
	public:
		virtual void InitSyncState(TSyncState& OutSyncState) const = 0;	// Called to create initial value of the sync state.
		virtual void ProduceInput(const TSimTime&, typename TUserBufferTypes::TInputCmd&) = 0; // Called when the sim is ready to process new local input
		virtual void FinalizeFrame(const TSyncState& SyncState) = 0; // Called from the Network Sim at the end of the sim frame when there is new sync data.
	};

	struct FTickParameters
	{
		ENetRole Role;
		float LocalDeltaTimeSeconds;
	};

	template<typename TDriver>
	void Tick(TDriver* Driver, const FTickParameters& Parameters)
	{
		TDebugState* const DebugState = GetNextDebugStateWrite();
		if (DebugState)
		{
			DebugState->LocalDeltaTimeSeconds = Parameters.LocalDeltaTimeSeconds;
			DebugState->LocalGFrameNumber = GFrameNumber;
			DebugState->ProcessedKeyframes.Reset();
		}

		// --------------------------------------------------------------------------------------------------------------------------
		//	Reconcile
		//	This will eventually be called outside the Tick loop, only after processing a network bunch
		//	Reconcile is about "making things right" after a network update. We are not processing "more" simulation yet.
		// --------------------------------------------------------------------------------------------------------------------------
		switch (Parameters.Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.template Reconcile<T, TDriver>(Driver, Buffers, TickInfo);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.template Reconcile<T, TDriver>(Driver, Buffers, TickInfo);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.template Reconcile<T, TDriver>(Driver, Buffers, TickInfo);
			break;
		}

		// ----------------------------------------------------------------------------------------------------------------
		//	PreSimTick
		//	This is the beginning of a new frame. PreSimTick will decide if we should take Parameters.LocalDeltaTimeSeconds
		//	and advance the simulation or not. It will also generate new local input if necessary.
		// ----------------------------------------------------------------------------------------------------------------
		switch (Parameters.Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.template PreSimTick<T, TDriver>(Driver, Buffers, TickInfo, Parameters.LocalDeltaTimeSeconds);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.template PreSimTick<T, TDriver>(Driver, Buffers, TickInfo, Parameters.LocalDeltaTimeSeconds);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.template PreSimTick<T, TDriver>(Driver, Buffers, TickInfo, Parameters.LocalDeltaTimeSeconds);
			break;
		}		

		switch (Parameters.Role) {

		
		case ROLE_AutonomousProxy:
		{
			// Check SyncBuffer being ahead of processed Keyframes. This would happen in cases where we are either not predicting or are buffering our input locally
			// while sending latest cmds to the server. Essentially, we got the authoritative motion state from the server before we ran the simulation locally.
			if (Buffers.Sync.GetHeadKeyframe() > TickInfo.LastProcessedInputKeyframe)
			{
				checkf(Buffers.Input.IsValidKeyframe(Buffers.Sync.GetHeadKeyframe()), TEXT("MotionState and InputCmd buffers are out of system. LastProcessedInputKeyframe: %d {%s} vs {%s}"),
					TickInfo.LastProcessedInputKeyframe, *Buffers.Sync.GetBasicDebugStr(), *Buffers.Input.GetBasicDebugStr());

				UE_LOG(LogNetworkSim, Warning, TEXT("Skipping local input frames because we have newer data in SyncBuffer. LastProcessedInputKeyframe: %d. {%s} {%s}"),
					TickInfo.LastProcessedInputKeyframe, *Buffers.Sync.GetBasicDebugStr(), *Buffers.Input.GetBasicDebugStr());

				TickInfo.LastProcessedInputKeyframe = Buffers.Sync.GetHeadKeyframe();
			}
			break;
		}

		case ROLE_Authority:
		{
			if ( TickInfo.LastProcessedInputKeyframe+1 < Buffers.Input.GetTailKeyframe() )
			{
				// We've missed commands
				UE_LOG(LogNetworkSim, Warning, TEXT("::Tick missing inputcmds. LastProcessedInputKeyframe: %d. %s"), TickInfo.LastProcessedInputKeyframe, *Buffers.Input.GetBasicDebugStr());
				TickInfo.LastProcessedInputKeyframe = Buffers.Input.GetTailKeyframe()+1;
			}
			break;
		}

		case ROLE_SimulatedProxy:
		{
			RepProxy_Simulated.template Reconcile<T, TDriver>(Driver, Buffers, TickInfo);
			break;
		}

		} // end switch

		// -------------------------------------------------------------------------------------------------------------------------------------------------
		//	PreInput processing
		//	We are just about to start mechanically processing input. Lets just make sure we have a valid sync state to start with
		// -------------------------------------------------------------------------------------------------------------------------------------------------

		// The SyncedState buffer needs to be in sync here:
		//	-We want it to have a SyncedState, but it may not on the first frame through (thats ok).
		//  -Its HeadKeyframe should be one behind the Keyframe we are about to process.
		//
		// Note, InputCmds start @ Keyframe=1. The first SyncedState that Update produces will go in KeyFrame=1.
		// (E.g, InputCmd @ keyframe=X is used to generate MotionState @ keyframe=X)
		// This means that SyncedState @ keyframe=0 is always created here via InitSyncState.
		// This also means that we never actually process InputCmd @ keyframe=0. Which is why LastProcessedInputKeyframe is initialized to 0 ("already processed")
		// and the buffer has an empty element inserted in InitLocalInputBuffer.

		if (Buffers.Sync.GetHeadKeyframe() != TickInfo.LastProcessedInputKeyframe)
		{
			if (TickInfo.LastProcessedInputKeyframe != 0)
			{
				// This shouldn't happen, but is not fatal. We are reseting the sync state buffer.
				UE_LOG(LogNetworkSim, Warning, TEXT("Break in SyncState continuity. LastProcessedInputKeyframe: %d. SyncBuffer.GetHeadKeyframe(): %d. Role=%d"), TickInfo.LastProcessedInputKeyframe, Buffers.Sync.GetHeadKeyframe(), (int32)Parameters.Role);
			}

			// We need an initial/current state. Get this from the sim driver
			Buffers.Sync.ResetNextHeadKeyframe(TickInfo.LastProcessedInputKeyframe);
			TSyncState* StartingState = Buffers.Sync.GetWriteNext();
			Driver->InitSyncState(*StartingState);
		}

		// -------------------------------------------------------------------------------------------------------------------------------------------------
		//														Input Processing
		// -------------------------------------------------------------------------------------------------------------------------------------------------

		while(true)
		{
			const int32 Keyframe = TickInfo.LastProcessedInputKeyframe+1;
			if (Keyframe > TickInfo.MaxAllowedInputKeyframe)
			{
				break;
			}

			if (TInputCmd* NextCmd = Buffers.Input.FindElementByKeyframe(Keyframe))
			{
				// We have an unprocessed command, do we have enough allotted simulation time to process it?
				if (TickInfo.GetRemaningAllowedSimulationTime() >= NextCmd->GetFrameDeltaTime())
				{
					// -------------------------------------------------------------------------------------------------
					//	The core process input command and call ::Update block!
					// -------------------------------------------------------------------------------------------------
					TSyncState* PrevSyncState = Buffers.Sync.FindElementByKeyframe(TickInfo.LastProcessedInputKeyframe);
					TSyncState* NextSyncState = Buffers.Sync.GetWriteNext();

					check(PrevSyncState != nullptr);
					check(NextSyncState != nullptr);
					check(Buffers.Sync.GetHeadKeyframe() == Keyframe);
				
					if (DebugState)
					{
						DebugState->ProcessedKeyframes.Add(Keyframe);
					}
					
					TAuxState AuxState; // Temp: aux buffer not implemented yet

					T::Update(Driver, NextCmd->GetFrameDeltaTime(), *NextCmd, *PrevSyncState, *NextSyncState, AuxState);
					
					TickInfo.TotalProcessedSimulationTime += NextCmd->GetFrameDeltaTime();
					TickInfo.LastProcessedInputKeyframe = Keyframe;
				}
				else
				{
					break;
				}
			}
			else
			{
				break;
			}
		}


		// FIXME: this needs to be sorted out. We really want to check if there is new sync state and then call this here.
		// Call into the driver to sync to the latest state if we processed any input
		//if (NumProcessed > 0)
		{
			//check(SyncBuffer.GetNumValidElements() > 0);
			if (Buffers.Sync.GetNumValidElements() > 0)
			{
				Driver->FinalizeFrame(*Buffers.Sync.GetElementFromHead(0));
			}
		}

		// -------------------------------------------------------------------------------------------------------------------------------------------------
		//														Debug
		// -------------------------------------------------------------------------------------------------------------------------------------------------

		// Finish debug state buffer recording (what the server processed each frame)
		if (DebugState)
		{
			DebugState->LastProcessedKeyframe = TickInfo.LastProcessedInputKeyframe;
			DebugState->HeadKeyframe = Buffers.Input.GetHeadKeyframe();
		}

		// Historical data recording (longer buffers for historical reference)
		if (auto* HistoricData = GetHistoricBuffers())
		{
			HistoricData->Input.CopyAndMerge(Buffers.Input);
			HistoricData->Sync.CopyAndMerge(Buffers.Sync);
			HistoricData->Aux.CopyAndMerge(Buffers.Aux);
		}
	}	
	
	void InitializeForNetworkRole(const ENetRole Role, const bool IsLocallyControlled, const FNetworkSimulationModelInitParameters& Parameters)
	{
		Buffers.Input.SetBufferSize(Parameters.InputBufferSize);
		Buffers.Sync.SetBufferSize(Parameters.SyncedBufferSize);
		Buffers.Aux.SetBufferSize(Parameters.AuxBufferSize);

		if (GetDebugBuffer())
		{
			GetDebugBuffer()->SetBufferSize(Parameters.DebugBufferSize);
		}

		if (auto* MyHistoricBuffers = GetHistoricBuffers(true))
		{
			MyHistoricBuffers->Input.SetBufferSize(Parameters.HistoricBufferSize);
			MyHistoricBuffers->Sync.SetBufferSize(Parameters.HistoricBufferSize);
			MyHistoricBuffers->Aux.SetBufferSize(Parameters.HistoricBufferSize);
		}

		if (IsLocallyControlled)
		{
			check(Parameters.InputBufferSize > 0); // If you tell me this is locally controlled, you need to have an input buffer.
			InitLocalInputBuffer();
		}
	}

	void NetSerializeProxy(EReplicationProxyTarget Target, const FNetSerializeParams& Params)
	{
		// You are not allowed to change the simulations TickInfo while NetSerializing. Since all rep proxies are templated
		// and there is not interface/base class, we are enforcing the constness at the call site.
		const TSimulationTickState<TTickSettings>& ConstTickInfo = const_cast<const TSimulationTickState<TTickSettings>&>(TickInfo);

		switch(Target)
		{
		case EReplicationProxyTarget::ServerRPC:
			RepProxy_ServerRPC.NetSerialize(Params, Buffers, ConstTickInfo);
			break;
		case EReplicationProxyTarget::AutonomousProxy:
			RepProxy_Autonomous.NetSerialize(Params, Buffers, ConstTickInfo);
			break;
		case EReplicationProxyTarget::SimulatedProxy:
			RepProxy_Simulated.NetSerialize(Params, Buffers, ConstTickInfo);
			break;
		case EReplicationProxyTarget::Replay:
			RepProxy_Replay.NetSerialize(Params, Buffers, ConstTickInfo);
			break;
		case EReplicationProxyTarget::Debug:
#if NETSIM_MODEL_DEBUG
			RepProxy_Debug.NetSerialize(Params, Buffers, ConstTickInfo);
			break;
#endif
		default:
			checkf(false, TEXT("Unknown: %d"), (int32)Target);
		};
	}

	int32 GetProxyDirtyCount(EReplicationProxyTarget Target)
	{
		switch(Target)
		{
		case EReplicationProxyTarget::ServerRPC:
			return RepProxy_ServerRPC.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::AutonomousProxy:
			return RepProxy_Autonomous.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::SimulatedProxy:
			return RepProxy_Simulated.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::Replay:
			return RepProxy_Replay.GetProxyDirtyCount(Buffers);
		case EReplicationProxyTarget::Debug:
#if NETSIM_MODEL_DEBUG
			return RepProxy_Debug.GetProxyDirtyCount(Buffers);
#endif
		default:
			checkf(false, TEXT("Unknown: %d"), (int32)Target);
			return 0;
		};
	}

	void InitLocalInputBuffer()
	{
		// Buffer should also be empty before calling this
		check(Buffers.Input.GetHeadKeyframe() == INDEX_NONE);

		// We want to start with an empty command in the input buffer. See notes in input buffer processing function.
		*Buffers.Input.GetWriteNext() = TInputCmd();
		TickInfo.LastLocalInputGFrameNumber = 0;
	}	
	
	TSimulationTickState<TTickSettings> TickInfo;	// Manages simulation time and what inputs we are processed

	TNetworkSimBufferContainer<TBufferTypes> Buffers;

	TRepProxyServerRPC RepProxy_ServerRPC;
	TRepProxyAutonomous RepProxy_Autonomous;
	TRepProxySimulated RepProxy_Simulated;
	TRepProxyReplay RepProxy_Replay;

	// ------------------------------------------------------------------
	// RPC Sending helper: provides basic send frequency settings for tracking when the Server RPC can be invoked.
	// Note that the Driver is the one that must call the RPC, that cannot be rolled into this templated structure.
	// More flexbile/dynamic send rates may be desireable. There is not reason this *has* to be done here, it could
	// completely be tracked at the driver level, but that will also push more boilerplate to that layer for users.
	// ------------------------------------------------------------------

	void SetDesiredServerRPCSendFrequency(float DesiredHz) { ServerRPCThresholdTimeSeconds = 1.f / DesiredHz; }
	bool ShouldSendServerRPC(ENetRole OwnerRole, float DeltaTimeSeconds)
	{
		// Don't allow a large delta time to pollute the accumulator
		const float CappedDeltaTimeSeconds = FMath::Min<float>(DeltaTimeSeconds, ServerRPCThresholdTimeSeconds);
		if (OwnerRole == ROLE_AutonomousProxy)
		{
			ServerRPCAccumulatedTimeSeconds += DeltaTimeSeconds;
			if (ServerRPCAccumulatedTimeSeconds >= ServerRPCThresholdTimeSeconds)
			{
				ServerRPCAccumulatedTimeSeconds -= ServerRPCThresholdTimeSeconds;
				return true;
			}
		}
		return false;
	}
private:
	float ServerRPCAccumulatedTimeSeconds = 0.f;
	float ServerRPCThresholdTimeSeconds = 1.f / 999.f; // Default is to send at a max of 999hz. This part of the system needs to be build out more (better handling of super high FPS clients and fixed rate servers)

	// ------------------------------------------------------------------
	//	Debugging
	// ------------------------------------------------------------------
public:

#if NETSIM_MODEL_DEBUG
	TReplicationBuffer<TDebugState>* GetDebugBuffer() {	return &Buffers.Debug; }
	TDebugState* GetNextDebugStateWrite() { return Buffers.Debug.GetWriteNext(); }
	TNetworkSimBufferContainer<TBufferTypes>* GetHistoricBuffers(bool bCreate=false)
	{
		if (HistoricBuffers.IsValid() == false && bCreate) { HistoricBuffers.Reset(new TNetworkSimBufferContainer<TBufferTypes>()); }
		return HistoricBuffers.Get();
	}
#else
	TReplicationBuffer<TDebugState>* GetDebugBuffer(bool bCreate=false) {	return nullptr; }
	TDebugState* GetNextDebugStateWrite() { return nullptr; }
	TNetworkSimBufferContainer<TBufferTypes>* GetHistoricBuffers() { return nullptr; }
#endif

private:

#if NETSIM_MODEL_DEBUG
	TRepProxyDebug RepProxy_Debug;
	TUniquePtr<TNetworkSimBufferContainer<TBufferTypes>> HistoricBuffers;
#endif
};
