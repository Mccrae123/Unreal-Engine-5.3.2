// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once
#include "NetworkPredictionTypes.h"
#include "NetworkedSimulationModelBuffer.h"
#include "NetworkedSimulationModelTypes.h"
#include "NetworkedSimulationModelRepControllers.h"
#include "NetworkedSimulationModelDebugger.h"
#include "NetworkedSimulationModelTraits.h"

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//	TNetworkedSimulationModel
//
//	This is the core object that ties all user-defined NetworkPrediction things together:
//		1. The Simulation: "pure" gameplay simulation: takes input -> produces output. Knows nothing about networking or the general UE4 side of things.
//		2. The Model Definition: defines user types, tick settings, the simulation class and functions such as ShouldReconcile and Interpolate. E.g, "How do you want the networking model to work".
//		3. The Driver: required interface for this NetSimModel to function: FinalizeFrame, ProduceInput, Debugging/VisualLogging, etc. Implemented by the Actor/Component/UE4 side.
//
//	* Contains all state in TNetworkedSimulationState
//		-Input: Generated by a client / not the authority.
//		-Sync: What we are trying to keep in sync. The state that evolves frame to frame with an Update function.
//		-Aux: State that is also an input into the simulation but does not intrinsically evolve from to frame. Changes to this state can be trapped/tracked/predicted.
//
//	* How other code interacts with this:
//		-Network updates will come in through UE4 networking -> FReplicationProxy (on actor/component) -> TNetworkedSimulationModel::RepProxy_* -> Buffers.*
//		-UNetworkSimulationGlobalManager: responsible for ticking simulation (after recv net traffic, prior to UE4 actor ticking)
//		-External game code can interact with the system:
//			-The TNetworkedSimulationModel is mostly public and exposed. It is not recommend to publicly expose to your "user" code (high level scripting, designers, etc).
//			-TNetkSimStateAccessor is a helper for safely reading/writing to state within the system.
//		-NetSimCues are how the simulation can invoke events out of the system that are "network aware"
//
//	* Notes on ownership and lifetime:
//		-User code will instantiate the underlying simulation class (TSimulation)
//		-Ownership of the simulation is taken over by TNetworkedSimulationModel on instantiation
//		-(user code may still want to cache a pointer to the TSimulation instance for its own, but does not need to destroy the simulation)
//		-Swapping TSimulation instance or releasing it early would be possible but use case is not clear so not implemented.
//		-TNetworkedSimulationModel lifetime is the responsibility of the code that created it (UNetworkPredictionComponent in most cases).
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Base for Network Simulation Model Defs (defines types used by the model)
class FNetSimModelDefBase
{
public:

	// -----------------------------------------------------------------------------------------------
	//	Must be set by user to compile:
	// -----------------------------------------------------------------------------------------------

	// The simulation class. This encompasses all state and functions for running the simulation but none of the networking/bookkeeping etc.
	using Simulation = void;

	// Buffer types: defines your Input/Sync/Aux state (and optional debug state)
	using BufferTypes = void;	

	// -----------------------------------------------------------------------------------------------
	//	Optional customization/overrides 
	// -----------------------------------------------------------------------------------------------

	// Model base class. E.g, common interface all NetworkedSimulationModels can be communicated with
	using Base = INetworkedSimulationModel;
	
	// Tick settings: defines variable vs fix step tick, etc
	using TickSettings = TNetworkSimTickSettings<>;
};

// Traits for which RepController structs are used internally
struct TNetSimModelRepControllerTraitsBase
{
	template<typename Model>
	using RepController_Server = TRepController_Server<Model>;

	template<typename Model>
	using RepController_Simulated = TRepController_Simulated<Model>;

	template<typename Model>
	using RepController_Autonomous = TRepController_Autonomous<Model>;

	template<typename Model>
	using RepController_Replay = TRepController_Simulated<Model>; // Replay writes simulated data stream.
};

// Template struct to specialize per-model
template<typename T> struct TNetSimModelRepControllerTraits : public TNetSimModelRepControllerTraitsBase { };

// The actual NetworkedSimulationModel templated class. InModelDef will be a user defined subtype of FNetSimModelDefBase
template <typename InModelDef>
class TNetworkedSimulationModel : public InModelDef::Base // InModelDef::Base defaults to INetworkedSimulationModel
{
public:

	// User Model
	using Model = InModelDef;
	
	// "Core" model pieces
	using TSimulation = typename Model::Simulation;
	using TTickSettings = typename Model::TickSettings;
	using TBufferTypes = typename Model::BufferTypes;

	using TDriver = TNetworkedSimulationModelDriver<TBufferTypes>;
	using TFrameState = TSimulationFrameState<Model>;

	// Buffer types
	using TInputCmd = typename TBufferTypes::TInputCmd;
	using TSyncState = typename TBufferTypes::TSyncState;
	using TAuxState = typename TBufferTypes::TAuxState;

	// Time
	using TSimTime = FNetworkSimTime;
	using TRealTime = FNetworkSimTime::FRealTime;
	
	// Core proxies that dictate how data replicates and how the simulation evolves for the three main roles
	using TRepProxyServerRPC =	typename TNetSimModelRepControllerTraits<Model>::template RepController_Server<Model>;
	using TRepProxySimulated =	typename TNetSimModelRepControllerTraits<Model>::template RepController_Simulated<Model>;
	using TRepProxyAutonomous =	typename TNetSimModelRepControllerTraits<Model>::template RepController_Autonomous<Model>;

	using TRepProxyReplay =	typename TNetSimModelRepControllerTraits<Model>::template RepController_Replay<Model>;

	// ----------------------------------------------------------------------------------------------------------
	//
	// ----------------------------------------------------------------------------------------------------------

	// Note: Ownership of TSimulation* is taken by this constructor
	template<typename TInDriver>
	TNetworkedSimulationModel(TSimulation* InSimulation, TInDriver* InDriver, const TSyncState& InitialSyncState = TSyncState(), const TAuxState& InitialAuxState = TAuxState())
		: Simulation(InSimulation)
	{
		check(Simulation.IsValid() && InDriver);
		Driver = InDriver;
		State.WriteFramePending()->SyncState = InitialSyncState;
		*State.WriteAuxState(0) = InitialAuxState;
		DO_NETSIM_MODEL_DEBUG(FNetworkSimulationModelDebuggerManager::Get().RegisterNetworkSimulationModel(this, Driver->GetVLogOwner()));

		this->ProcessPendingNetSimCuesFunc = [this, InDriver]()
		{ 
			State.CueDispatcher.template DispatchCueRecord<TInDriver>(*InDriver, State.GetTotalProcessedSimulationTime()); 
		};

		this->State.CueDispatcher.GetDebugName = [this]() { return Driver->GetDebugName(); };
		
		SimulationId = this->GetNextSimulationId();
		UE_NP_TRACE_SET_SCOPE_SIM(SimulationId);
		UE_NP_TRACE_SIM_CREATED(Driver->GetVLogOwner(), GetSimulationGroupName());
		UE_NP_TRACE_OOB_STATE_MOD(SimulationId);
		UE_NP_TRACE_USER_STATE_SYNC(InitialSyncState, 0);
		UE_NP_TRACE_USER_STATE_AUX(InitialAuxState, 0);

		bPendingOOBAuxWrite = false;
		bPendingOOBSyncWrite = false;
	}

	virtual ~TNetworkedSimulationModel()
	{
		SetParentSimulation(nullptr);
		ClearAllDependentSimulations();
	}

	void NetSerializeProxy(EReplicationProxyTarget Target, const FNetSerializeParams& Params) final override
	{
		UE_NP_TRACE_SET_SCOPE_SIM(SimulationId);
		FlushPendingOOBWrites();

		switch(Target)
		{
		case EReplicationProxyTarget::ServerRPC:
			RepProxy_ServerRPC.NetSerialize(Params, State);
			break;
		case EReplicationProxyTarget::AutonomousProxy:
			RepProxy_Autonomous.NetSerialize(Params, State);
			break;
		case EReplicationProxyTarget::SimulatedProxy:
			RepProxy_Simulated.NetSerialize(Params, State);
			break;
		case EReplicationProxyTarget::Replay:
			RepProxy_Replay.NetSerialize(Params, State);
			break;
		default:
			checkf(false, TEXT("Unknown: %d"), (int32)Target);
		};
	}

	virtual void Reconcile(const ENetRole Role) final override
	{
		UE_NP_TRACE_SET_SCOPE_SIM(SimulationId);
		FlushPendingOOBWrites();

		// --------------------------------------------------------------------------------------------------------------------------
		//	Reconcile
		//	This will eventually be called outside the Tick loop, only after processing a network bunch
		//	Reconcile is about "making things right" after a network update. We are not processing "more" simulation yet.
		// --------------------------------------------------------------------------------------------------------------------------
		switch (Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.Reconcile(Simulation.Get(), Driver, State);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.Reconcile(Simulation.Get(), Driver, State);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.Reconcile(Simulation.Get(), Driver, State);
			break;
		}
	}

	void Tick(const FNetSimTickParameters& Parameters) final override
	{
		UE_NP_TRACE_SET_SCOPE_SIM(SimulationId);
		FlushPendingOOBWrites();
		
		switch (Parameters.Role)
		{
			case ROLE_Authority:
				RepProxy_ServerRPC.Tick(Driver, Simulation.Get(), State, Parameters);
			break;

			case ROLE_AutonomousProxy:
				RepProxy_Autonomous.Tick(Driver, Simulation.Get(), State, Parameters);
			break;

			case ROLE_SimulatedProxy:
				RepProxy_Simulated.Tick(Driver, Simulation.Get(), State, Parameters);
			break;
		}		

		UE_NP_TRACE_SIM_EOF(State);
	}
	
	void InitializeForNetworkRole(const ENetRole Role, const FNetworkSimulationModelInitParameters& Parameters) final override
	{
		UE_NP_TRACE_NETROLE(SimulationId, Role);

		// FIXME: buffer sizes are now inlined allocated but we want to support role based buffer sizes

		//Buffers.Input.SetBufferSize(Parameters.InputBufferSize);
		//Buffers.Sync.SetBufferSize(Parameters.SyncedBufferSize);
		//Buffers.Aux.SetBufferSize(Parameters.AuxBufferSize);
	}	

	int32 GetProxyDirtyCount(EReplicationProxyTarget Target) final override
	{
		// Originally we were allowing RepControllers to define this but it seems overkill/unnecessary.
		// Simpler to assume if the system is changing, then replication is dirty. 
		return FMath::Max(State.GetPendingTickFrame(), State.GetLatestInputFrame());
	}

	ESimulatedUpdateMode GetSimulatedUpdateMode() const
	{
		return RepProxy_Simulated.GetSimulatedUpdateMode();
	}
	
	void SetEnableSimulationExtrapolation(bool bNewValue) final override
	{
		RepProxy_Simulated.bAllowSimulatedExtrapolation = bNewValue;
	}

	// ------------------------------------------------------------------------------------------------------
	//	OOB State access
	//		This is for outside game code to read/write to the sync&aux states.
	//		(Input should only be written via the ProduceInput driver callback)
	//		These accessors always operate on the PendingTickFrame's state: the 
	//		next frame that will be processed in a ::SimulationTick.
	// ------------------------------------------------------------------------------------------------------

	const TAuxState* ReadAuxState() const
	{
		const TAuxState* PendingAux = State.ReadAux(State.GetPendingTickFrame());
		npCheckSlow(PendingAux);
		return PendingAux; 
	}
	const TSyncState* ReadSyncState() const
	{
		const TFrameState* PendingFrameState = State.ReadFrame(State.GetPendingTickFrame());
		npCheckSlow(PendingFrameState);
		return &PendingFrameState->SyncState; 
	}

	// Returns Aux State for writing. TraceStr is an optional debug message that will traced.
	TAuxState* WriteAuxState(const TCHAR* TraceStr=nullptr)
	{
		FlushPendingOOBWriteAux();
		TAuxState* PendingAux = State.WriteAuxState(State.GetPendingTickFrame());
		npCheckSlow(PendingAux);
		bPendingOOBAuxWrite = true;
		UE_NP_TRACE_OOB_STR_AUX(SimulationId, TraceStr);
		return PendingAux; 
	}

	// Returns Sync State for writing. TraceStr is an optional debug message that will traced.
	TSyncState* WriteSyncState(const TCHAR* TraceStr=nullptr)
	{
		FlushPendingOOBWriteSync();
		TFrameState* PendingFrameState = State.WriteFramePending();
		npCheckSlow(PendingFrameState);
		bPendingOOBSyncWrite = true;
		UE_NP_TRACE_OOB_STR_SYNC(SimulationId, TraceStr);
		return &PendingFrameState->SyncState; 
	}

	// ------------------------------------------------------------------------------------------------------
	//	Dependent Simulations
	// ------------------------------------------------------------------------------------------------------

	void SetParentSimulation(INetworkedSimulationModel* ParentSimulation) final override
	{
		if (RepProxy_Simulated.ParentSimulation)
		{
			RepProxy_Simulated.ParentSimulation->RemoveDependentSimulation(this);
		}
		
		RepProxy_Simulated.ParentSimulation = ParentSimulation;
		if (ParentSimulation)
		{
			ParentSimulation->AddDependentSimulation(this);
		}
	}

	INetworkedSimulationModel* GetParentSimulation() const final override
	{
		return RepProxy_Simulated.ParentSimulation;
	}

	void AddDependentSimulation(INetworkedSimulationModel* DependentSimulation) final override
	{
		check(RepProxy_Autonomous.DependentSimulations.Contains(DependentSimulation) == false);
		RepProxy_Autonomous.DependentSimulations.Add(DependentSimulation);
		NotifyDependentSimNeedsReconcile(); // force reconcile on purpose
	}

	void RemoveDependentSimulation(INetworkedSimulationModel* DependentSimulation) final override
	{
		RepProxy_Autonomous.DependentSimulations.Remove(DependentSimulation);
	}

	void NotifyDependentSimNeedsReconcile()
	{
		RepProxy_Autonomous.bDependentSimulationNeedsReconcile = true;
	}

	void BeginRollback(const FNetworkSimTime& RollbackDeltaTime, const int32 ParentFrame) final override
	{
		UE_NP_TRACE_SET_SCOPE_SIM(SimulationId);
		RepProxy_Simulated.DependentRollbackBegin(Simulation.Get(), Driver, State, RollbackDeltaTime, ParentFrame);
	}

	void StepRollback(const FNetworkSimTime& Step, const int32 ParentFrame, const bool bFinalStep) final override
	{
		UE_NP_TRACE_SET_SCOPE_SIM(SimulationId);
		RepProxy_Simulated.DependentRollbackStep(Simulation.Get(), Driver, State, Step, ParentFrame, bFinalStep);
	}

	void ClearAllDependentSimulations()
	{
		TArray<INetworkedSimulationModel*> LocalList = MoveTemp(RepProxy_Autonomous.DependentSimulations);
		for (INetworkedSimulationModel* DependentSim : LocalList)
		{
			DependentSim->SetParentSimulation(nullptr);
		}
	}

	// -------------------------------------------------------------------------------------------------------

	TUniquePtr<TSimulation> Simulation;
	TDriver* Driver = nullptr;	

	TNetworkedSimulationState<Model> State;

	TRepProxyServerRPC RepProxy_ServerRPC;
	TRepProxyAutonomous RepProxy_Autonomous;
	TRepProxySimulated RepProxy_Simulated;
	TRepProxyReplay RepProxy_Replay;

	// ------------------------------------------------------------------
	// RPC Sending helper: provides basic send frequency settings for tracking when the Server RPC can be invoked.
	// Note that the Driver is the one that must call the RPC, that cannot be rolled into this templated structure.
	// More flexbile/dynamic send rates may be desireable. There is not reason this *has* to be done here, it could
	// completely be tracked at the driver level, but that will also push more boilerplate to that layer for users.
	// ------------------------------------------------------------------

	void SetDesiredServerRPCSendFrequency(float DesiredHz) final override { ServerRPCThresholdTimeSeconds = 1.f / DesiredHz; }
	bool ShouldSendServerRPC(float DeltaTimeSeconds) final override
	{
		// Don't allow a large delta time to pollute the accumulator
		const float CappedDeltaTimeSeconds = FMath::Min<float>(DeltaTimeSeconds, ServerRPCThresholdTimeSeconds);
		ServerRPCAccumulatedTimeSeconds += DeltaTimeSeconds;
		if (ServerRPCAccumulatedTimeSeconds >= ServerRPCThresholdTimeSeconds)
		{
			ServerRPCAccumulatedTimeSeconds -= ServerRPCThresholdTimeSeconds;
			return true;
		}

		return false;
	}

	// Simulation class should have a static const FName GroupName member
	FName GetSimulationGroupName() const final override { return Model::GroupName; }

	// Unique, global, per process Id of simulation. Used for trace debugging purposes only. Not replicated.
	uint32 GetSimulationId() const final override { return SimulationId; }

private:	

	void FlushPendingOOBWrites()
	{
		FlushPendingOOBWriteSync();
		FlushPendingOOBWriteAux();
	}

	void FlushPendingOOBWriteSync()
	{
		if (bPendingOOBSyncWrite)
		{
			UE_NP_TRACE_OOB_STATE_MOD(SimulationId);
			UE_NP_TRACE_USER_STATE_SYNC(*ReadSyncState(), State.GetPendingTickFrame());
			bPendingOOBSyncWrite = false;
		}
	}

	void FlushPendingOOBWriteAux()
	{
		if (bPendingOOBAuxWrite)
		{
			UE_NP_TRACE_OOB_STATE_MOD(SimulationId);
			UE_NP_TRACE_USER_STATE_AUX(*ReadAuxState(), State.GetPendingTickFrame());
			bPendingOOBAuxWrite = false;
		}
		
	}

	bool bPendingOOBAuxWrite:1;
	bool bPendingOOBSyncWrite:1;

	float ServerRPCAccumulatedTimeSeconds = 0.f;
	float ServerRPCThresholdTimeSeconds = 1.f / 999.f; // Default is to send at a max of 999hz. This part of the system needs to be build out more (better handling of super high FPS clients and fixed rate servers)

	uint32 SimulationId = 0;
};