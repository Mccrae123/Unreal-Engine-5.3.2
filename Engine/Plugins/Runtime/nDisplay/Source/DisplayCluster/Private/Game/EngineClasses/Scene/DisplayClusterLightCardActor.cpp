// Copyright Epic Games, Inc. All Rights Reserved.

#include "DisplayClusterLightCardActor.h"

#include "Components/StaticMeshComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "Materials/MaterialInstanceDynamic.h"
#include "Engine/StaticMesh.h"
#include "UObject/ConstructorHelpers.h"

#if WITH_OPENCV

#include "OpenCVHelper.h"

#include "PreOpenCVHeaders.h"
#include "opencv2/imgproc.hpp"
#include "PostOpenCVHeaders.h"

#endif //WITH_OPENCV

int32 GDisplayClusterLightCardPolygonTextureSize = 128;
static FAutoConsoleVariableRef CVarDisplayClusterLightCardPolygonTextureSize(
	TEXT("DC.LightCardPolygonTextureSize"),
	GDisplayClusterLightCardPolygonTextureSize,
	TEXT("Size of the textures generated by light cards that use a polygon to define its alpha mask. Use a power of 2."),
	ECVF_Default
);

const FRotator ADisplayClusterLightCardActor::PlaneMeshRotation = FRotator(0.0f, -90.0f, 90.0f);
const float ADisplayClusterLightCardActor::UVPlaneDefaultSize = 200.0f;
const float ADisplayClusterLightCardActor::UVPlaneDefaultDistance = 100.0f;

ADisplayClusterLightCardActor::ADisplayClusterLightCardActor(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
	, DistanceFromCenter(300.f)
	, Longitude(0.f)
	, Latitude(30.f)
	, Spin(0.f)
	, Pitch(0.f)
	, Yaw(0.f)
	, Scale(FVector2D(1.f))
	, RadialOffset(-0.5)
	, Mask(EDisplayClusterLightCardMask::Circle)
	, Texture(nullptr)
	, Color(FLinearColor(1.f, 1.f, 1.f, 1.f))
	, Temperature(6500)
	, Tint(0.f)
	, Exposure(0.f)
	, Gain(1.f)
	, Opacity(1.f)
	, Feathering(0.f)
{
	PrimaryActorTick.bCanEverTick = true;

	DefaultSceneRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("DefaultSceneRoot"));
	SetRootComponent(DefaultSceneRootComponent);

	MainSpringArmComponent = CreateDefaultSubobject<USpringArmComponent>(TEXT("MainSpringArm"));
	MainSpringArmComponent->AttachToComponent(DefaultSceneRootComponent, FAttachmentTransformRules::KeepRelativeTransform);
	MainSpringArmComponent->bDoCollisionTest = false;

	LightCardTransformerComponent = CreateDefaultSubobject<USceneComponent>(TEXT("LightCardTransformer"));
	LightCardTransformerComponent->AttachToComponent(MainSpringArmComponent, FAttachmentTransformRules::KeepRelativeTransform);

	static ConstructorHelpers::FObjectFinder<UStaticMesh> PlaneObj(TEXT("/nDisplay/LightCard/SM_LightCardPlane"));
	static ConstructorHelpers::FObjectFinder<UMaterial> LightCardMatObj(TEXT("/nDisplay/LightCard/M_LightCard"));

	LightCardComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("LightCard"));
	LightCardComponent->AttachToComponent(LightCardTransformerComponent, FAttachmentTransformRules::KeepRelativeTransform);
	LightCardComponent->SetCollisionProfileName(TEXT("OverlapAllDynamic"));
	LightCardComponent->Mobility = EComponentMobility::Movable;
	LightCardComponent->SetStaticMesh(PlaneObj.Object);
	LightCardComponent->SetMaterial(0, LightCardMatObj.Object);

	UpdateLightCardTransform();
}

void ADisplayClusterLightCardActor::OnConstruction(const FTransform& Transform)
{
	Super::OnConstruction(Transform);

	UpdatePolygonTexture();

	UMaterialInterface* Material = LightCardComponent->GetMaterial(0);

	if (Material && !Material->IsA<UMaterialInstanceDynamic>())
	{
		UMaterialInstanceDynamic* LightCardMatInstance = UMaterialInstanceDynamic::Create(Material, this, TEXT("LightCardMID"));
		LightCardComponent->SetMaterial(0, LightCardMatInstance);

		UpdateLightCardMaterialInstance();
	}
}

void ADisplayClusterLightCardActor::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	if (Longitude < 0 || Longitude > 360)
	{
		Longitude = FRotator::ClampAxis(Longitude);
	}

	if (Latitude < -90 || Latitude > 90)
	{
		// If latitude exceeds [-90, 90], mod it back into the appropriate range, and apply a shift of 180 degrees if
		// needed to the longitude, to allow the latitude to be continuous (increasing latitude indefinitely should result in the LC 
		// orbiting around a polar great circle)
		double Parity = FMath::Fmod(FMath::Abs(Latitude) + 90, 360) - 180;
		double DeltaLongitude = Parity > 1 ? 180.f : 0.f;

		double LatMod = FMath::Fmod(Latitude + 90.f, 180.f);
		if (LatMod < 0.f)
		{
			LatMod += 180.f;
		}

		Latitude = LatMod - 90;
		Longitude = FRotator::ClampAxis(Longitude + DeltaLongitude);
	}

	UpdateLightCardTransform();
	UpdateLightCardMaterialInstance();
	UpdateLightCardVisibility();
}

#if WITH_EDITOR

void ADisplayClusterLightCardActor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property && (
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, DistanceFromCenter) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Longitude) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Latitude) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Spin) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, RadialOffset) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Scale) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, bIsUVLightCard)))
	{
		UpdateLightCardTransform();
	}

	if (PropertyChangedEvent.Property && (
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Polygon) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Feathering)))
	{
		UpdatePolygonTexture();
	}

	if (PropertyChangedEvent.Property && (
		   PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Mask)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Polygon) 
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Texture) 
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Color)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Exposure)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Gain)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Opacity)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Feathering)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, AlphaGradient)
		))
	{
		UpdateLightCardMaterialInstance();
	}

	if (PropertyChangedEvent.Property && (
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, bIsUVLightCard)))
	{
		UpdateLightCardVisibility();
	}
}

#endif

FTransform ADisplayClusterLightCardActor::GetLightCardTransform(bool bIgnoreSpinYawPitch) const
{
	FTransform Transform;

	Transform.SetLocation(LightCardComponent->GetComponentLocation());

	FQuat LightCardOrientation;

	if (!bIgnoreSpinYawPitch)
	{
		// Use the light card component's orientation, but remove the plane mesh rotation so that the returned transform's local x axis
		// points radially inwards to match engine convention
		LightCardOrientation = LightCardComponent->GetComponentQuat() * PlaneMeshRotation.Quaternion().Inverse();
	}
	else
	{
		LightCardOrientation = LightCardTransformerComponent->GetComponentQuat();
	}

	Transform.SetRotation(LightCardOrientation);

	return Transform;
}

FBox ADisplayClusterLightCardActor::GetLightCardBounds(bool bLocalSpace) const
{
	FTransform ObjectOrientedTransform;
	ObjectOrientedTransform.SetRotation(PlaneMeshRotation.Quaternion());

	if (!bLocalSpace)
	{
		ObjectOrientedTransform.SetTranslation(LightCardComponent->GetComponentLocation());
		ObjectOrientedTransform.SetScale3D(LightCardComponent->GetComponentScale());
	}

	return LightCardComponent->CalcBounds(ObjectOrientedTransform).GetBox();
}

void ADisplayClusterLightCardActor::UpdateLightCardTransform()
{
	// If the light card is in UV space, set the spring arm's trasform to be zero, effectively removing it from the transform hierarchy
	// This allows the light card to be positioned with the actor's cartesian coordinates instead of longitude and latitude
	if (bIsUVLightCard)
	{
		MainSpringArmComponent->TargetArmLength = 0.0f;
		MainSpringArmComponent->SetRelativeRotation(FRotator(0.0, 180.0, 0.0));

		// Set world location and rotation such that the light card is always projected onto a YZ plane a distance of UVPlaneDefaultDistance from the world origin, facing in the -X direction
		// This ensures that when the UV light cards are rendered to the light card map, they are always positioned and oriented correctly regardless of the stages location and rotation.
		LightCardTransformerComponent->SetWorldLocation(FVector(UVPlaneDefaultDistance, -UVPlaneDefaultSize * (0.5 - UVCoordinates.X), UVPlaneDefaultSize * (0.5 - UVCoordinates.Y)));
		LightCardTransformerComponent->SetWorldRotation(FVector(-1, 0, 0).Rotation());
		LightCardTransformerComponent->SetWorldScale3D(FVector::OneVector);
	}
	else
	{
		MainSpringArmComponent->TargetArmLength = DistanceFromCenter + RadialOffset;
		MainSpringArmComponent->SetRelativeRotation(FRotator(-Latitude, Longitude, 0.0));
	}

	FRotator LightCardOrientation = FRotator(-Pitch, Yaw, Spin);

	LightCardComponent->SetRelativeRotation((LightCardOrientation.Quaternion() * PlaneMeshRotation.Quaternion()).Rotator());
	LightCardComponent->SetRelativeScale3D(FVector(Scale, 1.f));
}

void ADisplayClusterLightCardActor::UpdateLightCardMaterialInstance()
{
	if (UMaterialInstanceDynamic* LightCardMaterialInstance = Cast<UMaterialInstanceDynamic>(LightCardComponent->GetMaterial(0)))
	{
		// Showing proxy with low opacity to make it less distracting when it doesn't line up well with its projection in the Light Card Editor.
		constexpr float ProxyOpacity = 0.25;

		LightCardMaterialInstance->ClearParameterValues();

		LightCardMaterialInstance->SetVectorParameterValue(TEXT("CardColor"), Color);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Temperature"), Temperature);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Tint"), Tint);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Exposure"), Exposure);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Gain"), Gain);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Opacity"), bIsProxy ? ProxyOpacity : Opacity);
		LightCardMaterialInstance->SetTextureParameterValue(TEXT("Texture"), Texture);
		LightCardMaterialInstance->SetTextureParameterValue(TEXT("AlphaTexture"), PolygonMask);

		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradient"), AlphaGradient.bEnableAlphaGradient);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradientStartingAlpha"), AlphaGradient.StartingAlpha);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradientEndingAlpha"), AlphaGradient.EndingAlpha);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradientAngle"), AlphaGradient.Angle);

		bool bUseMask = true; // Enable masking
		bool bUseTextureAlpha = false; // Use the alpha channel of Texture as mask
		bool bUseAlphaTexture = false; // Use the AlphaTexture
		float FeatheringValue = Feathering;

		switch (Mask)
		{
		case EDisplayClusterLightCardMask::Square:
			bUseMask = false;
			break;

		case EDisplayClusterLightCardMask::UseTextureAlpha:
			bUseTextureAlpha = true;
			break;

		case EDisplayClusterLightCardMask::Polygon:
			bUseTextureAlpha = true;
			bUseAlphaTexture = true;
			FeatheringValue = 0.;
			break;
		}

		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Feather"), FeatheringValue);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("UseMask"), bUseMask);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("UseTextureAlpha"), bUseTextureAlpha);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("UseAlphaTexture"), bUseAlphaTexture);
	}
}

void ADisplayClusterLightCardActor::UpdatePolygonTexture()
{
#if WITH_OPENCV

	if (Polygon.Num() < 3)
	{
		PolygonMask = nullptr;
		return;
	}

	if (GDisplayClusterLightCardPolygonTextureSize < 2)
	{
		return;
	}

	const int32 TextureWidth = GDisplayClusterLightCardPolygonTextureSize;
	const int32 TextureHeight = GDisplayClusterLightCardPolygonTextureSize;

	cv::Mat GrayMat(cv::Size(TextureHeight, TextureWidth), CV_8UC1, cv::Scalar(0));

	std::vector<cv::Point2i> PolyVec; // polygon with LC shape that to be filled with cv::fillPoly
	PolyVec.reserve(Polygon.Num());

	for (const FVector2d& PolyPoint : Polygon)
	{
		PolyVec.push_back(cv::Point2i(
			FMath::RoundToInt(TextureWidth  * PolyPoint.X), 
			FMath::RoundToInt(TextureHeight * PolyPoint.Y))
		);
	}

	// Fill the polygon pixels
	cv::fillPoly(GrayMat, PolyVec, 255, cv::LINE_AA); // Polygon inside is 255, outside is 0

	// Apply feathering effect
	if (Feathering > 0)
	{
		// Overscan it so that the effects near the edges are as desired
		const int32 Overscan = (TextureWidth + TextureHeight) / 16;
		const cv::Size OverscanMatSize(GrayMat.rows + 2 * Overscan, GrayMat.cols + 2 * Overscan);
		cv::Mat OverscanMat(OverscanMatSize, GrayMat.type(), cv::Scalar(0));

		const cv::Rect OverscanActiveRect(Overscan, Overscan, GrayMat.cols, GrayMat.rows);

		GrayMat.copyTo(OverscanMat(OverscanActiveRect));

		// Erode to compensate for the growth that the blur causes
		{
			const int32 KernelSize = int32((Feathering * TextureWidth) / 6) * 2 + 1;

			const cv::Mat ErodeKernel = cv::getStructuringElement(
				cv::MORPH_ERODE,
				cv::Size(KernelSize, KernelSize)
			);

			cv::erode(OverscanMat, OverscanMat, ErodeKernel);
		}

		// Blur
		{
			const int32 KernelSize = int32((Feathering * TextureWidth) / 2) * 2 + 1;

			// We are going to blur the outside
			OverscanMat = 255 - OverscanMat;

			const float SigmaX = 0.2 * ((KernelSize - 1) * 0.5 - 1) + 0.8;
			const float SigmaY = SigmaX;

			cv::GaussianBlur(OverscanMat, OverscanMat, cv::Size(KernelSize, KernelSize), SigmaX, SigmaY);

			// We recover the non-inverted alpha now
			OverscanMat = 255 - OverscanMat;
		}

		// Put back to Gray
		OverscanMat(OverscanActiveRect).copyTo(GrayMat);
	}

	// Create a texture, all white and and the shape goes in the alpha
	cv::Mat RGBAMat(cv::Size(TextureWidth, TextureHeight), CV_8UC4, cv::Scalar::all(255));
	cv::insertChannel(GrayMat, RGBAMat, 3);

	// Create UTexture
	PolygonMask = FOpenCVHelper::TextureFromCvMat(RGBAMat);

#endif // WITH_OPENCV
}

void ADisplayClusterLightCardActor::UpdateLightCardVisibility()
{
	const bool bShouldBeVisible = !bIsUVLightCard || bIsProxy;
	const bool bIsVisible = !IsHidden();
	if (bIsVisible != bShouldBeVisible)
	{
		SetActorHiddenInGame(!bShouldBeVisible);
	}

#if WITH_EDITORONLY_DATA
	const bool bShouldHideFromEditor = !bShouldBeVisible;
	if (bShouldHideFromEditor != bHiddenEdLevel)
	{
		bHiddenEdLevel = bShouldHideFromEditor;
		bHiddenEdLayer = bShouldHideFromEditor;
		MarkComponentsRenderStateDirty();
	}
#endif
}

UStaticMesh* ADisplayClusterLightCardActor::GetStaticMesh() const
{
	return LightCardComponent->GetStaticMesh();
}

void ADisplayClusterLightCardActor::SetStaticMesh(UStaticMesh* InStaticMesh)
{
	LightCardComponent->SetStaticMesh(InStaticMesh);
}

ADisplayClusterLightCardActor::PositionalParams ADisplayClusterLightCardActor::GetPositionalParams()
{
	PositionalParams Params;

	Params.DistanceFromCenter = DistanceFromCenter;
	Params.Latitude = Latitude;
	Params.Longitude = Longitude;
	Params.Pitch = Pitch;
	Params.Spin = Spin;
	Params.Yaw = Yaw;
	Params.RadialOffset = RadialOffset;

	return Params;
}

void ADisplayClusterLightCardActor::SetPositionalParams(const PositionalParams& Params)
{
	DistanceFromCenter = Params.DistanceFromCenter;
	Latitude = Params.Latitude;
	Longitude = Params.Longitude;
	Pitch = Params.Pitch;
	Spin = Params.Spin;
	Yaw = Params.Yaw;
	RadialOffset = Params.RadialOffset;
}
