// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#pragma once

// Hash function
// From http://matthias-mueller-fischer.ch/publications/tetraederCollision.pdf
uint SpatialHash_HashFunction(int3 Position, uint TableSize)
{
	const uint p1 = 73856093;
	const uint p2 = 19349663;
	const uint p3 = 83492791;

	uint n = (p1 * Position.x) ^ (p2 * Position.y) ^ (p3 * Position.z);
	return n % TableSize;
}

int3 SpatialHash_GetCellIndex(float3 Position, float CellLength)
{
    return floor(Position / CellLength);
}

struct CandidateParticle
{
    NiagaraID ExternalID;
    float3 Position;
};

CandidateParticle ClosestCandidates[32];

void Initialize_ClosestCandidates()
{
    NiagaraID ID;
    ID.Index = -1;
    ID.AcquireTag = -1;
    CandidateParticle Candidate;
    Candidate.ExternalID = ID;
    Candidate.Position = float3(0, 0, 0);
    for (int i = 0; i < 32; ++i)
    {
        ClosestCandidates[i] = Candidate;
    }
}

#define FLT_MAX 3.402823466e+38F

void Heapify_ClosestCandidates(int Num, float3 Position)
{
    if (Num == 0 || Num == 1) { return; }
    CandidateParticle Closest[32];
    for (int ci = 0; ci < 32; ++ci) {
        Closest[ci] = ClosestCandidates[ci];
    }
    int StartIndex = 14;
    while (Closest[StartIndex].ExternalID.Index == -1)
    {
        StartIndex--;
    }
	
    for (int i = StartIndex; i >= 0; ++i)
    {
        int LeftChildIndex = ((i + 1) * 2) - 1;
        int RightChildIndex = LeftChildIndex + 1;
        float LeftDistance = Closest[LeftChildIndex].ExternalID.Index != -1 ? distance(Position, Closest[LeftChildIndex].Position) : FLT_MAX;
        float RightDistance = Closest[RightChildIndex].ExternalID.Index != -1 ? distance(Position, Closest[RightChildIndex].Position) : FLT_MAX;
        float CurrNodeDistance = distance(Position, Closest[i].Position);
        
        bool bSwapLeft = false;
        bool bSwapRight = false;

		if (CurrNodeDistance > LeftDistance && CurrNodeDistance > RightDistance)
        {
			// Swap with the smaller of the two
            if (LeftDistance < RightDistance)
            {
                bSwapLeft = true;
            }
            else
            {
                bSwapRight = true;
            }
        }
        else if (CurrNodeDistance > LeftDistance)
        {
            bSwapLeft = true;
        }
        else if (CurrNodeDistance > RightDistance)
        {
            bSwapRight = true;
        }

        if (bSwapLeft)
        {
            CandidateParticle Tmp = Closest[i];
            Closest[i] = Closest[LeftChildIndex];
            Closest[LeftChildIndex] = Tmp;
        }
        else if (bSwapRight)
        {
            CandidateParticle Tmp = Closest[i];
            Closest[i] = Closest[RightChildIndex];
            Closest[RightChildIndex] = Tmp;
        }
    }
    for (int i = 0; i < 32; ++i)
    {
        ClosestCandidates[i] = Closest[i];
    }
}

NiagaraID Pop_ClosestCandidates(int Num, float3 Position)
{
    NiagaraID Ret;
    if (Num == 0)
    {
        Ret.Index = -1;
        Ret.AcquireTag = -1;
        return Ret;
    }
	// Swap root with last element
    CandidateParticle Tmp = ClosestCandidates[0];
    Ret = Tmp.ExternalID;
    ClosestCandidates[0] = ClosestCandidates[Num - 1];

    NiagaraID ID;
    ID.Index = -1;
    ID.AcquireTag = -1;
    ClosestCandidates[Num - 1].ExternalID = ID;

	// Preserve heap order property
    int CurrIndex = 0;
    int LeftChildIndex = 1;
    int RightChildIndex = 2;
    float LeftDistance = ClosestCandidates[LeftChildIndex].ExternalID.Index != -1 ? distance(Position, ClosestCandidates[LeftChildIndex].Position) : FLT_MAX;
    float RightDistance = ClosestCandidates[RightChildIndex].ExternalID.Index != -1 ? distance(Position, ClosestCandidates[RightChildIndex].Position) : FLT_MAX;
    float CurrDistance = distance(Position, Tmp.Position);

    bool bSwapLeft = false;
    bool bSwapRight = false;

    while (CurrDistance > LeftDistance || CurrDistance > RightDistance)
    {
        if (CurrDistance > LeftDistance && CurrDistance > RightDistance)
        {
            if (LeftDistance < RightDistance)
            {
                bSwapLeft = true;
            }
            else
            {
                bSwapRight = true;
            }
        }
        else if (CurrDistance > LeftDistance)
        {
            bSwapLeft = true;
        }
        else if (CurrDistance > RightDistance)
        {
            bSwapRight = true;
        }
        if (bSwapLeft)
        {
            CandidateParticle Tmp = ClosestCandidates[CurrIndex];
            ClosestCandidates[CurrIndex] = ClosestCandidates[LeftChildIndex];
            ClosestCandidates[LeftChildIndex] = Tmp;
            CurrIndex = LeftChildIndex;
            CurrDistance = LeftDistance;
        }
        else if (bSwapRight)
        {
            CandidateParticle Tmp = ClosestCandidates[CurrIndex];
            ClosestCandidates[CurrIndex] = ClosestCandidates[RightChildIndex];
            ClosestCandidates[RightChildIndex] = Tmp;
            CurrIndex = RightChildIndex;
            CurrDistance = RightDistance;
        }
        LeftChildIndex = ((CurrIndex + 1) * 2) - 1;
        RightChildIndex = LeftChildIndex + 1;
        LeftDistance = ClosestCandidates[LeftChildIndex].ExternalID.Index != -1 ? distance(Position, ClosestCandidates[LeftChildIndex].Position) : FLT_MAX;
        RightDistance = ClosestCandidates[RightChildIndex].ExternalID.Index != -1 ? distance(Position, ClosestCandidates[RightChildIndex].Position) : FLT_MAX;
    }
    return Ret;
}

#undef FLT_MAX

#define DISPATIALHASH_DECLARE_CONSTANTS(NAME) \
	uint TableSize_ ## NAME; \
	uint MaximumNeighborCount_ ## NAME; \
	float MaximumSearchRadius_ ## NAME; \
	RWBuffer<int> NumParticles_ ## NAME; \
	float CellLength_ ## NAME; \
	RWBuffer<uint4> ParticleIDs_ ## NAME; \
	RWBuffer<float3> ParticlePosition_ ## NAME; \
	Buffer<uint4> Built_ParticleIDs_ ## NAME; \
	Buffer<float3> Built_ParticlePosition_ ## NAME; \
	RWBuffer<int> CellStartIndices_ ## NAME; \
	RWBuffer<int> CellEndIndices_ ## NAME; \
	RWBuffer<uint> CellCount_ ## NAME; \
	RWBuffer<NiagaraID> NearestNeighborResults_ ## NAME; \
	RWBuffer<uint> CurrentID_ ## NAME;
