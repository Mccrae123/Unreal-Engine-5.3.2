// Copyright Epic Games, Inc. All Rights Reserved.

#include "Custom/MaterialXUSDShadeMaterialTranslator.h"
#if USE_USD_SDK
#include "USDAssetCache.h"
#include "USDAssetUserData.h"
#include "USDClassesModule.h"
#include "USDConversionUtils.h"
#include "USDErrorUtils.h"
#include "USDLog.h"
#include "USDShadeConversion.h"
#include "USDTypesConversion.h"

#include "UsdWrappers/SdfLayer.h"
#include "UsdWrappers/SdfPath.h"
#include "UsdWrappers/UsdPrim.h"

#include "Engine/Level.h"
#include "Engine/Texture.h"
#include "InterchangeAssetImportData.h"
#include "InterchangeGenericMaterialPipeline.h"
#include "InterchangeManager.h"
#include "InterchangeTexture2DFactoryNode.h"
#include "InterchangeTexture2DNode.h"
#include "Materials/Material.h"
#include "Materials/MaterialInstance.h"
#include "Materials/MaterialInstanceConstant.h"
#include "MaterialShared.h"
#include "Misc/PackageName.h"
#include "UObject/StrongObjectPtr.h"

#include "USDIncludesStart.h"
	#include "pxr/usd/sdf/assetPath.h"
	#include "pxr/usd/usd/primCompositionQuery.h"
	#include "pxr/usd/usdShade/material.h"
#include "USDIncludesEnd.h"

#if WITH_EDITOR
#include "MaterialXFormat/Util.h"
#endif

#define LOCTEXT_NAMESPACE "MaterialXUSDShadeMaterialTranslator"

static bool GUseInterchangeMaterialXTranslator = true;
static FAutoConsoleVariableRef CvarUseInterchangeMaterialXTranslator(
	TEXT("USD.UseInterchangeMaterialXTranslator"),
	GUseInterchangeMaterialXTranslator,
	TEXT("Whether to translate MaterialX materials referenced by USD files with Unreal's own MaterialX importer. If instead this is false, we will try parsing the generated UsdShadeMaterial prims as generated by USD's usdMtlx plugin directly"));

FName FMaterialXUsdShadeMaterialTranslator::MaterialXRenderContext = TEXT("mtlx");

namespace UE::USDMaterialXTranslatorInternal::Private
{
	void HashMaterialXOptions(UInterchangePipelineBase* MaterialXOptions, FSHA1& SHA1)
	{
		// Reference: UInterchangePipelineBase::SaveSettingsInternal

		if (!MaterialXOptions)
		{
			return;
		}

		int32 PortFlags = 0;
		UClass* Class = MaterialXOptions->GetClass();
		for (FProperty* Property = Class->PropertyLink; Property; Property = Property->PropertyLinkNext)
		{
			FString Key = Property->GetName();
			const FName PropertyName = Property->GetFName();

			const bool bIsPropertyInherited = Property->GetOwnerClass() != Class;
			UObject* SuperClassDefaultObject = Class->GetSuperClass()->GetDefaultObject();
			FObjectProperty* SubObject = CastField<FObjectProperty>(Property);
			FArrayProperty* Array = CastField<FArrayProperty>(Property);
			if (Array)
			{
				const bool bForce = true;
				const bool bConst = false;

				FScriptArrayHelper_InContainer ArrayHelper(Array, MaterialXOptions);
				for (int32 i = 0; i < ArrayHelper.Num(); i++)
				{
					FString	Buffer;
					Array->Inner->ExportTextItem_Direct(Buffer, ArrayHelper.GetRawPtr(i), ArrayHelper.GetRawPtr(i), MaterialXOptions, PortFlags);

					SHA1.UpdateWithString(*Buffer, Buffer.Len());
				}
			}
			else if (UInterchangePipelineBase* SubPipeline = SubObject ? Cast<UInterchangePipelineBase>(SubObject->GetObjectPropertyValue_InContainer(MaterialXOptions)) : nullptr)
			{
				// Save the settings if the referenced pipeline is a subobject of ours
				if (SubPipeline->IsInOuter(MaterialXOptions))
				{
					HashMaterialXOptions(SubPipeline, SHA1);
				}
			}
			else
			{
				TCHAR TempKey[MAX_SPRINTF] = TEXT("");
				for (int32 Index = 0; Index < Property->ArrayDim; Index++)
				{
					if (Property->ArrayDim != 1)
					{
						FCString::Sprintf(TempKey, TEXT("%s[%i]"), *Property->GetName(), Index);
						Key = TempKey;
					}

					FString	Value;
					Property->ExportText_InContainer(Index, Value, MaterialXOptions, MaterialXOptions, MaterialXOptions, PortFlags);
					SHA1.UpdateWithString(*Value, Value.Len());
				}
			}
		}
	}
}

void FMaterialXUsdShadeMaterialTranslator::CreateAssets()
{
#if WITH_EDITOR
	// We handle MaterialX materials here by leveraging USD's own usdMtlx plugin. What it does is translate references
	// to .mtlx files into hierarchies of Material/Shader/NodeGraph prims as the stage is opened. To actually use
	// the materials contained in the .mtlx files, other prims from the stage will create material bindings to those
	// generated Material prims. For example, a stage that wishes to use MaterialX materials may have this:
	//
	// def Mesh "SomeMesh"
	// {
	//     ...
	//     rel material:binding = </MaterialX/Materials/TextureMaterial>
	// }
	//
	// def Scope "MaterialX" (
	//     references = [
	//         @./textureTest.mtlx@</MaterialX>,
	//     ]
	// )
	// {
	// }
	//
	// Note how SomeMesh references the "TextureMaterial" material: That's the name of one of the surfacematerials
	// inside the MaterialX file. This because when the stage is opened, the usdMtlx plugin will generate and
	// compose a child "Materials" prim and additional child prims something like the below, which is what the external
	// prims will be referencing:
	//
	// def Scope "MaterialX"
	// {
	//     def "Materials"
	//     {
	//         def Material "TextureMaterial"
	//         {
	//             float inputs:base = 1
	//             color3f inputs:base_color
	//             float inputs:coat
	//             float inputs:coat_affect_color
	//             ...
	//             token outputs:mtlx:surface.connect = </MaterialX/Materials/TextureMaterial/ND_standard_surface_surfaceshader.outputs:surface>
	//
	//             def Shader "ND_standard_surface_surfaceshader"
	//             {
	//                 uniform token info:id = "ND_standard_surface_surfaceshader"
	//                 float inputs:base.connect = </MaterialX/Materials/TextureMaterial.inputs:base>
	//                 color3f inputs:base_color.connect = </MaterialX/Materials/TextureMaterial/NG_imagetex1.outputs:out_color_0>
	//                 float inputs:coat.connect = </MaterialX/Materials/TextureMaterial.inputs:coat>
	//                 float inputs:coat_affect_color.connect = </MaterialX/Materials/TextureMaterial.inputs:coat_affect_color>
	//                 ...
	//             }
	//         }
	//     }
	// }
	//
	// Our goal in here is to translate those generated Materials (like "TextureMaterial" above). This because we want
	// to generate UMaterialInterfaces via Unreal's MaterialX plugin instead, and link them to those generated Material
	// prims within our info cache. This way, the rest or our USDImporter plugin doesn't need to care or know where
	// this material came from: It will find an UMaterialInterface linked to that Material prim and it will happily use
	// that as any other material.

	if (Context->RenderContext != MaterialXRenderContext || !GUseInterchangeMaterialXTranslator)
	{
		Super::CreateAssets();
		return;
	}

	if (!Context->AssetCache || !Context->InfoCache)
	{
		return;
	}

	if (Context->bTranslateOnlyUsedMaterials && !Context->InfoCache->IsMaterialUsed(PrimPath))
	{
		UE_LOG(LogUsd, Verbose, TEXT("Skipping creating assets for material prim '%s' as it is not currently bound by any prim."), *PrimPath.GetString());
		return;
	}

	FScopedUsdAllocs UsdAllocs;

	pxr::UsdPrim Prim = GetPrim();
	pxr::UsdShadeMaterial ShadeMaterial(Prim);
	if (!ShadeMaterial)
	{
		return;
	}

	const static pxr::TfToken RenderContextToken = UnrealToUsd::ConvertToken(*MaterialXRenderContext.ToString()).Get();
	pxr::UsdShadeShader SurfaceShader = ShadeMaterial.ComputeSurfaceSource(RenderContextToken);
	if (!SurfaceShader)
	{
		Super::CreateAssets();
		return;
	}

	// This material prim has the mtlx render context, so maybe it is one of the ones generated by usdMtlx.
	// Let's traverse upwards and try finding a .mtlx file reference in one of our parents.

	TFunction<bool(const pxr::UsdPrim&, FString&)> GetMaterialXFilePath = [this](const pxr::UsdPrim& Prim, FString& OutMaterialXFilePath)
	{
		pxr::UsdPrimCompositionQuery PrimCompositionQuery = pxr::UsdPrimCompositionQuery::GetDirectReferences(Prim);
		for (const pxr::UsdPrimCompositionQueryArc& CompositionArc : PrimCompositionQuery.GetCompositionArcs())
		{
			if (CompositionArc.GetArcType() == pxr::PcpArcTypeReference)
			{
				pxr::SdfReferenceEditorProxy ReferenceEditor;
				pxr::SdfReference UsdReference;

				if (CompositionArc.GetIntroducingListEditor(&ReferenceEditor, &UsdReference))
				{
					// The mtlx file will be the "target layer". It's useful to get its real path via the SdfLayer
					// interface as it already makes sure it is absolute
					pxr::SdfLayerHandle TargetLayer = CompositionArc.GetTargetLayer();
					FString AbsoluteFilePath = UsdToUnreal::ConvertString(TargetLayer->GetRealPath());

					FString Extension = FPaths::GetExtension(AbsoluteFilePath);
					if (Extension == MaterialXRenderContext && FPaths::FileExists(AbsoluteFilePath))
					{
						OutMaterialXFilePath = AbsoluteFilePath;
						return true;
					}
				}
			}
		}

		return false;
	};

	FString MaterialXFilePath;
	pxr::UsdPrim MaterialXReferencerPrim = Prim;
	if (!GetMaterialXFilePath(Prim, MaterialXFilePath))
	{
		// We know the usdMtlx plugin always generates a "Materials" schemaless prim to contain all the generated
		// Materials, so let's use that too.
		pxr::UsdPrim ParentPrim = Prim.GetParent();
		while (ParentPrim && ParentPrim.GetName() != "Materials")
		{
			ParentPrim = ParentPrim.GetParent();
		}

		if (ParentPrim)
		{
			// This prim likely holds the reference to the MaterialX file, but let's search upwards too
			pxr::UsdPrim MaterialXReferencerCandidate = ParentPrim.GetParent();
			while (MaterialXReferencerCandidate)
			{
				if (GetMaterialXFilePath(MaterialXReferencerCandidate, MaterialXFilePath))
				{
					break;
				}

				MaterialXReferencerCandidate = MaterialXReferencerCandidate.GetParent();
			}
			MaterialXReferencerPrim = MaterialXReferencerCandidate;
		}
	}

	if (MaterialXFilePath.IsEmpty() || !MaterialXReferencerPrim)
	{
		UE_LOG(LogUsd, Warning, TEXT("Recognized potential MaterialX materials on prim '%s', but failed to find a valid referenced MaterialX file. Reverting to parsing the generated Material prims instead."), *PrimPath.GetString());
		Super::CreateAssets();
		return;
	}

	// Quick shallow parse of MaterialX documents ourselves so that we can find all the referenced MaterialX files and
	// build a robust hash to use for caching our generated assets
	FSHA1 SHA1;
	{
		TSet<FString> ReferencedMaterialXFiles;
		TFunction<void(const FString&)> CollectReferencedMaterialXFilesRecursive;
		CollectReferencedMaterialXFilesRecursive =
			[&ReferencedMaterialXFiles, &CollectReferencedMaterialXFilesRecursive]
			(const FString& ActiveDocumentFullPath)
			{
				namespace mx = MaterialX;

				mx::DocumentPtr Document = mx::createDocument();
				mx::readFromXmlFile(Document, TCHAR_TO_UTF8(*ActiveDocumentFullPath));

				for (const std::string& ReferencedURI : Document->getReferencedSourceUris())
				{
					FString UEReferencedURI = UTF8_TO_TCHAR(ReferencedURI.c_str());

					// This could be relative to the referencer .mtlx file
					UEReferencedURI = FPaths::ConvertRelativePathToFull(
						FPaths::GetPath(ActiveDocumentFullPath),
						UEReferencedURI
					);

					if (ReferencedMaterialXFiles.Contains(UEReferencedURI))
					{
						continue;
					}

					if (FPaths::FileExists(UEReferencedURI))
					{
						ReferencedMaterialXFiles.Add(UEReferencedURI);
						CollectReferencedMaterialXFilesRecursive(UEReferencedURI);
					}
				}
			};

		// Note we don't have to add MaterialXFilePath ourselves because getReferencedSourceUris
		// always includes at least the active document itself anyway
		CollectReferencedMaterialXFilesRecursive(MaterialXFilePath);

		for (const FString& ReferencedMaterialXFile : ReferencedMaterialXFiles)
		{
			if (TUniquePtr<FArchive> Ar{IFileManager::Get().CreateFileReader(*ReferencedMaterialXFile)})
			{
				TArray<uint8> LocalScratch;
				LocalScratch.SetNumUninitialized(1024 * 64);

				const int64 Size = Ar->TotalSize();
				int64 Position = 0;

				// Read in BufferSize chunks
				while (Position < Size)
				{
					const int64 ReadNum = FMath::Min(Size - Position, (int64)LocalScratch.Num());
					Ar->Serialize(LocalScratch.GetData(), ReadNum);
					SHA1.Update(LocalScratch.GetData(), ReadNum);

					Position += ReadNum;
				}
			}
		}
	}

	// Hash the options we'll use so that we regenerate assets if those change
	if (Context->MaterialXOptions)
	{
		UE::USDMaterialXTranslatorInternal::Private::HashMaterialXOptions(Context->MaterialXOptions, SHA1);
	}

	FSHAHash Hash;
	SHA1.Final();
	SHA1.GetHash(&Hash.Hash[0]);
	FString MaterialXHash = Hash.ToString();

	FString TargetMaterialAssetHash = MaterialXHash + TEXT("/") + UsdToUnreal::ConvertString(Prim.GetName());
	UMaterialInterface* ParsedMaterial = Cast< UMaterialInterface >(Context->AssetCache->GetCachedAsset(TargetMaterialAssetHash));
	if (!ParsedMaterial)
	{
		// If we don't have this asset in the cache yet, we need to parse the MaterialX file

		UInterchangeManager& Manager = UInterchangeManager::GetInterchangeManager();
		UInterchangeSourceData* SourceData = Manager.CreateSourceData(MaterialXFilePath);

		FString ReferencerPrimPath = *UsdToUnreal::ConvertPath(MaterialXReferencerPrim.GetPrimPath());

		FImportAssetParameters InterchangeParameters;
		InterchangeParameters.bIsAutomated = true;

		if (Context->MaterialXOptions)
		{
			InterchangeParameters.OverridePipelines.Add(Context->MaterialXOptions);
		}

		// Get a temp content folder we can give interchange as it must have a destination
		int32 PackageSuffix = FMath::RandRange(0, TNumericLimits<int32>::Max()-1);
		FString TempPackagePath = FString::Printf(TEXT("/Engine/USDImporter/Transient/%d"), PackageSuffix++);

		// Make sure that content folder doesn't have any packages already in it
		TArray<FString> Filenames;
		while (FPackageName::FindPackagesInDirectory(Filenames, TempPackagePath))
		{
			TempPackagePath = FString::Printf(TEXT("/Engine/USDImporter/Transient/%d"), PackageSuffix++);
		}

		// Currently Interchange cannot import directly into the transient package, so we'll import into a temporary folder and then
		// move everything over
		InterchangeParameters.OnAssetsImportDoneNative.BindLambda(
			[this, &MaterialXFilePath, &MaterialXHash, &TargetMaterialAssetHash, &ParsedMaterial, &ReferencerPrimPath, &TempPackagePath]
			(const TArray<UObject*>& ImportedObjects)
			{
				// Move all our assets to the transient package
				for (UObject* ImportedObject : ImportedObjects)
				{
					const FName NewName = MakeUniqueObjectName(
						GetTransientPackage(),
						ImportedObject->GetClass(),
						ImportedObject->GetFName()
					);
					bool bSuccess = ImportedObject->Rename(
						*NewName.ToString(),
						GetTransientPackage(),
						REN_NonTransactional | REN_DontCreateRedirectors | REN_ForceNoResetLoaders
					);
					if (!bSuccess)
					{
						UE_LOG(LogUsd, Warning, TEXT("Failed to rename imported MaterialX material '%s', generated for referencer prim '%s'."),
							*ImportedObject->GetPathName(),
							*ReferencerPrimPath
						);
						continue;
					}

					ImportedObject->SetFlags(RF_Transient);

					if (UMaterialInterface* Material = Cast<UMaterialInterface>(ImportedObject))
					{
						// MaterialX names are unique, and can only have alphanumeric and the "_" character, so we should
						// always have a solid enough mapping to assume UAsset name == Prim name == MaterialX name
						FString NewMaterialHash = MaterialXHash + TEXT("/") + Material->GetFName().GetPlainNameString();

						// We generate all assets from the MaterialX file once, but it's possible we're just updating a
						// single material prim here. If we were to cache all assets here, we'd potentially be trying
						// to overwrite the existing assets that are being used by other prims and wouldn't otherwise
						// be discarded, so make sure we don't do that
						UMaterialInterface* ExistingMaterial = Cast<UMaterialInterface>(Context->AssetCache->GetCachedAsset(NewMaterialHash));
						if (!ExistingMaterial)
						{
							Context->AssetCache->CacheAsset(NewMaterialHash, Material);
						}

						if (NewMaterialHash == TargetMaterialAssetHash)
						{
							ParsedMaterial = Material;
						}
					}
					else if (UTexture* Texture = Cast<UTexture>(ImportedObject))
					{
						// Note: This filename will be the .mtlx file for now, which is why we append the texture name manually later
						const FString FilePath = Texture->AssetImportData ? Texture->AssetImportData->GetFirstFilename() : TEXT("");

						FString TextureHash = UsdUtils::GetTextureHash(
							FilePath,
							Texture->SRGB,
							Texture->CompressionSettings,
							Texture->GetTextureAddressX(),
							Texture->GetTextureAddressY()
						);
						// TODO: Replace this hash hack with relying on PostImportMaterial whenever the interchange
						// texture AssetImportData contains the correct filepaths, and not just the .mtlx file
						TextureHash += TEXT("_") + Texture->GetFName().GetPlainNameString();

						// See comment on the analogous part of the Material case above
						UTexture* ExistingTexture = Cast<UTexture>(Context->AssetCache->GetCachedAsset(TextureHash));
						if (!ExistingTexture)
						{
							UUsdAssetUserData* UserData = NewObject<UUsdAssetUserData>(Texture, TEXT("USDAssetUserData"));
							UserData->PrimPath = ReferencerPrimPath;
							Texture->AddAssetUserData(UserData);

							Context->AssetCache->CacheAsset(TextureHash, Texture);
						}
					}
					else
					{
						ensureMsgf(false, TEXT("Asset type unsupported!"));
					}
				}

				// Now that the asset cache took everything we imported we shouldn't have anything else
				TArray<FString> Filenames;
				if (FPackageName::FindPackagesInDirectory(Filenames, TempPackagePath))
				{
					ensureMsgf(false, TEXT("We should not have any leftover assets from MaterialX translation!"));
				}
			}
		);

		const bool bSuccess = Manager.ImportAsset(TempPackagePath, SourceData, InterchangeParameters);
		if (!bSuccess)
		{
			UE_LOG(LogUsd, Warning, TEXT("Recognized potential MaterialX materials on prim '%s', but MaterialX parsing of file '%s' failed. Reverting to parsing the generated Material prims instead."),
				*PrimPath.GetString(),
				*MaterialXFilePath
			);
			Super::CreateAssets();
			return;
		}
	}

	if (ParsedMaterial)
	{
		PostImportMaterial(TargetMaterialAssetHash, ParsedMaterial);
	}
	else
	{
		UE_LOG(LogUsd, Warning, TEXT("Parsing of MaterialX file '%s' on prim '%s' succeeded, but we failed to find the target material '%s' within the file."),
			*MaterialXFilePath,
			*PrimPath.GetString(),
			*UsdToUnreal::ConvertString(Prim.GetName())
		);
		Super::CreateAssets();
		return;
	}
#else
	Super::CreateAssets();
#endif // WITH_EDITOR
}

#undef LOCTEXT_NAMESPACE

#endif // #if USE_USD_SDK
