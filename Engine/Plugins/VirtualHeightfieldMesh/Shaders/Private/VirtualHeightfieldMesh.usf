// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"	
#include "/Engine/Private/MortonCode.ush"	
//#include "/Engine/Private/ShaderPrintCommon.ush"	
//#include "/Engine/Private/ShaderDrawDebug.ush"	
#include "VirtualHeightfieldMesh.ush"	


groupshared uint NumGroupTasks;
globallycoherent RWStructuredBuffer<WorkerQueueInfo> RWQueueInfo;
globallycoherent RWBuffer<uint> RWQueueBuffer;
uint QueueBufferSizeMask;

RWBuffer<uint2> RWQuadBuffer;
Buffer<uint2> QuadBuffer;

RWBuffer<uint> RWIndirectArgsBuffer;
Buffer<uint> IndirectArgsBufferSRV;

RWBuffer<uint> RWQuadNeighborBuffer;
Buffer<uint> QuadNeighborBuffer;

RWStructuredBuffer<QuadRenderInstance> RWInstanceBuffer;
StructuredBuffer<QuadRenderInstance> InstanceBuffer;

RWBuffer<uint> RWFeedbackBuffer;

Texture2D<uint> PageTableTexture;

Texture2D<float4> MinMaxTexture;
SamplerState MinMaxTextureSampler;

Texture2D<float> OcclusionTexture;
int OcclusionLevelOffset;

Texture2D<float2> LodTexture;

float3 PageTableSize;
uint PageTableFeedbackId;
float4x4 UVToWorld;
float3 CameraPosition;
float ProjectionLodScale;
float LodThreshold;
float4 FrustumPlanes[5];
int NumIndices;
uint4 PageTablePackedUniform;


/** */
struct FUniform
{
	// Page sizes are scaled by RcpPhysicalTextureSize
	float pPageSize;
	float vPageSize;
	float vPageBorderSize;
	uint PageCoordinateBitCount;
};

/** */
FUniform VTUniformUnpack(uint4 InPackedUniform)
{
	FUniform result;
	result.pPageSize = asfloat(InPackedUniform.w);
	result.vPageSize = asfloat(InPackedUniform.y);
	result.vPageBorderSize = asfloat(InPackedUniform.z);
	result.PageCoordinateBitCount = InPackedUniform.x == 0 ? 8 : 6;
	return result;
}

/** Compute physical UV from virtual UV. */
float2 VTComputePhysicalUVs(float2 LocalUV, uint PhysicalAddress, FUniform Uniform)
{
	// See packing in PageTableUpdate.usf
	const uint vLevel = PhysicalAddress & 0xf;
	const float UVScale = 1.0f / (float)(1 << vLevel);
	const float pPageX = (float)((PhysicalAddress >> 4) & ((1 << Uniform.PageCoordinateBitCount) - 1));
	const float pPageY = (float)(PhysicalAddress >> (4 + Uniform.PageCoordinateBitCount));

	const float2 pUV = float2(pPageX, pPageY) * Uniform.pPageSize + (LocalUV * Uniform.vPageSize + Uniform.vPageBorderSize);

	return pUV;
}

/** Returns transform from virtual to physical UV for a given virtual texture tile. */
float3 GetLocalToPhysicalUV(float4 LocalUVMinMax, uint PhysicalAddress, uint4 InPackedUniform)
{
	FUniform Uniform = VTUniformUnpack(InPackedUniform);
	float2 Min = VTComputePhysicalUVs(LocalUVMinMax.xy, PhysicalAddress, Uniform);
	float2 Max = VTComputePhysicalUVs(LocalUVMinMax.zw, PhysicalAddress, Uniform);
	return float3(Min, Max.x - Min.x); // Assume Max.y - Min.y == Max.x - Min.x
}

/** Unpack the values from the MinMaxHeight texture from the packed 8888 format. */
float2 UnPackMinMaxHeight(float4 Packed)
{
	uint4 PackedScaled = (uint4)floor(Packed *= 255.f);
	uint2 UnPackedScaled = uint2(PackedScaled.x << 8 | PackedScaled.y, PackedScaled.z << 8 | PackedScaled.w);
	float2 UnPacked = (float2)UnPackedScaled / 65535.f;
	return UnPacked;
}

/** Return projected screen radius (squared) for bounding sphere. */
float GetSphereBoundsScreenRadiusSquared(float3 InCenter, float3 InExtent, float3 InCameraPosition, float InProjectionLodScale)
{
	float RadiusSquared = dot(InExtent, InExtent);
	float3 ToCamera = InCameraPosition - InCenter;
	float CameraDistanceSquared = dot(ToCamera, ToCamera);
	return (RadiusSquared * InProjectionLodScale) / max(1, CameraDistanceSquared);
}

/** Return false if the AABB is completely outside one of the planes. */
bool PlaneTestAABB(float4 Planes[5], float3 Center, float3 Extent)
{
	bool bPlaneTest = true;
	
	[unroll]
	for (uint PlaneIndex = 0; PlaneIndex < 5; ++PlaneIndex)
	{
		float3 PlaneSigns = Planes[PlaneIndex].xyz >= 0.f ? 1.f : -1.f;
		bool bInsidePlane = dot(Planes[PlaneIndex], float4(Center + Extent * PlaneSigns, 1.0f)) > 0.f;
		bPlaneTest = bPlaneTest && bInsidePlane;
	}

	return bPlaneTest;
}

/** Return false if location is marked as occluded in the occlusion texture. */
bool OcclusionTest(uint2 Pos, int Level)
{
	int OcclusionLevel = Level - OcclusionLevelOffset;
	if (Level < 0)
	{
		return true;
	}
	return OcclusionTexture.Load(uint3(Pos, OcclusionLevel)) == 0;
}

/** Draw a bounding box using the ShaderDrawDebug system. */
void DebugDrawUVBox(float3 UVMin, float3 UVMax, float4x4 Mat, float4 Color)
{
#if 0 // Enable only if ShaderDrawDebug is enabled
	float3 WorldPos[8];
	WorldPos[0] = mul(float4(UVMin.x, UVMin.y, UVMin.z, 1), Mat);
	WorldPos[1] = mul(float4(UVMax.x, UVMin.y, UVMin.z, 1), Mat);
	WorldPos[2] = mul(float4(UVMin.x, UVMax.y, UVMin.z, 1), Mat);
	WorldPos[3] = mul(float4(UVMax.x, UVMax.y, UVMin.z, 1), Mat);
	WorldPos[4] = mul(float4(UVMin.x, UVMin.y, UVMax.z, 1), Mat);
	WorldPos[5] = mul(float4(UVMax.x, UVMin.y, UVMax.z, 1), Mat);
	WorldPos[6] = mul(float4(UVMin.x, UVMax.y, UVMax.z, 1), Mat);
	WorldPos[7] = mul(float4(UVMax.x, UVMax.y, UVMax.z, 1), Mat);

	AddQuad(WorldPos[0], WorldPos[2], WorldPos[3], WorldPos[1], Color);
	AddQuad(WorldPos[4], WorldPos[6], WorldPos[7], WorldPos[5], Color);
	AddLine(WorldPos[0], WorldPos[4], Color, Color);
	AddLine(WorldPos[1], WorldPos[5], Color, Color);
	AddLine(WorldPos[2], WorldPos[6], Color, Color);
	AddLine(WorldPos[3], WorldPos[7], Color, Color);
#endif
}

/**
 * Compute shader to initialize all buffers, including adding the lowest mip page(s) to the QuadBuffer.
 */

[numthreads(1, 1, 1)]
void InitBuffersCS()
{
	// Seed with one item in the queue.
	RWQueueInfo[0].Read = 0;
	RWQueueInfo[0].Write = 1;
	RWQueueInfo[0].NumActive = 1;

	RWQueueBuffer[0] = Pack(InitQuadItem(0, (uint)PageTableSize.z));

	// RenderLodMap indirect args
	RWIndirectArgsBuffer[0] = 6;
	RWIndirectArgsBuffer[1] = 0; // Increment this counter during CollectQuadsCS.
	RWIndirectArgsBuffer[2] = 0;
	RWIndirectArgsBuffer[3] = 0;
	RWIndirectArgsBuffer[4] = 0;

	// ResolveNeighborLods and CullInstances indirect args
	RWIndirectArgsBuffer[5] = 0; // Increment this counter during CollectQuadsCS.
	RWIndirectArgsBuffer[6] = 1;
	RWIndirectArgsBuffer[7] = 1;
	RWIndirectArgsBuffer[8] = 0;

	// Clear virtual texture feedback counter.
	RWFeedbackBuffer[0] = 0;
}

/**
 * Compute shader to traverse the virtual texture page table and generate an array of items to potentially render for a view.
 */

[numthreads(64, 1, 1)]
void CollectQuadsCS(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex
)
{
	// Persistant threads stay alive until the work queue is drained.
	bool bExit = false;
	while (!bExit)
	{
		// Sync and init group task count.
		NumGroupTasks = 0;
		GroupMemoryBarrierWithGroupSync();
		
		// Try and pull a task.
		int NumActive;
		InterlockedAdd(RWQueueInfo[0].NumActive, -1, NumActive);
		
		if (NumActive <= 0)
		{
			// No task pulled. Rewind.
			InterlockedAdd(RWQueueInfo[0].NumActive, 1, NumActive);
		}
		else
		{
			// Increment group task count for this loop.
			uint Dummy;
			InterlockedAdd(NumGroupTasks, 1, Dummy);

			// Read item to process from queue.
			uint Read;
			InterlockedAdd(RWQueueInfo[0].Read, 1, Read);
			
			const uint PackedItem = RWQueueBuffer[Read & QueueBufferSizeMask];
			const QuadItem Item = UnpackQuadItem(PackedItem);
			const uint Address = Item.Address;
			const uint2 Pos = MortonDecode(Address);
			const uint Level = Item.Level;

			// Check if occluded.
			bool bOcclude = !OcclusionTest(Pos, Level);

			// Get UV bounding box
			float2 Scale = (float)(1 << Level) / PageTableSize.xy;
			
			float2 UV0 = ((float2)Pos + float2(0, 0)) * Scale;
			float2 UV1 = ((float2)Pos + float2(1, 1)) * Scale;
			
			float2 MinMaxHeight = UnPackMinMaxHeight(MinMaxTexture.SampleLevel(MinMaxTextureSampler, UV0, (float)Level));
			
			float3 UVMin = float3(UV0, MinMaxHeight.x);
			float3 UVMax = float3(UV1, MinMaxHeight.y);

			float3 UVCenter = (UVMax + UVMin) * 0.5f;
			float3 UVExtent = UVMax - UVCenter;

			// Check if frustum culled
			bool bCull = !PlaneTestAABB(FrustumPlanes, UVCenter, UVExtent);

			// Get World space sphere for lod query
			float3 World0 = mul(float4(UVMin, 1), UVToWorld).xyz;
			float3 World1 = mul(float4(UVMax, 1), UVToWorld).xyz;
			float3 WorldCenter = (World0 + World1) * 0.5f;
			float3 WorldExtent = abs(World1 - WorldCenter);
			float ScreenSizeSq = GetSphereBoundsScreenRadiusSquared(WorldCenter, WorldExtent, CameraPosition, ProjectionLodScale);

			// Check if needs subdivide
			bool bSubdivide = false;
			bool bRequestSubdivide = Level > 0 && ScreenSizeSq > LodThreshold;

			// Store fractional component of LOD
			// check: clamp or saturate?
			float LodFracScale = 0.5; // reduce to force smoother but shorter lod transition - maybe expose this?
			float FractionalLod = clamp((LodThreshold - ScreenSizeSq) / (LodThreshold * LodFracScale), 0, 0.999);

			if (bCull || bOcclude)
			{
				// If culled then still store, but don't subdivide.
				DebugDrawUVBox(UVMin, UVMax, UVToWorld, float4(0, 0, 1, 1));
			}
			else if (bRequestSubdivide)
			{
				const uint2 PosMulTwo = Pos << 1;
				const uint LevelMinus1 = Level - 1;

				// Write page requests for children to the virtual texture feedback buffer.
				uint Request00 = PageTableFeedbackId | (PosMulTwo.x + 0) | ((PosMulTwo.y + 0) << 12) | (LevelMinus1 << 24);
				uint Request01 = PageTableFeedbackId | (PosMulTwo.x + 0) | ((PosMulTwo.y + 1) << 12) | (LevelMinus1 << 24);
				uint Request10 = PageTableFeedbackId | (PosMulTwo.x + 1) | ((PosMulTwo.y + 0) << 12) | (LevelMinus1 << 24);
				uint Request11 = PageTableFeedbackId | (PosMulTwo.x + 1) | ((PosMulTwo.y + 1) << 12) | (LevelMinus1 << 24);

				uint FeedbackPos;
				InterlockedAdd(RWFeedbackBuffer[0], 4, FeedbackPos);
				RWFeedbackBuffer[FeedbackPos + 1] = Request00;
				RWFeedbackBuffer[FeedbackPos + 2] = Request01;
				RWFeedbackBuffer[FeedbackPos + 3] = Request10;
				RWFeedbackBuffer[FeedbackPos + 4] = Request11;

				// Load children from page table and extract the current stored level in the virtual texture.
				uint Level00 = PageTableTexture.Load(int3(PosMulTwo + uint2(0, 0), LevelMinus1)) & 0xf;
				uint Level01 = PageTableTexture.Load(int3(PosMulTwo + uint2(0, 1), LevelMinus1)) & 0xf;
				uint Level10 = PageTableTexture.Load(int3(PosMulTwo + uint2(1, 0), LevelMinus1)) & 0xf;
				uint Level11 = PageTableTexture.Load(int3(PosMulTwo + uint2(1, 1), LevelMinus1)) & 0xf;

				// Only subdivide if all children are available at the next level.
				bSubdivide = max(Level00, max(Level01, max(Level10, Level11))) <= LevelMinus1;
				if (bSubdivide)
				{
					// Add child nodes to queue
					uint Write;
					InterlockedAdd(RWQueueInfo[0].Write, 4, Write);

					uint AddressMul4 = Address << 2;
					RWQueueBuffer[(Write + 0) & QueueBufferSizeMask] = Pack(InitQuadItem(AddressMul4 + 0, LevelMinus1));
					RWQueueBuffer[(Write + 1) & QueueBufferSizeMask] = Pack(InitQuadItem(AddressMul4 + 1, LevelMinus1));
					RWQueueBuffer[(Write + 2) & QueueBufferSizeMask] = Pack(InitQuadItem(AddressMul4 + 2, LevelMinus1));
					RWQueueBuffer[(Write + 3) & QueueBufferSizeMask] = Pack(InitQuadItem(AddressMul4 + 3, LevelMinus1));
			
					InterlockedAdd(RWQueueInfo[0].NumActive, 4, NumActive);
				}
			}

			// If we didn't subdivide then add this item to output list.
			if (!bSubdivide)
			{
				uint PhysicalAddress = PageTableTexture.Load(int3(Pos, Level));

				uint Write;
				InterlockedAdd(RWIndirectArgsBuffer[1], 1, Write);
				InterlockedMax(RWIndirectArgsBuffer[5], ((Write + 1) + 63) / 64);

				RWQuadBuffer[Write] = Pack(InitQuadRenderItem(Address, Level, PhysicalAddress, FractionalLod, bCull || bOcclude));
				
				DebugDrawUVBox(UVMin, UVMax, UVToWorld, float4(1, 0, 0, 1));
			}
		}

		// Exit if no work was found.
		DeviceMemoryBarrier();
		if (NumGroupTasks == 0)
		{
			bExit = true;
		}
	}
}

/**
 * Vertex/Pixel Shaders that draws to a render target the Lod info for the quads output by the Collect pass.
 */

void RenderLodMapVS(
	in uint InstanceId : SV_InstanceID,
	in uint VertexId : SV_VertexID,
	out float4 OutPosition : SV_POSITION,
	out float2 OutLod : TEXCOORD0
	)
{
	uint2 VertexUV = uint2((VertexId >> 0) & 1, (VertexId >> 1) & 1);
	
	const uint2 PackedItem = QuadBuffer[InstanceId];
	const QuadRenderItem Item = UnpackQuadRenderItem(PackedItem);
	const uint Address = Item.Address;
	const uint Level = Item.Level;
	const float FractionalLod = Item.FractionalLod;

	uint2 BaseXY = uint2( ReverseMortonCode2(Address), ReverseMortonCode2(Address >> 1) );
	uint2 XY = (BaseXY + VertexUV) * (1 << Level);
	float2 VertexPos = (float2(XY) / PageTableSize.xy) * float2(2.f, -2.f) + float2(-1.f, 1.f);

	OutPosition = float4(VertexPos, 0.f, 1.f);
	OutLod = float2(Level, FractionalLod);
}

void RenderLodMapPS(
	in float4 InPosition : SV_POSITION,
	in noperspective float2 InLod : TEXCOORD0,
	out float4 OutColor : SV_Target0
	)
{
	// Need to pack to render target...
	OutColor = float4(InLod.x / 255.f, InLod.y, 0.f, 1.f);
}

/**
 * Read the Lod info for the neighbors of each quad and resolve Lods at borders.
 */

[numthreads(64, 4, 1)]
void ResolveNeighborLodsCS( uint ThreadId : SV_GroupIndex )
{
	uint QuadIndex = ThreadId.x >> 2;
	uint NeighborIndex = ThreadId & 3;

	if (QuadIndex >= IndirectArgsBufferSRV[1])
		return;

	const uint2 PackedItem = QuadBuffer[QuadIndex];
	const QuadRenderItem Item = UnpackQuadRenderItem(PackedItem);
	const uint Address = Item.Address;
	const uint Level = Item.Level;
	const float FractionalLod = Item.FractionalLod;

	float LocalLodFloor = (float)Level;
	float LocalLodFrac = FractionalLod;

	int2 Offset;
	if (NeighborIndex == 0) Offset = int2(-1, 0);
	else if (NeighborIndex == 1) Offset = int2(0, (1 << Level));
	else if (NeighborIndex == 2) Offset = int2((1 << Level), 0);
	else Offset = int2(0, -1); 

	uint2 AddressXY = uint2(ReverseMortonCode2(Address), ReverseMortonCode2(Address >> 1));
	uint2 BaseXY = AddressXY << Level;
	int2 XY = clamp((int2)BaseXY + Offset, 0, (int2)PageTableSize.xy - 1);

	float2 NeighborLodPacked = LodTexture.Load(int3(XY, 0));
	float NeighborLodFloor = floor(NeighborLodPacked.r * 255.f);
	float NeighborLodFrac = NeighborLodPacked.g;

	if (NeighborLodFloor != LocalLodFloor)
	{
		NeighborLodFloor = max(LocalLodFloor, NeighborLodFloor);
		NeighborLodFrac = 0.f;
	}
	else
	{
		NeighborLodFrac = (LocalLodFrac + NeighborLodFrac) * 0.5;
	}

	float NeighborLod = NeighborLodFloor + NeighborLodFrac;

	uint LodShift = (uint)floor(max(NeighborLodFloor - LocalLodFloor, 0));
	uint PhysicalAddress = PageTableTexture.Load(int3(AddressXY >> LodShift, Level + LodShift));

	RWQuadNeighborBuffer[ThreadId] = Pack(InitQuadNeighborItem(PhysicalAddress, NeighborLod));
}

/**
 *
 */

[numthreads(1, 1, 1)]
void InitInstanceBufferCS()
{
	RWIndirectArgsBuffer[0] = NumIndices;
	RWIndirectArgsBuffer[1] = 0; // Increment this counter during CullInstancesCS.
	RWIndirectArgsBuffer[2] = 0;
	RWIndirectArgsBuffer[3] = 0;
	RWIndirectArgsBuffer[4] = 0;
}

/**
 *
 */

[numthreads(64, 1, 1)]
void CullInstancesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint QuadIndex = DispatchThreadId.x;
	if (QuadIndex >= IndirectArgsBufferSRV[1])
		return;

	const uint2 PackedItem = QuadBuffer[QuadIndex];
	const QuadRenderItem Item = UnpackQuadRenderItem(PackedItem);
	const uint2 Pos = MortonDecode(Item.Address);

#if REUSE_CULL
	// Reuse main view culling flag set in collect pass.
	bool bCull = Item.bCull;
#else
	// Cull against planes for this view.
	float2 Scale = (float)(1 << Item.Level) / PageTableSize.xy;
	float2 UV0 = ((float2)Pos + float2(0, 0)) * Scale;
	float2 UV1 = ((float2)Pos + float2(1, 1)) * Scale;

	float2 MinMaxHeight = UnPackMinMaxHeight(MinMaxTexture.SampleLevel(MinMaxTextureSampler, UV0, (float)Item.Level));

	float3 UVMin = float3(UV0, MinMaxHeight.x);
	float3 UVMax = float3(UV1, MinMaxHeight.y);

	float3 UVCenter = (UVMax + UVMin) * 0.5f;
	float3 UVExtent = UVMax - UVCenter;

	bool bCull = !PlaneTestAABB(FrustumPlanes, UVCenter, UVExtent);
#endif

	if (!bCull)
	{
		// Add to final render intance list.
		QuadRenderInstance OutInstance;
		OutInstance.Pad[0] = OutInstance.Pad[1] = 0;
		
		OutInstance.Address = Item.Address;
		OutInstance.Level = Item.Level;

		// Unpack physical address into full LocalToPhysicalUV here ready for use by vertex shader. 
		// Could move to vertex shader if we want to trade memory bandwidth for compute.
		OutInstance.PackedInfo.xyz = GetLocalToPhysicalUV(float4(0, 0, 1, 1), Item.PhysicalAddress, PageTablePackedUniform);
		OutInstance.PackedInfo.w = Item.FractionalLod;

		[unroll]
		for (int NeighborIndex = 0; NeighborIndex < 4; ++ NeighborIndex)
		{
			const uint PackedNeighborItem = QuadNeighborBuffer[QuadIndex * 4 + NeighborIndex];
			const QuadNeighborItem NeighborItem = UnpackQuadNeighborItem(PackedNeighborItem);

			// Unpack physical address into full LocalToPhysicalUV here ready for use by vertex shader.
			uint LodShift = (uint)floor(max(NeighborItem.Lod - (float)Item.Level, 0));
			float2 MinUV = frac((float2)Pos / (float)(1 << LodShift));
			float2 MaxUV = MinUV + 1.f / (float)(1 << LodShift);
			float3 LocalToPhysicalUV = GetLocalToPhysicalUV(float4(MinUV, MaxUV), NeighborItem.PhysicalAddress, PageTablePackedUniform);
			
			OutInstance.NeigborPackedInfo[NeighborIndex] = float4(LocalToPhysicalUV, NeighborItem.Lod);
		}

		uint Write;
		InterlockedAdd(RWIndirectArgsBuffer[1], 1, Write);

		RWInstanceBuffer[Write] = OutInstance;
	}
}
