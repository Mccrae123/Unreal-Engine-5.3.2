// Copyright Epic Games, Inc. All Rights Reserved.

#include "/Engine/Private/Common.ush"

/** The unswizzled buffer packed into 4 byte buffer stride. */
StructuredBuffer<uint> UnswizzledBuffer;

/** Texture size that the buffer is supposed to be unpacked to. */
int2 TextureSize;

/** Size of tiles that represent this texture. */
int2 TileSize;


/**
* This function extracts the 16bit (float) data stored in uint (32 bit)
*/
float UintContainingFloatToFloat(in uint Value)
{
	int Sign = (Value >> 15) & 0x00000001;
	int Exponent = (Value >> 10) & 0x0000001f;
	int Mantissa = Value & 0x000003ff;

	Exponent = Exponent + (127 - 15);
	Mantissa = Mantissa << 13;

	return asfloat((Sign << 31) | (Exponent << 23) | Mantissa);
}

/** Unpacks data from the provided structured buffer. */
int GetValueFromTheBuffer(int Offset, int2 TextureSize, int ChannelIndex)
{
	// the location as if it would've been if the buffer was unpacked.
	int UnpackedLocation = Offset + TextureSize.x * ChannelIndex;

	// Byte offset within the 4 byte packed value.
	int Remainder = UnpackedLocation % 2;

	// Position in a packed buffer.
	int PackedPosition = (UnpackedLocation - Remainder) >> 1;


	uint PackedFourByteValue = UnswizzledBuffer[PackedPosition];
	int ReturnValue = ((PackedFourByteValue >> (16 * Remainder)) & 0xffff);
	return ReturnValue;
}


/** Vertex Shader. */
void MainVS(
	in float4 InPosition : ATTRIBUTE0,
	in float2 InTexCoord : ATTRIBUTE1,
	out noperspective float4 OutUVAndScreenPos : TEXCOORD0,
	out float4 OutPosition : SV_POSITION)
{
	DrawRectangle(InPosition, InTexCoord, OutPosition, OutUVAndScreenPos);
}

void GetStartScanlinePosition(in int2 PixelPos, out float2 SampleSize, out int StartPosition)
{
	// Depending on the EXR file it could contain multi-channel data.
#if NUM_CHANNELS == 1
	int Channels = 1;
#elif NUM_CHANNELS == 2
	int Channels = 2;
#elif NUM_CHANNELS == 3
	int Channels = 3;
#else
	int Channels = 4;
#endif

#if SWIZZLE_TILES
	SampleSize.x = TileSize.x;
	SampleSize.y = TileSize.y;

	int xCoord = (PixelPos.x) % TileSize.x;
	int yCoord = (PixelPos.y) % TileSize.y;

	int TileX = floor((PixelPos.x) / TileSize.x);
	int TileY = floor((PixelPos.y) / TileSize.y);

	int MaxTilesX = TextureSize.x / TileSize.x;
	int MaxTilesY = TextureSize.y / TileSize.y;

	// Padding in bytes
	const int TilePadding = 10;

	// Current tile position.
	int TileBufferStride = TileSize.x * TileSize.y * Channels;
	int PreviousTilesOffset = (MaxTilesX * TileY + TileX) * TileBufferStride;
	StartPosition = PreviousTilesOffset + yCoord * TileSize.x * Channels + xCoord + (TileY * MaxTilesX + TileX + 1) * TilePadding;
#else
	SampleSize.x = TextureSize.x;
	SampleSize.y = TextureSize.y;

	// Padding in bytes
	const int TilePadding = 4;

	// Current scanline position.
	StartPosition = PixelPos.y * TextureSize.x * Channels + PixelPos.x + (PixelPos.y + 1) * 4;
#endif
}

/** Pixel Shader. */
half4 MainPS(noperspective float4 UVAndScreenPos : TEXCOORD0) : SV_Target0
{
	float2 UV = UVAndScreenPos.xy;

	float2 SampleSize;

	int2 PixelPos = UV * TextureSize;
	int StartBufferPosition;

	GetStartScanlinePosition(PixelPos, SampleSize, StartBufferPosition);

	int ChannelIndex = 0;
#if NUM_CHANNELS == 4
	half A = UintContainingFloatToFloat(GetValueFromTheBuffer(StartBufferPosition, SampleSize, ChannelIndex++));
#else
	half A = 1.;
#endif

	half B = UintContainingFloatToFloat(GetValueFromTheBuffer(StartBufferPosition, SampleSize, ChannelIndex++));
#if NUM_CHANNELS <= 1
	half G = B;
#else
	half G = UintContainingFloatToFloat(GetValueFromTheBuffer(StartBufferPosition, SampleSize, ChannelIndex++));
#endif
#if NUM_CHANNELS <= 2
	half R = B;
#else
	half R = UintContainingFloatToFloat(GetValueFromTheBuffer(StartBufferPosition, SampleSize, ChannelIndex++));
#endif
	half3 Rgb = half3(R, G, B);

	return half4(Rgb, A);
}