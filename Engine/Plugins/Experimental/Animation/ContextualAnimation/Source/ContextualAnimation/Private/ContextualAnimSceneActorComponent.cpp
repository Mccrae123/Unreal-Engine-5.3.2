// Copyright Epic Games, Inc. All Rights Reserved.

#include "ContextualAnimSceneActorComponent.h"
#include "Animation/AnimInstance.h"
#include "GameFramework/Character.h"
#include "ContextualAnimMetadata.h"
#include "Components/SkeletalMeshComponent.h"
#include "DrawDebugHelpers.h"
#include "ContextualAnimManager.h"
#include "ContextualAnimSceneInstance.h"
#include "ContextualAnimSceneAsset.h"
#include "ContextualAnimUtilities.h"

UContextualAnimSceneActorComponent::UContextualAnimSceneActorComponent(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	PrimaryComponentTick.bCanEverTick = false;
	PrimaryComponentTick.bStartWithTickEnabled = false;
}

FBoxSphereBounds UContextualAnimSceneActorComponent::CalcBounds(const FTransform& LocalToWorld) const
{
	const float Radius = SceneAsset ? SceneAsset->GetRadius() : 0.f;
	return FBoxSphereBounds(FSphere(GetComponentTransform().GetLocation(), Radius));
}

void UContextualAnimSceneActorComponent::OnRegister()
{
	Super::OnRegister();

	UContextualAnimManager* ContextAnimManager = UContextualAnimManager::Get(GetWorld());
	if (ensure(!bRegistered) && ContextAnimManager)
	{
		ContextAnimManager->RegisterSceneActorComponent(this);
		bRegistered = true;
	}
}

void UContextualAnimSceneActorComponent::OnUnregister()
{
	Super::OnUnregister();

	UContextualAnimManager* ContextAnimManager = UContextualAnimManager::Get(GetWorld());
	if (bRegistered && ContextAnimManager)
	{
		ContextAnimManager->UnregisterSceneActorComponent(this);
		bRegistered = false;
	}
}

void UContextualAnimSceneActorComponent::OnJoinedScene(const FContextualAnimSceneActorData* SceneActorData)
{
	check(SceneActorData);
	SceneActorDataPtr = SceneActorData;

	// Start listening to TickPose if we joined an scene where we need IK
	if (SceneActorData->GetSettings()->IKTargetDefinitions.Num() > 0)
	{
		if (USkeletalMeshComponent* SkelMeshComp = UContextualAnimUtilities::TryGetSkeletalMeshComponent(GetOwner()))
		{
			SkelMeshComp->OnTickPose.AddUObject(this, &UContextualAnimSceneActorComponent::OnTickPose);
		}
	}

	OnJoinedSceneDelegate.Broadcast(this);
}

void UContextualAnimSceneActorComponent::OnLeftScene(const FContextualAnimSceneActorData* SceneActorData)
{
	check(SceneActorData);

	OnLeftSceneDelegate.Broadcast(this);

	// Stop listening to TickPose if we were
	if (SceneActorData->GetSettings()->IKTargetDefinitions.Num() > 0)
	{
		if (USkeletalMeshComponent* SkelMeshComp = UContextualAnimUtilities::TryGetSkeletalMeshComponent(GetOwner()))
		{
			SkelMeshComp->OnTickPose.RemoveAll(this);
		}
	}

	SceneActorDataPtr = nullptr;
}

void UContextualAnimSceneActorComponent::OnTickPose(class USkinnedMeshComponent* SkinnedMeshComponent, float DeltaTime, bool bNeedsValidRootMotion)
{
	//@TODO: Check for LOD to prevent this update if the actor is too far away
	UpdateIKTargets();
}

void UContextualAnimSceneActorComponent::UpdateIKTargets()
{
	const UContextualAnimSceneInstance* SceneInstance = SceneActorDataPtr ? SceneActorDataPtr->GetSceneInstance() : nullptr;
	if (SceneInstance)
	{
		IKTargets.Reset();

		for (const FContextualAnimIKTargetDefinition& IKTargetDef : SceneActorDataPtr->GetSettings()->IKTargetDefinitions)
		{
			if (UAnimInstance* AnimInstance = SceneActorDataPtr->GetAnimInstance())
			{
				FTransform IKTargetTransform = FTransform::Identity;

				float Alpha = 0.f;
				bool bCurveFound = AnimInstance->GetCurveValue(IKTargetDef.AlphaCurveName, Alpha);

				//@TODO: IKTargetTransform will be off by 1 frame if we tick before target until setup tick dependencies

				if (IKTargetDef.Provider == EContextualAnimIKTargetProvider::Autogenerated)
				{
					if (const FContextualAnimSceneActorData* TargetSceneActorData = SceneInstance->FindSceneActorDataForRole(IKTargetDef.AutoParams.TargetRole))
					{
						if (USkeletalMeshComponent* TargetSkelMeshComp = TargetSceneActorData->GetSkeletalMeshComponent())
						{
							const FTransform IKTargetParentTransform = TargetSkelMeshComp->GetSocketTransform(IKTargetDef.AutoParams.BoneName);

							const float Time = SceneActorDataPtr->GetAnimTime();
							IKTargetTransform = SceneActorDataPtr->GetAnimData()->IKTargetData.ExtractTransformAtTime(IKTargetDef.IKGoalName, Time) * IKTargetParentTransform;
						}
					}
				}
				else if (IKTargetDef.Provider == EContextualAnimIKTargetProvider::Bone)
				{
					if (const FContextualAnimSceneActorData* TargetSceneActorData = SceneInstance->FindSceneActorDataForRole(IKTargetDef.BoneParams.TargetRole))
					{
						if (USkeletalMeshComponent* TargetSkelMeshComp = TargetSceneActorData->GetSkeletalMeshComponent())
						{
							IKTargetTransform = TargetSkelMeshComp->GetSocketTransform(IKTargetDef.BoneParams.BoneName);
						}
					}
				}

				// Draw Debug IK Targets
#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
				if (FContextualAnimCVars::CVarDrawDebugIKTargets.GetValueOnGameThread() > 0)
				{
					const FColor DrawColor = FColor::MakeRedToGreenColorFromScalar(Alpha);
					DrawDebugSphere(GetWorld(), IKTargetTransform.GetLocation(), 5.f, 12, DrawColor, false, 0.f, 0, 0.5f);
					DrawDebugCoordinateSystem(GetWorld(), IKTargetTransform.GetLocation(), IKTargetTransform.Rotator(), 10.f, false, 0.f, 0, 0.5f);

					//DrawDebugString(GetWorld(), IKTargetTransform.GetLocation(), FString::Printf(TEXT("%s (%f)"), *IKTargetDef.AlphaCurveName.ToString(), Alpha));
				}
#endif

				// Convert IK Target to mesh space
				IKTargetTransform = IKTargetTransform.GetRelativeTransform(SceneActorDataPtr->GetSkeletalMeshComponent()->GetComponentTransform());

				IKTargets.Add(FContextualAnimIKTarget(IKTargetDef.IKGoalName, Alpha, IKTargetTransform));
			}
		}
	}
}

FPrimitiveSceneProxy* UContextualAnimSceneActorComponent::CreateSceneProxy()
{
	class FSceneActorCompProxy final : public FPrimitiveSceneProxy
	{
	public:

		SIZE_T GetTypeHash() const override
		{
			static size_t UniquePointer;
			return reinterpret_cast<size_t>(&UniquePointer);
		}

		FSceneActorCompProxy(const UContextualAnimSceneActorComponent* InComponent)
			: FPrimitiveSceneProxy(InComponent)
			, SceneAssetPtr(InComponent->SceneAsset)
			, Params(InComponent->DebugParams)
		{
		}

		static void DrawSector(FPrimitiveDrawInterface* PDI, const FVector& Origin, const FVector& Direction, float MinDistance, float MaxDistance, float MinAngle, float MaxAngle, const FLinearColor& Color, uint8 DepthPriority, float Thickness)
		{
			// Draw Cone lines
			const FVector LeftDirection = Direction.RotateAngleAxis(MinAngle, FVector::UpVector);
			const FVector RightDirection = Direction.RotateAngleAxis(MaxAngle, FVector::UpVector);
			PDI->DrawLine(Origin + (LeftDirection * MinDistance), Origin + (LeftDirection * MaxDistance), Color, DepthPriority, Thickness);
			PDI->DrawLine(Origin + (RightDirection * MinDistance), Origin + (RightDirection * MaxDistance), Color, DepthPriority, Thickness);

			// Draw Near Arc
			FVector LastDirection = LeftDirection;
			float Angle = MinAngle;
			while (Angle < MaxAngle)
			{
				Angle = FMath::Clamp<float>(Angle + 10, MinAngle, MaxAngle);

				const float Length = MinDistance;
				const FVector NewDirection = Direction.RotateAngleAxis(Angle, FVector::UpVector);
				const FVector LineStart = Origin + (LastDirection * Length);
				const FVector LineEnd = Origin + (NewDirection * Length);
				PDI->DrawLine(LineStart, LineEnd, Color, DepthPriority, Thickness);
				LastDirection = NewDirection;
			}

			// Draw Far Arc
			LastDirection = LeftDirection;
			Angle = MinAngle;
			while (Angle < MaxAngle)
			{
				Angle = FMath::Clamp<float>(Angle + 10, MinAngle, MaxAngle);

				const float Length = MaxDistance;
				const FVector NewDirection = Direction.RotateAngleAxis(Angle, FVector::UpVector);
				const FVector LineStart = Origin + (LastDirection * Length);
				const FVector LineEnd = Origin + (NewDirection * Length);
				PDI->DrawLine(LineStart, LineEnd, Color, DepthPriority, Thickness);
				LastDirection = NewDirection;
			}
		}

		virtual void GetDynamicMeshElements(const TArray<const FSceneView*>& Views, const FSceneViewFamily& ViewFamily, uint32 VisibilityMap, FMeshElementCollector& Collector) const override
		{
			const UContextualAnimSceneAsset* Asset = SceneAssetPtr.Get();
			if (Asset == nullptr)
			{
				return;
			}

			const FMatrix& LocalToWorld = GetLocalToWorld();
			const FTransform ToWorldTransform = FTransform(LocalToWorld);

			for (int32 ViewIndex = 0; ViewIndex < Views.Num(); ViewIndex++)
			{
				if (VisibilityMap & (1 << ViewIndex))
				{
					const FSceneView* View = Views[ViewIndex];

					// Taking into account the min and maximum drawing distance
					const float DistanceSqr = (View->ViewMatrices.GetViewOrigin() - LocalToWorld.GetOrigin()).SizeSquared();
					if (DistanceSqr < FMath::Square(GetMinDrawDistance()) || DistanceSqr > FMath::Square(GetMaxDrawDistance()))
					{
						continue;
					}

					FPrimitiveDrawInterface* PDI = Collector.GetPDI(ViewIndex);

					//DrawCircle(PDI, ToWorldTransform.GetLocation(), FVector(1, 0, 0), FVector(0, 1, 0), FColor::Red, SceneAssetPtr->GetRadius(), 12, SDPG_World, 1.f);

					SceneAssetPtr->ForEachAnimData([=](const FName& Role, const FContextualAnimData& Data)
					{
						if (Role != SceneAssetPtr->PrimaryRole)
						{
							FLinearColor DrawColor = FLinearColor::White;

							//@TODO: Temp, this should not be here
							if(Params.TestActor.IsValid())
							{
								if (Data.Metadata)
								{
									const FTransform EntryTransform = Data.GetAlignmentTransformAtEntryTime() * ToWorldTransform;
									if (Data.Metadata->DoesQuerierPassConditions(FContextualAnimQuerier(Params.TestActor.Get()), FContextualAnimQueryContext(ToWorldTransform), EntryTransform))
									{
										DrawColor = FLinearColor::Red;
									}
								}
							}

							// Draw Entry Point
							const FTransform EntryTransform = (Data.GetAlignmentTransformAtEntryTime() * ToWorldTransform);
							DrawCoordinateSystem(PDI, EntryTransform.GetLocation(), EntryTransform.Rotator(), 20.f, SDPG_World, 3.f);

							// Draw Sync Point
							const FTransform SyncPoint = Data.GetAlignmentTransformAtSyncTime() * ToWorldTransform;
							DrawCoordinateSystem(PDI, SyncPoint.GetLocation(), SyncPoint.Rotator(), 20.f, SDPG_World, 3.f);

							if (Params.DrawAlignmentTransformAtTime != 0.f)
							{
								const FTransform RootAtTime = (Data.GetAlignmentTransformAtTime(Params.DrawAlignmentTransformAtTime) * ToWorldTransform);
								DrawCoordinateSystem(PDI, RootAtTime.GetLocation(), RootAtTime.Rotator(), 10.f, SDPG_World, 2.f);
							}

							// Draw Facing Tolerance
							if (Data.Metadata && Data.Metadata->Facing > 0.f)
							{
								DrawSector(PDI, EntryTransform.GetLocation(), EntryTransform.GetRotation().GetForwardVector(), 0.f, 30.f, -Data.Metadata->Facing, Data.Metadata->Facing, DrawColor, SDPG_World, 1.f);
							}
							else
							{
								DrawCircle(PDI, EntryTransform.GetLocation(), FVector(1, 0, 0), FVector(0, 1, 0), DrawColor, 30.f, 12, SDPG_World, 1.f);
							}

							// Draw Sector
							if (Data.Metadata)
							{
								FVector Origin = ToWorldTransform.GetLocation();
								Origin.Z = EntryTransform.GetLocation().Z;

								FVector Direction = (EntryTransform.GetLocation() - ToWorldTransform.GetLocation()).GetSafeNormal2D();

								if (Data.Metadata->DirectionOffset != 0.f)
								{
									Direction = Direction.RotateAngleAxis(Data.Metadata->DirectionOffset, FVector::UpVector);
								}

								if (Data.Metadata->OriginOffset.X != 0.f)
								{
									Origin = Origin + Direction * Data.Metadata->OriginOffset.X;
								}

								if (Data.Metadata->OriginOffset.Y != 0.f)
								{
									Origin = Origin + (Direction.ToOrientationQuat().GetRightVector()) * Data.Metadata->OriginOffset.Y;
								}

								if (Data.Metadata->NearWidth > 0.f || Data.Metadata->FarWidth > 0.f)
								{
									const float HalfNearWidth = (Data.Metadata->NearWidth / 2.f);
									const FVector RightVector = Direction.ToOrientationQuat().GetRightVector();
									const FVector A = Origin + (-RightVector * HalfNearWidth);
									const FVector B = Origin + (RightVector * HalfNearWidth);

									const float HalfFarWidth = (Data.Metadata->FarWidth / 2.f);
									const FVector FarEdgeCenter = Origin + (Direction * Data.Metadata->MaxDistance);
									const FVector C = FarEdgeCenter + (-RightVector * HalfFarWidth);
									const FVector D = FarEdgeCenter + (RightVector * HalfFarWidth);

									PDI->DrawLine(A, B, DrawColor, SDPG_World, 2.f);
									PDI->DrawLine(C, D, DrawColor, SDPG_World, 2.f);

									PDI->DrawLine(A, C, DrawColor, SDPG_World, 2.f);
									PDI->DrawLine(B, D, DrawColor, SDPG_World, 2.f);
								}
								else
								{
									PDI->DrawLine(Origin, Origin + Direction * Data.Metadata->MaxDistance, DrawColor, SDPG_World, 2.f);
									DrawCircle(PDI, Origin, FVector(1, 0, 0), FVector(0, 1, 0), DrawColor, Data.Metadata->MaxDistance, 32, SDPG_World, 2.f);
								}
							}
						}

						return EContextualAnimForEachResult::Continue;
					});
				}
			}
		}

		virtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) const override
		{
			const bool bShowForCollision = View->Family->EngineShowFlags.Collision;
			FPrimitiveViewRelevance Result;
			Result.bDrawRelevance = IsShown(View);
			Result.bDynamicRelevance = true;
			Result.bNormalTranslucency = Result.bSeparateTranslucency = IsShown(View);
			return Result;
		}

		virtual uint32 GetMemoryFootprint(void) const override
		{
			return(sizeof(*this) + GetAllocatedSize());
		}

		uint32 GetAllocatedSize(void) const
		{
			return(FPrimitiveSceneProxy::GetAllocatedSize());
		}

	private:
		TWeakObjectPtr<const UContextualAnimSceneAsset> SceneAssetPtr;
		FContextualAnimDebugParams Params;
	};

	if(bEnableDebug)
	{
		return new FSceneActorCompProxy(this);
	}

	return nullptr;
}