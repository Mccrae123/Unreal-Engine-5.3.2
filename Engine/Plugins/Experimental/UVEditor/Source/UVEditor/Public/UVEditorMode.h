// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

#include "Tools/UEdMode.h"

#include "UVEditorMode.generated.h"


class IUVUnwrapDynamicMesh;
class UMeshElementsVisualizer;
class UPreviewMesh;
class UWorld;
class UInteractiveToolPropertySet;
class UUVToolStateObjectStore;

/**
 * The UV editor mode is the mode used in the UV asset editor. It holds most of the inter-tool state.
 * We put things in a mode instead of directly into the asset editor in case we want to someday use the mode
 * in multiple asset editors.
 */
UCLASS(Transient)
class UUVEditorMode : public UEdMode
{
	GENERATED_BODY()
public:
	const static FEditorModeID EM_UVEditorModeId;

	UUVEditorMode();

	void RegisterTools();
	void InitializeTargets(TArray<TObjectPtr<UObject>>& UVUnwrapMeshTargetsIn);

	TObjectPtr<UUVToolStateObjectStore> GetStateObjectStore() { return StateObjectStore; }

	// Asset management
	bool HaveUnappliedChanges();
	void GetAssetsWithUnappliedChanges(TArray<TObjectPtr<UObject>> UnappliedAssetsOut);
	void ApplyChanges();

	// UEdMode overrides
	virtual void Enter() override;
	virtual void Exit() override;
	virtual void ModeTick(float DeltaTime) override;

	// We don't actually override MouseEnter, etc, because things get forwarded to the input
	// router via FEditorModeTools, and we don't have any additional input handling to do at the mode level.

protected:

	// UEdMode overrides
	virtual void CreateToolkit() override;
	virtual void ActivateDefaultTool() override;
	// Not sure whether we need these yet
	virtual void BindCommands() override;
	virtual void OnToolStarted(UInteractiveToolManager* Manager, UInteractiveTool* Tool) {}
	virtual void OnToolEnded(UInteractiveToolManager* Manager, UInteractiveTool* Tool) {}

	/**
	 * This stores the original objects that the UV editor was asked to operate on (for
	 * instance UStaticMesh pointers).
	 */
	UPROPERTY()
	TArray<TObjectPtr<UObject>> OriginalObjectsToEdit;

	/**
	 * This stores the targets generated by the tool target manager that give us the unwrapped UV meshes to work with.
	 */
	UPROPERTY()
	TArray<TScriptInterface<IUVUnwrapDynamicMesh>> UVUnwrapMeshTargets;

	/**
	 * This is the main storage for the UV meshes, wrapped inside preview objects. Tools will
	 * get a pointer to these so that they can hide and alter the meshes.
	 */
	UPROPERTY()
	TArray<TObjectPtr<UPreviewMesh>> DisplayedMeshes;

	/**
	 * These wireframes track the meshes inside DisplayedMeshes
	 */
	UPROPERTY()
	TArray<TObjectPtr<UMeshElementsVisualizer>> DisplayedWireframes;

	/**
	 * This lets the tools cache arbitrary state or see if it has been cached by another tool. This
	 * can store selection, spatial data structures, etc.
	 */
	UPROPERTY()
	TObjectPtr<UUVToolStateObjectStore> StateObjectStore = nullptr;

	/**
	 * If we want to have mode-level property objects, whether user-visible or not,
	 * they can be put here to be ticked.
	 */
	UPROPERTY()
	TArray<TObjectPtr<UInteractiveToolPropertySet>> PropertyObjectsToTick;

	// This keeps track of whether the meshes inside DisplayedMeshes have been changed since
	// the last time that they were baked back to their targets.
	TArray<int32> MeshChangeStamps;
};
