// Copyright Epic Games, Inc. All Rights Reserved.

#include "K2Node_EnhancedInputAction.h"
#include "AssetRegistryModule.h"
#include "BlueprintActionDatabase.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraphSchema_K2_Actions.h"
#include "Editor.h"
#include "EditorCategoryUtils.h"
#include "EnhancedInputModule.h"
#include "Factories/Factory.h"
#include "GameFramework/InputSettings.h"
#include "GraphEditorSettings.h"
#include "InputCoreTypes.h"
#include "K2Node_AssignmentStatement.h"
#include "K2Node_EnhancedInputActionEvent.h"
#include "K2Node_GetInputActionValue.h"
#include "K2Node_TemporaryVariable.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "KismetCompiler.h"
#include "Subsystems/AssetEditorSubsystem.h"

#define LOCTEXT_NAMESPACE "K2Node_EnhancedInputAction"

static const FName InputActionPinName = TEXT("InputAction");
static const FName ElapsedSecondsPinName = TEXT("ElapsedSeconds");
static const FName TriggeredSecondsPinName = TEXT("TriggeredSeconds");
static const FName ActionValuePinName = TEXT("ActionValue");

UK2Node_EnhancedInputAction::UK2Node_EnhancedInputAction(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void ForEachEventPinName(TFunctionRef<void(ETriggerEvent Event, FName PinName)> PinLambda)
{
	UEnum* EventEnum = StaticEnum<ETriggerEvent>();
	for (int32 i = 0; i < EventEnum->NumEnums() - 1; ++i)
	{
		if (!EventEnum->HasMetaData(TEXT("Hidden"), i))
		{
			PinLambda(ETriggerEvent(EventEnum->GetValueByIndex(i)), *EventEnum->GetNameStringByIndex(i));
		}
	}
}

void UK2Node_EnhancedInputAction::AllocateDefaultPins()
{
	PreloadObject((UObject*)InputAction);

	ForEachEventPinName([this](ETriggerEvent Event, FName PinName)
	{
		static const UEnum* EventEnum = StaticEnum<ETriggerEvent>();

		UEdGraphPin* NewPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
		NewPin->PinToolTip = EventEnum->GetToolTipTextByIndex((int32)Event).ToString();
	});
	
	HideEventPins(nullptr);
	const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
	
	AdvancedPinDisplay = ENodeAdvancedPins::Hidden;

	UEdGraphPin* ValuePin = CreatePin(EGPD_Output, UK2Node_GetInputActionValue::GetValueCategory(InputAction), UK2Node_GetInputActionValue::GetValueSubCategoryObject(InputAction), ActionValuePinName);
	
	Schema->SetPinAutogeneratedDefaultValueBasedOnType(ValuePin);

	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Float, ElapsedSecondsPinName)->bAdvancedView = true;
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Float, TriggeredSecondsPinName)->bAdvancedView = true;

	UEdGraphPin* ActionPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Object, InputAction->GetClass(), InputActionPinName);
	ActionPin->DefaultObject = const_cast<UObject*>(Cast<UObject>(InputAction));
	ActionPin->DefaultValue = InputAction->GetName();
	Schema->ConstructBasicPinTooltip(*ActionPin, LOCTEXT("InputActionPinDescription", "The input action that caused this event to fire"), ActionPin->PinToolTip);
	
	Super::AllocateDefaultPins();
}

void UK2Node_EnhancedInputAction::HideEventPins(UEdGraphPin* RetainPin)
{
	// Gather pins
	int32 NumActivePins = 0;
	TMap<UEdGraphPin*, bool> EventPins;
	ForEachEventPinName([this, &NumActivePins, &EventPins](ETriggerEvent Event, FName PinName)
	{
		if (UEdGraphPin* Pin = FindPin(PinName))
		{
			NumActivePins += Pin->LinkedTo.Num() ? 1 : 0;
			EventPins.Emplace(Pin, Event == ETriggerEvent::Triggered);
		}
	});


	for (TPair<UEdGraphPin*, bool> PinData : EventPins)
	{
		UEdGraphPin* Pin = PinData.Key;
		bool bIsTriggeredPin = PinData.Value;
		// Triggered pin is shown if there are no active links, unless we just disconnected a pin in which case we continue to show that. Any other pins are only shown if connected.
		bool bVisible = (Pin == RetainPin && NumActivePins == 0) || (bIsTriggeredPin && NumActivePins == 0 && !RetainPin);
		Pin->bAdvancedView = !bVisible;
	}
}

void UK2Node_EnhancedInputAction::PostReconstructNode()
{
	Super::PostReconstructNode();
	HideEventPins(nullptr);
}

void UK2Node_EnhancedInputAction::PinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::PinConnectionListChanged(Pin);
	HideEventPins(Pin);
}

FLinearColor UK2Node_EnhancedInputAction::GetNodeTitleColor() const
{
	return GetDefault<UGraphEditorSettings>()->EventNodeTitleColor;
}

FName UK2Node_EnhancedInputAction::GetActionName() const
{
	return  InputAction ? InputAction->GetFName() : FName();
}

FText UK2Node_EnhancedInputAction::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	// TODO: Is Using InputAction->GetFName okay here? Full Asset path would be better for disambiguation.
	if (TitleType == ENodeTitleType::MenuTitle)
	{
		return FText::FromName(GetActionName());
	}
	else if (CachedNodeTitle.IsOutOfDate(this))
	{
		FFormatNamedArguments Args;
		Args.Add(TEXT("InputActionName"), FText::FromName(GetActionName()));

		FText LocFormat = LOCTEXT("EnhancedInputAction_Name", "EnhancedInputAction {InputActionName}");
		// FText::Format() is slow, so we cache this to save on performance
		CachedNodeTitle.SetCachedText(FText::Format(LocFormat, Args), this);
	}

	return CachedNodeTitle;
}

FText UK2Node_EnhancedInputAction::GetTooltipText() const
{
	if (CachedTooltip.IsOutOfDate(this))
	{
		// FText::Format() is slow, so we cache this to save on performance
		FString ActionPath = InputAction ? InputAction->GetFullName() : TEXT("");
		CachedTooltip.SetCachedText(FText::Format(LOCTEXT("EnhancedInputAction_Tooltip", "Event for when {0} triggers."), FText::FromString(ActionPath)), this);
	}
	return CachedTooltip;
}

FSlateIcon UK2Node_EnhancedInputAction::GetIconAndTint(FLinearColor& OutColor) const
{
	static FSlateIcon Icon("EditorStyle", "GraphEditor.Event_16x");
	return Icon;
}

bool UK2Node_EnhancedInputAction::IsCompatibleWithGraph(UEdGraph const* Graph) const
{
	// This node expands into event nodes and must be placed in a Ubergraph
	EGraphType const GraphType = Graph->GetSchema()->GetGraphType(Graph);
	bool bIsCompatible = (GraphType == EGraphType::GT_Ubergraph);

	if (bIsCompatible)
	{
		UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(Graph);

		UEdGraphSchema_K2 const* K2Schema = Cast<UEdGraphSchema_K2>(Graph->GetSchema());
		bool const bIsConstructionScript = (K2Schema != nullptr) ? UEdGraphSchema_K2::IsConstructionScript(Graph) : false;

		bIsCompatible = (Blueprint != nullptr) && Blueprint->SupportsInputEvents() && !bIsConstructionScript && Super::IsCompatibleWithGraph(Graph);
	}
	return bIsCompatible;
}

UObject* UK2Node_EnhancedInputAction::GetJumpTargetForDoubleClick() const
{
	return const_cast<UObject*>(Cast<UObject>(InputAction));
}

void UK2Node_EnhancedInputAction::JumpToDefinition() const
{
	GEditor->GetEditorSubsystem<UAssetEditorSubsystem>()->OpenEditorForAsset(GetJumpTargetForDoubleClick());
}

void UK2Node_EnhancedInputAction::ValidateNodeDuringCompilation(class FCompilerResultsLog& MessageLog) const
{
	Super::ValidateNodeDuringCompilation(MessageLog);

	if (!InputAction)
	{
		MessageLog.Error(*LOCTEXT("EnhancedInputAction_ErrorFmt", "EnhancedInputActionEvent references invalid 'null' action for @@").ToString(), this);
	}
}

void UK2Node_EnhancedInputAction::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	// Establish active pins
	struct ActivePinData
	{
		ActivePinData(UEdGraphPin* InPin, ETriggerEvent InTriggerEvent) : Pin(InPin), TriggerEvent(InTriggerEvent) {}
		UEdGraphPin* Pin;
		ETriggerEvent TriggerEvent;
	};

	TArray<ActivePinData> ActivePins;
	ForEachEventPinName([this, &ActivePins](ETriggerEvent Event, FName PinName) 
	{
		UEdGraphPin* InputActionPin = FindPin(PinName, EEdGraphPinDirection::EGPD_Output);
		if (InputActionPin && InputActionPin->LinkedTo.Num() > 0)
		{
			ActivePins.Add(ActivePinData(InputActionPin, Event));
		}
	});

	if (ActivePins.Num() == 0)
	{
		return;
	}

	// Bind all active pins to their action delegate
	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

	auto CreateInputActionEvent = [this, &CompilerContext, &SourceGraph](UEdGraphPin* Pin, ETriggerEvent TriggerEvent) -> UK2Node_EnhancedInputActionEvent*
	{
		if (!InputAction)
		{
			return nullptr;
		}

		UK2Node_EnhancedInputActionEvent* InputActionEvent = CompilerContext.SpawnIntermediateEventNode<UK2Node_EnhancedInputActionEvent>(this, Pin, SourceGraph);
		InputActionEvent->CustomFunctionName = FName(*FString::Printf(TEXT("InpActEvt_%s_%s"), *GetActionName().ToString(), *InputActionEvent->GetName()));
		InputActionEvent->InputAction = InputAction;
		InputActionEvent->TriggerEvent = TriggerEvent;
		InputActionEvent->EventReference.SetExternalDelegateMember(FName(TEXT("EnhancedInputActionHandlerDynamicSignature__DelegateSignature")));
		InputActionEvent->AllocateDefaultPins();
		return InputActionEvent;
	};

	// Create temporary variables to copy ActionValue and ElapsedSeconds into
	UK2Node_TemporaryVariable* ActionValueVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	ActionValueVar->VariableType.PinCategory = UK2Node_GetInputActionValue::GetValueCategory(InputAction);
	ActionValueVar->VariableType.PinSubCategoryObject = UK2Node_GetInputActionValue::GetValueSubCategoryObject(InputAction);
	ActionValueVar->AllocateDefaultPins();
	UK2Node_TemporaryVariable* ElapsedSecondsVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	ElapsedSecondsVar->VariableType.PinCategory = UEdGraphSchema_K2::PC_Float;
	ElapsedSecondsVar->AllocateDefaultPins();
	UK2Node_TemporaryVariable* TriggeredSecondsVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	TriggeredSecondsVar->VariableType.PinCategory = UEdGraphSchema_K2::PC_Float;
	TriggeredSecondsVar->AllocateDefaultPins();
	UK2Node_TemporaryVariable* InputActionVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	InputActionVar->VariableType.PinCategory = UEdGraphSchema_K2::PC_Object;
	InputActionVar->VariableType.PinSubCategoryObject = InputAction->GetClass();
	InputActionVar->AllocateDefaultPins();

	for (ActivePinData& PinData : ActivePins)
	{
		UEdGraphPin* EachPin = PinData.Pin;
		UK2Node_EnhancedInputActionEvent* InputActionEvent = CreateInputActionEvent(EachPin, PinData.TriggerEvent);

		if (!InputActionEvent)
		{
			continue;
		}

		// Create assignment nodes to assign the action value
		UK2Node_AssignmentStatement* ActionValueInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		ActionValueInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(ActionValueVar->GetVariablePin(), ActionValueInitialize->GetVariablePin());
		Schema->TryCreateConnection(ActionValueInitialize->GetValuePin(), InputActionEvent->FindPinChecked(ActionValuePinName));
		// Connect the events to the assign location nodes
		Schema->TryCreateConnection(Schema->FindExecutionPin(*InputActionEvent, EGPD_Output), ActionValueInitialize->GetExecPin());

		// Create assignment nodes to assign the elapsed timers and input action
		UK2Node_AssignmentStatement* ElapsedSecondsInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		ElapsedSecondsInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(ElapsedSecondsVar->GetVariablePin(), ElapsedSecondsInitialize->GetVariablePin());
		Schema->TryCreateConnection(ElapsedSecondsInitialize->GetValuePin(), InputActionEvent->FindPinChecked(TEXT("ElapsedTime")));

		UK2Node_AssignmentStatement* TriggeredSecondsInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		TriggeredSecondsInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(TriggeredSecondsVar->GetVariablePin(), TriggeredSecondsInitialize->GetVariablePin());
		Schema->TryCreateConnection(TriggeredSecondsInitialize->GetValuePin(), InputActionEvent->FindPinChecked(TEXT("TriggeredTime")));

		UK2Node_AssignmentStatement* InputActionInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		InputActionInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(InputActionVar->GetVariablePin(), InputActionInitialize->GetVariablePin());
		Schema->TryCreateConnection(InputActionInitialize->GetValuePin(), InputActionEvent->FindPinChecked(TEXT("SourceAction")));
		 
		// Connect the assign location to the assign elapsed time nodes
		Schema->TryCreateConnection(ActionValueInitialize->GetThenPin(), ElapsedSecondsInitialize->GetExecPin());
		Schema->TryCreateConnection(ElapsedSecondsInitialize->GetThenPin(), TriggeredSecondsInitialize->GetExecPin());
		Schema->TryCreateConnection(TriggeredSecondsInitialize->GetThenPin(), InputActionInitialize->GetExecPin());
		
		// Move the original event connections to the then pin of the Input Action assign
		CompilerContext.MovePinLinksToIntermediate(*EachPin, *InputActionInitialize->GetThenPin());

		// Move the original event variable connections to the intermediate nodes
		CompilerContext.MovePinLinksToIntermediate(*FindPin(ActionValuePinName), *ActionValueVar->GetVariablePin());
		CompilerContext.MovePinLinksToIntermediate(*FindPin(ElapsedSecondsPinName), *ElapsedSecondsVar->GetVariablePin());
		CompilerContext.MovePinLinksToIntermediate(*FindPin(TriggeredSecondsPinName), *TriggeredSecondsVar->GetVariablePin());
		CompilerContext.MovePinLinksToIntermediate(*FindPin(InputActionPinName), *InputActionVar->GetVariablePin());
	}
}

void UK2Node_EnhancedInputAction::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	auto CustomizeInputNodeLambda = [](UEdGraphNode* NewNode, bool bIsTemplateNode, TWeakObjectPtr<const UInputAction> Action)
	{
		UK2Node_EnhancedInputAction* InputNode = CastChecked<UK2Node_EnhancedInputAction>(NewNode);
		InputNode->InputAction = Action.Get();
	};

	// Do a first time registration using the node's class to pull in all existing actions
	if (ActionRegistrar.IsOpenForRegistration(GetClass()))
	{
		IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();

		static bool bRegisterOnce = true;
		if (bRegisterOnce)
		{
			bRegisterOnce = false;
			if (AssetRegistry.IsLoadingAssets())
			{
				AssetRegistry.OnFilesLoaded().AddLambda([]() { FBlueprintActionDatabase::Get().RefreshClassActions(StaticClass()); });
			}
		}

		TArray<FAssetData> ActionAssets;
		AssetRegistry.GetAssetsByClass(UInputAction::StaticClass()->GetFName(), ActionAssets);
		for (const FAssetData& ActionAsset : ActionAssets)
		{
			UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
			check(NodeSpawner != nullptr);

			if (const UInputAction* Action = Cast<const UInputAction>(ActionAsset.GetAsset()))
			{
				NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(CustomizeInputNodeLambda, TWeakObjectPtr<const UInputAction>(Action));
				ActionRegistrar.AddBlueprintAction(Action, NodeSpawner);	
			}
		}
	}
	else if (const UInputAction* Action = Cast<const UInputAction>(ActionRegistrar.GetActionKeyFilter()))
	{
		// If this is a specific UInputAction asset update it.
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(CustomizeInputNodeLambda, TWeakObjectPtr<const UInputAction>(Action));
		ActionRegistrar.AddBlueprintAction(Action, NodeSpawner);
	}
}

FText UK2Node_EnhancedInputAction::GetMenuCategory() const
{
	static FNodeTextCache CachedCategory;
	if (CachedCategory.IsOutOfDate(this))
	{
		// FText::Format() is slow, so we cache this to save on performance
		CachedCategory.SetCachedText(FEditorCategoryUtils::BuildCategoryString(FCommonEditorCategory::Input, LOCTEXT("ActionMenuCategory", "Enhanced Action Events")), this);	// TODO: Rename Action Events once old action system is removed
	}
	return CachedCategory;
}

FBlueprintNodeSignature UK2Node_EnhancedInputAction::GetSignature() const
{
	FBlueprintNodeSignature NodeSignature = Super::GetSignature();
	NodeSignature.AddKeyValue(GetActionName().ToString());

	return NodeSignature;
}

TSharedPtr<FEdGraphSchemaAction> UK2Node_EnhancedInputAction::GetEventNodeAction(const FText& ActionCategory)
{
	// TODO: Custom EdGraphSchemaAction required?
	TSharedPtr<FEdGraphSchemaAction_K2InputAction> EventNodeAction = MakeShareable(new FEdGraphSchemaAction_K2InputAction(ActionCategory, GetNodeTitle(ENodeTitleType::EditableTitle), GetTooltipText(), 0));
	EventNodeAction->NodeTemplate = this;
	return EventNodeAction;
}

#undef LOCTEXT_NAMESPACE
