// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Features/IModularFeature.h"

class AActor;
class UStaticMesh;
class UMaterial;
class UTexture2D;


/**
 * IGeometryProcessing_ApproximateActors is a generic high-level interface to a function/system that
 * outputs a set of new Mesh assets that approximate a set of input Actors.
 * This can be used to provide LOD-generation implementations for systems like ProxyLOD and HLOD.
 * 
 * This is an IModularFeature, and so clients can query/enumerate the available ApproximateActors implementations 
 * based on the ::GetModularFeatureName(). However, the preferred way is to use code like the following:
 * 
 *     IGeometryProcessingInterfacesModule& GeomProcInterfaces = FModuleManager::Get().LoadModuleChecked<IGeometryProcessingInterfacesModule>("GeometryProcessingInterfaces");
 *     IGeometryProcessing_ApproximateActors* ApproxActorsAPI = GeomProcInterfaces.GetApproximateActorsImplementation();
 * 
 * This will automatically determine which available implementation to use (based on any applicable config settings/etc),
 * and cache the result of that decision.
 */
class IGeometryProcessing_ApproximateActors : public IModularFeature
{
public:
	virtual ~IGeometryProcessing_ApproximateActors() {}

	enum class EApproximationPolicy
	{
		MeshAndGeneratedMaterial,
		CollisionMesh
	};


	enum class ESimplificationPolicy
	{
		FixedTriangleCount = 0,
		TrianglesPerUnitSqMeter = 1
	};


	/**
	 * Input options to Actor Approximation process
	 */
	struct FOptions
	{
		// Base path for generated assets. Names will be generated by appending strings to this path.
		FString BasePackagePath;

		// high-level control of the overall approximation process
		EApproximationPolicy BasePolicy = EApproximationPolicy::MeshAndGeneratedMaterial;

		//
		// Shape Approximation settings
		//

		// Meshing settings (ie for voxelization)
		float WorldSpaceApproximationAccuracyMeters = 1.0f;
		int32 ClampVoxelDimension = 512;

		float WindingThreshold = 0.5;

		bool bApplyMorphology = false;
		float MorphologyDistanceMeters = 0.1;

		ESimplificationPolicy MeshSimplificationPolicy = ESimplificationPolicy::FixedTriangleCount;
		int32 FixedTriangleCount = 5000;
		float SimplificationTargetMetric = 0.1;		// interpretation varies depending on MeshSimplificationPolicy

		//
		// Material approximation settings
		//
		int32 RenderCaptureImageSize = 1024;

		// render capture parameters
		float FieldOfViewDegrees = 45.0f;
		float NearPlaneDist = 1.0f;


		//
		// Material output settings
		//

		// output texture options
		int32 TextureImageSize = 1024;

		// supersampling parameter
		int32 AntiAliasMultiSampling = 0;



		// todo
		//   - which texture types to generate (BaseColor, Specular, WorldNormal, etc)
		//   - per-texture resolution, and channel/compression settings
		//   - which material to use as input, whether to make new UMaterial or a MIC
		//   - custom Generated-Texture to Material Parameter Name mapping
	};

	enum class EResultCode
	{
		Success,
		MeshGenerationFailed,
		UnknownError
	};

	/**
	 * Outputs of an Actor Approximation process
	 */
	struct FResults
	{
		EResultCode ResultCode = EResultCode::UnknownError;

		TArray<UStaticMesh*> NewMeshAssets;

		TArray<UMaterial*> NewMaterials;
		
		TArray<UTexture2D*> NewTextures;

		// todo
	};

	/**
	 * Top-level driver function that clients call to generate the approximation for a set of input Actors.
	 */
	virtual void ApproximateActors(const TArray<AActor*>& Actors, const FOptions& Options, FResults& ResultsOut) 
	{
		check(false);		// not implemented in base class
	}


	// Modular feature name to register for retrieval during runtime
	static const FName GetModularFeatureName()
	{
		return TEXT("GeometryProcessing_ApproximateActors");
	}


	// delegates to pass back info?
	DECLARE_DELEGATE_OneParam(FApproximateActorsCompleteDelegate, FResults&);
	FApproximateActorsCompleteDelegate CompleteDelegate;

};