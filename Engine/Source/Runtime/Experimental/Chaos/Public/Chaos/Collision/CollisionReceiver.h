// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.
#pragma once

#include "Chaos/ParticleHandle.h"
#include "Chaos/PBDCollisionConstraints.h"
#include "Chaos/PBDRigidsSOAs.h"

namespace Chaos
{
	/**
	 * Consumes lists of contacts generated by an FCollisionDetector (which may be on a separate thread) and
	 * then adds the contacts to the CollisionConstraints in a thread-safe way.
	 */
	class FAsyncCollisionReceiver
	{
	public:
		using FCollisionConstraints = TPBDCollisionConstraints<FReal, 3>;

		FAsyncCollisionReceiver(FCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it finds collisions.
		 */
		void ReceiveCollisions(const TArray<TCollisionConstraintBase<float, 3>*>& Constraints)
		{
			for (TCollisionConstraintBase<FReal, 3>* ConstraintBase : Constraints)
			{
				Queue.Enqueue(ConstraintBase);
			}
		}

		/**
		 * Add received collisions to the container (on physics thread)
		 */
		void ProcessCollisions()
		{
			FCollisionConstraintBase* ConstraintBase = nullptr;
			while (Queue.Dequeue(ConstraintBase))
			{
				// @todo(chaos) : Collision Constraints
				//    This needs to be moved within the MidPhase (which does not exist yet). The 
				//    NarrowPhase is creating temporary constraints for all interacting bodies 
				//    even though we might already have those bodies within the constraint.
				//    So there is a bunch of wasted computation when the CreateConstraints is called. 
				if (!CollisionConstraints.Contains(ConstraintBase))
				{
					CollisionConstraints.AddConstraint(ConstraintBase);
				}
			}
		}

	private:
		//todo(ocohen): use per thread buffer instead, need better support than ParallelFor for this
		TQueue<FCollisionConstraintBase*, EQueueMode::Mpsc> Queue;
		FCollisionConstraints& CollisionConstraints;
	};


	/**
	 * A synchronous collision receiver. This immediately adds collisions to the container as they are received. 
	 * /see FAsyncCollisionReceiver
	 */
	class FSyncCollisionReceiver
	{
	public:
		using FCollisionConstraints = TPBDCollisionConstraints<FReal, 3>;

		FSyncCollisionReceiver(FCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it finds collisions.
		 */
		void ReceiveCollisions(const TArray<TCollisionConstraintBase<float, 3>*>& Constraints)
		{
			for (TCollisionConstraintBase<FReal, 3>* ConstraintBase : Constraints)
			{
				CollisionConstraints.AddConstraint(ConstraintBase);
			}
		}

		/**
		 * No-op
		 */
		void ProcessCollisions()
		{
		}

	private:
		FCollisionConstraints& CollisionConstraints;
	};
}