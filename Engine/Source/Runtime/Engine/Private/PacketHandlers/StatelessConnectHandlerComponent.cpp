// Copyright Epic Games, Inc. All Rights Reserved.

#include "PacketHandlers/StatelessConnectHandlerComponent.h"
#include "Stats/Stats.h"
#include "Serialization/MemoryWriter.h"
#include "EngineStats.h"
#include "Misc/SecureHash.h"
#include "Engine/NetConnection.h"
#include "Net/Core/Misc/PacketAudit.h"


DEFINE_LOG_CATEGORY(LogHandshake);


/**
 * Purpose:
 *
 * UDP connections are vulnerable to various types of DoS attacks, particularly spoofing the IP address in UDP packets,
 * and to protect against this a handshake is needed to verify that the IP is really owned by the client.
 *
 * This handshake can be implemented in two ways:
 *	Stateful:	Here the server stores connection state information (i.e. maintains a UNetConnection) while the handshake is underway,
 *				allowing spoofed packets to allocate server memory space, prior to handshake verification.
 *
 *	Stateless:	Here the server does not store any connection state information, until the handshake completes,
 *				preventing spoofed packets from allocating server memory space until after the handshake.
 *
 * Stateful handshakes are vulnerable to DoS attacks through server memory usage, whereas stateless handshakes are not,
 * so this implementation uses stateless handshakes.
 *
 *
 *
 * Handshake Process/Protocol:
 * --------------------------
 *
 * The protocol for the handshake involves the client sending an initial packet to the server,
 * and the server responding with a unique 'Cookie' value, which the client has to respond with.
 *
 * Client - Initial Connect:
 * [?:MagicHeader][HandshakeBit][RestartHandshakeBit][8:MinVersion][8:CurVersion][8:HandshakePacketType][8:SentPacketCount][SecretIdBit][28:PacketSizeFiller][AlignPad][?:RandomData]
 *													--->
 *															Server - Stateless Handshake Challenge:
 *															[?:MagicHeader][HandshakeBit][RestartHandshakeBit][8:MinVersion][8:CurVersion][8:HandshakePacketType][8:SentPacketCount][SecretIdBit][8:Timestamp][20:Cookie][AlignPad][?:RandomData]
 *													<---
 * Client - Stateless Challenge Response:
 * [?:MagicHeader][HandshakeBit][RestartHandshakeBit][8:MinVersion][8:CurVersion][8:HandshakePacketType][8:SentPacketCount][SecretIdBit][8:Timestamp][20:Cookie][AlignPad][?:RandomData]
 *													--->
 *															Server:
 *															Ignore, or create UNetConnection.
 *
 *															Server - Stateless Handshake Ack
 *															[?:MagicHeader][HandshakeBit][RestartHandshakeBit][8:MinVersion][8:CurVersion][8:HandshakePacketType][8:SentPacketCount][SecretIdBit][8:Timestamp][20:Cookie][AlignPad][?:RandomData]
 *													<---
 * Client:
 * Handshake Complete.
 *
 *
 * Restart Handshake Process/Protocol:
 * ----------------------------------
 * The Restart Handshake process is triggered by receiving a (possibly spoofed) non-handshake packet from an unknown IP,
 * so the protocol has been crafted so the server sends only a minimal (1 byte) response, to minimize DRDoS reflection amplification.
 *
 *															Server - Restart Handshake Request:
 *															[?:MagicHeader][HandshakeBit][RestartHandshakeBit][8:MinVersion][8:CurVersion][8:HandshakePacketType][8:SentPacketCount][AlignPad][?:RandomData]
 *													<--
 * Client -  Initial Connect (as above)
 *													-->
 *															Server -  Stateless Handshake Challenge (as above)
 *													<--
 * Client - Stateless Challenge Response + Original Cookie
 * [?:MagicHeader][HandshakeBit][RestartHandshakeBit][8:MinVersion][8:CurVersion][8:HandshakePacketType][8:SentPacketCount][SecretIdBit][8:Timestamp][20:Cookie][20:OriginalCookie][AlignPad][?:RandomData]
 *													-->
 *															Server:
 *															Ignore, or restore UNetConnection.
 *
 *															Server - Stateless Handshake Ack (as above)
 *													<--
 * Client:
 * Handshake Complete. Connection restored.
 *
 *
 *
 *	- MagicHeader:			An optional static/predefined header, between 0-32 bits in size. Serves no purpose for the handshake code.
 *	- HandshakeBit:			Bit signifying whether a packet is a handshake packet. Applied to all game packets.
 *	- SecretIdBit:			For handshake packets, specifies which HandshakeSecret array was used to generate Cookie.
 *	- RestartHandshakeBit:  Sent by the server when it detects normal game traffic from an unknown IP/port combination.
 *	- MinVersion:			The minimum handshake protocol version supported by the remote side
 *	- CurVersion:			The currently active protocol version used by the remote side (determines received packet format)
 *	- HandshakePacketType:	Number indicating the type of handshake packet, based on EHandshakePacketType
 *	- SentPacketCount:		The number of handshake packets sent - for packet-analysis/debugging purposes
 *	- Timestamp:			Server timestamp, from the moment the handshake challenge was sent.
 *	- Cookie:				Cookie generated by the server, which the client must reply with.
 *	- AlignPad:				Handshake packets and PacketHandler's in general, require complex padding of packets. See ParseHandshakePacket.
 *	- RandomData:			Data of random length/content appended to handshake packets, to work around potential faulty ISP packet filtering
 *
 *	- PacketSizeFiller:		Pads the client packet with blank information, so that the initial client packet,
 *							is the same size as the server response packet.
 *
 *							The server will ignore initial packets below/above this length. This prevents hijacking of game servers,
 *							for use in 'DRDoS' reflection amplification attacks.
 *
 *
 *
 * Game Protocol Changes:
 *
 * Every game (as opposed to handshake) packet starts with an extra bit, represented by [HandshakeBit], and game packets set this to 0.
 * This is the only change to game packets. When HandshakeBit is set to 1, the separate protocol above is used for handshake packets.
 *
 *
 *
 * HandshakeSecret/Cookie:
 *
 * The Cookie value is used to uniquely identify and perform a handshake with a connecting client,
 * but only the server can generate and recognize valid cookies, and the server must do this without storing any connection state data.
 *
 * To do this, the server stores 2 large random HandshakeSecret values, that only the server knows,
 * and combines that with data unique to the client connection (IP and Port), plus a server Timestamp, as part of generating the cookie.
 *
 * This data is then combined using a special HMAC hashing function, used specifically for authentication, to generate the cookie:
 *	Cookie = HMAC(HandshakeSecret, Timestamp + Client IP + Client Port)
 *
 * When the client responds to the handshake challenge, sending back TimeStamp and the Cookie,
 * the server will be able to collect all the remaining information it needs from the client packet (Client IP, Client Port),
 * plus the HandshakeSecret, to be able to regenerate the Cookie from scratch, and verify that the regenerated cookie,
 * is the same as the one the client sent back.
 *
 * No connection state data needs to be stored in order to do this, so this allows a stateless handshake.
 *
 *
 * In addition, HandshakeSecret updates every 15 + Rand(0,5) seconds (with previous value being stored/accepted for same amount of time)
 * in order to limit packet replay attacks, where a valid cookie can be reused multiple times.
 *
 * Checks on the handshake Timestamp, especially when combined with 5 second variance above, compliment this in limiting replay attacks.
 *
 *
 *
 * IP/Port Switching:
 *
 * Rarely, some routers have a bug where they suddenly change the port they send traffic from. The consequence of this is the server starts
 * receiving traffic from a new IP/port combination from an already connected player. When this happens, it tells the client via the
 * RestartHandshakeBit to restart the handshake process.
 *
 * The client carries on with the handshake as normal, but when completing the handshake, the client also sends the cookie it previously connected with.
 * The server looks up the NetConnection associated with that cookie, and then updates the address for the connection.
 */



/**
 * Debug Defines
 */

// Enables packetloss testing, which should be tested by connecting/reconnecting to a server a couple dozen times.
// Every such connection attempt should eventually succeed/recover automatically - if any fail, something's broken.
#define PACKETLOSS_TEST 0



/**
 * Defines
 */

#define HANDSHAKE_PACKET_SIZE_BITS				259
#define RESTART_HANDSHAKE_PACKET_SIZE_BITS		34
#define RESTART_RESPONSE_SIZE_BITS				419


// The number of seconds between secret value updates, and the random variance applied to this
#define SECRET_UPDATE_TIME			15.f
#define SECRET_UPDATE_TIME_VARIANCE	5.f

// The maximum allowed lifetime (in seconds) of any one handshake cookie
#define MAX_COOKIE_LIFETIME			((SECRET_UPDATE_TIME + SECRET_UPDATE_TIME_VARIANCE) * (float)SECRET_COUNT)

// The minimum amount of possible time a cookie may exist (for calculating when the clientside should timeout a challenge response)
#define MIN_COOKIE_LIFETIME			SECRET_UPDATE_TIME


/**
 * CVars
 */

TAutoConsoleVariable<FString> CVarNetMagicHeader(
	TEXT("net.MagicHeader"),
	TEXT(""),
	TEXT("String representing binary bits which are prepended to every packet sent by the game. Max length: 32 bits."));


namespace UE::Net
{
	static float HandshakeResendInterval = 1.f;

	FAutoConsoleVariableRef CVarNetHandshakeResendInterval(
		TEXT("net.HandshakeResendInterval"),
		HandshakeResendInterval,
		TEXT("The delay between resending handshake packets which we have not received a response for."));

	/** The minimum supported stateless handshake protocol version */
#ifdef HANDSHAKE_MIN_VERSION_OVERRIDE
	static int32 MinSupportedHandshakeVersion = HANDSHAKE_MIN_VERSION_OVERRIDE;
#else
	static int32 MinSupportedHandshakeVersion = static_cast<uint8>(EHandshakeVersion::Original);
#endif

	/** The current compile-time handshake version */
#ifdef HANDSHAKE_VERSION_OVERRIDE
	static int32 CurrentHandshakeVersion = HANDSHAKE_VERSION_OVERRIDE;
#else
	static int32 CurrentHandshakeVersion = static_cast<uint8>(EHandshakeVersion::Latest);
#endif

	FAutoConsoleVariableRef CVarNetMinHandshakeVersion(
		TEXT("net.MinHandshakeVersion"),
		MinSupportedHandshakeVersion,
		TEXT("The minimum supported stateless handshake protocol version (numeric)."));

	FAutoConsoleVariableRef CVarNetCurrentHandshakeVersion(
		TEXT("net.CurrentHandshakeVersion"),
		CurrentHandshakeVersion,
		TEXT("The current supported stateless handshake protocol version (numeric)"));

	TAutoConsoleVariable<int32> CVarNetDoHandshakeVersionFallback(
		TEXT("net.DoHandshakeVersionFallback"),
		0,
		TEXT("Whether or not to (clientside) perform randomized falling-back to previous versions of the handshake protocol, upon failure."));

	/** The base amount of random data to add to handshake packets */
	static constexpr int32 BaseRandomDataLengthBytes		= 16;

	/** The amount by which the length of random data should randomly vary */
	static constexpr int32 RandomDataLengthVarianceBytes	= 8;


	/** HANDSHAKE_PACKET_SIZE_BITS for EHandshakeVersion::Original */
	static constexpr int32 OriginalHandshakePacketSizeBits = 227;

	/** RESTART_HANDSHAKE_PACKET_SIZE_BITS for EHandshakeVersion::Original */
	static constexpr int32 OriginalRestartHandshakePacketSizeBits = 2;

	/** RESTART_RESPONSE_SIZE_BITS for EHandshakeVersion::Original */
	static constexpr int32 OriginalRestartResponseSizeBits = 387;
}



/**
 * StatelessConnectHandlerComponent
 */

StatelessConnectHandlerComponent::StatelessConnectHandlerComponent()
	: HandlerComponent(FName(TEXT("StatelessConnectHandlerComponent")))
	, Driver(nullptr)
	, HandshakeSecret()
	, ActiveSecret(255)
	, LastSecretUpdateTimestamp(0.0)
	, LastChallengeSuccessAddress(nullptr)
	, LastServerSequence(0)
	, LastClientSequence(0)
	, MinClientHandshakeVersion(static_cast<EHandshakeVersion>(UE::Net::CurrentHandshakeVersion))
	, LastClientSendTimestamp(0.0)
	, LastChallengeTimestamp(0.0)
	, LastRestartPacketTimestamp(0.0)
	, LastSecretId(0)
	, LastTimestamp(0.0)
	, LastCookie()
	, bRestartedHandshake(false)
	, AuthorisedCookie()
	, MagicHeader()
	, LastRemoteHandshakeVersion(static_cast<EHandshakeVersion>(UE::Net::CurrentHandshakeVersion))
{
	SetActive(true);

	bRequiresHandshake = true;

	FString MagicHeaderStr = CVarNetMagicHeader.GetValueOnAnyThread();

	if (!MagicHeaderStr.IsEmpty())
	{
		int32 HeaderStrLen = MagicHeaderStr.Len();

		if (HeaderStrLen <= 32)
		{
			bool bValidBinaryStr = true;

			for (int32 i=0; i<MagicHeaderStr.Len() && bValidBinaryStr; i++)
			{
				const TCHAR& CurChar = MagicHeaderStr[i];

				bValidBinaryStr = CurChar == '0' || CurChar == '1';

				MagicHeader.Add(CurChar != '0');
			}

			if (!bValidBinaryStr)
			{
				UE_LOG(LogHandshake, Error, TEXT("CVar net.MagicHeader must be a binary string, containing only 1's and 0's, e.g.: 00010101. Current string: %s"), *MagicHeaderStr);

				MagicHeader.Empty();
			}
		}
		else
		{
			UE_LOG(LogHandshake, Error, TEXT("CVar net.MagicHeader is too long (%i), maximum size is 32 bits: %s"), MagicHeaderStr.Len(), *MagicHeaderStr);
		}
	}
}

void StatelessConnectHandlerComponent::CountBytes(FArchive& Ar) const
{
	HandlerComponent::CountBytes(Ar);

	const SIZE_T SizeOfThis = sizeof(*this) - sizeof(HandlerComponent);

	for (int32 i = 0; i < SECRET_COUNT; ++i)
	{
		HandshakeSecret[i].CountBytes(Ar);
	}
}

void StatelessConnectHandlerComponent::NotifyHandshakeBegin()
{
	using namespace UE::Net;

	SendInitialPacket(static_cast<EHandshakeVersion>(CurrentHandshakeVersion));
}

void StatelessConnectHandlerComponent::SendInitialPacket(EHandshakeVersion HandshakeVersion)
{
	using namespace UE::Net;

	if (Handler->Mode == Handler::Mode::Client)
	{
		UNetConnection* ServerConn = (Driver != nullptr ? ToRawPtr(Driver->ServerConnection) : nullptr);

		if (ServerConn != nullptr)
		{
			FBitWriter InitialPacket(GetAdjustedSizeBits(HANDSHAKE_PACKET_SIZE_BITS) + (BaseRandomDataLengthBytes * 8) + 1 /* Termination bit */);
			uint8 bHandshakePacket = 1;

			if (MagicHeader.Num() > 0)
			{
				InitialPacket.SerializeBits(MagicHeader.GetData(), MagicHeader.Num());
			}

			InitialPacket.WriteBit(bHandshakePacket);


			// In order to prevent DRDoS reflection amplification attacks, clients must pad the packet to match server packet size
			uint8 bRestartHandshake = bRestartedHandshake ? 1 : 0;
			uint8 SecretIdPad = 0;
			uint8 PacketSizeFiller[28];

			InitialPacket.WriteBit(bRestartHandshake);

			if (HandshakeVersion >= EHandshakeVersion::Randomized)
			{
				uint8 MinVersion = MinSupportedHandshakeVersion;
				uint8 CurVersion = CurrentHandshakeVersion;
				uint8 HandshakePacketType = static_cast<uint8>(EHandshakePacketType::InitialPacket);

				InitialPacket << MinVersion;
				InitialPacket << CurVersion;
				InitialPacket << HandshakePacketType;
				InitialPacket << SentHandshakePacketCount;
			}

			InitialPacket.WriteBit(SecretIdPad);

			FMemory::Memzero(PacketSizeFiller, UE_ARRAY_COUNT(PacketSizeFiller));
			InitialPacket.Serialize(PacketSizeFiller, UE_ARRAY_COUNT(PacketSizeFiller));



			CapHandshakePacket(InitialPacket, HandshakeVersion);


			// Disable PacketHandler parsing, and send the raw packet
			Handler->SetRawSend(true);

#if !UE_BUILD_SHIPPING && PACKETLOSS_TEST
			bool bRandFail = FMath::RandBool();

			if (bRandFail)
			{
				UE_LOG(LogHandshake, Log, TEXT("Triggering random initial connect packet fail."));
			}

			if (!bRandFail)
#endif
			{
				if (ServerConn->Driver->IsNetResourceValid())
				{
					FOutPacketTraits Traits;

					ServerConn->LowLevelSend(InitialPacket.GetData(), InitialPacket.GetNumBits(), Traits);
				}
			}

			Handler->SetRawSend(false);

			LastClientSendTimestamp = FPlatformTime::Seconds();
		}
		else
		{
			UE_LOG(LogHandshake, Error, TEXT("Tried to send handshake connect packet without a server connection."));
		}
	}
}

void StatelessConnectHandlerComponent::SendConnectChallenge(TSharedPtr<const FInternetAddr> ClientAddress, EHandshakeVersion HandshakeVersion,
															uint8 ClientSentHandshakePacketCount)
{
	using namespace UE::Net;

	if (Driver != nullptr)
	{
		FBitWriter ChallengePacket(GetAdjustedSizeBits(HANDSHAKE_PACKET_SIZE_BITS) + (BaseRandomDataLengthBytes * 8) + 1 /* Termination bit */);
		uint8 bHandshakePacket = 1;
		uint8 bRestartHandshake = 0; // Ignored clientside
		double Timestamp = Driver->GetElapsedTime();
		uint8 Cookie[COOKIE_BYTE_SIZE];

		GenerateCookie(ClientAddress, ActiveSecret, Timestamp, Cookie);

		if (MagicHeader.Num() > 0)
		{
			ChallengePacket.SerializeBits(MagicHeader.GetData(), MagicHeader.Num());
		}

		ChallengePacket.WriteBit(bHandshakePacket);
		ChallengePacket.WriteBit(bRestartHandshake);

		if (HandshakeVersion >= EHandshakeVersion::Randomized)
		{
			uint8 MinVersion = MinSupportedHandshakeVersion;
			uint8 CurVersion = static_cast<uint8>(HandshakeVersion);
			uint8 HandshakePacketType = static_cast<uint8>(EHandshakePacketType::Challenge);

			ChallengePacket << MinVersion;
			ChallengePacket << CurVersion;
			ChallengePacket << HandshakePacketType;
			ChallengePacket << ClientSentHandshakePacketCount;
		}

		ChallengePacket.WriteBit(ActiveSecret);

		ChallengePacket << Timestamp;
		ChallengePacket.Serialize(Cookie, UE_ARRAY_COUNT(Cookie));

#if !UE_BUILD_SHIPPING
		FDDoSDetection* DDoS = Handler->GetDDoS();

		UE_CLOG((DDoS == nullptr || !DDoS->CheckLogRestrictions()), LogHandshake, Log,
				TEXT("SendConnectChallenge. Timestamp: %f, Cookie: %s" ), Timestamp, *FString::FromBlob(Cookie, UE_ARRAY_COUNT(Cookie)));
#endif

		CapHandshakePacket(ChallengePacket, HandshakeVersion);

		
		// Disable PacketHandler parsing, and send the raw packet
		PacketHandler* ConnectionlessHandler = Driver->ConnectionlessHandler.Get();

		if (ConnectionlessHandler != nullptr)
		{
			ConnectionlessHandler->SetRawSend(true);
		}

#if !UE_BUILD_SHIPPING && PACKETLOSS_TEST
		bool bRandFail = FMath::RandBool();

		if (bRandFail)
		{
			UE_LOG(LogHandshake, Log, TEXT("Triggering random connect challenge packet fail."));
		}

		if (!bRandFail)
#endif
		{
			if (Driver->IsNetResourceValid())
			{
				FOutPacketTraits Traits;

				Driver->LowLevelSend(ClientAddress, ChallengePacket.GetData(), ChallengePacket.GetNumBits(), Traits);
			}
		}


		if (ConnectionlessHandler != nullptr)
		{
			ConnectionlessHandler->SetRawSend(false);
		}
	}
	else
	{
#if !UE_BUILD_SHIPPING
		UE_LOG(LogHandshake, Error, TEXT("Tried to send handshake challenge packet without a net driver."));
#endif
	}
}

void StatelessConnectHandlerComponent::SendChallengeResponse(EHandshakeVersion HandshakeVersion, uint8 InSecretId, double InTimestamp,
																uint8 InCookie[COOKIE_BYTE_SIZE])
{
	using namespace UE::Net;

	UNetConnection* ServerConn = (Driver != nullptr ? ToRawPtr(Driver->ServerConnection) : nullptr);

	if (ServerConn != nullptr)
	{
		int32 RestartHandshakeResponseSize = RESTART_RESPONSE_SIZE_BITS;

		const int32 BaseSize = GetAdjustedSizeBits(bRestartedHandshake ? RestartHandshakeResponseSize : HANDSHAKE_PACKET_SIZE_BITS);
		FBitWriter ResponsePacket(BaseSize + (BaseRandomDataLengthBytes * 8) + 1 /* Termination bit */);
		uint8 bHandshakePacket = 1;
		uint8 bRestartHandshake = (bRestartedHandshake ? 1 : 0);

		if (MagicHeader.Num() > 0)
		{
			ResponsePacket.SerializeBits(MagicHeader.GetData(), MagicHeader.Num());
		}

		ResponsePacket.WriteBit(bHandshakePacket);
		ResponsePacket.WriteBit(bRestartHandshake);

		if (HandshakeVersion >= EHandshakeVersion::Randomized)
		{
			uint8 MinVersion = MinSupportedHandshakeVersion;
			uint8 CurVersion = static_cast<uint8>(HandshakeVersion);
			uint8 HandshakePacketType = static_cast<uint8>(bRestartedHandshake ? EHandshakePacketType::RestartResponse :
											EHandshakePacketType::Response);

			ResponsePacket << MinVersion;
			ResponsePacket << CurVersion;

			ResponsePacket << HandshakePacketType;
			ResponsePacket << SentHandshakePacketCount;
		}

		ResponsePacket.WriteBit(InSecretId);

		ResponsePacket << InTimestamp;
		ResponsePacket.Serialize(InCookie, COOKIE_BYTE_SIZE);

		if (bRestartedHandshake)
		{
			ResponsePacket.Serialize(AuthorisedCookie, COOKIE_BYTE_SIZE);
		}

#if !UE_BUILD_SHIPPING
		UE_LOG( LogHandshake, Log, TEXT( "SendChallengeResponse. Timestamp: %f, Cookie: %s" ), InTimestamp, *FString::FromBlob( InCookie, COOKIE_BYTE_SIZE ) );
#endif

		CapHandshakePacket(ResponsePacket, HandshakeVersion);


		// Disable PacketHandler parsing, and send the raw packet
		Handler->SetRawSend(true);

#if !UE_BUILD_SHIPPING && PACKETLOSS_TEST
		bool bRandFail = FMath::RandBool();

		if (bRandFail)
		{
			UE_LOG(LogHandshake, Log, TEXT("Triggering random challenge response packet fail."));
		}

		if (!bRandFail)
#endif
		{
			if (ServerConn->Driver->IsNetResourceValid())
			{
				FOutPacketTraits Traits;

				ServerConn->LowLevelSend(ResponsePacket.GetData(), ResponsePacket.GetNumBits(), Traits);
			}
		}

		Handler->SetRawSend(false);

		int16* CurSequence = (int16*)InCookie;

		LastClientSendTimestamp = FPlatformTime::Seconds();
		LastSecretId = InSecretId;
		LastTimestamp = InTimestamp;
		LastServerSequence = *CurSequence & (MAX_PACKETID - 1);
		LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);
		LastRemoteHandshakeVersion = HandshakeVersion;

		FMemory::Memcpy(LastCookie, InCookie, UE_ARRAY_COUNT(LastCookie));
	}
	else
	{
		UE_LOG(LogHandshake, Error, TEXT("Tried to send handshake response packet without a server connection."));
	}
}

void StatelessConnectHandlerComponent::SendChallengeAck(TSharedPtr<const FInternetAddr> ClientAddress, EHandshakeVersion HandshakeVersion,
														uint8 ClientSentHandshakePacketCount, uint8 InCookie[COOKIE_BYTE_SIZE])
{
	using namespace UE::Net;

	if (Driver != nullptr)
	{
		FBitWriter AckPacket(GetAdjustedSizeBits(HANDSHAKE_PACKET_SIZE_BITS) + (BaseRandomDataLengthBytes * 8) + 1 /* Termination bit */);
		uint8 bHandshakePacket = 1;
		uint8 bRestartHandshake = 0; // Ignored clientside
		double Timestamp  = -1.0;

		if (MagicHeader.Num() > 0)
		{
			AckPacket.SerializeBits(MagicHeader.GetData(), MagicHeader.Num());
		}

		AckPacket.WriteBit(bHandshakePacket);
		AckPacket.WriteBit(bRestartHandshake);

		if (HandshakeVersion >= EHandshakeVersion::Randomized)
		{
			uint8 MinVersion = MinSupportedHandshakeVersion;
			uint8 CurVersion = static_cast<uint8>(HandshakeVersion);
			uint8 HandshakePacketType = static_cast<uint8>(EHandshakePacketType::Ack);

			AckPacket << MinVersion;
			AckPacket << CurVersion;

			AckPacket << HandshakePacketType;
			AckPacket << ClientSentHandshakePacketCount;
		}

		AckPacket.WriteBit(bHandshakePacket);	// ActiveSecret

		AckPacket << Timestamp;
		AckPacket.Serialize(InCookie, COOKIE_BYTE_SIZE);

#if !UE_BUILD_SHIPPING
		UE_LOG(LogHandshake, Log, TEXT("SendChallengeAck. InCookie: %s" ), *FString::FromBlob(InCookie, COOKIE_BYTE_SIZE));
#endif

		CapHandshakePacket(AckPacket, HandshakeVersion);

		
		// Disable PacketHandler parsing, and send the raw packet
		PacketHandler* ConnectionlessHandler = Driver->ConnectionlessHandler.Get();

		if (ConnectionlessHandler != nullptr)
		{
			ConnectionlessHandler->SetRawSend(true);
		}

#if !UE_BUILD_SHIPPING && PACKETLOSS_TEST
		bool bRandFail = FMath::RandBool();

		if (bRandFail)
		{
			UE_LOG(LogHandshake, Log, TEXT("Triggering random challenge ack packet fail."));
		}

		if (!bRandFail)
#endif
		{
			if (Driver->IsNetResourceValid())
			{
				FOutPacketTraits Traits;

				Driver->LowLevelSend(ClientAddress, AckPacket.GetData(), AckPacket.GetNumBits(), Traits);
			}
		}


		if (ConnectionlessHandler != nullptr)
		{
			ConnectionlessHandler->SetRawSend(false);
		}
	}
	else
	{
#if !UE_BUILD_SHIPPING
		UE_LOG(LogHandshake, Error, TEXT("Tried to send handshake challenge ack packet without a net driver."));
#endif
	}
}

void StatelessConnectHandlerComponent::SendRestartHandshakeRequest(const TSharedPtr<const FInternetAddr> ClientAddress,
																	EHandshakeVersion HandshakeVersion)
{
	using namespace UE::Net;

	if (Driver != nullptr)
	{
		FBitWriter RestartPacket(GetAdjustedSizeBits(RESTART_HANDSHAKE_PACKET_SIZE_BITS) + (BaseRandomDataLengthBytes * 8) + 1 /* Termination bit */);
		uint8 bHandshakePacket = 1;
		uint8 bRestartHandshake = 1;

		if (MagicHeader.Num() > 0)
		{
			RestartPacket.SerializeBits(MagicHeader.GetData(), MagicHeader.Num());
		}

		RestartPacket.WriteBit(bHandshakePacket);
		RestartPacket.WriteBit(bRestartHandshake);

		if (HandshakeVersion >= EHandshakeVersion::Randomized)
		{
			uint8 MinVersion = MinSupportedHandshakeVersion;
			uint8 CurVersion = static_cast<uint8>(HandshakeVersion);
			uint8 HandshakePacketType = static_cast<uint8>(EHandshakePacketType::RestartHandshake);

			RestartPacket << MinVersion;
			RestartPacket << CurVersion;

			RestartPacket << HandshakePacketType;
			RestartPacket << SentHandshakePacketCount;
		}

#if !UE_BUILD_SHIPPING
		FDDoSDetection* DDoS = Handler->GetDDoS();

		UE_CLOG((DDoS == nullptr || !DDoS->CheckLogRestrictions()), LogHandshake, Verbose, TEXT("SendRestartHandshakeRequest."));
#endif

		CapHandshakePacket(RestartPacket, HandshakeVersion);

		
		// Disable PacketHandler parsing, and send the raw packet
		PacketHandler* ConnectionlessHandler = Driver->ConnectionlessHandler.Get();

		if (ConnectionlessHandler != nullptr)
		{
			ConnectionlessHandler->SetRawSend(true);
		}

#if !UE_BUILD_SHIPPING && PACKETLOSS_TEST
		bool bRandFail = FMath::RandBool();

		if (bRandFail)
		{
			UE_LOG(LogHandshake, Log, TEXT("Triggering random restart handshake packet fail."));
		}

		if (!bRandFail)
#endif
		{
			if (Driver->IsNetResourceValid())
			{
				FOutPacketTraits Traits;

				Driver->LowLevelSend(ClientAddress, RestartPacket.GetData(), RestartPacket.GetNumBits(), Traits);
			}
		}


		if (ConnectionlessHandler != nullptr)
		{
			ConnectionlessHandler->SetRawSend(false);
		}
	}
	else
	{
#if !UE_BUILD_SHIPPING
		UE_LOG(LogHandshake, Error, TEXT("Tried to send restart handshake packet without a net driver."));
#endif
	}
}

void StatelessConnectHandlerComponent::CapHandshakePacket(FBitWriter& HandshakePacket, EHandshakeVersion HandshakeVersion)
{
	using namespace UE::Net;

	uint32 NumBits = HandshakePacket.GetNumBits() - GetAdjustedSizeBits(0);

#if !UE_BUILD_SHIPPING
	if (HandshakeVersion == EHandshakeVersion::Original)
	{
		check(NumBits == OriginalHandshakePacketSizeBits || NumBits == OriginalRestartHandshakePacketSizeBits ||
				NumBits == OriginalRestartResponseSizeBits);
	}
	else
	{
		check(NumBits == HANDSHAKE_PACKET_SIZE_BITS || NumBits == RESTART_HANDSHAKE_PACKET_SIZE_BITS || NumBits == RESTART_RESPONSE_SIZE_BITS);
	}
#endif

	FPacketAudit::AddStage(TEXT("PostPacketHandler"), HandshakePacket);

	if (HandshakeVersion >= EHandshakeVersion::Randomized)
	{
		const int32 RandomDataLengthBytes = BaseRandomDataLengthBytes - FMath::RandRange(0, RandomDataLengthVarianceBytes);

		for (int32 RandIdx=0; RandIdx<RandomDataLengthBytes; RandIdx++)
		{
			uint8 RandVal = FMath::Rand() % 255;

			HandshakePacket << RandVal;
		}
	}

	// Add a termination bit, the same as the UNetConnection code does
	HandshakePacket.WriteBit(1);

	SentHandshakePacketCount++;
}

void StatelessConnectHandlerComponent::SetDriver(UNetDriver* InDriver)
{
	Driver = InDriver;

	if (Handler->Mode == Handler::Mode::Server)
	{
		StatelessConnectHandlerComponent* StatelessComponent = Driver->StatelessConnectComponent.Pin().Get();

		if (StatelessComponent != nullptr)
		{
			if (StatelessComponent == this)
			{
				UpdateSecret();
			}
			else
			{
				InitFromConnectionless(StatelessComponent);
			}
		}
	}
}

void StatelessConnectHandlerComponent::Initialize()
{
	// On the server, initializes immediately. Clientside doesn't initialize until handshake completes.
	if (Handler->Mode == Handler::Mode::Server)
	{
		Initialized();
	}
}

void StatelessConnectHandlerComponent::InitFromConnectionless(StatelessConnectHandlerComponent* InConnectionlessHandler)
{
	// Store the cookie/address used for the handshake, to enable server ack-retries
	LastChallengeSuccessAddress = InConnectionlessHandler->LastChallengeSuccessAddress;
	LastRemoteHandshakeVersion = InConnectionlessHandler->LastRemoteHandshakeVersion;

	FMemory::Memcpy(AuthorisedCookie, InConnectionlessHandler->AuthorisedCookie, UE_ARRAY_COUNT(AuthorisedCookie));

	LastInitTimestamp = (Driver != nullptr ? Driver->GetElapsedTime() : 0.0);
}

void StatelessConnectHandlerComponent::Incoming(FBitReader& Packet)
{
	using namespace UE::Net;

	if (MagicHeader.Num() > 0)
	{
		// Don't bother with the expense of verifying the magic header here.
		uint32 ReadMagic = 0;
		Packet.SerializeBits(&ReadMagic, MagicHeader.Num());
	}

	bool bHandshakePacket = !!Packet.ReadBit() && !Packet.IsError();

	if (bHandshakePacket)
	{
		FParsedHandshakeData HandshakeData;

		bHandshakePacket = ParseHandshakePacket(Packet, HandshakeData);

		if (bHandshakePacket)
		{
			if (Handler->Mode == Handler::Mode::Client)
			{
				if (State == Handler::Component::State::UnInitialized || State == Handler::Component::State::InitializedOnLocal)
				{
					if (HandshakeData.bRestartHandshake)
					{
#if !UE_BUILD_SHIPPING
						UE_LOG(LogHandshake, Log, TEXT("Ignoring restart handshake request, while already restarted."));
#endif
					}
					// Receiving challenge, verify the timestamp is > 0.0f
					else if (HandshakeData.HandshakePacketType == EHandshakePacketType::Challenge && HandshakeData.Timestamp > 0.0)
					{
						LastChallengeTimestamp = (Driver != nullptr ? Driver->GetElapsedTime() : 0.0);

						SendChallengeResponse(HandshakeData.RemoteCurVersion, HandshakeData.SecretId, HandshakeData.Timestamp, HandshakeData.Cookie);

						// Utilize this state as an intermediary, indicating that the challenge response has been sent
						SetState(Handler::Component::State::InitializedOnLocal);
					}
					// Receiving challenge ack, verify the timestamp is < 0.0f
					else if (HandshakeData.HandshakePacketType == EHandshakePacketType::Ack && HandshakeData.Timestamp < 0.0)
					{
						if (!bRestartedHandshake)
						{
							UNetConnection* ServerConn = (Driver != nullptr ? ToRawPtr(Driver->ServerConnection) : nullptr);

							// Extract the initial packet sequence from the random Cookie data
							if (ensure(ServerConn != nullptr))
							{
								int16* CurSequence = (int16*)HandshakeData.Cookie;

								int32 ServerSequence = *CurSequence & (MAX_PACKETID - 1);
								int32 ClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);

								ServerConn->InitSequence(ServerSequence, ClientSequence);
							}

							// Save the final authorized cookie
							FMemory::Memcpy(AuthorisedCookie, HandshakeData.Cookie, UE_ARRAY_COUNT(AuthorisedCookie));
						}

						// Now finish initializing the handler - flushing the queued packet buffer in the process.
						SetState(Handler::Component::State::Initialized);
						Initialized();

						bRestartedHandshake = false;

						// Reset packet count clientside, due to how it affects protocol version fallback selection
						SentHandshakePacketCount = 0;
					}
				}
				else if (HandshakeData.bRestartHandshake)
				{
					uint8 ZeroCookie[COOKIE_BYTE_SIZE] = {0};
					bool bValidAuthCookie = FMemory::Memcmp(AuthorisedCookie, ZeroCookie, COOKIE_BYTE_SIZE) != 0;

					// The server has requested us to restart the handshake process - this is because
					// it has received traffic from us on a different address than before.
					if (ensure(bValidAuthCookie))
					{
						bool bPassedDelayCheck = false;
						bool bPassedDualIPCheck = false;
						double CurrentTime = FPlatformTime::Seconds();;

						if (!bRestartedHandshake)
						{
							UNetConnection* ServerConn = (Driver != nullptr ? ToRawPtr(Driver->ServerConnection) : nullptr);
							double LastNetConnPacketTime = (ServerConn != nullptr ? ServerConn->LastReceiveRealtime : 0.0);

							// The server may send multiple restart handshake packets, so have a 10 second delay between accepting them
							bPassedDelayCheck = (CurrentTime - LastClientSendTimestamp) > 10.0;

							// Some clients end up sending packets duplicated over multiple IP's, triggering the restart handshake.
							// Detect this by checking if any restart handshake requests have been received in roughly the last second
							// (Dual IP situations will make the server send them constantly) - and override the checks as a failsafe,
							// if no NetConnection packets have been received in the last second.
							double LastRestartPacketTimeDiff = CurrentTime - LastRestartPacketTimestamp;
							double LastNetConnPacketTimeDiff = CurrentTime - LastNetConnPacketTime;

							bPassedDualIPCheck = LastRestartPacketTimestamp == 0.0 ||
													LastRestartPacketTimeDiff > 1.1 ||
													LastNetConnPacketTimeDiff > 1.0;
						}

						LastRestartPacketTimestamp = CurrentTime;

						auto WithinHandshakeLogLimit = [&Driver = Driver]() -> bool
							{
								const double LogCountPeriod = 30.0;
								const int8 MaxLogCount = 3;

								static double LastLogStartTime = 0.0;
								static int32 LogCounter = 0;

								double CurTimeApprox = Driver->GetElapsedTime();
								bool bWithinLimit = false;

								if ((CurTimeApprox - LastLogStartTime) > LogCountPeriod)
								{
									LastLogStartTime = CurTimeApprox;
									LogCounter = 1;
									bWithinLimit = true;
								}
								else if (LogCounter < MaxLogCount)
								{
									LogCounter++;
									bWithinLimit = true;
								}

								return bWithinLimit;
							};

						if (!bRestartedHandshake && bPassedDelayCheck && bPassedDualIPCheck)
						{
							UE_LOG(LogHandshake, Log, TEXT("Beginning restart handshake process."));

							bRestartedHandshake = true;

							SetState(Handler::Component::State::UnInitialized);
							SendInitialPacket(LastRemoteHandshakeVersion);
						}
						else if (WithinHandshakeLogLimit())
						{
							if (bRestartedHandshake)
							{
								UE_LOG(LogHandshake, Log, TEXT("Ignoring restart handshake request, while already restarted (this is normal)."));
							}
#if !UE_BUILD_SHIPPING
							else if (!bPassedDelayCheck)
							{
								UE_LOG(LogHandshake, Log, TEXT("Ignoring restart handshake request, due to < 10 seconds since last handshake."));
							}
							else // if (!bPassedDualIPCheck)
							{
								UE_LOG(LogHandshake, Log, TEXT("Ignoring restart handshake request, due to recent NetConnection packets."));
							}
#endif
						}
					}
					else
					{
						UE_LOG(LogHandshake, Log, TEXT("Server sent restart handshake request, when we don't have an authorised cookie."));

						Packet.SetError();
					}
				}
				else
				{
					// Ignore, could be a dupe/out-of-order challenge packet
				}
			}
			else if (Handler->Mode == Handler::Mode::Server)
			{
				if (LastChallengeSuccessAddress.IsValid())
				{
					// The server should not be receiving handshake packets at this stage - resend the ack in case it was lost.
					// In this codepath, this component is linked to a UNetConnection, and the Last* values below, cache the handshake info.
#if !UE_BUILD_SHIPPING
					UE_LOG(LogHandshake, Log, TEXT("Received unexpected post-connect handshake packet - resending ack for LastChallengeSuccessAddress %s and LastCookie %s."),
							*LastChallengeSuccessAddress->ToString(true), *FString::FromBlob(AuthorisedCookie, COOKIE_BYTE_SIZE));
#endif

					SendChallengeAck(LastChallengeSuccessAddress, LastRemoteHandshakeVersion, 0, AuthorisedCookie);
				}
			}
		}
		else
		{
			Packet.SetError();

#if !UE_BUILD_SHIPPING
			UE_LOG(LogHandshake, Log, TEXT("Incoming: Error reading handshake packet."));
#endif
		}
	}
#if !UE_BUILD_SHIPPING
	else if (Packet.IsError())
	{
		UE_LOG(LogHandshake, Log, TEXT("Incoming: Error reading handshake bit from packet."));
	}
#endif
	// Servers should wipe LastChallengeSuccessAddress shortly after the first non-handshake packet is received by the client,
	// in order to disable challenge ack resending
	else if (LastInitTimestamp != 0.0 && LastChallengeSuccessAddress.IsValid() && Handler->Mode == Handler::Mode::Server)
	{
		// Restart handshakes require extra time before disabling challenge ack resends, as NetConnection packets will already be in flight
		const double RestartHandshakeAckResendWindow = 10.0;
		double CurTime = Driver != nullptr ? Driver->GetElapsedTime() : 0.0;

		if (CurTime - LastInitTimestamp >= RestartHandshakeAckResendWindow)
		{
			LastChallengeSuccessAddress.Reset();
			LastInitTimestamp = 0.0;
		}
	}
}

void StatelessConnectHandlerComponent::Outgoing(FBitWriter& Packet, FOutPacketTraits& Traits)
{
	// All UNetConnection packets must specify a zero bHandshakePacket value
	FBitWriter NewPacket(GetAdjustedSizeBits(Packet.GetNumBits())+1, true);
	uint8 bHandshakePacket = 0;

	if (MagicHeader.Num() > 0)
	{
		NewPacket.SerializeBits(MagicHeader.GetData(), MagicHeader.Num());
	}

	NewPacket.WriteBit(bHandshakePacket);
	NewPacket.SerializeBits(Packet.GetData(), Packet.GetNumBits());

	Packet = MoveTemp(NewPacket);
}

void StatelessConnectHandlerComponent::IncomingConnectionless(FIncomingPacketRef PacketRef)
{
	using namespace UE::Net;

	FBitReader& Packet = PacketRef.Packet;
	const TSharedPtr<const FInternetAddr> Address = PacketRef.Address;

	if (MagicHeader.Num() > 0)
	{
		// Don't bother with the expense of verifying the magic header here.
		uint32 ReadMagic = 0;
		Packet.SerializeBits(&ReadMagic, MagicHeader.Num());
	}

	bool bHandshakePacket = !!Packet.ReadBit() && !Packet.IsError();

	LastChallengeSuccessAddress = nullptr;

	if (bHandshakePacket)
	{
		FParsedHandshakeData HandshakeData;

		bHandshakePacket = ParseHandshakePacket(Packet, HandshakeData);

		if (bHandshakePacket)
		{
			bool bValidVersion = false;
			EHandshakeVersion TargetVersion = static_cast<EHandshakeVersion>(CurrentHandshakeVersion);

			if (static_cast<uint8>(HandshakeData.RemoteMinVersion) >= MinSupportedHandshakeVersion &&
				HandshakeData.RemoteMinVersion < TargetVersion)
			{
				if (HandshakeData.RemoteCurVersion <= TargetVersion)
				{
					TargetVersion = HandshakeData.RemoteCurVersion;
				}

				bValidVersion = true;
			}


			if (Handler->Mode == Handler::Mode::Server)
			{
				const bool bInitialConnect = HandshakeData.HandshakePacketType == EHandshakePacketType::InitialPacket &&
												HandshakeData.Timestamp == 0.0;

				if (bInitialConnect)
				{
					SendConnectChallenge(Address, TargetVersion, HandshakeData.RemoteSentHandshakePacketCount);
				}
				// Challenge response
				else if (Driver != nullptr)
				{
					// NOTE: Allow CookieDelta to be 0.0, as it is possible for a server to send a challenge and receive a response,
					//			during the same tick
					bool bChallengeSuccess = false;
					const double CookieDelta = Driver->GetElapsedTime() - HandshakeData.Timestamp;
					const double SecretDelta = HandshakeData.Timestamp - LastSecretUpdateTimestamp;
					const bool bValidCookieLifetime = CookieDelta >= 0.0 && (MAX_COOKIE_LIFETIME - CookieDelta) > 0.0;
					const bool bValidSecretIdTimestamp = (HandshakeData.SecretId == ActiveSecret) ? (SecretDelta >= 0.0) : (SecretDelta <= 0.0);

					if (bValidCookieLifetime && bValidSecretIdTimestamp)
					{
						// Regenerate the cookie from the packet info, and see if the received cookie matches the regenerated one
						uint8 RegenCookie[COOKIE_BYTE_SIZE];

						GenerateCookie(Address, HandshakeData.SecretId, HandshakeData.Timestamp, RegenCookie);

						bChallengeSuccess = FMemory::Memcmp(HandshakeData.Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0;

						if (bChallengeSuccess)
						{
							if (HandshakeData.bRestartHandshake)
							{
								FMemory::Memcpy(AuthorisedCookie, HandshakeData.OrigCookie, UE_ARRAY_COUNT(AuthorisedCookie));
							}
							else
							{
								int16* CurSequence = (int16*)HandshakeData.Cookie;

								LastServerSequence = *CurSequence & (MAX_PACKETID - 1);
								LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);

								FMemory::Memcpy(AuthorisedCookie, HandshakeData.Cookie, UE_ARRAY_COUNT(AuthorisedCookie));
							}

							bRestartedHandshake = HandshakeData.bRestartHandshake;
							LastChallengeSuccessAddress = Address->Clone();
							LastRemoteHandshakeVersion = TargetVersion;

							if (TargetVersion < MinClientHandshakeVersion && static_cast<uint8>(TargetVersion) >= MinSupportedHandshakeVersion)
							{
								MinClientHandshakeVersion = TargetVersion;
							}


							// Now ack the challenge response - the cookie is stored in AuthorisedCookie, to enable retries
							SendChallengeAck(Address, TargetVersion, HandshakeData.RemoteSentHandshakePacketCount, AuthorisedCookie);
						}
					}
				}
			}
		}
		else
		{
			Packet.SetError();

			FDDoSDetection* DDoS = Handler->GetDDoS();

			if (DDoS != nullptr)
			{
				DDoS->IncBadPacketCounter();
			}

#if !UE_BUILD_SHIPPING
			UE_CLOG(DDoS == nullptr || !DDoS->CheckLogRestrictions(), LogHandshake, Log,
					TEXT("IncomingConnectionless: Error reading handshake packet."));
#endif
		}
	}
#if !UE_BUILD_SHIPPING
	else if (Packet.IsError())
	{
		UE_LOG(LogHandshake, Log, TEXT("IncomingConnectionless: Error reading handshake bit from packet."));
	}
#endif
	// Late packets from recently disconnected clients may incorrectly trigger this code path, so detect and exclude those packets
	else if (!Packet.IsError() && !PacketRef.Traits.bFromRecentlyDisconnected)
	{
		// The packet was fine but not a handshake packet - an existing client might suddenly be communicating on a different address.
		// If we get them to resend their cookie, we can update the connection's info with their new address.
		SendRestartHandshakeRequest(Address, static_cast<EHandshakeVersion>(MinSupportedHandshakeVersion));
	}
}

bool StatelessConnectHandlerComponent::ParseHandshakePacket(FBitReader& Packet, FParsedHandshakeData& OutResult)
{
	using namespace UE::Net;

	// Ensure original packet sizes don't overlap with size range of new packet format - so that we can detect original version, based on size
	{
		static constexpr int32 MinHandshakePacketVariance = HANDSHAKE_PACKET_SIZE_BITS - RandomDataLengthVarianceBytes;
		static constexpr int32 MaxHandshakePacketVariance = HANDSHAKE_PACKET_SIZE_BITS;
		static constexpr int32 MinRestartHandshakePacketVariance = RESTART_HANDSHAKE_PACKET_SIZE_BITS - RandomDataLengthVarianceBytes;
		static constexpr int32 MaxRestartHandshakePacketVariance = RESTART_HANDSHAKE_PACKET_SIZE_BITS;
		static constexpr int32 MinRestartResponsePacketVariance = RESTART_RESPONSE_SIZE_BITS - RandomDataLengthVarianceBytes;
		static constexpr int32 MaxRestartResponsePacketVariance = RESTART_RESPONSE_SIZE_BITS;

		static_assert(OriginalHandshakePacketSizeBits < MinHandshakePacketVariance || OriginalHandshakePacketSizeBits > MaxHandshakePacketVariance);
		static_assert(OriginalHandshakePacketSizeBits < MinRestartHandshakePacketVariance ||
						OriginalHandshakePacketSizeBits > MaxRestartHandshakePacketVariance);
		static_assert(OriginalHandshakePacketSizeBits < MinRestartResponsePacketVariance ||
						OriginalHandshakePacketSizeBits > MaxRestartResponsePacketVariance);
		static_assert(OriginalRestartHandshakePacketSizeBits < MinHandshakePacketVariance ||
						OriginalRestartHandshakePacketSizeBits > MaxHandshakePacketVariance);
		static_assert(OriginalRestartHandshakePacketSizeBits < MinRestartHandshakePacketVariance ||
						OriginalRestartHandshakePacketSizeBits > MaxRestartHandshakePacketVariance);
		static_assert(OriginalRestartHandshakePacketSizeBits < MinRestartResponsePacketVariance ||
						OriginalRestartHandshakePacketSizeBits > MaxRestartResponsePacketVariance);
		static_assert(OriginalRestartResponseSizeBits < MinHandshakePacketVariance || OriginalRestartResponseSizeBits > MaxHandshakePacketVariance);
		static_assert(OriginalRestartResponseSizeBits < MinRestartHandshakePacketVariance ||
						OriginalRestartResponseSizeBits > MaxRestartHandshakePacketVariance);
		static_assert(OriginalRestartResponseSizeBits < MinRestartResponsePacketVariance ||
						OriginalRestartResponseSizeBits > MaxRestartResponsePacketVariance);
	};

	bool bValidPacket = false;
	const int32 BitsLeft = Packet.GetBitsLeft();
	const bool bOriginalVersion = BitsLeft == (OriginalHandshakePacketSizeBits - 1) || BitsLeft == (OriginalRestartHandshakePacketSizeBits - 1) ||
									BitsLeft == (OriginalRestartResponseSizeBits - 1);

	if (bOriginalVersion)
	{
		return ParseHandshakePacketOriginal(Packet, OutResult);
	}


	const int32 HandshakePacketBitsLeft = BitsLeft - (HANDSHAKE_PACKET_SIZE_BITS - 1);
	const int32 RestartHandshakePacketBitsLeft = BitsLeft - (RESTART_HANDSHAKE_PACKET_SIZE_BITS - 1);
	const int32 RestartResponsePacketBitsLeft = BitsLeft - (RESTART_RESPONSE_SIZE_BITS - 1);
	const int32 MinBitsLeft = (BaseRandomDataLengthBytes - RandomDataLengthVarianceBytes) * 8;
	const int32 MaxBitsLeft = BaseRandomDataLengthBytes * 8;
	const bool bMaybeHandshakePacketSize = HandshakePacketBitsLeft >= MinBitsLeft && HandshakePacketBitsLeft <= MaxBitsLeft;
	const bool bMaybeRestartHandshakePacket = RestartHandshakePacketBitsLeft >= MinBitsLeft && RestartHandshakePacketBitsLeft <= MaxBitsLeft;
	const bool bMaybeRestartResponsePacketSize = RestartResponsePacketBitsLeft >= MinBitsLeft && RestartResponsePacketBitsLeft <= MaxBitsLeft;

	OutResult.bRestartHandshake = !!Packet.ReadBit();

	uint8 RemoteMinVersion = 0;
	uint8 RemoteCurVersion = 0;
	uint8 HandshakePacketType = 0;
	EHandshakePacketType& HandshakePacketTypeEnum = OutResult.HandshakePacketType;

	Packet << RemoteMinVersion;
	Packet << RemoteCurVersion;
	Packet << HandshakePacketType;
	Packet << OutResult.RemoteSentHandshakePacketCount;

	OutResult.RemoteMinVersion = static_cast<EHandshakeVersion>(RemoteMinVersion);
	OutResult.RemoteCurVersion = static_cast<EHandshakeVersion>(RemoteCurVersion);
	HandshakePacketTypeEnum = static_cast<EHandshakePacketType>(HandshakePacketType);

	// Only accept handshake packets of roughly the right size
	const bool bHandshakePacket = bMaybeHandshakePacketSize && (HandshakePacketTypeEnum == EHandshakePacketType::InitialPacket ||
		HandshakePacketTypeEnum == EHandshakePacketType::Challenge || HandshakePacketTypeEnum == EHandshakePacketType::Response ||
		HandshakePacketTypeEnum == EHandshakePacketType::Ack);

	const bool bRestartHandshakePacket = bMaybeRestartHandshakePacket && HandshakePacketTypeEnum == EHandshakePacketType::RestartHandshake;
	const bool bRestartResponsePacket = bMaybeRestartResponsePacketSize && HandshakePacketTypeEnum == EHandshakePacketType::RestartResponse;

	// Only accept handshake packets of precisely the right size
	if (bHandshakePacket || bRestartResponsePacket)
	{
		OutResult.SecretId = Packet.ReadBit();

		Packet << OutResult.Timestamp;

		Packet.Serialize(OutResult.Cookie, COOKIE_BYTE_SIZE);

		if (bRestartResponsePacket)
		{
			Packet.Serialize(OutResult.OrigCookie, COOKIE_BYTE_SIZE);
		}

		bValidPacket = !Packet.IsError();
	}
	else if (bRestartHandshakePacket)
	{
		bValidPacket = !Packet.IsError() && OutResult.bRestartHandshake && Handler->Mode == Handler::Mode::Client;
	}

	if (bValidPacket)
	{
		Packet.SetAtEnd();
	}

	return bValidPacket;
}

bool StatelessConnectHandlerComponent::ParseHandshakePacketOriginal(FBitReader& Packet, FParsedHandshakeData& OutResult)
{
	using namespace UE::Net;

	bool bValidPacket = false;
	uint32 BitsLeft = Packet.GetBitsLeft();
	bool bHandshakePacketSize = BitsLeft == (OriginalHandshakePacketSizeBits - 1);
	bool bRestartResponsePacketSize = BitsLeft == (OriginalRestartResponseSizeBits - 1);

	OutResult.RemoteMinVersion = EHandshakeVersion::Original;
	OutResult.RemoteCurVersion = EHandshakeVersion::Original;

	// Only accept handshake packets of precisely the right size
	if (bHandshakePacketSize || bRestartResponsePacketSize)
	{
		OutResult.bRestartHandshake = !!Packet.ReadBit();
		OutResult.SecretId = Packet.ReadBit();

		Packet << OutResult.Timestamp;

		Packet.Serialize(OutResult.Cookie, COOKIE_BYTE_SIZE);

		if (bRestartResponsePacketSize)
		{
			OutResult.HandshakePacketType = EHandshakePacketType::RestartResponse;
			Packet.Serialize(OutResult.OrigCookie, COOKIE_BYTE_SIZE);
		}
		else if (OutResult.Timestamp > 0.0)
		{
			if (Handler->Mode == Handler::Mode::Client)
			{
				OutResult.HandshakePacketType = EHandshakePacketType::Challenge;
			}
			else
			{
				OutResult.HandshakePacketType = EHandshakePacketType::Response;
			}
		}
		else if (OutResult.Timestamp < 0.0)
		{
			OutResult.HandshakePacketType = EHandshakePacketType::Ack;
		}
		else
		{
			OutResult.HandshakePacketType = EHandshakePacketType::InitialPacket;
		}

		bValidPacket = !Packet.IsError();
	}
	else if (BitsLeft == (OriginalRestartHandshakePacketSizeBits - 1))
	{
		OutResult.HandshakePacketType = EHandshakePacketType::RestartHandshake;
		OutResult.bRestartHandshake = !!Packet.ReadBit();
		bValidPacket = !Packet.IsError() && OutResult.bRestartHandshake && Handler->Mode == Handler::Mode::Client;
	}

	return bValidPacket;
}

void StatelessConnectHandlerComponent::GenerateCookie(TSharedPtr<const FInternetAddr> ClientAddress, uint8 SecretId, double Timestamp, uint8 (&OutCookie)[20])
{
	TArray<uint8> CookieData;
	FMemoryWriter CookieArc(CookieData);
	FString ClientAddressString(ClientAddress->ToString(true));

	CookieArc << Timestamp;
	CookieArc << ClientAddressString;

	FSHA1::HMACBuffer(HandshakeSecret[!!SecretId].GetData(), SECRET_BYTE_SIZE, CookieData.GetData(), CookieData.Num(), OutCookie);
}

void StatelessConnectHandlerComponent::UpdateSecret()
{
	LastSecretUpdateTimestamp = Driver != nullptr ? Driver->GetElapsedTime() : 0.0;

	// On first update, update both secrets
	if (ActiveSecret == 255)
	{
		// NOTE: The size of this may be excessive.
		HandshakeSecret[0].AddUninitialized(SECRET_BYTE_SIZE);
		HandshakeSecret[1].AddUninitialized(SECRET_BYTE_SIZE);

		TArray<uint8>& CurArray = HandshakeSecret[1];

		for (int32 i=0; i<SECRET_BYTE_SIZE; i++)
		{
			CurArray[i] = FMath::Rand() % 255;
		}

		ActiveSecret = 0;
	}
	else
	{
		ActiveSecret = (uint8)!ActiveSecret;
	}

	TArray<uint8>& CurArray = HandshakeSecret[ActiveSecret];

	for (int32 i=0; i<SECRET_BYTE_SIZE; i++)
	{
		CurArray[i] = FMath::Rand() % 255;
	}
}

int32 StatelessConnectHandlerComponent::GetReservedPacketBits() const
{
	int32 ReturnVal = MagicHeader.Num() + 1 /* bHandshakePacket */;

#if !UE_BUILD_SHIPPING
	SET_DWORD_STAT(STAT_PacketReservedHandshake, ReturnVal);
#endif

	return ReturnVal;
}

void StatelessConnectHandlerComponent::Tick(float DeltaTime)
{
	using namespace UE::Net;

	if (Handler->Mode == Handler::Mode::Client)
	{
		if (State != Handler::Component::State::Initialized && LastClientSendTimestamp != 0.0)
		{
			double LastSendTimeDiff = FPlatformTime::Seconds() - LastClientSendTimestamp;

			if (LastSendTimeDiff > UE::Net::HandshakeResendInterval)
			{
				const bool bRestartChallenge = Driver != nullptr && ((Driver->GetElapsedTime() - LastChallengeTimestamp) > MIN_COOKIE_LIFETIME);

				if (bRestartChallenge)
				{
					SetState(Handler::Component::State::UnInitialized);
				}

				if (State == Handler::Component::State::UnInitialized)
				{
					UE_LOG(LogHandshake, Verbose, TEXT("Initial handshake packet timeout - resending."));

					EHandshakeVersion ResendVersion = static_cast<EHandshakeVersion>(CurrentHandshakeVersion);

					// In case the server doesn't support the current handshake version, randomly switch between supported versions - if enabled
					// (we don't know if the server supports the minimum version either, so pick from the full range).
					// It's better for devs to explicitly hotfix the 'net.MinHandshakeVersion' value, instead of relying upon this fallback.
					if (!!CVarNetDoHandshakeVersionFallback.GetValueOnAnyThread() && FMath::RandBool())
					{
						// Decrement the minimum version, based on the number of handshake packets sent - to select for higher supported versions
						const int32 MinVersion = FMath::Max(MinSupportedHandshakeVersion, CurrentHandshakeVersion - SentHandshakePacketCount);

						if (MinVersion != CurrentHandshakeVersion)
						{
							ResendVersion = static_cast<EHandshakeVersion>(FMath::RandRange(MinVersion, CurrentHandshakeVersion));
						}
					}

					SendInitialPacket(ResendVersion);
				}
				else if (State == Handler::Component::State::InitializedOnLocal && LastTimestamp != 0.0)
				{
					UE_LOG(LogHandshake, Verbose, TEXT("Challenge response packet timeout - resending."));

					SendChallengeResponse(LastRemoteHandshakeVersion, LastSecretId, LastTimestamp, LastCookie);
				}
			}
		}
	}
	else // if (Handler->Mode == Handler::Mode::Server)
	{
		const bool bConnectionlessHandler = Driver != nullptr && Driver->StatelessConnectComponent.HasSameObject(this);

		if (bConnectionlessHandler)
		{
			static float CurVariance = FMath::FRandRange(0.f, SECRET_UPDATE_TIME_VARIANCE);

			// Update the secret value periodically, to reduce replay attacks. Also adds a bit of randomness to the timing of this,
			// so that handshake Timestamp checking as an added method of reducing replay attacks, is more effective.
			if (((Driver->GetElapsedTime() - LastSecretUpdateTimestamp) - (SECRET_UPDATE_TIME + CurVariance)) > 0.0)
			{
				CurVariance = FMath::FRandRange(0.f, SECRET_UPDATE_TIME_VARIANCE);

				UpdateSecret();
			}
		}
	}
}

