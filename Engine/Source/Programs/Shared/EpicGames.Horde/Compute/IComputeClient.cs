// Copyright Epic Games, Inc. All Rights Reserved.

using EpicGames.Core;
using EpicGames.Horde.Storage;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace EpicGames.Horde.Compute
{
	/// <summary>
	/// Response decribing a cluster
	/// </summary>
	public interface IComputeClusterInfo
	{
		/// <summary>
		/// Id of the cluster
		/// </summary>
		public ClusterId Id { get; }

		/// <summary>
		/// Namespace containing the requests and responses
		/// </summary>
		public NamespaceId NamespaceId { get; }

		/// <summary>
		/// The request bucket id
		/// </summary>
		public BucketId RequestBucketId { get; }

		/// <summary>
		/// Bucket to store response refs
		/// </summary>
		public BucketId ResponseBucketId { get; }
	}

	/// <summary>
	/// State of a compute task
	/// </summary>
	public enum ComputeTaskState
	{
		/// <summary>
		/// The task is queued for execution
		/// </summary>
		Queued = 0,

		/// <summary>
		/// Currently being executed by a remote agent
		/// </summary>
		Executing = 1,

		/// <summary>
		/// Completed
		/// </summary>
		Complete = 2,
	}

	/// <summary>
	/// Outcome of a task, if it's in the complete state
	/// </summary>
	public enum ComputeTaskOutcome
	{
		/// <summary>
		/// The task was executed successfully
		/// </summary>
		Success = 0,

		/// <summary>
		/// The lease failed with an error
		/// </summary>
		Failed = 1,

		/// <summary>
		/// The lease was cancelled
		/// </summary>
		Cancelled = 2,

		/// <summary>
		/// The task ran but did not return a result for unknown reasons
		/// </summary>
		NoResult = 3,

		/// <summary>
		/// The item was not scheduled for execution in the default time period, and was expired.
		/// </summary>
		Expired = 4,

		/// <summary>
		/// A blob could not be found. The detail field includes the hash of the blob.
		/// </summary>
		BlobNotFound = 5,

		/// <summary>
		/// An uncaught exception occurred during task execution
		/// </summary>
		Exception = 6,
	}

	/// <summary>
	/// Supplies information about the current execution state of a task
	/// </summary>
	public interface IComputeTaskInfo
	{
		/// <summary>
		/// Reference to the task decriptor that was requested
		/// </summary>
		public RefId TaskRefId { get; }

		/// <summary>
		/// Time that the event happened
		/// </summary>
		public DateTime Time { get; }

		/// <summary>
		/// New state of the task
		/// </summary>
		public ComputeTaskState State { get; }

		/// <summary>
		/// Outcome of the task execution.Note that this reflects the outcome of the execution rather than the outcome of the task.        
		/// </summary>
		public ComputeTaskOutcome Outcome { get; }

		/// <summary>
		/// Additional information about the outcome of the task.Dependent on the value of Outcome.        
		/// </summary>
		public string? Detail { get; }

		/// <summary>
		/// Ref containing the task result
		/// </summary>
		public RefId? ResultRefId { get; }

		/// <summary>
		/// When transitioning to the executing state, includes the name of the agent performing the work
		/// </summary>
		public string? AgentId { get; }

		/// <summary>
		/// When transitioning to the executing state, includes the id of the lease assigned to the agent
		/// </summary>
		public string? LeaseId { get; }
	}

	/// <summary>
	/// Interface for communicating with a compute server
	/// </summary>
	public interface IComputeClient
	{
		/// <summary>
		/// Gets information about a cluster
		/// </summary>
		/// <param name="clusterId">The cluster to retreive information on</param>
		/// <param name="cancellationToken">Cancellation token for the request</param>
		/// <returns>Cluster information</returns>
		Task<IComputeClusterInfo> GetClusterInfoAsync(ClusterId clusterId, CancellationToken cancellationToken = default);

		/// <summary>
		/// Queues a set of tasks for execution
		/// </summary>
		/// <param name="clusterId">Cluster for executing the tasks</param>
		/// <param name="channelId">Indicates an identifier generated by the client to query responses on</param>
		/// <param name="requirementsHash">Requirements of the task to execute</param>
		/// <param name="taskRefIds">Refs describing the request</param>
		/// <param name="skipCacheLookup">Whether to skip the lookup of cached output for this task</param>
		/// <param name="cancellationToken">Cancellation token for the request</param>
		/// <returns>The new channel id</returns>
		Task AddTasksAsync(ClusterId clusterId, ChannelId channelId, IEnumerable<RefId> taskRefIds, IoHash requirementsHash, bool skipCacheLookup, CancellationToken cancellationToken = default);

		/// <summary>
		/// Read updates from the given remote execution channel
		/// </summary>
		/// <param name="clusterId">Cluster for executing the tasks</param>
		/// <param name="channelId">Channel to receive updates on</param>
		/// <param name="cancellationToken">Cancellation token for the operation</param>
		/// <returns></returns>
		IAsyncEnumerable<IComputeTaskInfo> GetTaskUpdatesAsync(ClusterId clusterId, ChannelId channelId, CancellationToken cancellationToken = default);
	}

	/// <summary>
	/// Extension methods for <see cref="IComputeClient"/>
	/// </summary>
	public static class ComputeClientExtensions
	{
		/// <summary>
		/// Queues a single task for execution
		/// </summary>
		/// <param name="computeClient">The compute client instance</param>
		/// <param name="clusterId">Name of the profile to use for executing the tasks</param>
		/// <param name="channelId">Channel to receive updates on</param>
		/// <param name="taskRefId">Ref describing the request</param>
		/// <param name="requirementsHash">Requirements of the task to execute</param>
		/// <param name="skipCacheLookup">Whether to skip the lookup of cached output for this task</param>
		/// <param name="cancellationToken">Cancellation token for the operation</param>
		public static Task AddTaskAsync(this IComputeClient computeClient, ClusterId clusterId, ChannelId channelId, RefId taskRefId, IoHash requirementsHash, bool skipCacheLookup, CancellationToken cancellationToken = default)
		{
			return computeClient.AddTasksAsync(clusterId, channelId, new[] { taskRefId }, requirementsHash, skipCacheLookup, cancellationToken);
		}
	}
}
